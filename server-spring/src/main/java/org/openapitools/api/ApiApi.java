/*
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.20.0-SNAPSHOT).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.Account;
import org.openapitools.model.AccountListResponse;
import org.openapitools.model.AccountLoginResponse;
import org.openapitools.model.AccountMiniResponse;
import org.openapitools.model.AccountResponse;
import org.openapitools.model.AchievementProgressResponse;
import org.openapitools.model.AchievementResponse;
import org.openapitools.model.AchievementShortResponse;
import org.openapitools.model.AchievementTierResponse;
import org.openapitools.model.ActivityResponse;
import org.openapitools.model.AgeGroupResponse;
import org.openapitools.model.AlbumContestListResponse;
import org.openapitools.model.AlbumContestResponse;
import org.openapitools.model.AlbumFullResponse;
import org.openapitools.model.AlbumResponse;
import org.openapitools.model.AppResponse;
import org.openapitools.model.ApplicationConfigResponse;
import org.openapitools.model.ApplicationResponse;
import org.openapitools.model.ApplicationSettingsResponse;
import org.openapitools.model.ApplicationShortResponse;
import org.openapitools.model.ApplicationUsageResponse;
import org.openapitools.model.AssetFullResponse;
import org.openapitools.model.AssetListResponse;
import org.openapitools.model.AssetResponse;
import org.openapitools.model.AssetShortResponse;
import org.openapitools.model.AssignmentResponse;
import org.openapitools.model.AssignmentStatusResponse;
import org.openapitools.model.AudienceDeviceResponse;
import org.openapitools.model.AudienceResponse;
import org.openapitools.model.AvailabilityResponse;
import org.openapitools.model.BidResponse;
import java.math.BigDecimal;
import org.openapitools.model.BillableEntityResponse;
import org.openapitools.model.BlockedNotificationResponse;
import org.openapitools.model.CargoType;
import org.openapitools.model.CategoryResponse;
import org.openapitools.model.CategoryTreeResponse;
import org.openapitools.model.CellCarrierResponse;
import org.openapitools.model.ChartData;
import org.openapitools.model.ConnectionGroupResponse;
import org.openapitools.model.ConnectionInfoResponse;
import org.openapitools.model.ConnectionListResponse;
import org.openapitools.model.ConnectionResponse;
import org.openapitools.model.ConsumerInviteResponse;
import org.openapitools.model.CoordsResponse;
import org.openapitools.model.CountResponse;
import org.openapitools.model.CreativeResponse;
import org.openapitools.model.CsvImportResponse;
import org.openapitools.model.Direction;
import org.openapitools.model.DisbursementResponse;
import org.openapitools.model.EmployeeResponse;
import org.openapitools.model.EntityReference;
import org.openapitools.model.EventAttendanceResponse;
import org.openapitools.model.FilterResponse;
import org.openapitools.model.FilterTreeResponse;
import org.openapitools.model.FlagResponse;
import org.openapitools.model.GameLevelListResponse;
import org.openapitools.model.GameLevelResponse;
import org.openapitools.model.GameResponse;
import org.openapitools.model.GeoPointResponse;
import org.openapitools.model.ImportStatuses;
import org.openapitools.model.InviteResponse;
import org.openapitools.model.LeaderboardResponse;
import org.openapitools.model.Leg;
import org.openapitools.model.LegResponse;
import org.openapitools.model.LikableResponse;
import org.openapitools.model.ListCountResponse;
import org.openapitools.model.ListingFullResponse;
import org.openapitools.model.ListingGroupResponse;
import org.openapitools.model.ListingResponse;
import org.openapitools.model.Location;
import org.openapitools.model.LocationSearchResponse;
import java.util.Map;
import org.openapitools.model.MediaOfferResponse;
import org.openapitools.model.MissionFormatResponse;
import org.openapitools.model.MissionResponse;
import org.openapitools.model.MissionShortResponse;
import org.openapitools.model.NoteResponse;
import org.openapitools.model.NotificationMessageListResponse;
import org.openapitools.model.NotificationRecipientResponse;
import org.openapitools.model.NotificationRecipientResponseListResponse;
import org.openapitools.model.NotificationTemplateResponse;
import org.springframework.lang.Nullable;
import org.openapitools.model.ObjectStoreResponse;
import org.openapitools.model.OfferListResponse;
import org.openapitools.model.OfferResponse;
import org.openapitools.model.OfferShortResponse;
import org.openapitools.model.OfferTransactionResponse;
import org.openapitools.model.OfferTransactionStatusResponse;
import org.openapitools.model.OrderResponse;
import org.openapitools.model.Orders;
import org.openapitools.model.OrsonAiAddMovieResponse;
import org.openapitools.model.OrsonAiBatchResponse;
import org.openapitools.model.OrsonAiEmotionsResponse;
import org.openapitools.model.OrsonAiProtoResponse;
import org.openapitools.model.OrsonAiSTTResponse;
import org.openapitools.model.OrsonAiTTSResponse;
import org.openapitools.model.OrsonAiTechTuneResponse;
import org.openapitools.model.OrsonAiTopicsResponse;
import org.openapitools.model.OrsonAiVoiceCanvasResponse;
import org.openapitools.model.OrsonEpisodeResponse;
import org.openapitools.model.OrsonRenderResponse;
import org.openapitools.model.PackResponse;
import org.openapitools.model.PathingResponse;
import org.openapitools.model.PaymentRequest;
import org.openapitools.model.PaymentTypesResponse;
import org.openapitools.model.PlacementResponse;
import org.openapitools.model.PostalCodeResponse;
import org.openapitools.model.PredictedLocationResponse;
import org.openapitools.model.PreferredLocationResponse;
import org.openapitools.model.PreviewPersonaResponse;
import org.openapitools.model.ProfileInfoResponse;
import org.openapitools.model.ProfileResponse;
import org.openapitools.model.Program;
import org.openapitools.model.PurchaseItemFullResponse;
import org.openapitools.model.PurchaseItemListResponse;
import org.openapitools.model.PurchaseItemResponse;
import org.openapitools.model.QuestionResponse;
import org.openapitools.model.QueueResponse;
import org.openapitools.model.RankFullResponse;
import org.openapitools.model.RatingIndexResponse;
import org.openapitools.model.RatingResponse;
import org.openapitools.model.RegionLegSummary;
import org.openapitools.model.RegionResponse;
import org.openapitools.model.ReportBatchResponse;
import org.openapitools.model.ReportRegionLegSummaryBatchResponse;
import org.openapitools.model.ReportResponse;
import org.openapitools.model.ReservationResponse;
import org.openapitools.model.RetailerFullResponse;
import org.openapitools.model.RetailerLocationResponse;
import org.openapitools.model.RetailerOfferResponse;
import org.openapitools.model.RetailerResponse;
import org.openapitools.model.Route;
import org.openapitools.model.RouteSettings;
import org.openapitools.model.RoutingListResponse;
import org.openapitools.model.ScheduledNotificationFullResponse;
import org.openapitools.model.ScoreResponse;
import org.openapitools.model.SearchResponse;
import org.openapitools.model.ServiceHub;
import org.openapitools.model.Shipment;
import org.openapitools.model.ShipmentBatch;
import org.openapitools.model.ShipmentImportStatus;
import org.openapitools.model.ShipmentOrder;
import org.openapitools.model.SirqulResponse;
import org.openapitools.model.StepResponse;
import org.openapitools.model.Stop;
import org.openapitools.model.SubscriptionPlanResponse;
import org.openapitools.model.SubscriptionResponse;
import org.openapitools.model.TaskResponse;
import org.openapitools.model.TerritoryResponse;
import org.openapitools.model.ThemeDescriptorResponse;
import org.openapitools.model.ThirdPartyCredentialResponse;
import org.openapitools.model.ThirdPartyNetworkResponse;
import org.openapitools.model.ThirdPartyNetworkShortResponse;
import org.openapitools.model.TicketListResponse;
import org.openapitools.model.TicketOfferResponse;
import org.openapitools.model.TimeSlotResponse;
import org.openapitools.model.TokenResponse;
import org.openapitools.model.TournamentResponse;
import org.openapitools.model.TriggerResponse;
import org.openapitools.model.TrilatCacheRequest;
import org.openapitools.model.Trip;
import org.openapitools.model.TwiMLResponse;
import org.openapitools.model.UserActivityResponse;
import org.openapitools.model.UserLocationSearchResponse;
import org.openapitools.model.UserPermissionsResponse;
import org.openapitools.model.UserSettingsResponse;
import org.openapitools.model.Vehicle;
import org.openapitools.model.VehicleType;
import org.openapitools.model.WeatherResponse;
import org.openapitools.model.WordzWordResponse;
import org.openapitools.model.WrappedProxyItemResponse;
import org.openapitools.model.WrappedResponse;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.ExampleObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2026-02-09T20:58:37.853899731Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
@Validated
@Tag(name = "Invite", description = "the Invite API")
public interface ApiApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    String PATH_ACCEPT_INVITE = "/api/{version}/invite/accept";
    /**
     * POST /api/{version}/invite/accept : Accept Invite
     * Allows a user to accept an invite. The user could also become the inviter&#39;s friend.
     *
     * @param version  (required)
     * @param token the invite token (required)
     * @param accountId the accountId of the user who is accepting the invite (required)
     * @param albumId the album id associated with this invite (if applicable) (optional)
     * @param missionId the mission id associated with this invite (if applicable) (optional)
     * @param albumContestId the album contest id associated with this invite (if applicable) (optional)
     * @param offerId the offer id associated with this invite (if applicable) (optional)
     * @param offerLocationId the offer location id associated with this invite (if applicable) (optional)
     * @param retailerLocationId the retailer location id associated with this invite (if applicable) (optional)
     * @param appKey the application key (optional)
     * @param autoFriend whether to auto-friend the invite sender and receiver (optional, default to true)
     * @param autoAttendEvent whether to mark the event as attending automatically after invite is accepted (optional, default to false)
     * @param autoFavoriteOffer whether to mark the offer as favorited automatically after invite is accepted (optional, default to false)
     * @param autoFavoriteOfferLocation whether to mark the offer location as favorited automatically after invite is accepted (optional, default to false)
     * @param autoFavoriteRetailerLocation whether to mark the retailer location as favorited automatically after invite is accepted (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "acceptInvite",
        summary = "Accept Invite",
        description = "Allows a user to accept an invite. The user could also become the inviter's friend.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConsumerInviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ACCEPT_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<ConsumerInviteResponse> acceptInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "token", description = "the invite token", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token,
        @NotNull @Parameter(name = "accountId", description = "the accountId of the user who is accepting the invite", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "albumId", description = "the album id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "missionId", description = "the mission id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "albumContestId", description = "the album contest id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = false) @Nullable Long albumContestId,
        @Parameter(name = "offerId", description = "the offer id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "the offer location id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "retailerLocationId", description = "the retailer location id associated with this invite (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "autoFriend", description = "whether to auto-friend the invite sender and receiver", in = ParameterIn.QUERY) @Valid @RequestParam(value = "autoFriend", required = false, defaultValue = "true") Boolean autoFriend,
        @Parameter(name = "autoAttendEvent", description = "whether to mark the event as attending automatically after invite is accepted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "autoAttendEvent", required = false, defaultValue = "false") Boolean autoAttendEvent,
        @Parameter(name = "autoFavoriteOffer", description = "whether to mark the offer as favorited automatically after invite is accepted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "autoFavoriteOffer", required = false, defaultValue = "false") Boolean autoFavoriteOffer,
        @Parameter(name = "autoFavoriteOfferLocation", description = "whether to mark the offer location as favorited automatically after invite is accepted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "autoFavoriteOfferLocation", required = false, defaultValue = "false") Boolean autoFavoriteOfferLocation,
        @Parameter(name = "autoFavoriteRetailerLocation", description = "whether to mark the retailer location as favorited automatically after invite is accepted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "autoFavoriteRetailerLocation", required = false, defaultValue = "false") Boolean autoFavoriteRetailerLocation
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ACCOUNT_LOCATION_SEARCH = "/api/{version}/account/search";
    /**
     * GET /api/{version}/account/search : Search Accounts by Location
     * Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q Deprecated - legacy query parameter (optional)
     * @param keyword An optional keyword to search on, will be ignore if empty (NOT implemented yet) (optional)
     * @param postalCode The postal code to search on, either postalCode or the user&#39;s exact location is required (optional)
     * @param latitude The latitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param longitude The longitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param appKey The application key (optional)
     * @param range The range to search on (optional, default to 10)
     * @param locationLastUpdated Searches for user&#39;s that has updated their location since this date (optional)
     * @param gender The preferred gender (optional)
     * @param minAge The preferred min age (optional)
     * @param maxAge The preferred max age (optional)
     * @param companionshipIndex The preferred companionship index (optional)
     * @param i this is the start index of a query (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l this is the limit index of a query (optional)
     * @param limit Limit of the pagination (optional, default to 100)
     * @param searchMode Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH) (optional)
     * @param sortField Sorting field for results (default: DISTANCE) (optional)
     * @param descending Whether to sort descending (default: false) (optional)
     * @param roles Roles to filter on (optional)
     * @param tags Tags to filter on (optional)
     * @param experience The experience to filter on (optional)
     * @param categoryIds The category ids to filter on (comma separated) (optional)
     * @param audienceIds The audience ids to filter on (comma separated) (optional)
     * @param audienceOperator Operator used to combine audience filters (default: AND) (optional, default to AND)
     * @param updateCurrentLocation Whether to use the given lat &amp; long to update the user&#39;s current location (optional, default to false)
     * @param updatePreferredSettings Whether to use the given parameters to update the user&#39;s preferred settings (optional, default to false)
     * @param showExactLocations Determines whether to always display user exact locations (optional, default to true)
     * @param showConnectionToSearcher Return connection of the accounts in the result to the passed in account if there exists any (optional, default to false)
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param verifiedUserOnly Returns only verified users (optional)
     * @param contentAdminOnly Returns only content admin users (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "accountLocationSearch",
        summary = "Search Accounts by Location",
        description = "Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = UserLocationSearchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ACCOUNT_LOCATION_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<UserLocationSearchResponse> accountLocationSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", description = "Deprecated - legacy query parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "An optional keyword to search on, will be ignore if empty (NOT implemented yet)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "postalCode", description = "The postal code to search on, either postalCode or the user's exact location is required", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "latitude", description = "The latitude of the user, either postalCode or the user's exact location is required", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The longitude of the user, either postalCode or the user's exact location is required", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "range", description = "The range to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "range", required = false, defaultValue = "10") Double range,
        @Parameter(name = "locationLastUpdated", description = "Searches for user's that has updated their location since this date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationLastUpdated", required = false) @Nullable Long locationLastUpdated,
        @Parameter(name = "gender", description = "The preferred gender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "minAge", description = "The preferred min age", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minAge", required = false) @Nullable Integer minAge,
        @Parameter(name = "maxAge", description = "The preferred max age", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxAge", required = false) @Nullable Integer maxAge,
        @Parameter(name = "companionshipIndex", description = "The preferred companionship index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionshipIndex", required = false) @Nullable Integer companionshipIndex,
        @Parameter(name = "_i", description = "this is the start index of a query", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "Start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", description = "this is the limit index of a query", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "Limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit,
        @Parameter(name = "searchMode", description = "Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMode", required = false) @Nullable String searchMode,
        @Parameter(name = "sortField", description = "Sorting field for results (default: DISTANCE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Whether to sort descending (default: false)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "roles", description = "Roles to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "roles", required = false) @Nullable String roles,
        @Parameter(name = "tags", description = "Tags to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "experience", description = "The experience to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "experience", required = false) @Nullable String experience,
        @Parameter(name = "categoryIds", description = "The category ids to filter on (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "audienceIds", description = "The audience ids to filter on (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "audienceOperator", description = "Operator used to combine audience filters (default: AND)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceOperator", required = false, defaultValue = "AND") String audienceOperator,
        @Parameter(name = "updateCurrentLocation", description = "Whether to use the given lat & long to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateCurrentLocation", required = false, defaultValue = "false") Boolean updateCurrentLocation,
        @Parameter(name = "updatePreferredSettings", description = "Whether to use the given parameters to update the user's preferred settings", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatePreferredSettings", required = false, defaultValue = "false") Boolean updatePreferredSettings,
        @Parameter(name = "showExactLocations", description = "Determines whether to always display user exact locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showExactLocations", required = false, defaultValue = "true") Boolean showExactLocations,
        @Parameter(name = "showConnectionToSearcher", description = "Return connection of the accounts in the result to the passed in account if there exists any", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showConnectionToSearcher", required = false, defaultValue = "false") Boolean showConnectionToSearcher,
        @Parameter(name = "flagCountMinimum", description = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagCountMinimum", required = false) @Nullable Long flagCountMinimum,
        @Parameter(name = "verifiedUserOnly", description = "Returns only verified users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "verifiedUserOnly", required = false) @Nullable Boolean verifiedUserOnly,
        @Parameter(name = "contentAdminOnly", description = "Returns only content admin users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentAdminOnly", required = false) @Nullable Boolean contentAdminOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ACTIVITIES = "/api/{version}/analytics/useractivity";
    /**
     * GET /api/{version}/analytics/useractivity : Get User Activity
     * Get an activity feed by user.
     *
     * @param version  (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param accountId the account id of the user (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "activities",
        summary = "Get User Activity",
        description = "Get an activity feed by user.",
        tags = { "Analytics" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = UserActivityResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ACTIVITIES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<UserActivityResponse>> activities(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_ALBUM_COLLECTION = "/api/{version}/album/create";
    /**
     * POST /api/{version}/album/create : Create Album
     * Create an Album.
     *
     * @param version  (required)
     * @param title the title of the album (required)
     * @param coverAssetNullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param includeCoverInAssetList determines whether the cover image should be added to the album asset list (required)
     * @param publicRead determines whether the album&#39;s participants has read permissions (required)
     * @param publicWrite determines whether the album&#39;s participants has write permissions (required)
     * @param publicDelete determines whether the album&#39;s participants has delete permissions (required)
     * @param publicAdd determines whether the album&#39;s participants has add permissions (required)
     * @param anonymous determines whether the album is posted anonymously (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param assetsToAdd Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param mediaURL this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param assetId The asset ID to set the album cover image (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaURL this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param startDate the start date (optional)
     * @param endDate the end date (optional)
     * @param tags the tags (optional)
     * @param description the description of the album (optional)
     * @param albumType a custom field used for aggregation and searching (optional)
     * @param albumTypeId a custom indexed number used for aggregation and searching (optional)
     * @param subType a custom string field used for aggregation and searching (optional)
     * @param latitude latitude used to update the album&#39;s location (optional)
     * @param longitude longitude used to update the album&#39;s location (optional)
     * @param locationDescription the location description (optional)
     * @param visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param gameType @deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param cellPhone the cell phone number (optional)
     * @param streetAddress The street address of the location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the location (optional)
     * @param state The state of of the location (optional)
     * @param postalCode The postal code of the location (optional)
     * @param fullAddress The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param metaData External custom client defined data (optional)
     * @param categoryIds comma separated category ids string associated with the Album (optional)
     * @param categoryFilterIds comma separated filter ids string associated with the Album (optional)
     * @param audienceIds comma separated audience ids string associated with the album (optional)
     * @param includeAllAppUsersAsMembers determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param includeAudiencesAsMembers determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param audienceOperator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param linkedObjectType sets a linked object so that it can be returned as part of the album response (optional)
     * @param linkedObjectId sets a linked object id so that it can be returned as part of the album response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addAlbumCollection",
        summary = "Create Album",
        description = "Create an Album.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SearchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_ALBUM_COLLECTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SearchResponse> addAlbumCollection(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "title", description = "the title of the album", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "coverAssetNullable", description = "determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "coverAssetNullable", required = true) Boolean coverAssetNullable,
        @NotNull @Parameter(name = "includeCoverInAssetList", description = "determines whether the cover image should be added to the album asset list", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCoverInAssetList", required = true) Boolean includeCoverInAssetList,
        @NotNull @Parameter(name = "publicRead", description = "determines whether the album's participants has read permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicRead", required = true) Boolean publicRead,
        @NotNull @Parameter(name = "publicWrite", description = "determines whether the album's participants has write permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicWrite", required = true) Boolean publicWrite,
        @NotNull @Parameter(name = "publicDelete", description = "determines whether the album's participants has delete permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicDelete", required = true) Boolean publicDelete,
        @NotNull @Parameter(name = "publicAdd", description = "determines whether the album's participants has add permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicAdd", required = true) Boolean publicAdd,
        @NotNull @Parameter(name = "anonymous", description = "determines whether the album is posted anonymously", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "anonymous", required = true) Boolean anonymous,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "assetsToAdd", description = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetsToAdd", required = false) @Nullable String assetsToAdd,
        @Parameter(name = "media", description = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "media", required = false) @Nullable org.springframework.core.io.Resource media,
        @Parameter(name = "mediaURL", description = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaURL", required = false) @Nullable String mediaURL,
        @Parameter(name = "assetId", description = "The asset ID to set the album cover image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "attachedMedia", description = "a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMedia", required = false) @Nullable org.springframework.core.io.Resource attachedMedia,
        @Parameter(name = "attachedMediaURL", description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaURL", required = false) @Nullable String attachedMediaURL,
        @Parameter(name = "startDate", description = "the start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tags", description = "the tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "description", description = "the description of the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "albumType", description = "a custom field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumType", required = false) @Nullable String albumType,
        @Parameter(name = "albumTypeId", description = "a custom indexed number used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypeId", required = false) @Nullable Long albumTypeId,
        @Parameter(name = "subType", description = "a custom string field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "latitude", description = "latitude used to update the album's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the album's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "locationDescription", description = "the location description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "visibility", description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "gameType", description = "@deprecated, use the appKey", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "cellPhone", description = "the cell phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "streetAddress", description = "The street address of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "fullAddress", description = "The full address of the location which should include the street address, city, state, and postal code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullAddress", required = false) @Nullable String fullAddress,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "categoryIds", description = "comma separated category ids string associated with the Album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "categoryFilterIds", description = "comma separated filter ids string associated with the Album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryFilterIds", required = false) @Nullable String categoryFilterIds,
        @Parameter(name = "audienceIds", description = "comma separated audience ids string associated with the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "includeAllAppUsersAsMembers", description = "determines whether to include all app users as members (only admins of the app can do this)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAllAppUsersAsMembers", required = false) @Nullable Boolean includeAllAppUsersAsMembers,
        @Parameter(name = "includeAudiencesAsMembers", description = "determines whether to include all users of the audiences as members (only admins of the app can do this)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiencesAsMembers", required = false) @Nullable Boolean includeAudiencesAsMembers,
        @Parameter(name = "audienceOperator", description = "determines whether to use ands or ors when using the audience list to add users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceOperator", required = false) @Nullable String audienceOperator,
        @Parameter(name = "approvalStatus", description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false) @Nullable String approvalStatus,
        @Parameter(name = "linkedObjectType", description = "sets a linked object so that it can be returned as part of the album response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectType", required = false) @Nullable String linkedObjectType,
        @Parameter(name = "linkedObjectId", description = "sets a linked object id so that it can be returned as part of the album response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectId", required = false) @Nullable Long linkedObjectId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_ALBUM_USERS = "/api/{version}/album/user/add";
    /**
     * POST /api/{version}/album/user/add : Add Album Users
     * Add users to an album as participants.
     *
     * @param version  (required)
     * @param albumId the album ID (required)
     * @param includeFriendGroup determines whether to include all friends as participants (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param read determines whether the users being added have read permissions (optional)
     * @param write determines whether the users being added have write permissions (optional)
     * @param delete determines whether the users being added have delete permissions (optional)
     * @param add determines whether the users being added have add permissions (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param connectionGroups comma separated list of connection group IDs (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addAlbumUsers",
        summary = "Add Album Users",
        description = "Add users to an album as participants.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_ALBUM_USERS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> addAlbumUsers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "the album ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @NotNull @Parameter(name = "includeFriendGroup", description = "determines whether to include all friends as participants", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = true) Boolean includeFriendGroup,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "read", description = "determines whether the users being added have read permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "read", required = false) @Nullable Boolean read,
        @Parameter(name = "write", description = "determines whether the users being added have write permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "write", required = false) @Nullable Boolean write,
        @Parameter(name = "delete", description = "determines whether the users being added have delete permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "delete", required = false) @Nullable Boolean delete,
        @Parameter(name = "add", description = "determines whether the users being added have add permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "add", required = false) @Nullable Boolean add,
        @Parameter(name = "connections", description = "comma separated list of connection IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connections", required = false) @Nullable String connections,
        @Parameter(name = "connectionGroups", description = "comma separated list of connection group IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroups", required = false) @Nullable String connectionGroups
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_CONNECTION_TO_GROUP = "/api/{version}/consumer/connection/group/addConnection";
    /**
     * POST /api/{version}/consumer/connection/group/addConnection : Add Connection
     * Adds a connection to a group.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param groupId the group id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addConnectionToGroup",
        summary = "Add Connection",
        description = "Adds a connection to a group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_CONNECTION_TO_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> addConnectionToGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "groupId", description = "the group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = true) Long groupId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionId", description = "the connection id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionId", required = false) @Nullable Long connectionId,
        @Parameter(name = "connectionAccountId", description = "the connection account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "pendingId", description = "the pending id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pendingId", required = false) @Nullable Long pendingId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_CONNECTIONS_TO_GROUP = "/api/{version}/connection/group/addConnections";
    /**
     * POST /api/{version}/connection/group/addConnections : Add Connections
     * Adds a list of connections to a group.
     *
     * @param version  (required)
     * @param connectionGroupId the connection group ID (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addConnectionsToGroup",
        summary = "Add Connections",
        description = "Adds a list of connections to a group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_CONNECTIONS_TO_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> addConnectionsToGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "connectionGroupId", description = "the connection group ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupId", required = true) Long connectionGroupId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionIds", description = "comma separated list of connection ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionAccountIds", description = "comma separated list of connection account ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_FAVORITE = "/api/{version}/favorite/create";
    /**
     * POST /api/{version}/favorite/create : Create Favorite
     * Adds an offer, offer location, retailer location, or category to your favorites.
     *
     * @param version  (required)
     * @param favoritableId The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId} (required)
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM} (required)
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addFavorite",
        summary = "Create Favorite",
        description = "Adds an offer, offer location, retailer location, or category to your favorites.",
        tags = { "Favorite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WrappedResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_FAVORITE,
        produces = { "*/*" }
    )
    default ResponseEntity<WrappedResponse> addFavorite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "favoritableId", description = "The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableId", required = true) Long favoritableId,
        @NotNull @Parameter(name = "favoritableType", description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableType", required = true) String favoritableType,
        @Parameter(name = "deviceId", description = "The unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_FIELD = "/api/{version}/object/field/add";
    /**
     * POST /api/{version}/object/field/add : Create Field
     * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to add the field to (required)
     * @param fieldName field name The name of the field to add. (required)
     * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addField",
        summary = "Create Field",
        description = "Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_FIELD,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> addField(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to add the field to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName,
        @NotNull @Parameter(name = "fieldName", description = "field name The name of the field to add.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldName", required = true) String fieldName,
        @NotNull @Parameter(name = "fieldType", description = "field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldType", required = true) String fieldType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_MOVIE = "/api/{version}/orson/ai/addMovie";
    /**
     * POST /api/{version}/orson/ai/addMovie : Add Movie
     * Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param movieName Movie Name (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addMovie",
        summary = "Add Movie",
        description = "Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiAddMovieResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_MOVIE,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiAddMovieResponse> addMovie(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "movieName", description = "Movie Name", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "movieName", required = true) String movieName,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "tags", description = "A user defined list (comma-delimited) of tags associated with the movie", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_OR_UPDATE_ALBUM_CONTEST = "/api/{version}/consumer/album/contest";
    /**
     * POST /api/{version}/consumer/album/contest : Create or Update Contest
     * Creates or updates a contest.
     *
     * @param version  (required)
     * @param publicRead determines whether the contest&#39;s participants has read permissions (required)
     * @param publicWrite determines whether the contest&#39;s participants has write permissions (required)
     * @param publicDelete determines whether the contest&#39;s participants has delete permissions (required)
     * @param publicAdd determines whether the contest&#39;s participants has add permissions (required)
     * @param visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (required)
     * @param includeFriendGroup determines whether to include all friends as participants (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. the application key (optional)
     * @param appKey the application key (optional)
     * @param contestType a custom field used for aggregation and searching (optional)
     * @param albumContestId the album contest ID for updating (don&#39;t pass in if creating) (optional)
     * @param title the title of the contest (optional)
     * @param description the description of the contest (optional)
     * @param albumId1 the album ID for the first album (optional)
     * @param removeAlbum1 removes album1 from the contest (optional)
     * @param albumId2 the album ID for the second album (optional)
     * @param removeAlbum2 removes album2 from the contest (optional)
     * @param startDate the start date of the contest (time-stamp in milliseconds) (optional)
     * @param endDate the end date of the contest (time-stamp in milliseconds) (optional)
     * @param locationDescription the location description of the contest taking place (optional)
     * @param connectionIdsToAdd comma separated list of connection IDs (optional)
     * @param connectionGroupIdsToAdd comma separated list of connection group IDs (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addOrUpdateAlbumContest",
        summary = "Create or Update Contest",
        description = "Creates or updates a contest.",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumContestResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_OR_UPDATE_ALBUM_CONTEST,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumContestResponse> addOrUpdateAlbumContest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "publicRead", description = "determines whether the contest's participants has read permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicRead", required = true) Boolean publicRead,
        @NotNull @Parameter(name = "publicWrite", description = "determines whether the contest's participants has write permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicWrite", required = true) Boolean publicWrite,
        @NotNull @Parameter(name = "publicDelete", description = "determines whether the contest's participants has delete permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicDelete", required = true) Boolean publicDelete,
        @NotNull @Parameter(name = "publicAdd", description = "determines whether the contest's participants has add permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicAdd", required = true) Boolean publicAdd,
        @NotNull @Parameter(name = "visibility", description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = true) String visibility,
        @NotNull @Parameter(name = "includeFriendGroup", description = "determines whether to include all friends as participants", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = true) Boolean includeFriendGroup,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated. the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "contestType", description = "a custom field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contestType", required = false) @Nullable String contestType,
        @Parameter(name = "albumContestId", description = "the album contest ID for updating (don't pass in if creating)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = false) @Nullable Long albumContestId,
        @Parameter(name = "title", description = "the title of the contest", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "the description of the contest", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "albumId1", description = "the album ID for the first album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId1", required = false) @Nullable Long albumId1,
        @Parameter(name = "removeAlbum1", description = "removes album1 from the contest", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeAlbum1", required = false) @Nullable Boolean removeAlbum1,
        @Parameter(name = "albumId2", description = "the album ID for the second album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId2", required = false) @Nullable Long albumId2,
        @Parameter(name = "removeAlbum2", description = "removes album2 from the contest", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeAlbum2", required = false) @Nullable Boolean removeAlbum2,
        @Parameter(name = "startDate", description = "the start date of the contest (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date of the contest (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "locationDescription", description = "the location description of the contest taking place", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "connectionIdsToAdd", description = "comma separated list of connection IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIdsToAdd", required = false) @Nullable String connectionIdsToAdd,
        @Parameter(name = "connectionGroupIdsToAdd", description = "comma separated list of connection group IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIdsToAdd", required = false) @Nullable String connectionGroupIdsToAdd,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_OR_UPDATE_THEME_DESCRIPTOR = "/api/{version}/consumer/theme";
    /**
     * POST /api/{version}/consumer/theme : Create/Update Theme
     * Creates or updates a theme descriptor that can be used to give applications a customized look and feel. The theme can be created by consumers and shared to other users, allowing them to use and/or collaborate on making the theme.
     *
     * @param version  (required)
     * @param publicRead determines whether the theme&#39;s participants have read permissions (required)
     * @param publicWrite determines whether the theme&#39;s participants have write permissions (required)
     * @param publicDelete determines whether the theme&#39;s participants have delete permissions (required)
     * @param publicAdd  (required)
     * @param visibility the determines the theme&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (required)
     * @param includeFriendGroup flag to determine whether to share to the user&#39;s \&quot;friends\&quot; group (required)
     * @param completeWithDefaultValues determines whether to use default values to complete the theme (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param gameType the application key (optional)
     * @param themeDescriptorId the theme descriptor id used to update an existing theme, leave empty for creating a new theme (optional)
     * @param title the title of the theme (optional)
     * @param description the description of the theme (optional)
     * @param connectionIdsToAdd a comma separated list of connection IDs to share to users (optional)
     * @param connectionGroupIdsToAdd a comma separated list of connection group IDs to share to groups (optional)
     * @param appVersion the application version the theme was created for (optional)
     * @param colorValueJson a json array used to replace colors within the application. Example: &#x60;&#x60;&#x60;json [   {     \&quot;name\&quot;: \&quot;sceneAtlas\&quot;,     \&quot;valueString\&quot;: \&quot;100,100,100,255\&quot;   },   {     \&quot;name\&quot;: \&quot;bg\&quot;,     \&quot;valueString\&quot;: \&quot;100,100,100,255\&quot;   } ] &#x60;&#x60;&#x60;  (optional)
     * @param stringReplacerJson a json array used to replace strings within the application. Example: &#x60;&#x60;&#x60;json [   {     \&quot;name\&quot;: \&quot;coins\&quot;,     \&quot;valueString\&quot;: \&quot;Gems\&quot;   },   {     \&quot;name\&quot;: \&quot;lives\&quot;,     \&quot;valueString\&quot;: \&quot;lives\&quot;   } ] &#x60;&#x60;&#x60;  (optional)
     * @param customJsonObjects a json object used by the scene atlas to position sprites. Example: &#x60;&#x60;&#x60;json {   \&quot;pShootingOffset\&quot;: [     {       \&quot;name\&quot;: \&quot;x\&quot;,       \&quot;valueString\&quot;: \&quot;2.2\&quot;     },     {       \&quot;name\&quot;: \&quot;y\&quot;,       \&quot;valueString\&quot;: \&quot;-0.3\&quot;     }   ],   \&quot;e1ShootingOffset\&quot;: [     {       \&quot;name\&quot;: \&quot;x\&quot;,       \&quot;valueString\&quot;: \&quot;0.25\&quot;     },     {       \&quot;name\&quot;: \&quot;y\&quot;,       \&quot;valueString\&quot;: \&quot;0.5\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param iconImage a MultipartFile containing the image used as the theme icon (optional)
     * @param sceneAtlasImage a MultipartFile containing the scene atlas (optional)
     * @param bgImage a MultipartFile containing the background image (optional)
     * @param bgSound a MultipartFile containing the background sound file (preferably in MP3 format) (optional)
     * @param musicSelection used to select a default sound file that already exists in the application (optional)
     * @param locationDescription the description of the user&#39;s current location (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addOrUpdateThemeDescriptor",
        summary = "Create/Update Theme",
        description = "Creates or updates a theme descriptor that can be used to give applications a customized look and feel. The theme can be created by consumers and shared to other users, allowing them to use and/or collaborate on making the theme.",
        tags = { "Theme Descriptor" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ThemeDescriptorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_OR_UPDATE_THEME_DESCRIPTOR,
        produces = { "*/*" }
    )
    default ResponseEntity<ThemeDescriptorResponse> addOrUpdateThemeDescriptor(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "publicRead", description = "determines whether the theme's participants have read permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicRead", required = true) Boolean publicRead,
        @NotNull @Parameter(name = "publicWrite", description = "determines whether the theme's participants have write permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicWrite", required = true) Boolean publicWrite,
        @NotNull @Parameter(name = "publicDelete", description = "determines whether the theme's participants have delete permissions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicDelete", required = true) Boolean publicDelete,
        @NotNull @Parameter(name = "publicAdd", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicAdd", required = true) Boolean publicAdd,
        @NotNull @Parameter(name = "visibility", description = "the determines the theme's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = true) String visibility,
        @NotNull @Parameter(name = "includeFriendGroup", description = "flag to determine whether to share to the user's \"friends\" group", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = true) Boolean includeFriendGroup,
        @NotNull @Parameter(name = "completeWithDefaultValues", description = "determines whether to use default values to complete the theme", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "completeWithDefaultValues", required = true) Boolean completeWithDefaultValues,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "themeDescriptorId", description = "the theme descriptor id used to update an existing theme, leave empty for creating a new theme", in = ParameterIn.QUERY) @Valid @RequestParam(value = "themeDescriptorId", required = false) @Nullable Long themeDescriptorId,
        @Parameter(name = "title", description = "the title of the theme", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "the description of the theme", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "connectionIdsToAdd", description = "a comma separated list of connection IDs to share to users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIdsToAdd", required = false) @Nullable String connectionIdsToAdd,
        @Parameter(name = "connectionGroupIdsToAdd", description = "a comma separated list of connection group IDs to share to groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIdsToAdd", required = false) @Nullable String connectionGroupIdsToAdd,
        @Parameter(name = "appVersion", description = "the application version the theme was created for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "colorValueJson", description = "a json array used to replace colors within the application. Example: ```json [   {     \"name\": \"sceneAtlas\",     \"valueString\": \"100,100,100,255\"   },   {     \"name\": \"bg\",     \"valueString\": \"100,100,100,255\"   } ] ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "colorValueJson", required = false) @Nullable String colorValueJson,
        @Parameter(name = "stringReplacerJson", description = "a json array used to replace strings within the application. Example: ```json [   {     \"name\": \"coins\",     \"valueString\": \"Gems\"   },   {     \"name\": \"lives\",     \"valueString\": \"lives\"   } ] ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stringReplacerJson", required = false) @Nullable String stringReplacerJson,
        @Parameter(name = "customJsonObjects", description = "a json object used by the scene atlas to position sprites. Example: ```json {   \"pShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"2.2\"     },     {       \"name\": \"y\",       \"valueString\": \"-0.3\"     }   ],   \"e1ShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"0.25\"     },     {       \"name\": \"y\",       \"valueString\": \"0.5\"     }   ] } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customJsonObjects", required = false) @Nullable String customJsonObjects,
        @Parameter(name = "iconImage", description = "a MultipartFile containing the image used as the theme icon", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconImage", required = false) @Nullable org.springframework.core.io.Resource iconImage,
        @Parameter(name = "sceneAtlasImage", description = "a MultipartFile containing the scene atlas", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sceneAtlasImage", required = false) @Nullable org.springframework.core.io.Resource sceneAtlasImage,
        @Parameter(name = "bgImage", description = "a MultipartFile containing the background image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bgImage", required = false) @Nullable org.springframework.core.io.Resource bgImage,
        @Parameter(name = "bgSound", description = "a MultipartFile containing the background sound file (preferably in MP3 format)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bgSound", required = false) @Nullable org.springframework.core.io.Resource bgSound,
        @Parameter(name = "musicSelection", description = "used to select a default sound file that already exists in the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "musicSelection", required = false) @Nullable String musicSelection,
        @Parameter(name = "locationDescription", description = "the description of the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_PAYMENT_METHOD = "/api/{version}/billing/update";
    /**
     * POST /api/{version}/billing/update : Update Payment Method
     * Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
     *
     * @param version  (required)
     * @param accountId The account used to perform the the request (required)
     * @param paymentMethodId Payment Method Id (optional)
     * @param accountName the name of the account (optional)
     * @param firstName First Name that the account is filed as (optional)
     * @param lastName Last Name that the account is filed as (optional)
     * @param address Address that the account is filed as (optional)
     * @param city City that the account is filed as (optional)
     * @param state State that the account is filed as (optional)
     * @param postalCode Postal Code that the account is filed as (optional)
     * @param country Country that the account is filed as (optional)
     * @param phone Phone that the account is filed as (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber Routing Number (optional)
     * @param defaultPaymentMethod Default Payment Method (optional)
     * @param paymentMethodNickname Payment Method Nickname (optional)
     * @param taxId Tax Id (optional)
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addPaymentMethod",
        summary = "Update Payment Method",
        description = "Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_PAYMENT_METHOD,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> addPaymentMethod(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "paymentMethodId", description = "Payment Method Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId,
        @Parameter(name = "accountName", description = "the name of the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountName", required = false) @Nullable String accountName,
        @Parameter(name = "firstName", description = "First Name that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "lastName", description = "Last Name that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "address", description = "Address that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "address", required = false) @Nullable String address,
        @Parameter(name = "city", description = "City that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "State that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "Postal Code that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "Country that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "phone", description = "Phone that the account is filed as", in = ParameterIn.QUERY) @Valid @RequestParam(value = "phone", required = false) @Nullable String phone,
        @Parameter(name = "creditCardNumber", description = "The full credit card number to store on file", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creditCardNumber", required = false) @Nullable String creditCardNumber,
        @Parameter(name = "expirationDate", description = "The credit card expiration date YYYY-MM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expirationDate", required = false) @Nullable String expirationDate,
        @Parameter(name = "ccv", description = "The 3 digit confirmation code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ccv", required = false) @Nullable String ccv,
        @Parameter(name = "accountNumber", description = "The bank account number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountNumber", required = false) @Nullable String accountNumber,
        @Parameter(name = "bankName", description = "The bank name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bankName", required = false) @Nullable String bankName,
        @Parameter(name = "routingNumber", description = "Routing Number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "routingNumber", required = false) @Nullable String routingNumber,
        @Parameter(name = "defaultPaymentMethod", description = "Default Payment Method", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultPaymentMethod", required = false) @Nullable Boolean defaultPaymentMethod,
        @Parameter(name = "paymentMethodNickname", description = "Payment Method Nickname", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodNickname", required = false) @Nullable String paymentMethodNickname,
        @Parameter(name = "taxId", description = "Tax Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "taxId", required = false) @Nullable String taxId,
        @Parameter(name = "providerCustomerProfileId", description = "Provider customer profile Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "providerCustomerProfileId", required = false) @Nullable String providerCustomerProfileId,
        @Parameter(name = "providerPaymentProfileId", description = "Provider customer payment profile Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "providerPaymentProfileId", required = false) @Nullable String providerPaymentProfileId,
        @Parameter(name = "metaData", description = "Meta Data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_PREVIEW = "/api/{version}/creative/addpreview";
    /**
     * POST /api/{version}/creative/addpreview : Add Preview
     * Enable this ad for preview for this account.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param creativeId The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addPreview",
        summary = "Add Preview",
        description = "Enable this ad for preview for this account.",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_PREVIEW,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> addPreview(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "creativeId", description = "The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = true) Long creativeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_SUB_GROUPS = "/api/{version}/consumer/connection/group/addSubGroup";
    /**
     * POST /api/{version}/consumer/connection/group/addSubGroup : Add Connection Groups
     * Add sub groups to a group.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param groupId the parent group id (required)
     * @param subGroupIds comma separated list of group IDs to add to the parent group (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addSubGroups",
        summary = "Add Connection Groups",
        description = "Add sub groups to a group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionGroupResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_SUB_GROUPS,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionGroupResponse> addSubGroups(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "groupId", description = "the parent group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = true) Long groupId,
        @NotNull @Parameter(name = "subGroupIds", description = "comma separated list of group IDs to add to the parent group", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "subGroupIds", required = true) String subGroupIds,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADD_USERS_TO_PERMISSIONABLE = "/api/{version}/consumer/permissions/add";
    /**
     * POST /api/{version}/consumer/permissions/add : Add User
     * Adds a user to a permissionable object.
     *
     * @param version  (required)
     * @param permissionableType the permissionable type of the object (required)
     * @param permissionableId the id of the permissionable object (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param read the read permission of the users/groups (optional, default to true)
     * @param write the write permission of the users/groups (optional, default to false)
     * @param delete the delete permission of the users/groups (optional, default to false)
     * @param add the add permission of the users/groups (optional, default to false)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param admin sets whether the added users will become admins or not (optional)
     * @param includeFriendGroup flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addUsersToPermissionable",
        summary = "Add User",
        description = "Adds a user to a permissionable object.",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ADD_USERS_TO_PERMISSIONABLE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> addUsersToPermissionable(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "permissionableType", description = "the permissionable type of the object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = true) String permissionableType,
        @NotNull @Parameter(name = "permissionableId", description = "the id of the permissionable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = true) Long permissionableId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "read", description = "the read permission of the users/groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "read", required = false, defaultValue = "true") Boolean read,
        @Parameter(name = "write", description = "the write permission of the users/groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "write", required = false, defaultValue = "false") Boolean write,
        @Parameter(name = "delete", description = "the delete permission of the users/groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "delete", required = false, defaultValue = "false") Boolean delete,
        @Parameter(name = "add", description = "the add permission of the users/groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "add", required = false, defaultValue = "false") Boolean add,
        @Parameter(name = "connectionIds", description = "a comma separated list of connection ids (NOT the account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionAccountIds", description = "a comma separated list of account ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "connectionGroupIds", description = "a comma separated list of connection group ids (these are groups made by the user)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "pending", description = "sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pending", required = false, defaultValue = "false") Boolean pending,
        @Parameter(name = "admin", description = "sets whether the added users will become admins or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "admin", required = false) @Nullable Boolean admin,
        @Parameter(name = "includeFriendGroup", description = "flag to determine whether to include the built-in \"friends\" group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = false, defaultValue = "false") Boolean includeFriendGroup,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "audienceIds", description = "comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ADS_FIND = "/api/{version}/ads/find";
    /**
     * GET /api/{version}/ads/find : Find Missions
     * Get a set of ad filtered by the parameters provided.
     *
     * @param version  (required)
     * @param appKey The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic. (required)
     * @param randomize return a random set of results, default is true. If false returns in nature order. (required)
     * @param targetedAdsOnly return only ads targets to the specific app, no global ads. (required)
     * @param type The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
     * @param accountId The logged in user. (optional)
     * @param appVersion The version of the application, will not return levels newer than the appVersion. (optional)
     * @param latitude The current location of the requesting device (optional)
     * @param longitude The current location of the requesting device (optional)
     * @param device Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
     * @param deviceIdentifier The device ID of the requesting device, use /audience/devices for list (optional)
     * @param deviceVersion The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param allocatesTickets If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
     * @param missionIds return only ads from the specified campaigns. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "adsFind",
        summary = "Find Missions",
        description = "Get a set of ad filtered by the parameters provided.",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MissionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ADS_FIND,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MissionResponse>> adsFind(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "randomize", description = "return a random set of results, default is true. If false returns in nature order.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "randomize", required = true) Boolean randomize,
        @NotNull @Parameter(name = "targetedAdsOnly", description = "return only ads targets to the specific app, no global ads.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "targetedAdsOnly", required = true) Boolean targetedAdsOnly,
        @Parameter(name = "type", description = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appVersion", description = "The version of the application, will not return levels newer than the appVersion.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "latitude", description = "The current location of the requesting device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the requesting device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "device", description = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = false) @Nullable String device,
        @Parameter(name = "deviceIdentifier", description = "The device ID of the requesting device, use /audience/devices for list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdentifier", required = false) @Nullable Long deviceIdentifier,
        @Parameter(name = "deviceVersion", description = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersion", required = false) @Nullable String deviceVersion,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of record to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "includeAudiences", description = "If true then return the audience data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiences", required = false) @Nullable Boolean includeAudiences,
        @Parameter(name = "allocatesTickets", description = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocatesTickets", required = false) @Nullable Boolean allocatesTickets,
        @Parameter(name = "missionIds", description = "return only ads from the specified campaigns.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionIds", required = false) @Nullable String missionIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AGGREGATED_FILTERED_USAGE = "/api/{version}/analytics/aggregatedFilteredUsage";
    /**
     * GET /api/{version}/analytics/aggregatedFilteredUsage : Get Aggregated Filtered Usage
     * Query analytics to get data used for nested graphs and charts
     *
     * @param version  (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param groupByRoot Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param groupBy Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT} (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "aggregatedFilteredUsage",
        summary = "Get Aggregated Filtered Usage",
        description = "Query analytics to get data used for nested graphs and charts",
        tags = { "Analytics" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ChartData.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_AGGREGATED_FILTERED_USAGE,
        produces = { "*/*" }
    )
    default ResponseEntity<ChartData> aggregatedFilteredUsage(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "applicationId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationId", required = false) @Nullable Long applicationId,
        @Parameter(name = "appKey", description = "The application key used to filter results by application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "startDate", description = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "deviceType", description = "The device type to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "device", description = "The device to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = false) @Nullable String device,
        @Parameter(name = "deviceOS", description = "The device OS to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceOS", required = false) @Nullable String deviceOS,
        @Parameter(name = "gender", description = "The gender to filter results by {MALE, FEMALE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroup", description = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroup", required = false) @Nullable String ageGroup,
        @Parameter(name = "country", description = "The country to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "state", description = "The state to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "city", description = "The city to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "zip", description = "The zip to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zip", required = false) @Nullable String zip,
        @Parameter(name = "model", description = "The model to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "model", required = false) @Nullable String model,
        @Parameter(name = "tag", description = "The tag to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tag", required = false) @Nullable String tag,
        @Parameter(name = "userAccountId", description = "The account id to filter results for a particular user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountId", required = false) @Nullable Long userAccountId,
        @Parameter(name = "userAccountDisplay", description = "The user display to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountDisplay", required = false) @Nullable String userAccountDisplay,
        @Parameter(name = "userAccountUsername", description = "The username to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountUsername", required = false) @Nullable String userAccountUsername,
        @Parameter(name = "groupByRoot", description = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupByRoot", required = false) @Nullable String groupByRoot,
        @Parameter(name = "groupBy", description = "Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupBy", required = false) @Nullable String groupBy,
        @Parameter(name = "distinctCount", description = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distinctCount", required = false) @Nullable String distinctCount,
        @Parameter(name = "sortField", description = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether to return results in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "hideUnknown", description = "Determines whether to return data that has empty or unknown values", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hideUnknown", required = false) @Nullable Boolean hideUnknown,
        @Parameter(name = "responseFormat", description = "Determines whether to return a JOSN or XML representation of the graph results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AI_DOCS = "/api/{version}/orson/ai/docs";
    /**
     * GET /api/{version}/orson/ai/docs : Search Docs
     * Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param doc Doc (required)
     * @param returnTopics Return Topics (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "aiDocs",
        summary = "Search Docs",
        description = "Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiProtoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_AI_DOCS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiProtoResponse> aiDocs(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "doc", description = "Doc", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "doc", required = true) String doc,
        @Parameter(name = "return_topics", description = "Return Topics", in = ParameterIn.QUERY) @Valid @RequestParam(value = "return_topics", required = false) @Nullable Boolean returnTopics,
        @Parameter(name = "limit", description = "Limit", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "offset", description = "Offset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) @Nullable Integer offset
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AI_FIND_IMAGES = "/api/{version}/orson/ai/img";
    /**
     * GET /api/{version}/orson/ai/img : Find images
     * Returns a list of URIs of images that match the text.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param text Text (required)
     * @param parseFlag Parse Flag (optional)
     * @param fetchFlag Fetch Flag (optional)
     * @param size Size (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "aiFindImages",
        summary = "Find images",
        description = "Returns a list of URIs of images that match the text.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiProtoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_AI_FIND_IMAGES,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiProtoResponse> aiFindImages(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "text", description = "Text", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "text", required = true) String text,
        @Parameter(name = "parse_flag", description = "Parse Flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parse_flag", required = false) @Nullable String parseFlag,
        @Parameter(name = "fetch_flag", description = "Fetch Flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetch_flag", required = false) @Nullable String fetchFlag,
        @Parameter(name = "size", description = "Size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "size", required = false) @Nullable String size
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AI_TAGS = "/api/{version}/orson/ai/tags";
    /**
     * GET /api/{version}/orson/ai/tags : Search Tags
     * Search the tags column of user provided tags using this endpoint.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param tags Tags (required)
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "aiTags",
        summary = "Search Tags",
        description = "Search the tags column of user provided tags using this endpoint.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiProtoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_AI_TAGS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiProtoResponse> aiTags(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "tags", description = "Tags", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = true) String tags,
        @Parameter(name = "conditional", description = "Conditional", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditional", required = false) @Nullable String conditional,
        @Parameter(name = "limit", description = "Limit", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "offset", description = "Offset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) @Nullable Integer offset
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AI_TEXT = "/api/{version}/orson/ai/text";
    /**
     * GET /api/{version}/orson/ai/text : Search Text
     * Search the movie text column of movie text using this endpoint.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param terms Terms (required)
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "aiText",
        summary = "Search Text",
        description = "Search the movie text column of movie text using this endpoint.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiProtoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_AI_TEXT,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiProtoResponse> aiText(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "terms", description = "Terms", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "terms", required = true) String terms,
        @Parameter(name = "conditional", description = "Conditional", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditional", required = false) @Nullable String conditional,
        @Parameter(name = "limit", description = "Limit", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "offset", description = "Offset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) @Nullable Integer offset
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ALBUM_CONTEST_INVITE = "/api/{version}/invite/albumContest";
    /**
     * POST /api/{version}/invite/albumContest : Invite to Contest
     * Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user&#39;s friend when the invitation is accepted.
     *
     * @param version  (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param appId This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param albumContestId the album contest to share (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "albumContestInvite",
        summary = "Invite to Contest",
        description = "Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ALBUM_CONTEST_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> albumContestInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appId", required = false) @Nullable Long appId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "albumContestId", description = "the album contest to share", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = false) @Nullable Long albumContestId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ALBUM_INVITE = "/api/{version}/invite/album";
    /**
     * POST /api/{version}/invite/album : Invite to Collection
     * Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user&#39;s friend when the invitation is accepted.
     *
     * @param version  (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param appId This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param albumId the album to share (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "albumInvite",
        summary = "Invite to Collection",
        description = "Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ALBUM_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> albumInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appId", required = false) @Nullable Long appId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "albumId", description = "the album to share", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_API_VERSION_ACHIEVEMENT_TIER_SEARCH_POST = "/api/{version}/achievement/tier/search";
    /**
     * POST /api/{version}/achievement/tier/search : Searches an Achievement Tier
     * Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param achievementType filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param sortField the field to sort by. See {@link AchievementApiMap} (optional)
     * @param descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param start The start of the index for pagination (optional)
     * @param limit the limit for pagination (has a hard limit of 1000) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "apiVersionAchievementTierSearchPost",
        summary = "Searches an Achievement Tier",
        description = "Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementTierResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_API_VERSION_ACHIEVEMENT_TIER_SEARCH_POST,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementTierResponse> apiVersionAchievementTierSearchPost(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "achievementType", description = "filter results by achievementType (these are exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementType", required = false) @Nullable Long achievementType,
        @Parameter(name = "rankType", description = "filter results by the rankType (these are the exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "sortField", description = "the field to sort by. See {@link AchievementApiMap}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "determines whether the sort list is in descending or ascending order (of the achievement)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "descendingGoal", description = "determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descendingGoal", required = false) @Nullable Boolean descendingGoal,
        @Parameter(name = "start", description = "The start of the index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "limit", description = "the limit for pagination (has a hard limit of 1000)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Long limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_APPROVE_ALBUM = "/api/{version}/album/approve";
    /**
     * POST /api/{version}/album/approve : Approve Album
     * Sets the approval status of an Album.
     *
     * @param version  (required)
     * @param albumId The ID of the album (required)
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "approveAlbum",
        summary = "Approve Album",
        description = "Sets the approval status of an Album.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_APPROVE_ALBUM,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> approveAlbum(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "The ID of the album", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "A unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "approvalStatus", description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false) @Nullable String approvalStatus,
        @Parameter(name = "verified", description = "Sets whether the album should be marked as \"verified\"", in = ParameterIn.QUERY) @Valid @RequestParam(value = "verified", required = false) @Nullable Boolean verified
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_APPROVE_ALBUM_CONTEST = "/api/{version}/consumer/album/contest/approve";
    /**
     * POST /api/{version}/consumer/album/contest/approve : Approve Contest
     * Sets the approval status of a contest.
     *
     * @param version  (required)
     * @param albumContestId The ID of the album contest (required)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (required)
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "approveAlbumContest",
        summary = "Approve Contest",
        description = "Sets the approval status of a contest.",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_APPROVE_ALBUM_CONTEST,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> approveAlbumContest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumContestId", description = "The ID of the album contest", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = true) Long albumContestId,
        @NotNull @Parameter(name = "approvalStatus", description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = true) String approvalStatus,
        @Parameter(name = "deviceId", description = "A unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_APPROVE_PERMISSIONABLE = "/api/{version}/permissionable/approve";
    /**
     * POST /api/{version}/permissionable/approve : Approve Permissionable
     * Sets the approval status of a permissionable object.
     *
     * @param version  (required)
     * @param permissionableType The permissionable type of the object (required)
     * @param permissionableId The id of the permissionable object (required)
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to APPROVED)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "approvePermissionable",
        summary = "Approve Permissionable",
        description = "Sets the approval status of a permissionable object.",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_APPROVE_PERMISSIONABLE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> approvePermissionable(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "permissionableType", description = "The permissionable type of the object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = true) String permissionableType,
        @NotNull @Parameter(name = "permissionableId", description = "The id of the permissionable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = true) Long permissionableId,
        @Parameter(name = "deviceId", description = "A unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "approvalStatus", description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false, defaultValue = "APPROVED") String approvalStatus
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_APPROVE_ROUTE = "/api/{version}/route/{routeId}/approve";
    /**
     * POST /api/{version}/route/{routeId}/approve : Approve Route
     * Approve a route
     *
     * @param version  (required)
     * @param routeId the id of the route to approve (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "approveRoute",
        summary = "Approve Route",
        description = "Approve a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_APPROVE_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> approveRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to approve", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSET_DOWNLOAD = "/api/{version}/asset/download/{filename}";
    /**
     * GET /api/{version}/asset/download/{filename} : Download Asset
     * Downloads an asset from the server for assets that have been uploaded to the server.
     *
     * @param version  (required)
     * @param filename the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId} (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assetDownload",
        summary = "Download Asset",
        description = "Downloads an asset from the server for assets that have been uploaded to the server.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSET_DOWNLOAD,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> assetDownload(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Pattern(regexp = ".+") @Parameter(name = "filename", description = "the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}", required = true, in = ParameterIn.PATH) @PathVariable("filename") String filename
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSET_MORPH = "/api/{version}/asset/morph";
    /**
     * POST /api/{version}/asset/morph : Convert Offer to Creative
     * Converts an offer image + text into a creative image.
     *
     * @param version  (required)
     * @param offerId offer id used for inserting offer text/flavor (required)
     * @param adSize the ad size used for selecting a format for the creative image (required)
     * @param creativeId used for inserting the newly created image into (optional)
     * @param width total width of the creative image (optional)
     * @param height total height of the creative image (optional)
     * @param backgroundSize the size of the background (optional)
     * @param template the template to use (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assetMorph",
        summary = "Convert Offer to Creative",
        description = "Converts an offer image + text into a creative image.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssetShortResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSET_MORPH,
        produces = { "*/*" }
    )
    default ResponseEntity<AssetShortResponse> assetMorph(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerId", description = "offer id used for inserting offer text/flavor", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = true) Long offerId,
        @NotNull @Parameter(name = "adSize", description = "the ad size used for selecting a format for the creative image", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "adSize", required = true) String adSize,
        @Parameter(name = "creativeId", description = "used for inserting the newly created image into", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = false) @Nullable Long creativeId,
        @Parameter(name = "width", description = "total width of the creative image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "width", required = false) @Nullable Integer width,
        @Parameter(name = "height", description = "total height of the creative image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable Integer height,
        @Parameter(name = "backgroundSize", description = "the size of the background", in = ParameterIn.QUERY) @Valid @RequestParam(value = "backgroundSize", required = false) @Nullable String backgroundSize,
        @Parameter(name = "template", description = "the template to use", in = ParameterIn.QUERY) @Valid @RequestParam(value = "template", required = false) @Nullable String template
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGMENT_ASSIGNEE_ACCOUNT_SEARCH = "/api/{version}/assignment/assignee/search";
    /**
     * GET /api/{version}/assignment/assignee/search : Search Assignment Assignees
     * Search for avaiable users for creating or updating assignment.
     *
     * @param version  (required)
     * @param accountId The account id sending the request (required)
     * @param keyword The keyword to filter the returned results (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assigmentAssigneeAccountSearch",
        summary = "Search Assignment Assignees",
        description = "Search for avaiable users for creating or updating assignment.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AccountMiniResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSIGMENT_ASSIGNEE_ACCOUNT_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AccountMiniResponse>> assigmentAssigneeAccountSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id sending the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "The keyword to filter the returned results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGN_EMPLOYEE = "/api/{version}/employee/assign";
    /**
     * POST /api/{version}/employee/assign : Assign Employee
     * Assign An existing account to be an employee
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param managerAccountId The account id of the manager to assign under (required)
     * @param employeeAccountId The account id of the user to be assigned as employee (required)
     * @param role The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignEmployee",
        summary = "Assign Employee",
        description = "Assign An existing account to be an employee",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = EmployeeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGN_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<EmployeeResponse> assignEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "managerAccountId", description = "The account id of the manager to assign under", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "managerAccountId", required = true) Long managerAccountId,
        @NotNull @Parameter(name = "employeeAccountId", description = "The account id of the user to be assigned as employee", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = true) Long employeeAccountId,
        @Parameter(name = "role", description = "The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGN_TO_LOCATION_EMPLOYEE = "/api/{version}/employee/assignToLocation";
    /**
     * POST /api/{version}/employee/assignToLocation : Assign Employee to Location
     * Assign or unassign the account to a retailer location.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param retailerLocationId The retailer location to apply the change to (required)
     * @param employeeAccountId The account id of the user to apply the change to (optional)
     * @param assign If true (default) assign to the location, otherwise remove from the retailer (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignToLocationEmployee",
        summary = "Assign Employee to Location",
        description = "Assign or unassign the account to a retailer location.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGN_TO_LOCATION_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> assignToLocationEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "retailerLocationId", description = "The retailer location to apply the change to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = true) Long retailerLocationId,
        @Parameter(name = "employeeAccountId", description = "The account id of the user to apply the change to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = false) @Nullable Long employeeAccountId,
        @Parameter(name = "assign", description = "If true (default) assign to the location, otherwise remove from the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assign", required = false, defaultValue = "true") Boolean assign
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_CREATE = "/api/{version}/assignment/create";
    /**
     * POST /api/{version}/assignment/create : Create Assignment
     * Create an assignment.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param name the name for the assignment (required)
     * @param assigneeAccountId the account id to assign to (required)
     * @param description the desciprtion for the assignment (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentCreate",
        summary = "Create Assignment",
        description = "Create an assignment.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_CREATE,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentResponse> assignmentCreate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "the name for the assignment", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "assigneeAccountId", description = "the account id to assign to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assigneeAccountId", required = true) Long assigneeAccountId,
        @Parameter(name = "description", description = "the desciprtion for the assignment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "retailerLocationId", description = "the retailer location id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "tags", description = "the tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "active", description = "determines whether the assignment is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_DELETE = "/api/{version}/assignment/delete";
    /**
     * POST /api/{version}/assignment/delete : Delete Assignment
     * Delete an assignment.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentId the assignment id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentDelete",
        summary = "Delete Assignment",
        description = "Delete an assignment.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_DELETE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> assignmentDelete(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentId", description = "the assignment id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentId", required = true) Long assignmentId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_GET = "/api/{version}/assignment/get";
    /**
     * GET /api/{version}/assignment/get : Get Assignment
     * Get the details of an assignment.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentId the assignment id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentGet",
        summary = "Get Assignment",
        description = "Get the details of an assignment.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSIGNMENT_GET,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentResponse> assignmentGet(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentId", description = "the assignment id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentId", required = true) Long assignmentId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_SEARCH = "/api/{version}/assignment/search";
    /**
     * GET /api/{version}/assignment/search : Search Assignments
     * Search for assignments by the given parameters.
     *
     * @param version  (required)
     * @param accountId the account sending the request (required)
     * @param sortField sort by table field (required)
     * @param descending return results in descending order or not (required)
     * @param activeOnly return active results only or not (required)
     * @param start The record to begin the return set on (required)
     * @param limit The number of records to return (required)
     * @param creatorAccountId the creator of the assignment (optional)
     * @param assigneeAccountIds filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (optional)
     * @param retailerLocationIds filter results by retailer locations (optional)
     * @param currentStatusType filter results by assignment status (optional)
     * @param keyword filter results by keyword search that matches the assignee, creator, or retailer location name (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentSearch",
        summary = "Search Assignments",
        description = "Search for assignments by the given parameters.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AssignmentResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSIGNMENT_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AssignmentResponse>> assignmentSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account sending the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "sort by table field", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "return results in descending order or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "activeOnly", description = "return active results only or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "start", description = "The record to begin the return set on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The number of records to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "creatorAccountId", description = "the creator of the assignment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creatorAccountId", required = false) @Nullable Long creatorAccountId,
        @Parameter(name = "assigneeAccountIds", description = "filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assigneeAccountIds", required = false) @Nullable String assigneeAccountIds,
        @Parameter(name = "retailerLocationIds", description = "filter results by retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "currentStatusType", description = "filter results by assignment status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentStatusType", required = false) @Nullable String currentStatusType,
        @Parameter(name = "keyword", description = "filter results by keyword search that matches the assignee, creator, or retailer location name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_STATUS_CREATE = "/api/{version}/assignment/status/create";
    /**
     * POST /api/{version}/assignment/status/create : Create Assignment Status
     * Create an assignment status.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentId the assignment id (required)
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentStatusCreate",
        summary = "Create Assignment Status",
        description = "Create an assignment status.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_STATUS_CREATE,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentStatusResponse> assignmentStatusCreate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentId", description = "the assignment id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentId", required = true) Long assignmentId,
        @Parameter(name = "scheduledNotificationId", description = "the scheduled notification id for reminders", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = false) @Nullable Long scheduledNotificationId,
        @Parameter(name = "toDo", description = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "toDo", required = false) @Nullable String toDo,
        @Parameter(name = "connection", description = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connection", required = false) @Nullable String connection,
        @Parameter(name = "method", description = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "method", required = false) @Nullable String method,
        @Parameter(name = "status", description = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "closure", description = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", in = ParameterIn.QUERY) @Valid @RequestParam(value = "closure", required = false) @Nullable String closure,
        @Parameter(name = "message", description = "the message from the assignee", in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = false) @Nullable String message,
        @Parameter(name = "followUp", description = "the date to follow up by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "followUp", required = false) @Nullable Long followUp,
        @Parameter(name = "active", description = "determines whether the assignment status is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_STATUS_DELETE = "/api/{version}/assignment/status/delete";
    /**
     * POST /api/{version}/assignment/status/delete : Deletes Assignment Status
     * Deletes an assignment status.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentStatusId the assignment status id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentStatusDelete",
        summary = "Deletes Assignment Status",
        description = "Deletes an assignment status.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_STATUS_DELETE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> assignmentStatusDelete(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentStatusId", description = "the assignment status id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentStatusId", required = true) Long assignmentStatusId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_STATUS_GET = "/api/{version}/assignment/status/get";
    /**
     * GET /api/{version}/assignment/status/get : Get Assignment Status
     * Get an assignment status.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentStatusId the assignment status id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentStatusGet",
        summary = "Get Assignment Status",
        description = "Get an assignment status.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSIGNMENT_STATUS_GET,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentStatusResponse> assignmentStatusGet(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentStatusId", description = "the assignment status id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentStatusId", required = true) Long assignmentStatusId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_STATUS_SEARCH = "/api/{version}/assignment/status/search";
    /**
     * GET /api/{version}/assignment/status/search : Search Assignment Statuses
     * Search on assignment statuses.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param sortField the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param activeOnly determines whether to only return active results (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (required)
     * @param assignmentId the assignment id (optional)
     * @param creatorAccountId filter results by the account who created the status (optional)
     * @param assigneeAccountId filter results by the assignee account (optional)
     * @param retailerLocationId filter results by by retailer location (optional)
     * @param statusType filter results by the status type (optional)
     * @param keyword filter results by keyword search (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentStatusSearch",
        summary = "Search Assignment Statuses",
        description = "Search on assignment statuses.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AssignmentStatusResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_ASSIGNMENT_STATUS_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AssignmentStatusResponse>> assignmentStatusSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "activeOnly", description = "determines whether to only return active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "assignmentId", description = "the assignment id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentId", required = false) @Nullable Long assignmentId,
        @Parameter(name = "creatorAccountId", description = "filter results by the account who created the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creatorAccountId", required = false) @Nullable Long creatorAccountId,
        @Parameter(name = "assigneeAccountId", description = "filter results by the assignee account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assigneeAccountId", required = false) @Nullable Long assigneeAccountId,
        @Parameter(name = "retailerLocationId", description = "filter results by by retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "statusType", description = "filter results by the status type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statusType", required = false) @Nullable String statusType,
        @Parameter(name = "keyword", description = "filter results by keyword search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_STATUS_UPDATE = "/api/{version}/assignment/status/update";
    /**
     * POST /api/{version}/assignment/status/update : Update Assignment Status
     * Updates an assignment status.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentStatusId the assignment status id (required)
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentStatusUpdate",
        summary = "Update Assignment Status",
        description = "Updates an assignment status.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_STATUS_UPDATE,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentStatusResponse> assignmentStatusUpdate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentStatusId", description = "the assignment status id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentStatusId", required = true) Long assignmentStatusId,
        @Parameter(name = "scheduledNotificationId", description = "the scheduled notification id for reminders", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = false) @Nullable Long scheduledNotificationId,
        @Parameter(name = "toDo", description = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "toDo", required = false) @Nullable String toDo,
        @Parameter(name = "connection", description = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connection", required = false) @Nullable String connection,
        @Parameter(name = "method", description = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "method", required = false) @Nullable String method,
        @Parameter(name = "status", description = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "closure", description = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", in = ParameterIn.QUERY) @Valid @RequestParam(value = "closure", required = false) @Nullable String closure,
        @Parameter(name = "message", description = "the message from the assignee", in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = false) @Nullable String message,
        @Parameter(name = "followUp", description = "the date to follow up by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "followUp", required = false) @Nullable Long followUp,
        @Parameter(name = "active", description = "determines whether the assignment status is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ASSIGNMENT_UPDATE = "/api/{version}/assignment/update";
    /**
     * POST /api/{version}/assignment/update : Update Assignment
     * Updates an assignment.
     *
     * @param version  (required)
     * @param accountId the user account id (required)
     * @param assignmentId the assignment id (required)
     * @param name the name of the assignment (optional)
     * @param description the description of the assignment (optional)
     * @param assigneeAccountId the account id to assign to (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "assignmentUpdate",
        summary = "Update Assignment",
        description = "Updates an assignment.",
        tags = { "Assignment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssignmentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ASSIGNMENT_UPDATE,
        produces = { "*/*" }
    )
    default ResponseEntity<AssignmentResponse> assignmentUpdate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "assignmentId", description = "the assignment id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignmentId", required = true) Long assignmentId,
        @Parameter(name = "name", description = "the name of the assignment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "the description of the assignment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "assigneeAccountId", description = "the account id to assign to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assigneeAccountId", required = false) @Nullable Long assigneeAccountId,
        @Parameter(name = "retailerLocationId", description = "the retailer location id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "tags", description = "the tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "active", description = "determines whether the assignment is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_ATTEND_EVENT = "/api/{version}/event/attend";
    /**
     * POST /api/{version}/event/attend : Attend Event
     *  Specify whether the user is attending an event at a particular location. This can also be used as a \&quot;check-in\&quot; action.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @param appKey The application of where to send notifications about the attend action (optional)
     * @param listingId The scheduled broadcast or marketing experience id (optional)
     * @param retailerLocationId The retailer location where the event is being held (optional)
     * @param offerLocationId The actual event being held (optional)
     * @param transactionId The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId (optional)
     * @param status Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3) (optional)
     * @param latitude The location of the status update (optional)
     * @param longitude The location of the status update (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "attendEvent",
        summary = "Attend Event",
        description = " Specify whether the user is attending an event at a particular location. This can also be used as a \"check-in\" action.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_ATTEND_EVENT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferResponse> attendEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application of where to send notifications about the attend action", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "listingId", description = "The scheduled broadcast or marketing experience id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = false) @Nullable Long listingId,
        @Parameter(name = "retailerLocationId", description = "The retailer location where the event is being held", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "offerLocationId", description = "The actual event being held", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "transactionId", description = "The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId", in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionId", required = false) @Nullable Long transactionId,
        @Parameter(name = "status", description = "Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable Integer status,
        @Parameter(name = "latitude", description = "The location of the status update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The location of the status update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_AUTHORIZE_TWITTER = "/api/{version}/twitter/authorize";
    /**
     * POST /api/{version}/twitter/authorize : Authorize Twitter
     * Makes an authorization call to twitter for a user to login and allow any app permissions.
     *
     * @param version  (required)
     * @param appKey the application key (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "authorizeTwitter",
        summary = "Authorize Twitter",
        description = "Makes an authorization call to twitter for a user to login and allow any app permissions.",
        tags = { "Twitter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_AUTHORIZE_TWITTER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> authorizeTwitter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_BATCH = "/api/{version}/orson/ai/batch";
    /**
     * POST /api/{version}/orson/ai/batch : Batch Analysis
     * Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param limit The number of topics to return (optional)
     * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "batch",
        summary = "Batch Analysis",
        description = "Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiBatchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiBatchResponse> batch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "limit", description = "The number of topics to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "operations", description = "The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "operations", required = false) @Nullable String operations,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_BATCH_OPERATION = "/api/{version}/note/batch";
    /**
     * POST /api/{version}/note/batch : Batch Note Operation
     * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
     *
     * @param version  (required)
     * @param notableId The id of the notable object the batch operation will affect (required)
     * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.) (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "batchOperation",
        summary = "Batch Note Operation",
        description = "Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). ",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_BATCH_OPERATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> batchOperation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "notableId", description = "The id of the notable object the batch operation will affect", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableId", required = true) Long notableId,
        @NotNull @Parameter(name = "notableType", description = "The notable object type (for example ALBUM, ASSET, OFFER, etc.)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableType", required = true) String notableType,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "batchOperation", description = "The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "batchOperation", required = false) @Nullable String batchOperation
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_BATCH_SAVE_TRACKING = "/api/{version}/tracking/batch/create";
    /**
     * POST /api/{version}/tracking/batch/create : Create Batch Tracking
     * Batch create tracking legs
     *
     * @param version  (required)
     * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to PASSIVE)
     * @param slaveUID  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "batchSaveTracking",
        summary = "Create Batch Tracking",
        description = "Batch create tracking legs",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Leg.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_BATCH_SAVE_TRACKING,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Leg>> batchSaveTracking(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "data", description = "JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "generateAccounts", description = "Whether to generate accounts for tracking entries when the owner does not exist", in = ParameterIn.QUERY) @Valid @RequestParam(value = "generateAccounts", required = false) @Nullable Boolean generateAccounts,
        @Parameter(name = "updateAccountLocations", description = "Whether to update the account's current location from the incoming tracking data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateAccountLocations", required = false) @Nullable Boolean updateAccountLocations,
        @Parameter(name = "defaultTag", description = "The default tag to apply to incoming legs when no tag is provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultTag", required = false, defaultValue = "PASSIVE") String defaultTag,
        @Parameter(name = "slaveUID", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "slaveUID", required = false) @Nullable String slaveUID
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_BATCH_UPDATE_OFFER_LOCATIONS = "/api/{version}/retailer/offer/location/batchUpdate";
    /**
     * POST /api/{version}/retailer/offer/location/batchUpdate : Update Offer Locations
     * Batch update offer locations.
     *
     * @param version  (required)
     * @param data JSON string in the following format: &#x60;&#x60;&#x60;json [{   \&quot;offerLocationId\&quot;: 1705,   \&quot;latitude\&quot;: 54.0,   \&quot;longitude\&quot;: -122.0,   \&quot;altitude\&quot;: 1.0,   \&quot;locationDetail\&quot;: \&quot;floor 1\&quot;,   \&quot;locationDescription\&quot;: \&quot;behind the Coke sign\&quot; }, {   \&quot;offerLocationId\&quot;: 1704,   \&quot;latitude\&quot;: 54.1,   \&quot;longitude\&quot;: -122.1 }] &#x60;&#x60;&#x60;  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "batchUpdateOfferLocations",
        summary = "Update Offer Locations",
        description = "Batch update offer locations.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_BATCH_UPDATE_OFFER_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> batchUpdateOfferLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "data", description = "JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_BLOCK_ACCOUNT = "/api/{version}/account/block";
    /**
     * POST /api/{version}/account/block : Block Account
     * Moves or removes an account into the user&#39;s blocked group.
     *
     * @param version  (required)
     * @param accountIdBeingBlocked The id of the account to be blocked/unblocked (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockFlagValue Determines whether the account is blocked or unblocked (optional, default to true)
     * @param removeFromGroupsIfBlocked Determines whether the account is removed from all other groups if blocked (optional, default to false)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "blockAccount",
        summary = "Block Account",
        description = "Moves or removes an account into the user's blocked group.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_BLOCK_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> blockAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountIdBeingBlocked", description = "The id of the account to be blocked/unblocked", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountIdBeingBlocked", required = true) Long accountIdBeingBlocked,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "blockFlagValue", description = "Determines whether the account is blocked or unblocked", in = ParameterIn.QUERY) @Valid @RequestParam(value = "blockFlagValue", required = false, defaultValue = "true") Boolean blockFlagValue,
        @Parameter(name = "removeFromGroupsIfBlocked", description = "Determines whether the account is removed from all other groups if blocked", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFromGroupsIfBlocked", required = false, defaultValue = "false") Boolean removeFromGroupsIfBlocked,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CACHE_TRILATERATION_DATA = "/api/{version}/location/trilaterate/cache";
    /**
     * POST /api/{version}/location/trilaterate/cache : Create Trilateration Data with File
     * Creates trilateration samples for a source device (i.e. a router).
     *
     * @param version  (required)
     * @param udid The unique identifier of the source device (required)
     * @param sourceTime The current timestamp of the source device (optional)
     * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)
     * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param dataFile Binary file containing data (multipart upload) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "cacheTrilaterationData",
        summary = "Create Trilateration Data with File",
        description = "Creates trilateration samples for a source device (i.e. a router).",
        tags = { "Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CACHE_TRILATERATION_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> cacheTrilaterationData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "udid", description = "The unique identifier of the source device", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = true) String udid,
        @Parameter(name = "sourceTime", description = "The current timestamp of the source device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sourceTime", required = false) @Nullable Long sourceTime,
        @Parameter(name = "minimumSampleSize", description = "the minimum number of Edysen devices that must be used to be able to trilaterate a device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumSampleSize", required = false) @Nullable Integer minimumSampleSize,
        @Parameter(name = "data", description = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = false) @Nullable String data,
        @Parameter(name = "dataFile", description = "Binary file containing data (multipart upload)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dataFile", required = false) @Nullable org.springframework.core.io.Resource dataFile
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CACHE_TRILATERATION_DATA_GZIP = "/api/{version}/location/trilaterate/cache/submit";
    /**
     * POST /api/{version}/location/trilaterate/cache/submit : Create Trilateration Data with Rest
     * Creates trilateration samples for a source device (i.e. a router).
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "cacheTrilaterationDataGzip",
        summary = "Create Trilateration Data with Rest",
        description = "Creates trilateration samples for a source device (i.e. a router).",
        tags = { "Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CACHE_TRILATERATION_DATA_GZIP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> cacheTrilaterationDataGzip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable TrilatCacheRequest body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CANCEL_SHIPMENT = "/api/{version}/shipment/{id}/cancel";
    /**
     * POST /api/{version}/shipment/{id}/cancel : Cancel Shipment
     * Remove shipment from route
     *
     * @param version  (required)
     * @param id the id of the shipment to cancel (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "cancelShipment",
        summary = "Cancel Shipment",
        description = "Remove shipment from route",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CANCEL_SHIPMENT
    )
    default ResponseEntity<Void> cancelShipment(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the shipment to cancel", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CATEGORY_DISTANCE_SEARCH = "/api/{version}/category/distancesearch";
    /**
     * GET /api/{version}/category/distancesearch : Search Categories by Distance
     * Search for categories by distance.
     *
     * @param version  (required)
     * @param accountId The account id of the user (optional)
     * @param keyword The keyword string to search on (optional)
     * @param appKey the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param categoryIds Restrict the search by specific categories (optional)
     * @param parentCategoryIds Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param rootOnly Restrict the search to only those categories with no parent category assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to DISPLAY)
     * @param responseGroup The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @param returnExternal Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param exactMatch If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param type Filters results by the Category&#39;s type (optional)
     * @param externalType Filters results by externalType (optional)
     * @param minOfferCount Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param latitude the latitude of where the search is centered on (optional)
     * @param longitude the longitude of where the search is centered on (optional)
     * @param range the maximum range the category can be from the center (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "categoryDistanceSearch",
        summary = "Search Categories by Distance",
        description = "Search for categories by distance.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = CategoryResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_CATEGORY_DISTANCE_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<CategoryResponse>> categoryDistanceSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "The keyword string to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "appKey", description = "the appKey of the application to retrieve categories for, if not specified then search on the global application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "categoryIds", description = "Restrict the search by specific categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "parentCategoryIds", description = "Restrict the search by specific parent categories so that only its sub children are searched.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentCategoryIds", required = false) @Nullable String parentCategoryIds,
        @Parameter(name = "rootOnly", description = "Restrict the search to only those categories with no parent category assigned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rootOnly", required = false) @Nullable Boolean rootOnly,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") String sortField,
        @Parameter(name = "responseGroup", description = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroup", required = false) @Nullable String responseGroup,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "returnExternal", description = "Determines whether to return extra info about the category's \"Participant\" reference", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnExternal", required = false) @Nullable Boolean returnExternal,
        @Parameter(name = "exactMatch", description = "If true search categories using the exact keyword, if false then do a partial match (like) search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exactMatch", required = false) @Nullable Boolean exactMatch,
        @Parameter(name = "type", description = "Filters results by the Category's type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "externalType", description = "Filters results by externalType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "minOfferCount", description = "Filters results to only return Categories that have been referenced by a minimum number of Offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minOfferCount", required = false) @Nullable Integer minOfferCount,
        @Parameter(name = "latitude", description = "the latitude of where the search is centered on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of where the search is centered on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "range", description = "the maximum range the category can be from the center", in = ParameterIn.QUERY) @Valid @RequestParam(value = "range", required = false) @Nullable Double range
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CHECK_DISBURSEMENTS = "/api/{version}/disbursement/check";
    /**
     * GET /api/{version}/disbursement/check : Check Disbursements
     * Checks the status of a captured disbrusement to see if it has been settled.
     *
     * @param version  (required)
     * @param disbursementId the ID of the disbursement being checked on (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "checkDisbursements",
        summary = "Check Disbursements",
        description = "Checks the status of a captured disbrusement to see if it has been settled.",
        tags = { "Disbursement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DisbursementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_CHECK_DISBURSEMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<DisbursementResponse> checkDisbursements(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "disbursementId", description = "the ID of the disbursement being checked on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "disbursementId", required = true) Long disbursementId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_COMPUTE_PATH = "/api/{version}/pathing/compute";
    /**
     * GET /api/{version}/pathing/compute : Calculate Path
     * Calculates the shortest path from point to point on a grid
     *
     * @param version  (required)
     * @param data the data to with start, end point and exclusion points (required)
     * @param units the system of measurement for directions: {METRIC, IMPERIAL} (required)
     * @param reducePath determines whether to reduce the path to go in diagonal lines (required)
     * @param directions determines whether to return text directions (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "computePath",
        summary = "Calculate Path",
        description = "Calculates the shortest path from point to point on a grid",
        tags = { "Pathing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PathingResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_COMPUTE_PATH,
        produces = { "*/*" }
    )
    default ResponseEntity<PathingResponse> computePath(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "data", description = "the data to with start, end point and exclusion points", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @NotNull @Parameter(name = "units", description = "the system of measurement for directions: {METRIC, IMPERIAL}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "units", required = true) String units,
        @NotNull @Parameter(name = "reducePath", description = "determines whether to reduce the path to go in diagonal lines", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reducePath", required = true) Boolean reducePath,
        @NotNull @Parameter(name = "directions", description = "determines whether to return text directions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "directions", required = true) Boolean directions
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_COMPUTE_ROUTING = "/api/{version}/routing/compute";
    /**
     * POST /api/{version}/routing/compute : Compute Route
     * This service finds the most optimal routes for delivering items between locations (reducing transit time/resources). It can take in a list of vehicles and a list of items (to be transported).All load items have pick-up and drop-off locations with time windows for when the item is expected to be picked-up and dropped-off. 
     *
     * @param version  (required)
     * @param data Json object containing inputs for generating the routes. See description for more info. Also see RoutingRequest (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "computeRouting",
        summary = "Compute Route",
        description = "This service finds the most optimal routes for delivering items between locations (reducing transit time/resources). It can take in a list of vehicles and a list of items (to be transported).All load items have pick-up and drop-off locations with time windows for when the item is expected to be picked-up and dropped-off. ",
        tags = { "Routing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RoutingListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_COMPUTE_ROUTING,
        produces = { "*/*" }
    )
    default ResponseEntity<RoutingListResponse> computeRouting(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "data", description = "Json object containing inputs for generating the routes. See description for more info. Also see RoutingRequest", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CONSUMER_CREATE = "/api/{version}/queue/consumer/create";
    /**
     * POST /api/{version}/queue/consumer/create : Create Consumer
     * Create a connection to an existing amqp queue and register as a consumer.
     *
     * @param version  (required)
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied. (required)
     * @param name The name of the queue to connect to (required)
     * @param hostname The hostname of the server the queue is hosted on (required)
     * @param username The username to access the server the queue is hosted on (required)
     * @param password The password to access the queue to connect to (required)
     * @param dataMapping The data mapping information in the format of AMQPRequest (required)
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param port The port of the server the queue is hosted on (optional, default to 5672)
     * @param virtualHost The virtual host defined on the server the queue is associated on (optional)
     * @param exchanger The exchanger of the queue to connect to (optional)
     * @param exchangerType The exchanger type of the queue to connect to (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param useSSL Use SSL (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "consumerCreate",
        summary = "Create Consumer",
        description = "Create a connection to an existing amqp queue and register as a consumer.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CONSUMER_CREATE,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> consumerCreate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "name", description = "The name of the queue to connect to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "hostname", description = "The hostname of the server the queue is hosted on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "hostname", required = true) String hostname,
        @NotNull @Parameter(name = "username", description = "The username to access the server the queue is hosted on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "The password to access the queue to connect to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @NotNull @Parameter(name = "dataMapping", description = "The data mapping information in the format of AMQPRequest", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "dataMapping", required = true) String dataMapping,
        @Parameter(name = "deviceId", description = "The client deviceID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "port", description = "The port of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "port", required = false, defaultValue = "5672") Integer port,
        @Parameter(name = "virtualHost", description = "The virtual host defined on the server the queue is associated on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "virtualHost", required = false) @Nullable String virtualHost,
        @Parameter(name = "exchanger", description = "The exchanger of the queue to connect to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exchanger", required = false) @Nullable String exchanger,
        @Parameter(name = "exchangerType", description = "The exchanger type of the queue to connect to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exchangerType", required = false) @Nullable String exchangerType,
        @Parameter(name = "workers", description = "The number of workers to generate ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "workers", required = false, defaultValue = "1") Integer workers,
        @Parameter(name = "useSSL", description = "Use SSL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useSSL", required = false) @Nullable Boolean useSSL
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CONSUMER_UPDATE = "/api/{version}/queue/consumer/update";
    /**
     * POST /api/{version}/queue/consumer/update : Update Consumer
     * Update an existing amqp queue&#39;s data mapping.
     *
     * @param version  (required)
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied. (required)
     * @param queueId The queue to update (required)
     * @param dataMapping The data mapping information in the format of AMQPRequest (required)
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param useSSL Use SSL (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "consumerUpdate",
        summary = "Update Consumer",
        description = "Update an existing amqp queue's data mapping.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CONSUMER_UPDATE,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> consumerUpdate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "queueId", description = "The queue to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = true) Long queueId,
        @NotNull @Parameter(name = "dataMapping", description = "The data mapping information in the format of AMQPRequest", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "dataMapping", required = true) String dataMapping,
        @Parameter(name = "deviceId", description = "The client deviceID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "useSSL", description = "Use SSL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useSSL", required = false) @Nullable Boolean useSSL
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_COPY_ROUTE = "/api/{version}/route/{routeId}/copy";
    /**
     * POST /api/{version}/route/{routeId}/copy : Copy Route
     * Make an copy of the given route with optional overriding properties
     *
     * @param version  (required)
     * @param routeId the id of the route to duplicate (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "copyRoute",
        summary = "Copy Route",
        description = "Make an copy of the given route with optional overriding properties",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_COPY_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> copyRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to duplicate", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Route body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE = "/api/{version}/cargo/dependent/{accountId}";
    /**
     * PUT /api/{version}/cargo/dependent/{accountId} : Create Dependent
     * Create dependent of the account
     *
     * @param version  (required)
     * @param accountId the id of the parent account to create a dependent for (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "create",
        summary = "Create Dependent",
        description = "Create dependent of the account",
        tags = { "Dependent" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_CREATE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> create(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the parent account to create a dependent for", required = true, in = ParameterIn.PATH) @PathVariable("accountId") Long accountId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Account body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ACCOUNT = "/api/{version}/account/create";
    /**
     * POST /api/{version}/account/create : Create Account
     * Create a new account by role.
     *
     * @param version  (required)
     * @param username The access token to authenticate with (ex: username) (required)
     * @param password The secret to authenticate with (ex: password) (required)
     * @param name The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user (AudienceGender) (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param role The account role (default: MEMBER) (optional)
     * @param platforms Comma separated list of development platforms (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About us information (optional)
     * @param gameExperience Game experience of the user (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred location in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param inviteToken The inviteToken that the referrer used for this account to sign up (optional)
     * @param referralAccountId The accountId of the referrer (used if there is no inviteToken) (optional)
     * @param sendValidation Whether to send validation email (optional)
     * @param gameType Deprecated: use appKey (optional)
     * @param appKey The application key (optional)
     * @param appVersion The application version (optional)
     * @param responseType Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in (optional)
     * @param audienceIdsToAdd Comma separated list of audience ids to assign to the user (optional)
     * @param appBlob Application blob data (optional)
     * @param appEnablePush Enable push for the app (optional)
     * @param appEnableSMS Enable SMS for the app (optional)
     * @param appEnableEmail Enable email for the app (optional)
     * @param locationVisibility Location visibility setting (optional)
     * @param homeLatitude Home latitude (optional)
     * @param homeLongitude Home longitude (optional)
     * @param appNickname The nickname used in the application for this account (optional)
     * @param personalAudienceId Personal audience id to associate with this account (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAccount",
        summary = "Create Account",
        description = "Create a new account by role.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AccountLoginResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<AccountLoginResponse> createAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "username", description = "The access token to authenticate with (ex: username)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "The secret to authenticate with (ex: password)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "name", description = "The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "prefixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "prefixName", required = false) @Nullable String prefixName,
        @Parameter(name = "firstName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "middleName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "middleName", required = false) @Nullable String middleName,
        @Parameter(name = "lastName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "suffixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffixName", required = false) @Nullable String suffixName,
        @Parameter(name = "title", description = "This field will be used to set the user's job title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "deviceIdType", description = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdType", required = false) @Nullable String deviceIdType,
        @Parameter(name = "emailAddress", description = "The user's contact email address (NOT the username)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "assetId", description = "The asset id to set the user's profile image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "streetAddress", description = "The street address of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "zipcode", description = "The zipcode of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "gender", description = "The gender of the user (AudienceGender)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "birthday", description = "The birthday date of the user in UTC milliseconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "birthday", required = false) @Nullable Long birthday,
        @Parameter(name = "homePhone", description = "The home phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homePhone", required = false) @Nullable String homePhone,
        @Parameter(name = "cellPhone", description = "The cellular phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "cellPhoneCarrier", description = "The cellular service provider", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhoneCarrier", required = false) @Nullable String cellPhoneCarrier,
        @Parameter(name = "businessPhone", description = "The business phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "role", description = "The account role (default: MEMBER)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "platforms", description = "Comma separated list of development platforms", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "tags", description = "Search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "aboutUs", description = "About us information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "aboutUs", required = false) @Nullable String aboutUs,
        @Parameter(name = "gameExperience", description = "Game experience of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperience", required = false) @Nullable String gameExperience,
        @Parameter(name = "categoryIds", description = "A list of category ids that represent interests and associations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "hometown", description = "The user's hometown", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hometown", required = false) @Nullable String hometown,
        @Parameter(name = "height", description = "The user's height", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable String height,
        @Parameter(name = "heightIndex", description = "The user's height in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "heightIndex", required = false) @Nullable Integer heightIndex,
        @Parameter(name = "ethnicity", description = "The user's ethnicity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ethnicity", required = false) @Nullable String ethnicity,
        @Parameter(name = "bodyType", description = "The user's body type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bodyType", required = false) @Nullable String bodyType,
        @Parameter(name = "maritalStatus", description = "The user's marital status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maritalStatus", required = false) @Nullable String maritalStatus,
        @Parameter(name = "children", description = "The user's children status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "children", required = false) @Nullable String children,
        @Parameter(name = "religion", description = "The user's religion", in = ParameterIn.QUERY) @Valid @RequestParam(value = "religion", required = false) @Nullable String religion,
        @Parameter(name = "education", description = "The user's education", in = ParameterIn.QUERY) @Valid @RequestParam(value = "education", required = false) @Nullable String education,
        @Parameter(name = "educationIndex", description = "The user's education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "educationIndex", required = false) @Nullable Integer educationIndex,
        @Parameter(name = "smoke", description = "The user's smoke status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smoke", required = false) @Nullable String smoke,
        @Parameter(name = "drink", description = "The user's drink status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "drink", required = false) @Nullable String drink,
        @Parameter(name = "companionship", description = "The user's companionship status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionship", required = false) @Nullable String companionship,
        @Parameter(name = "companionshipIndex", description = "The user's companionship index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionshipIndex", required = false) @Nullable Integer companionshipIndex,
        @Parameter(name = "preferredMinAge", description = "The preferred minimum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinAge", required = false) @Nullable Integer preferredMinAge,
        @Parameter(name = "preferredMaxAge", description = "The preferred maximum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxAge", required = false) @Nullable Integer preferredMaxAge,
        @Parameter(name = "preferredMinHeight", description = "The preferred minimum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinHeight", required = false) @Nullable Integer preferredMinHeight,
        @Parameter(name = "preferredMaxHeight", description = "The preferred maximum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxHeight", required = false) @Nullable Integer preferredMaxHeight,
        @Parameter(name = "preferredGender", description = "The preferred gender in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredGender", required = false) @Nullable String preferredGender,
        @Parameter(name = "preferredEducation", description = "The preferred education in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducation", required = false) @Nullable String preferredEducation,
        @Parameter(name = "preferredEducationIndex", description = "The preferred education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducationIndex", required = false) @Nullable Integer preferredEducationIndex,
        @Parameter(name = "preferredBodyType", description = "The preferred body type in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredBodyType", required = false) @Nullable String preferredBodyType,
        @Parameter(name = "preferredEthnicity", description = "The preferred ethnicity in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEthnicity", required = false) @Nullable String preferredEthnicity,
        @Parameter(name = "preferredLocation", description = "The preferred location in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocation", required = false) @Nullable String preferredLocation,
        @Parameter(name = "preferredLocationRange", description = "The preferred location range in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocationRange", required = false) @Nullable Double preferredLocationRange,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "acceptedTerms", description = "Accepted Terms", in = ParameterIn.QUERY) @Valid @RequestParam(value = "acceptedTerms", required = false) @Nullable Boolean acceptedTerms,
        @Parameter(name = "inviteToken", description = "The inviteToken that the referrer used for this account to sign up", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inviteToken", required = false) @Nullable String inviteToken,
        @Parameter(name = "referralAccountId", description = "The accountId of the referrer (used if there is no inviteToken)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referralAccountId", required = false) @Nullable Long referralAccountId,
        @Parameter(name = "sendValidation", description = "Whether to send validation email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendValidation", required = false) @Nullable Boolean sendValidation,
        @Parameter(name = "gameType", description = "Deprecated: use appKey", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "appVersion", description = "The application version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "responseType", description = "Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseType", required = false) @Nullable String responseType,
        @Parameter(name = "audienceIdsToAdd", description = "Comma separated list of audience ids to assign to the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "appBlob", description = "Application blob data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appBlob", required = false) @Nullable String appBlob,
        @Parameter(name = "appEnablePush", description = "Enable push for the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnablePush", required = false) @Nullable Boolean appEnablePush,
        @Parameter(name = "appEnableSMS", description = "Enable SMS for the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnableSMS", required = false) @Nullable Boolean appEnableSMS,
        @Parameter(name = "appEnableEmail", description = "Enable email for the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnableEmail", required = false) @Nullable Boolean appEnableEmail,
        @Parameter(name = "locationVisibility", description = "Location visibility setting", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationVisibility", required = false) @Nullable String locationVisibility,
        @Parameter(name = "homeLatitude", description = "Home latitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homeLatitude", required = false) @Nullable Double homeLatitude,
        @Parameter(name = "homeLongitude", description = "Home longitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homeLongitude", required = false) @Nullable Double homeLongitude,
        @Parameter(name = "appNickname", description = "The nickname used in the application for this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appNickname", required = false) @Nullable String appNickname,
        @Parameter(name = "personalAudienceId", description = "Personal audience id to associate with this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "personalAudienceId", required = false) @Nullable Long personalAudienceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ACHIEVEMENT = "/api/{version}/achievement/create";
    /**
     * POST /api/{version}/achievement/create : Create Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param appKey the application key the achievement is for (required)
     * @param title the title of the achievement (255 character limit) (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active achievement is active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAchievement",
        summary = "Create Achievement",
        description = "Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ACHIEVEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementResponse> createAchievement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key the achievement is for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "title", description = "the title of the achievement (255 character limit)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "analyticsTag", description = "the analytics tag that will trigger when a user's achievement count gets updated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "analyticsTag", required = false) @Nullable String analyticsTag,
        @Parameter(name = "description", description = "the description of the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "rankType", description = "the rank type for updating leader boards", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "rankIncrement", description = "determines how much the rank count is incremented", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankIncrement", required = false) @Nullable Integer rankIncrement,
        @Parameter(name = "minIncrement", description = "restrict scores to be above or equal to this minimum value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minIncrement", required = false) @Nullable Integer minIncrement,
        @Parameter(name = "maxIncrement", description = "restrict scores to be below or equal to this maximum value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxIncrement", required = false) @Nullable Integer maxIncrement,
        @Parameter(name = "validate", description = "determines whether the customId on analytics are used to validate a user's achievement progress.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "validate", required = false) @Nullable Boolean validate,
        @Parameter(name = "active", description = "achievement is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "triggerDefinition", description = "if provided will define what triggers to run after a tier is completed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "triggerDefinition", required = false) @Nullable String triggerDefinition
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ACHIEVEMENT_TIER = "/api/{version}/achievement/tier/create";
    /**
     * POST /api/{version}/achievement/tier/create : Create Achievement Tier
     * Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param achievementId the achievement id for adding a new tier (required)
     * @param scoreAllInstances score all instances (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAchievementTier",
        summary = "Create Achievement Tier",
        description = "Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementTierResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ACHIEVEMENT_TIER,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementTierResponse> createAchievementTier(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "achievementId", description = "the achievement id for adding a new tier", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementId", required = true) Long achievementId,
        @NotNull @Parameter(name = "scoreAllInstances", description = "score all instances", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoreAllInstances", required = true) Boolean scoreAllInstances,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "icon", description = "achievement tier icon image file", in = ParameterIn.QUERY) @Valid @RequestParam(value = "icon", required = false) @Nullable org.springframework.core.io.Resource icon,
        @Parameter(name = "iconAssetId", description = "the icon assetId, if icon is provided, icon will overrule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconAssetId", required = false) @Nullable Long iconAssetId,
        @Parameter(name = "title", description = "the title of the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "the description of the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "goalCount", description = "the count requirement for completing the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "goalCount", required = false) @Nullable Long goalCount,
        @Parameter(name = "missionId", description = "The ID of the mission to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "gameId", description = "The ID of the game to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "packId", description = "The ID of the pack to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "The ID of the game level to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "gameObjectId", description = "The ID of the game object to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = false) @Nullable Integer gameObjectId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_APPLICATION = "/api/{version}/application/create";
    /**
     * POST /api/{version}/application/create : Create Application
     * Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.
     *
     * @param version  (required)
     * @param appName The name of the application (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param about The description of the application (optional)
     * @param bundleId The application bundle identifier (format - com.company.appName) (optional)
     * @param appIconAssetId The application icon asset id (optional)
     * @param appLogoAssetId The application logo asset id (optional)
     * @param facebookAppId The Facebook application id (optional)
     * @param facebookAppSecret The Facebook application secret (optional)
     * @param googleApiKey This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging (optional)
     * @param updateEULADate Determines whether to update the EULA date (optional)
     * @param eulaVersion The EULA version (optional)
     * @param landingPageUrl The landing page URL (optional)
     * @param showInActivities Determines whether to show the application in the activity feed (optional)
     * @param activityDescription The description of the application in the activity feed (optional)
     * @param inviteWelcomeText The text to display on the invite page (optional)
     * @param invitePageUrl The url to the application invite page (optional)
     * @param urlScheme The protocal the app uses to load the app via a browser (optional)
     * @param platforms A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param downloadUrls Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;   (optional)
     * @param categoryIds List of categories to apply (optional)
     * @param scoringType The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT (optional, default to GAME_LEVEL)
     * @param hintCost The cost of hints (optional, default to 11)
     * @param maxScore The maximum score that will be possible (optional, default to 125)
     * @param ticketsPerPoint The point-to-ticket conversion ratio (optional, default to 0.037)
     * @param hasGameData Determines whether the application uses services to save custom game objects (optional, default to true)
     * @param publicNotifications Public Notifications (optional)
     * @param useMatchingAlgorithm Use Matching Algorithm (optional)
     * @param globalTickets Determines whether earned tickets are applied across all applications (optional, default to false)
     * @param buildVersion The current build version of the application (optional, default to 1)
     * @param apiVersion The current API version the application uses (optional)
     * @param placementName The name of the placement (optional)
     * @param placementDescription The description of the placement (optional)
     * @param placementSize The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created) (optional)
     * @param placementHeight The height of a custom ad size (optional)
     * @param placementWidth The width of a custom ad size (optional)
     * @param placementRefreshInterval The refresh interval in seconds (optional)
     * @param createObjectStore Generate a custom object store to use (optional, default to true)
     * @param publicContentApproval Determine whether or not public content requires admin approval before it becomes public (optional, default to false)
     * @param productionMode Determines whether the application uses production or sandbox services (optional, default to false)
     * @param minimumSessionLength Minimum Session Length (optional)
     * @param sessionGapLength Session Gap Length (optional)
     * @param localAdsEnabled Local Ads Enabled (optional, default to false)
     * @param sqootApiKey Sqoot Api Key (optional)
     * @param trilatProcessingType Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT (optional, default to FINGERPRINT)
     * @param maxSampleSize Determines what the maximum sample size during trilateration (optional)
     * @param minRSSI Determines what the minimum acceptable RSSI value (optional)
     * @param modules List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL (optional, default to ALL)
     * @param authorizedCount How many servers the license will support (optional, default to 1)
     * @param authorizedServers The list of ip addresses of servers the license will support, leave null for any server (optional)
     * @param defaultTimezone Sets the default timezone for the app (used for leaderboards and other time specific content) (optional)
     * @param smtpPass SMTP Pass (optional)
     * @param metaData The application meta data. Defined by the client (optional)
     * @param placementMetaData The ad placement meta data. Defined by the client (optional)
     * @param ipsFloor Create floor tables for Ips (optional, default to false)
     * @param enableAPNSBadge Enables setting the APNS badge value in the payload (optional, default to true)
     * @param includeInReport Enables using the application in session reports (optional, default to true)
     * @param defaultAppFilterId Sets the default filter to use (if none is passed in) for certain search APIs including Album Search. (optional)
     * @param enableWelcomeEmail Enables whether the default welcome email will be sent for new app users (optional)
     * @param appleAppId The Apple Application ID (optional)
     * @param appleTeamId The Apple Team ID (optional)
     * @param appleAuthKeyId The Apple Auth Key ID (optional)
     * @param appleAuthKey The Apple Auth Signin Key (p8) File (optional)
     * @param appleIssuerId The Apple Issuer ID (optional)
     * @param appStoreKeyId The Apple App Store Key ID (optional)
     * @param appStoreKey The Apple App Store Key (p8) File (optional)
     * @param googlePrivateKeyFile This is the private key file for your Google service account. (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @param emailSender Email Sender (optional)
     * @param smtpUser SMTP User (optional)
     * @param smtpHost SMTP Host (optional)
     * @param vatomBusinessId Vatom Business Id (optional)
     * @param vatomRestClientId Vatom REST Client Id (optional)
     * @param vatomRestSecretKey Vatom Secret Key (optional)
     * @param twilioAccountSID Twilio Account SID (optional)
     * @param twilioAuthToken Twilio Auth Token (optional)
     * @param twilioSenderPhoneNumber Twilio Sender Phone Number (optional)
     * @param openAISecretKey OpenAI Secret API Key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createApplication",
        summary = "Create Application",
        description = "Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationResponse> createApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appName", description = "The name of the application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appName", required = true) String appName,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "about", description = "The description of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "about", required = false) @Nullable String about,
        @Parameter(name = "bundleId", description = "The application bundle identifier (format - com.company.appName)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bundleId", required = false) @Nullable String bundleId,
        @Parameter(name = "appIconAssetId", description = "The application icon asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appIconAssetId", required = false) @Nullable Long appIconAssetId,
        @Parameter(name = "appLogoAssetId", description = "The application logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appLogoAssetId", required = false) @Nullable Long appLogoAssetId,
        @Parameter(name = "facebookAppId", description = "The Facebook application id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookAppId", required = false) @Nullable String facebookAppId,
        @Parameter(name = "facebookAppSecret", description = "The Facebook application secret", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookAppSecret", required = false) @Nullable String facebookAppSecret,
        @Parameter(name = "googleApiKey", description = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googleApiKey", required = false) @Nullable String googleApiKey,
        @Parameter(name = "updateEULADate", description = "Determines whether to update the EULA date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateEULADate", required = false) @Nullable Boolean updateEULADate,
        @Parameter(name = "eulaVersion", description = "The EULA version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eulaVersion", required = false) @Nullable String eulaVersion,
        @Parameter(name = "landingPageUrl", description = "The landing page URL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "landingPageUrl", required = false) @Nullable String landingPageUrl,
        @Parameter(name = "showInActivities", description = "Determines whether to show the application in the activity feed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showInActivities", required = false) @Nullable Boolean showInActivities,
        @Parameter(name = "activityDescription", description = "The description of the application in the activity feed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activityDescription", required = false) @Nullable String activityDescription,
        @Parameter(name = "inviteWelcomeText", description = "The text to display on the invite page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inviteWelcomeText", required = false) @Nullable String inviteWelcomeText,
        @Parameter(name = "invitePageUrl", description = "The url to the application invite page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "invitePageUrl", required = false) @Nullable String invitePageUrl,
        @Parameter(name = "urlScheme", description = "The protocal the app uses to load the app via a browser", in = ParameterIn.QUERY) @Valid @RequestParam(value = "urlScheme", required = false) @Nullable String urlScheme,
        @Parameter(name = "platforms", description = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "downloadUrls", description = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "downloadUrls", required = false) @Nullable String downloadUrls,
        @Parameter(name = "categoryIds", description = "List of categories to apply", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "scoringType", description = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoringType", required = false, defaultValue = "GAME_LEVEL") String scoringType,
        @Parameter(name = "hintCost", description = "The cost of hints", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hintCost", required = false, defaultValue = "11") Integer hintCost,
        @Parameter(name = "maxScore", description = "The maximum score that will be possible", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxScore", required = false, defaultValue = "125") Integer maxScore,
        @Parameter(name = "ticketsPerPoint", description = "The point-to-ticket conversion ratio", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsPerPoint", required = false, defaultValue = "0.037") Float ticketsPerPoint,
        @Parameter(name = "hasGameData", description = "Determines whether the application uses services to save custom game objects", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasGameData", required = false, defaultValue = "true") Boolean hasGameData,
        @Parameter(name = "publicNotifications", description = "Public Notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicNotifications", required = false) @Nullable Boolean publicNotifications,
        @Parameter(name = "useMatchingAlgorithm", description = "Use Matching Algorithm", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useMatchingAlgorithm", required = false) @Nullable Boolean useMatchingAlgorithm,
        @Parameter(name = "globalTickets", description = "Determines whether earned tickets are applied across all applications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalTickets", required = false, defaultValue = "false") Boolean globalTickets,
        @Parameter(name = "buildVersion", description = "The current build version of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "buildVersion", required = false, defaultValue = "1") Float buildVersion,
        @Parameter(name = "apiVersion", description = "The current API version the application uses", in = ParameterIn.QUERY) @Valid @RequestParam(value = "apiVersion", required = false) @Nullable Float apiVersion,
        @Parameter(name = "placementName", description = "The name of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementName", required = false) @Nullable String placementName,
        @Parameter(name = "placementDescription", description = "The description of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementDescription", required = false) @Nullable String placementDescription,
        @Parameter(name = "placementSize", description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementSize", required = false) @Nullable String placementSize,
        @Parameter(name = "placementHeight", description = "The height of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementHeight", required = false) @Nullable Integer placementHeight,
        @Parameter(name = "placementWidth", description = "The width of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementWidth", required = false) @Nullable Integer placementWidth,
        @Parameter(name = "placementRefreshInterval", description = "The refresh interval in seconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementRefreshInterval", required = false) @Nullable Integer placementRefreshInterval,
        @Parameter(name = "createObjectStore", description = "Generate a custom object store to use", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createObjectStore", required = false, defaultValue = "true") Boolean createObjectStore,
        @Parameter(name = "publicContentApproval", description = "Determine whether or not public content requires admin approval before it becomes public", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicContentApproval", required = false, defaultValue = "false") Boolean publicContentApproval,
        @Parameter(name = "productionMode", description = "Determines whether the application uses production or sandbox services", in = ParameterIn.QUERY) @Valid @RequestParam(value = "productionMode", required = false, defaultValue = "false") Boolean productionMode,
        @Parameter(name = "minimumSessionLength", description = "Minimum Session Length", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumSessionLength", required = false) @Nullable Integer minimumSessionLength,
        @Parameter(name = "sessionGapLength", description = "Session Gap Length", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sessionGapLength", required = false) @Nullable Integer sessionGapLength,
        @Parameter(name = "localAdsEnabled", description = "Local Ads Enabled", in = ParameterIn.QUERY) @Valid @RequestParam(value = "localAdsEnabled", required = false, defaultValue = "false") Boolean localAdsEnabled,
        @Parameter(name = "sqootApiKey", description = "Sqoot Api Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sqootApiKey", required = false) @Nullable String sqootApiKey,
        @Parameter(name = "trilatProcessingType", description = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilatProcessingType", required = false, defaultValue = "FINGERPRINT") String trilatProcessingType,
        @Parameter(name = "maxSampleSize", description = "Determines what the maximum sample size during trilateration", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxSampleSize", required = false) @Nullable Integer maxSampleSize,
        @Parameter(name = "minRSSI", description = "Determines what the minimum acceptable RSSI value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minRSSI", required = false) @Nullable Double minRSSI,
        @Parameter(name = "modules", description = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "modules", required = false, defaultValue = "ALL") String modules,
        @Parameter(name = "authorizedCount", description = "How many servers the license will support", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizedCount", required = false, defaultValue = "1") Integer authorizedCount,
        @Parameter(name = "authorizedServers", description = "The list of ip addresses of servers the license will support, leave null for any server", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizedServers", required = false) @Nullable String authorizedServers,
        @Parameter(name = "defaultTimezone", description = "Sets the default timezone for the app (used for leaderboards and other time specific content)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultTimezone", required = false) @Nullable String defaultTimezone,
        @Parameter(name = "smtpPass", description = "SMTP Pass", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpPass", required = false) @Nullable String smtpPass,
        @Parameter(name = "metaData", description = "The application meta data. Defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "placementMetaData", description = "The ad placement meta data. Defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementMetaData", required = false) @Nullable String placementMetaData,
        @Parameter(name = "ipsFloor", description = "Create floor tables for Ips", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ipsFloor", required = false, defaultValue = "false") Boolean ipsFloor,
        @Parameter(name = "enableAPNSBadge", description = "Enables setting the APNS badge value in the payload", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableAPNSBadge", required = false, defaultValue = "true") Boolean enableAPNSBadge,
        @Parameter(name = "includeInReport", description = "Enables using the application in session reports", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInReport", required = false, defaultValue = "true") Boolean includeInReport,
        @Parameter(name = "defaultAppFilterId", description = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultAppFilterId", required = false) @Nullable Long defaultAppFilterId,
        @Parameter(name = "enableWelcomeEmail", description = "Enables whether the default welcome email will be sent for new app users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableWelcomeEmail", required = false) @Nullable Boolean enableWelcomeEmail,
        @Parameter(name = "appleAppId", description = "The Apple Application ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAppId", required = false) @Nullable String appleAppId,
        @Parameter(name = "appleTeamId", description = "The Apple Team ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleTeamId", required = false) @Nullable String appleTeamId,
        @Parameter(name = "appleAuthKeyId", description = "The Apple Auth Key ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAuthKeyId", required = false) @Nullable String appleAuthKeyId,
        @Parameter(name = "appleAuthKey", description = "The Apple Auth Signin Key (p8) File", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAuthKey", required = false) @Nullable org.springframework.core.io.Resource appleAuthKey,
        @Parameter(name = "appleIssuerId", description = "The Apple Issuer ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleIssuerId", required = false) @Nullable String appleIssuerId,
        @Parameter(name = "appStoreKeyId", description = "The Apple App Store Key ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appStoreKeyId", required = false) @Nullable String appStoreKeyId,
        @Parameter(name = "appStoreKey", description = "The Apple App Store Key (p8) File", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appStoreKey", required = false) @Nullable org.springframework.core.io.Resource appStoreKey,
        @Parameter(name = "googlePrivateKeyFile", description = "This is the private key file for your Google service account.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googlePrivateKeyFile", required = false) @Nullable org.springframework.core.io.Resource googlePrivateKeyFile,
        @Parameter(name = "authorizeNetApiKey", description = "Authorize Net Api Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetApiKey", required = false) @Nullable String authorizeNetApiKey,
        @Parameter(name = "authorizeNetTransactionKey", description = "Authorize Net Transaction Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) @Nullable String authorizeNetTransactionKey,
        @Parameter(name = "emailSender", description = "Email Sender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailSender", required = false) @Nullable String emailSender,
        @Parameter(name = "smtpUser", description = "SMTP User", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpUser", required = false) @Nullable String smtpUser,
        @Parameter(name = "smtpHost", description = "SMTP Host", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpHost", required = false) @Nullable String smtpHost,
        @Parameter(name = "vatomBusinessId", description = "Vatom Business Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomBusinessId", required = false) @Nullable String vatomBusinessId,
        @Parameter(name = "vatomRestClientId", description = "Vatom REST Client Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomRestClientId", required = false) @Nullable String vatomRestClientId,
        @Parameter(name = "vatomRestSecretKey", description = "Vatom Secret Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomRestSecretKey", required = false) @Nullable String vatomRestSecretKey,
        @Parameter(name = "twilioAccountSID", description = "Twilio Account SID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioAccountSID", required = false) @Nullable String twilioAccountSID,
        @Parameter(name = "twilioAuthToken", description = "Twilio Auth Token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioAuthToken", required = false) @Nullable String twilioAuthToken,
        @Parameter(name = "twilioSenderPhoneNumber", description = "Twilio Sender Phone Number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioSenderPhoneNumber", required = false) @Nullable String twilioSenderPhoneNumber,
        @Parameter(name = "openAISecretKey", description = "OpenAI Secret API Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "openAISecretKey", required = false) @Nullable String openAISecretKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_APPLICATION_CONFIG = "/api/{version}/appconfig/create";
    /**
     * POST /api/{version}/appconfig/create : Create AppConfig
     * Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won&#39;t be created.
     *
     * @param version  (required)
     * @param accountId The account ID of the user (required)
     * @param appKey The application key that the newly created applicationConfig will be associated to (required)
     * @param configVersion The application configuration, has to be unique within the application (required)
     * @param assetId The json assetId that stores the configuration detail. (required)
     * @param retailerId The retailer id for retailer specific configurations (optional)
     * @param retailerLocationId The retailer location id for retailer location specific configurations (optional)
     * @param udid The device udid for device specific configurations (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createApplicationConfig",
        summary = "Create AppConfig",
        description = "Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationConfigResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_APPLICATION_CONFIG,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationConfigResponse> createApplicationConfig(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key that the newly created applicationConfig will be associated to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "configVersion", description = "The application configuration, has to be unique within the application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "configVersion", required = true) String configVersion,
        @NotNull @Parameter(name = "assetId", description = "The json assetId that stores the configuration detail.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = true) Long assetId,
        @Parameter(name = "retailerId", description = "The retailer id for retailer specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "The retailer location id for retailer location specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "udid", description = "The device udid for device specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_APPLICATION_PLACEMENT = "/api/{version}/application/placement/create";
    /**
     * POST /api/{version}/application/placement/create : Create Ad Placement
     * Creates a new ad placement for an application.
     *
     * @param version  (required)
     * @param appKey The appKey of the application the ad placement is for (required)
     * @param size The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the placement (optional)
     * @param description The description of the placement (optional)
     * @param height The height of a custom ad size (optional)
     * @param width The width of a custom ad size (optional)
     * @param refreshInterval The refresh interval in seconds (optional)
     * @param defaultImageId Default Image Id (optional)
     * @param active Active (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createApplicationPlacement",
        summary = "Create Ad Placement",
        description = "Creates a new ad placement for an application.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PlacementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_APPLICATION_PLACEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<PlacementResponse> createApplicationPlacement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The appKey of the application the ad placement is for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "size", description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "size", required = true) String size,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "height", description = "The height of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable Integer height,
        @Parameter(name = "width", description = "The width of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "width", required = false) @Nullable Integer width,
        @Parameter(name = "refreshInterval", description = "The refresh interval in seconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "refreshInterval", required = false) @Nullable Integer refreshInterval,
        @Parameter(name = "defaultImageId", description = "Default Image Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultImageId", required = false) @Nullable Long defaultImageId,
        @Parameter(name = "active", description = "Active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ASSET = "/api/{version}/asset/create";
    /**
     * POST /api/{version}/asset/create : Create Asset
     * Uploads an asset to server and returns an asset id which can be used to assign to various objects.
     *
     * @param version  (required)
     * @param returnNulls to return nulls (optional)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the album the asset will be added to (optional) (optional)
     * @param collectionId Deprecated: use collections via the collection endpoints. (optional)
     * @param addToDefaultAlbum Whether to add to a default album (optional)
     * @param addToMediaLibrary Whether to add to the media library (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional) (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional) (optional)
     * @param app Deprecated: app parameter (optional)
     * @param appKey the application key (optional)
     * @param searchTags the search tags (optional)
     * @param latitude the latitude (optional) (optional)
     * @param longitude the longitude (optional) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAsset",
        summary = "Create Asset",
        description = "Uploads an asset to server and returns an asset id which can be used to assign to various objects.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssetResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ASSET,
        produces = { "*/*" }
    )
    default ResponseEntity<AssetResponse> createAsset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "returnNulls", description = "to return nulls", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false) @Nullable Boolean returnNulls,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumId", description = "the album the asset will be added to (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "collectionId", description = "Deprecated: use collections via the collection endpoints.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionId", required = false) @Nullable Long collectionId,
        @Parameter(name = "addToDefaultAlbum", description = "Whether to add to a default album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "addToDefaultAlbum", required = false) @Nullable String addToDefaultAlbum,
        @Parameter(name = "addToMediaLibrary", description = "Whether to add to the media library", in = ParameterIn.QUERY) @Valid @RequestParam(value = "addToMediaLibrary", required = false) @Nullable Boolean addToMediaLibrary,
        @Parameter(name = "versionCode", description = "the version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "versionName", description = "the version name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionName", required = false) @Nullable String versionName,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "caption", description = "the caption (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "caption", required = false) @Nullable String caption,
        @Parameter(name = "assetType", description = "the asset type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetType", required = false) @Nullable String assetType,
        @Parameter(name = "approvalStatus", description = "approval status for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false) @Nullable String approvalStatus,
        @Parameter(name = "assignedAccountId", description = "account id assigned to the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignedAccountId", required = false) @Nullable Long assignedAccountId,
        @Parameter(name = "media", description = "a MultipartFile containing the mimetype, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "media", required = false) @Nullable org.springframework.core.io.Resource media,
        @Parameter(name = "mediaUrl", description = "this can be used if the \"media\" is a link (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaUrl", required = false) @Nullable String mediaUrl,
        @Parameter(name = "mediaString", description = "the media content as a string (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaString", required = false) @Nullable String mediaString,
        @Parameter(name = "mediaStringFileName", description = "file name for mediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaStringFileName", required = false) @Nullable String mediaStringFileName,
        @Parameter(name = "mediaStringContentType", description = "content type for mediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaStringContentType", required = false) @Nullable String mediaStringContentType,
        @Parameter(name = "mediaHeight", description = "the media height (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaHeight", required = false) @Nullable Integer mediaHeight,
        @Parameter(name = "mediaWidth", description = "the media width (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaWidth", required = false) @Nullable Integer mediaWidth,
        @Parameter(name = "attachedMedia", description = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMedia", required = false) @Nullable org.springframework.core.io.Resource attachedMedia,
        @Parameter(name = "attachedMediaUrl", description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaUrl", required = false) @Nullable String attachedMediaUrl,
        @Parameter(name = "attachedMediaString", description = "attached media content as a string (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaString", required = false) @Nullable String attachedMediaString,
        @Parameter(name = "attachedMediaStringFileName", description = "file name for attachedMediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaStringFileName", required = false) @Nullable String attachedMediaStringFileName,
        @Parameter(name = "attachedMediaStringContentType", description = "content type for attachedMediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaStringContentType", required = false) @Nullable String attachedMediaStringContentType,
        @Parameter(name = "attachedMediaHeight", description = "the attached media height (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaHeight", required = false) @Nullable Integer attachedMediaHeight,
        @Parameter(name = "attachedMediaWidth", description = "the attached media width (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaWidth", required = false) @Nullable Integer attachedMediaWidth,
        @Parameter(name = "locationDescription", description = "the location description (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "app", description = "Deprecated: app parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "app", required = false) @Nullable String app,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "searchTags", description = "the search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "latitude", description = "the latitude (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_AUDIENCE = "/api/{version}/audience/create";
    /**
     * POST /api/{version}/audience/create : Create Audience
     * Create a user defined audience.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the audience (required)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param associateDescription The description of the associated object (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAudience",
        summary = "Create Audience",
        description = "Create a user defined audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> createAudience(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the audience", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "description", description = "The description of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "gender", description = "The gender; possible values are: MALE, FEMALE, ANY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroups", description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroups", required = false) @Nullable String ageGroups,
        @Parameter(name = "categoryIds", description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "applicationIds", description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "gameExperienceLevel", description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "devices", description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius,
        @Parameter(name = "startTimeOffset", description = "Seconds from the start time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startTimeOffset", required = false) @Nullable Integer startTimeOffset,
        @Parameter(name = "endTimeOffset", description = "Seconds from the end time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endTimeOffset", required = false) @Nullable Integer endTimeOffset,
        @Parameter(name = "sendSuggestion", description = "If true, then notify matching users when they are inside the radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false, defaultValue = "true") Boolean sendSuggestion,
        @Parameter(name = "associateDescription", description = "The description of the associated object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateDescription", required = false) @Nullable String associateDescription,
        @Parameter(name = "associateType", description = "The type of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateType", required = false) @Nullable String associateType,
        @Parameter(name = "associateId", description = "The ID of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateId", required = false) @Nullable Long associateId,
        @Parameter(name = "groupingId", description = "Optional grouping id for the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "visibility", description = "Visibility of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "audienceType", description = "Type of audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "useOrder", description = "Use order for cohort", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useOrder", required = false) @Nullable Boolean useOrder,
        @Parameter(name = "cohortRegionsData", description = "Cohort data for \"cohort\" audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cohortRegionsData", required = false) @Nullable String cohortRegionsData,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "trilaterationTypes", description = "Trilateration types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilaterationTypes", required = false) @Nullable String trilaterationTypes,
        @Parameter(name = "uniqueName", description = "If true, makes sure the audience name is unique", in = ParameterIn.QUERY) @Valid @RequestParam(value = "uniqueName", required = false) @Nullable Boolean uniqueName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_BATCH = "/api/{version}/report/batch/create";
    /**
     * POST /api/{version}/report/batch/create : Create Offline Report
     * Create an entry for the batch for offline report
     *
     * @param version  (required)
     * @param accountId The account id of the user for passing account related params (required)
     * @param status the status of the report (required)
     * @param previewLimit the limit on how much you can preview of the batch report (required)
     * @param appKey The application key for passing application related params (optional)
     * @param endpoint  (optional)
     * @param parameters a json structure list of the parameter values, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param name name of the batch report (optional)
     * @param startDate the start date of the batch report (optional)
     * @param endDate the end date of the batch report (optional)
     * @param description the description of the batch report (optional)
     * @param pageUrl  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createBatch",
        summary = "Create Offline Report",
        description = "Create an entry for the batch for offline report",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ReportBatchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<ReportBatchResponse> createBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user for passing account related params", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "status", description = "the status of the report", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = true) String status,
        @NotNull @Parameter(name = "previewLimit", description = "the limit on how much you can preview of the batch report", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "previewLimit", required = true) Integer previewLimit,
        @Parameter(name = "appKey", description = "The application key for passing application related params", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "endpoint", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpoint", required = false) @Nullable String endpoint,
        @Parameter(name = "parameters", description = "a json structure list of the parameter values, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parameters", required = false) @Nullable String parameters,
        @Parameter(name = "name", description = "name of the batch report", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "startDate", description = "the start date of the batch report", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date of the batch report", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "description", description = "the description of the batch report", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "pageUrl", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pageUrl", required = false) @Nullable String pageUrl
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_BID = "/api/{version}/bid/create";
    /**
     * POST /api/{version}/bid/create : Create Bid
     * Creates a bid on a biddable object
     *
     * @param version  (required)
     * @param biddableType A biddable object type. Possible values include: CREATIVE (ads). (required)
     * @param biddableId The id of the biddable object (required)
     * @param amountPerView The bid amount for views. For ads, this is the amount that will be taken for each impression. (required)
     * @param amountPerAction The bid amount for actions. For ads, this is the amount that will be taken for each click. (required)
     * @param budgetAmount The allocated budget amount that will be used (required)
     * @param budgetSchedule The schedule for when the allocated budget amount is reset (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createBid",
        summary = "Create Bid",
        description = "Creates a bid on a biddable object",
        tags = { "Bid" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BidResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_BID,
        produces = { "*/*" }
    )
    default ResponseEntity<BidResponse> createBid(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "biddableType", description = "A biddable object type. Possible values include: CREATIVE (ads).", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "biddableType", required = true) String biddableType,
        @NotNull @Parameter(name = "biddableId", description = "The id of the biddable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "biddableId", required = true) Long biddableId,
        @NotNull @Parameter(name = "amountPerView", description = "The bid amount for views. For ads, this is the amount that will be taken for each impression.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "amountPerView", required = true) Double amountPerView,
        @NotNull @Parameter(name = "amountPerAction", description = "The bid amount for actions. For ads, this is the amount that will be taken for each click.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "amountPerAction", required = true) Double amountPerAction,
        @NotNull @Parameter(name = "budgetAmount", description = "The allocated budget amount that will be used", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "budgetAmount", required = true) Double budgetAmount,
        @NotNull @Parameter(name = "budgetSchedule", description = "The schedule for when the allocated budget amount is reset", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "budgetSchedule", required = true) String budgetSchedule,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_BILLABLE_ENTITY = "/api/{version}/billable/create";
    /**
     * POST /api/{version}/billable/create : Create Billable
     * reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity
     *
     * @param version  (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createBillableEntity",
        summary = "Create Billable",
        description = "reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity",
        tags = { "Billable Entity" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BillableEntityResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<BillableEntityResponse> createBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the entity responsible for billing ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "streetAddress", description = "The street address of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box) ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "businessPhone", description = "The business phone of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "authorizeNetApiKey", description = "Authorize Net Api Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetApiKey", required = false) @Nullable String authorizeNetApiKey,
        @Parameter(name = "authorizeNetTransactionKey", description = "Authorize Net Transaction Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) @Nullable String authorizeNetTransactionKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_CARGO_TYPE = "/api/{version}/cargo/type";
    /**
     * POST /api/{version}/cargo/type : Create Cargo Type
     * Create new cargo type
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createCargoType",
        summary = "Create Cargo Type",
        description = "Create new cargo type",
        tags = { "Cargo Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CargoType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_CARGO_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<CargoType> createCargoType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable CargoType body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_CATEGORY = "/api/{version}/category/create";
    /**
     * POST /api/{version}/category/create : Create Category
     * Create a new category.
     *
     * @param version  (required)
     * @param accountId The account id of the user (must have permissions to the target application) (required)
     * @param name The name of the category (required)
     * @param appKey The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param parentCategoryId The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param description The description of the category (optional)
     * @param type The type of the category (optional)
     * @param assetId The ID of the image asset previously uploaded using the media service (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param externalCategorySlug external category slug (optional)
     * @param sqootSlug sqoot slug (optional)
     * @param active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @param searchTags user defined strings for searching (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createCategory",
        summary = "Create Category",
        description = "Create a new category.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CategoryTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_CATEGORY,
        produces = { "*/*" }
    )
    default ResponseEntity<CategoryTreeResponse> createCategory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user (must have permissions to the target application)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the category", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "appKey", description = "The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "parentCategoryId", description = "The ID of the parent category, if not provided then the parent category will be null", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentCategoryId", required = false) @Nullable Long parentCategoryId,
        @Parameter(name = "description", description = "The description of the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "type", description = "The type of the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "assetId", description = "The ID of the image asset previously uploaded using the media service", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "externalId", description = "A string identifier used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalType", description = "A string type used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "externalCategorySlug", description = "external category slug", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalCategorySlug", required = false) @Nullable String externalCategorySlug,
        @Parameter(name = "sqootSlug", description = "sqoot slug", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sqootSlug", required = false) @Nullable String sqootSlug,
        @Parameter(name = "active", description = "Sets whether the category is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "searchTags", description = "user defined strings for searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_CREATIVE = "/api/{version}/creative/create";
    /**
     * POST /api/{version}/creative/create : Create Creative
     * Create a creative
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the level. (required)
     * @param active If true set the game level as active. Default is false. (required)
     * @param waitForAsset determines whether the response will wait until the asset gets created (required)
     * @param description The description of the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param action This parameter is deprecated. deprecated use data field (optional)
     * @param data The creative data, json based format depending on type. If not using action then data is required. (optional)
     * @param suffix This parameter is deprecated. deprecated use type field (optional)
     * @param type The type of creative. If not using suffix then type is required. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param referenceId if creative related so some other content provided the id (optional)
     * @param appVersion The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives. (optional)
     * @param missionId Assign the creative to a campaign for timing and audience matching. (optional)
     * @param offerId the id of the offer (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createCreative",
        summary = "Create Creative",
        description = "Create a creative",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CreativeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_CREATIVE,
        produces = { "*/*" }
    )
    default ResponseEntity<CreativeResponse> createCreative(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the level.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "active", description = "If true set the game level as active. Default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @NotNull @Parameter(name = "waitForAsset", description = "determines whether the response will wait until the asset gets created", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "waitForAsset", required = true) Boolean waitForAsset,
        @Parameter(name = "description", description = "The description of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "assetImageId", description = "The asset Id of the level image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetImageId", required = false) @Nullable Long assetImageId,
        @Parameter(name = "action", description = "This parameter is deprecated. deprecated use data field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "action", required = false) @Nullable String action,
        @Parameter(name = "data", description = "The creative data, json based format depending on type. If not using action then data is required.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = false) @Nullable String data,
        @Parameter(name = "suffix", description = "This parameter is deprecated. deprecated use type field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffix", required = false) @Nullable String suffix,
        @Parameter(name = "type", description = "The type of creative. If not using suffix then type is required.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "balance", description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "referenceId", description = "if creative related so some other content provided the id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referenceId", required = false) @Nullable Long referenceId,
        @Parameter(name = "appVersion", description = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "missionId", description = "Assign the creative to a campaign for timing and audience matching.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "offerId", description = "the id of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_CREDENTIAL = "/api/{version}/thirdparty/credential/create";
    /**
     * POST /api/{version}/thirdparty/credential/create : Create Credential
     * This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user&#39;s third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
     *
     * @param version  (required)
     * @param thirdPartyId the third party user account id (required)
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token or phone number) (required)
     * @param networkUID the access provider to authenticate against (required)
     * @param appKey the application key (required)
     * @param accountId the unique id of the account that needs authenticating (optional for PHONE_V2) (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyName the third party user&#39;s display name (optional)
     * @param emailAddress optional email address associated with the third party account (optional)
     * @param signinOnlyMode when true will error out if can&#39;t find any accounts matching (signin only) (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createCredential",
        summary = "Create Credential",
        description = "This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. ",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_CREDENTIAL,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> createCredential(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "thirdPartyId", description = "the third party user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyId", required = true) String thirdPartyId,
        @NotNull @Parameter(name = "thirdPartyToken", description = "the access token to authenticate with (ex: username or fb token or phone number)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyToken", required = true) String thirdPartyToken,
        @NotNull @Parameter(name = "networkUID", description = "the access provider to authenticate against", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "accountId", description = "the unique id of the account that needs authenticating (optional for PHONE_V2)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "sessionId", description = "the session id for the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sessionId", required = false) @Nullable String sessionId,
        @Parameter(name = "thirdPartyName", description = "the third party user's display name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyName", required = false) @Nullable String thirdPartyName,
        @Parameter(name = "emailAddress", description = "optional email address associated with the third party account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "signinOnlyMode", description = "when true will error out if can't find any accounts matching (signin only)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "signinOnlyMode", required = false, defaultValue = "false") Boolean signinOnlyMode,
        @Parameter(name = "responseFilters", description = "this determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false) @Nullable String responseFilters,
        @Parameter(name = "latitude", description = "the latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "thirdPartyRefreshToken", description = "optional refresh token for the third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyRefreshToken", required = false) @Nullable String thirdPartyRefreshToken,
        @Parameter(name = "audienceIdsToAdd", description = "audience ids to add to the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "audience ids to remove from the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_DATA = "/api/{version}/object/data/{objectName}";
    /**
     * POST /api/{version}/object/data/{objectName} : Create Data
     * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
     *
     * @param version  (required)
     * @param objectName the name of the object to create data for (required)
     * @param accountId the account id (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createData",
        summary = "Create Data",
        description = "Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. ",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> createData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "objectName", description = "the name of the object to create data for", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @Parameter(name = "accountId", description = "the account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_DISBURSEMENT = "/api/{version}/disbursement/create";
    /**
     * POST /api/{version}/disbursement/create : Create Disbursement
     * Creates a Disbursement for sending money to a retailer
     *
     * @param version  (required)
     * @param accountId the ID of the logging in user (must be an EXECUTIVE account) (required)
     * @param receiverAccountId the ID of the account receiving the disbursement (required)
     * @param originalSenderAccountId the ID of the original sender account (required)
     * @param amount the dollar amount of the disbursement (required)
     * @param provider the provider (e.g. Authorize.net, Bill.com, etc.) (required)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title a title given for the disbursement (optional)
     * @param comment a comment that could be made for a disbursement (optional)
     * @param externalId external ID, which can be used as a way to reference the disbursement (optional)
     * @param introspectionParams This is for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createDisbursement",
        summary = "Create Disbursement",
        description = "Creates a Disbursement for sending money to a retailer",
        tags = { "Disbursement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DisbursementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_DISBURSEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<DisbursementResponse> createDisbursement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the ID of the logging in user (must be an EXECUTIVE account)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "receiverAccountId", description = "the ID of the account receiving the disbursement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountId", required = true) Long receiverAccountId,
        @NotNull @Parameter(name = "originalSenderAccountId", description = "the ID of the original sender account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "originalSenderAccountId", required = true) Long originalSenderAccountId,
        @NotNull @Parameter(name = "amount", description = "the dollar amount of the disbursement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "amount", required = true) BigDecimal amount,
        @NotNull @Parameter(name = "provider", description = "the provider (e.g. Authorize.net, Bill.com, etc.)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "provider", required = true) String provider,
        @Parameter(name = "scheduledDate", description = "the date that the disbursement is scheduled to go out to the payment provider", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "title", description = "a title given for the disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "comment", description = "a comment that could be made for a disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "comment", required = false) @Nullable String comment,
        @Parameter(name = "externalId", description = "external ID, which can be used as a way to reference the disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "introspectionParams", description = "This is for specifying parameters to make an http callback request for validating that the disbursement is valid", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionParams", required = false) @Nullable String introspectionParams
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_EMPLOYEE = "/api/{version}/employee/create";
    /**
     * POST /api/{version}/employee/create : Create Employee
     * Create a new account record with the provided information.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param managerAccountId The account id of the manager to assign under (required)
     * @param username The username/email for the new user. This must be unique across the entire the system. (required)
     * @param password The password for the new user (required)
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param aboutUs Additional about/biography text (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param retailerLocationIds the retailer location IDs the employee is associated with (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createEmployee",
        summary = "Create Employee",
        description = "Create a new account record with the provided information.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = EmployeeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<EmployeeResponse> createEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "managerAccountId", description = "The account id of the manager to assign under", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "managerAccountId", required = true) Long managerAccountId,
        @NotNull @Parameter(name = "username", description = "The username/email for the new user. This must be unique across the entire the system.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "The password for the new user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "name", description = "a name field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "prefixName", description = "The name prefix; Mr, Mrs, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "prefixName", required = false) @Nullable String prefixName,
        @Parameter(name = "firstName", description = "The first name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "middleName", description = "The middle name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "middleName", required = false) @Nullable String middleName,
        @Parameter(name = "lastName", description = "The last name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "suffixName", description = "The name suffix; Jr, Sr, III, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffixName", required = false) @Nullable String suffixName,
        @Parameter(name = "title", description = "The title of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "aboutUs", description = "Additional about/biography text", in = ParameterIn.QUERY) @Valid @RequestParam(value = "aboutUs", required = false) @Nullable String aboutUs,
        @Parameter(name = "assetId", description = "the asset id to set the user's profile image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "gender", description = "The gender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "homePhone", description = "The home phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homePhone", required = false) @Nullable String homePhone,
        @Parameter(name = "cellPhone", description = "The cellular phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "cellPhoneCarrier", description = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhoneCarrier", required = false) @Nullable String cellPhoneCarrier,
        @Parameter(name = "businessPhone", description = "The business phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "emailAddress", description = "The user's contact email address (NOT the username)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "streetAddress", description = "The street address of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "zipcode", description = "The zipcode of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "country", description = "The country of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "role", description = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "retailerLocationIds", description = "the retailer location IDs the employee is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "settingsAppKey", description = "Determines whether to return the application settings for the employee for a particular application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "settingsAppKey", required = false) @Nullable String settingsAppKey,
        @Parameter(name = "appBlob", description = "external custom client defined data (per Application)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appBlob", required = false) @Nullable String appBlob,
        @Parameter(name = "assignedDeviceId", description = "The device id to assign to the user (used for IPS beacon tracking)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignedDeviceId", required = false) @Nullable String assignedDeviceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ENTITY_REFERENCE = "/api/{version}/entity/reference";
    /**
     * POST /api/{version}/entity/reference : Create an entity reference.
     * Creates a reference for an entity for syncing data between servers.
     *
     * @param version  (required)
     * @param body The entity reference object (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createEntityReference",
        summary = "Create an entity reference.",
        description = "Creates a reference for an entity for syncing data between servers.",
        tags = { "Activity" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ActivityResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ENTITY_REFERENCE,
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    default ResponseEntity<ActivityResponse> createEntityReference(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "The entity reference object", required = true) @Valid @RequestBody EntityReference body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_EVENT = "/api/{version}/event/create";
    /**
     * POST /api/{version}/event/create : Create Event
     * Create a private event to share with associates.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param title The event title (required)
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createEvent",
        summary = "Create Event",
        description = "Create a private event to share with associates.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_EVENT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferResponse> createEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "title", description = "The event title", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @Parameter(name = "retailerLocationIds", description = "The retailer location to have the event at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "subTitle", description = "The event sub title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The event details", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "categoryIds", description = "The categories the associate the event with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "The filters the associate the event with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "active", description = "Is this event active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "imageAssetId", description = "The image to show for the event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "redeemableStart", description = "The event start date/time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The event end date/time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_FILTER = "/api/{version}/filter/create";
    /**
     * POST /api/{version}/filter/create : Create Filter
     * Create a filter
     *
     * @param version  (required)
     * @param accountId The account id of the user (must have permissions to the target application) (required)
     * @param name The name of the filter (required)
     * @param appKey The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createFilter",
        summary = "Create Filter",
        description = "Create a filter",
        tags = { "Filter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = FilterTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_FILTER,
        produces = { "*/*" }
    )
    default ResponseEntity<FilterTreeResponse> createFilter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user (must have permissions to the target application)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the filter", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "appKey", description = "The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "parentFilterId", description = "The ID of the parent filter, if not provided then the parent filter will be null", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentFilterId", required = false) @Nullable Long parentFilterId,
        @Parameter(name = "description", description = "The description of the filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "externalId", description = "A string identifier used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalType", description = "A string type used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "active", description = "Sets whether the filter is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_FLAG = "/api/{version}/flag/create";
    /**
     * POST /api/{version}/flag/create : Create Flag
     * Allows a user to flag an object that the user deems inappropriate or offensive. Flagable objects include accounts, albums, album contests, assets, game levels, and theme descriptors
     *
     * @param version  (required)
     * @param flagableType The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER} (required)
     * @param flagableId The flagable object id (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param flagDescription An optional description of why is it being flagged (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createFlag",
        summary = "Create Flag",
        description = "Allows a user to flag an object that the user deems inappropriate or offensive. Flagable objects include accounts, albums, album contests, assets, game levels, and theme descriptors",
        tags = { "Flag" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_FLAG,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> createFlag(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "flagableType", description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableType", required = true) String flagableType,
        @NotNull @Parameter(name = "flagableId", description = "The flagable object id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableId", required = true) Long flagableId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "flagDescription", description = "An optional description of why is it being flagged", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagDescription", required = false) @Nullable String flagDescription,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_FOLLOWING = "/api/{version}/vatom/me/rels/following/create";
    /**
     * POST /api/{version}/vatom/me/rels/following/create : Create following
     * Create following.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createFollowing",
        summary = "Create following",
        description = "Create following.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_FOLLOWING
    )
    default ResponseEntity<Void> createFollowing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_GAME = "/api/{version}/game/create";
    /**
     * POST /api/{version}/game/create : Create a Game
     * Create a Game.
     *
     * @param version  (required)
     * @param accountId The logged in user. (optional)
     * @param appKey The game application key to save the level for. (optional)
     * @param title Title of the game. (optional)
     * @param description Description of the game. (optional)
     * @param metaData metaData of the Game. (optional)
     * @param packIds comma separated String of pack Ids that will associate with the game. (optional)
     * @param includeGameData Show more details in response. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createGame",
        summary = "Create a Game",
        description = "Create a Game.",
        tags = { "Game" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_GAME,
        produces = { "*/*" }
    )
    default ResponseEntity<GameResponse> createGame(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The game application key to save the level for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "title", description = "Title of the game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "Description of the game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "metaData of the Game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "packIds", description = "comma separated String of pack Ids that will associate with the game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packIds", required = false) @Nullable String packIds,
        @Parameter(name = "includeGameData", description = "Show more details in response.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_GAME_LEVEL = "/api/{version}/level/create";
    /**
     * POST /api/{version}/level/create : Create Game Level
     * Create a game level. Currently does NOT support game objects.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the level. (required)
     * @param gameData The game level data: xml, json, or other text based format. (required)
     * @param gameDataSuffix The game level data format type. (required)
     * @param appKey The game application key to save the level for. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the application required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. Default is false. (optional)
     * @param allocateTickets If true then scoring will give tickets. Default is false. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutotrial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId id of the offer (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createGameLevel",
        summary = "Create Game Level",
        description = "Create a game level. Currently does NOT support game objects.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameLevelResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_GAME_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<GameLevelResponse> createGameLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the level.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "gameData", description = "The game level data: xml, json, or other text based format.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameData", required = true) String gameData,
        @NotNull @Parameter(name = "gameDataSuffix", description = "The game level data format type.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameDataSuffix", required = true) String gameDataSuffix,
        @Parameter(name = "appKey", description = "The game application key to save the level for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "description", description = "The description of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "difficulty", description = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "difficulty", required = false) @Nullable String difficulty,
        @Parameter(name = "appVersion", description = "The version number of the application required to correctly load/play the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "assetImageId", description = "The asset Id of the level image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetImageId", required = false) @Nullable Long assetImageId,
        @Parameter(name = "assetIconId", description = "The asset Id of the level icon.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetIconId", required = false) @Nullable Long assetIconId,
        @Parameter(name = "visibility", description = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "friendGroup", description = "Make the level be readable by all friends.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendGroup", required = false) @Nullable Boolean friendGroup,
        @Parameter(name = "connectionIds", description = "Make the level be readable by connections in this list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionGroupIds", description = "Make the level be readable by connection groups in this list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "balance", description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "active", description = "If true set the game level as active. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketCount", description = "The number of tickets to reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = false) @Nullable Long ticketCount,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a level", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "tutorialTitle", description = "Title of the tutorial.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialTitle", required = false) @Nullable String tutorialTitle,
        @Parameter(name = "tutorialMessage", description = "Message of the tutotrial.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialMessage", required = false) @Nullable String tutorialMessage,
        @Parameter(name = "tutorialAlignment", description = "Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialAlignment", required = false) @Nullable String tutorialAlignment,
        @Parameter(name = "tutorialImageAssetId", description = "Asset id of the tutorial image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialImageAssetId", required = false) @Nullable Long tutorialImageAssetId,
        @Parameter(name = "offerId", description = "id of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_INSTANT_EPISODE = "/api/{version}/orson/stories/episodes/instant";
    /**
     * POST /api/{version}/orson/stories/episodes/instant : Creates an instant episode
     * Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param data Request Data String (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createInstantEpisode",
        summary = "Creates an instant episode",
        description = "Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonEpisodeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_INSTANT_EPISODE,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonEpisodeResponse> createInstantEpisode(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "data", description = "Request Data String", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_LEADERBOARD = "/api/{version}/leaderboard/create";
    /**
     * POST /api/{version}/leaderboard/create : Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
     * Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
     *
     * @param version  (required)
     * @param accountId The account id of the user creating the leaderboard. (optional)
     * @param appKey The application key (optional)
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (optional)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword (optional)
     * @param iconMedia a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty) (optional)
     * @param iconAssetId The asset ID to set the leaderboard icon (optional)
     * @param bannerMedia a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty) (optional)
     * @param bannerAssetId The asset ID to set the leaderboard banner (optional)
     * @param limitation limit number of rankings for each leaderboard (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (optional)
     * @param title leaderboard&#39;s title (optional)
     * @param description leaderboard&#39;s description (optional)
     * @param metaData custom meta data for the leaderboard (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createLeaderboard",
        summary = "Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        description = "Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        tags = { "Leaderboard" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LeaderboardResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_LEADERBOARD,
        produces = { "*/*" }
    )
    default ResponseEntity<LeaderboardResponse> createLeaderboard(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user creating the leaderboard.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "rankType", description = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "leaderboardMode", description = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardMode", required = false) @Nullable String leaderboardMode,
        @Parameter(name = "iconMedia", description = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconMedia", required = false) @Nullable org.springframework.core.io.Resource iconMedia,
        @Parameter(name = "iconAssetId", description = "The asset ID to set the leaderboard icon", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconAssetId", required = false) @Nullable Long iconAssetId,
        @Parameter(name = "bannerMedia", description = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bannerMedia", required = false) @Nullable org.springframework.core.io.Resource bannerMedia,
        @Parameter(name = "bannerAssetId", description = "The asset ID to set the leaderboard banner", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bannerAssetId", required = false) @Nullable Long bannerAssetId,
        @Parameter(name = "limitation", description = "limit number of rankings for each leaderboard", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limitation", required = false) @Nullable Integer limitation,
        @Parameter(name = "sortField", description = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "title", description = "leaderboard's title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "leaderboard's description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "custom meta data for the leaderboard", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_LISTING = "/api/{version}/listing/create";
    /**
     * POST /api/{version}/listing/create : Create Listing
     * Creates a listing.
     *
     * @param version  (required)
     * @param accountId the user&#39;s account ID (required)
     * @param name the name of the listing (required)
     * @param filterIds comma separated list of filter IDs (optional)
     * @param description the description of the listing (optional)
     * @param start the start date of the listing (optional)
     * @param end the end date of the listing (optional)
     * @param locationName the name of the location the listing will be held at (optional)
     * @param locationDescription the description of the location the listing will be held at (optional)
     * @param isPrivate determines whether the listing is public or private (optional, default to false)
     * @param externalId external identifier used by a third party (optional)
     * @param externalId2 secondary external identifier used by a third party (optional)
     * @param externalGroupId external group identifier used by a third party (optional)
     * @param active Sets the active flag (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createListing",
        summary = "Create Listing",
        description = "Creates a listing.",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListingFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<ListingFullResponse> createListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user's account ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "the name of the listing", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "filterIds", description = "comma separated list of filter IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "description", description = "the description of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "start", description = "the start date of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "end", description = "the end date of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "end", required = false) @Nullable Long end,
        @Parameter(name = "locationName", description = "the name of the location the listing will be held at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationName", required = false) @Nullable String locationName,
        @Parameter(name = "locationDescription", description = "the description of the location the listing will be held at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "isPrivate", description = "determines whether the listing is public or private", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isPrivate", required = false, defaultValue = "false") Boolean isPrivate,
        @Parameter(name = "externalId", description = "external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalId2", description = "secondary external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId2", required = false) @Nullable String externalId2,
        @Parameter(name = "externalGroupId", description = "external group identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalGroupId", required = false) @Nullable String externalGroupId,
        @Parameter(name = "active", description = "Sets the active flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_LOCATION_V2 = "/api/{version}/location";
    /**
     * POST /api/{version}/location : Create new location
     * Create a new location from a real object location.
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createLocationV2",
        summary = "Create new location",
        description = "Create a new location from a real object location.",
        tags = { "LocationApiV2" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_LOCATION_V2,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> createLocationV2(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Location body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_MEDIA = "/api/{version}/media/create";
    /**
     * POST /api/{version}/media/create : Create Media
     * Create a media offering.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param title The title (255 char limit) (required)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (required)
     * @param availableLimit The limit of how many times the offer can be used by consumers (required)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (required)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (required)
     * @param viewLimit The limit of how many times the offer can be viewed (required)
     * @param maxPrints The maximum number of times the offer can be printed (required)
     * @param ticketPrice The cost of the offer in tickets (required)
     * @param fullPrice The retail/full price cost of the offer in real currency (required)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (required)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
     * @param active Sets the active flag (required)
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details of the media (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print of the media (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param ticketPriceType the type of ticket needed to buy offer (optional)
     * @param showRemaining show how many of the media is remaining (if there is a limit) (optional)
     * @param showRedeemed show how many of the media has been redeemed (optional)
     * @param replaced if the media has been replaced (optional)
     * @param featured if the media should be featured or not (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition type of the media (optional)
     * @param isbn The ISBN id (optional)
     * @param asin The ASIN id (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated (optional)
     * @param parentalRating The parental control rating (optional)
     * @param availabilityDate The date the media is available to use (optional)
     * @param mediaType the media type (optional)
     * @param duration The total playing time of the media item (optional)
     * @param author The created/author of the media item (optional)
     * @param releaseDate The date/time of when the media item was originally released (optional)
     * @param collectionIds the IDs of the collections this media should be assigned to (optional)
     * @param availability ability to assign if this media should active or not (optional)
     * @param availabilitySummary ability to assign when the media expires (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createMedia",
        summary = "Create Media",
        description = "Create a media offering.",
        tags = { "Media" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MediaOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_MEDIA,
        produces = { "*/*" }
    )
    default ResponseEntity<MediaOfferResponse> createMedia(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "title", description = "The title (255 char limit)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "barcodeType", description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = true) String barcodeType,
        @NotNull @Parameter(name = "noExpiration", description = "Overrides the expiration date so that the offer does not expire", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "noExpiration", required = true) Boolean noExpiration,
        @NotNull @Parameter(name = "availableLimit", description = "The limit of how many times the offer can be used by consumers", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = true) Integer availableLimit,
        @NotNull @Parameter(name = "availableLimitPerUser", description = "The limit of how many times a user can used the same offer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimitPerUser", required = true) Integer availableLimitPerUser,
        @NotNull @Parameter(name = "addedLimit", description = "The limit of how many times the offer can be added to consumer wallets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "addedLimit", required = true) Integer addedLimit,
        @NotNull @Parameter(name = "viewLimit", description = "The limit of how many times the offer can be viewed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "viewLimit", required = true) Integer viewLimit,
        @NotNull @Parameter(name = "maxPrints", description = "The maximum number of times the offer can be printed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxPrints", required = true) Integer maxPrints,
        @NotNull @Parameter(name = "ticketPrice", description = "The cost of the offer in tickets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPrice", required = true) Long ticketPrice,
        @NotNull @Parameter(name = "fullPrice", description = "The retail/full price cost of the offer in real currency", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullPrice", required = true) Double fullPrice,
        @NotNull @Parameter(name = "discountPrice", description = "The cost of the offer at a discounted price (what the consumer pays)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "discountPrice", required = true) Double discountPrice,
        @NotNull @Parameter(name = "specialOfferType", description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = true) String specialOfferType,
        @NotNull @Parameter(name = "offerVisibility", description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerVisibility", required = true) String offerVisibility,
        @NotNull @Parameter(name = "active", description = "Sets the active flag", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "subTitle", description = "The sub title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The details of the media", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "subDetails", description = "A string for custom details (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subDetails", required = false) @Nullable String subDetails,
        @Parameter(name = "finePrint", description = "The fine print of the media", in = ParameterIn.QUERY) @Valid @RequestParam(value = "finePrint", required = false) @Nullable String finePrint,
        @Parameter(name = "barcodeEntry", description = "The bar code entry string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "externalRedeemOptions", description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalRedeemOptions", required = false) @Nullable String externalRedeemOptions,
        @Parameter(name = "externalUrl", description = "The clickUrl of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalUrl", required = false) @Nullable String externalUrl,
        @Parameter(name = "ticketsRewardType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsRewardType", required = false) @Nullable String ticketsRewardType,
        @Parameter(name = "ticketsReward", description = "Determines how many tickets are awarded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsReward", required = false) @Nullable Long ticketsReward,
        @Parameter(name = "activated", description = "The date of when the offer will be visible to consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activated", required = false) @Nullable Long activated,
        @Parameter(name = "expires", description = "The date of when the offer expires", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expires", required = false) @Nullable Long expires,
        @Parameter(name = "ticketPriceType", description = "the type of ticket needed to buy offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPriceType", required = false) @Nullable String ticketPriceType,
        @Parameter(name = "showRemaining", description = "show how many of the media is remaining (if there is a limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRemaining", required = false) @Nullable Boolean showRemaining,
        @Parameter(name = "showRedeemed", description = "show how many of the media has been redeemed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRedeemed", required = false) @Nullable Boolean showRedeemed,
        @Parameter(name = "replaced", description = "if the media has been replaced", in = ParameterIn.QUERY) @Valid @RequestParam(value = "replaced", required = false) @Nullable Boolean replaced,
        @Parameter(name = "featured", description = "if the media should be featured or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "barcodeAssetId", description = "The id of the barcode asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeAssetId", required = false) @Nullable Long barcodeAssetId,
        @Parameter(name = "imageAssetId", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "imageAssetId1", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId1", required = false) @Nullable Long imageAssetId1,
        @Parameter(name = "imageAssetId2", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId2", required = false) @Nullable Long imageAssetId2,
        @Parameter(name = "imageAssetId3", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId3", required = false) @Nullable Long imageAssetId3,
        @Parameter(name = "imageAssetId4", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId4", required = false) @Nullable Long imageAssetId4,
        @Parameter(name = "imageAssetId5", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId5", required = false) @Nullable Long imageAssetId5,
        @Parameter(name = "publisher", description = "The maker of the item.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publisher", required = false) @Nullable String publisher,
        @Parameter(name = "redeemableStart", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd,
        @Parameter(name = "conditionType", description = "The condition type of the media", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionType", required = false) @Nullable String conditionType,
        @Parameter(name = "isbn", description = "The ISBN id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "The ASIN id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "catalogNumbers", description = "The list of catelog numbers, comma seperated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "catalogNumbers", required = false) @Nullable String catalogNumbers,
        @Parameter(name = "parentalRating", description = "The parental control rating", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentalRating", required = false) @Nullable String parentalRating,
        @Parameter(name = "availabilityDate", description = "The date the media is available to use", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilityDate", required = false) @Nullable Long availabilityDate,
        @Parameter(name = "mediaType", description = "the media type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaType", required = false) @Nullable String mediaType,
        @Parameter(name = "duration", description = "The total playing time of the media item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Integer duration,
        @Parameter(name = "author", description = "The created/author of the media item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "author", required = false) @Nullable String author,
        @Parameter(name = "releaseDate", description = "The date/time of when the media item was originally released", in = ParameterIn.QUERY) @Valid @RequestParam(value = "releaseDate", required = false) @Nullable Long releaseDate,
        @Parameter(name = "collectionIds", description = "the IDs of the collections this media should be assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionIds", required = false) @Nullable String collectionIds,
        @Parameter(name = "availability", description = "ability to assign if this media should active or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availability", required = false) @Nullable String availability,
        @Parameter(name = "availabilitySummary", description = "ability to assign when the media expires", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilitySummary", required = false) @Nullable String availabilitySummary
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_MISSION = "/api/{version}/mission/create";
    /**
     * POST /api/{version}/mission/create : Create Mission
     * Create a user defined mission.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param title The title of the mission (required)
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds creatives to associate with the mission (optional)
     * @param audienceIds audiences to associate with the mission (optional)
     * @param missionTask This parameter is deprecated. (optional)
     * @param formatType The string identifier for a mission format (this is not the missionFormatId) (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param metaData external custom client defined data (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createMission",
        summary = "Create Mission",
        description = "Create a user defined mission.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_MISSION,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> createMission(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "title", description = "The title of the mission", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @Parameter(name = "description", description = "The description of the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "subType", description = "Custom string client apps can use for searching/filtering missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "startDate", description = "The date/time to start the mission, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The date/time to end the mission, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "active", description = "Activate/deactivate the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "gameLevelIds", description = "the game level ids to include in the mission, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "creativeIds", description = "creatives to associate with the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeIds", required = false) @Nullable String creativeIds,
        @Parameter(name = "audienceIds", description = "audiences to associate with the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "missionTask", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionTask", required = false) @Nullable String missionTask,
        @Parameter(name = "formatType", description = "The string identifier for a mission format (this is not the missionFormatId)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "formatType", required = false) @Nullable String formatType,
        @Parameter(name = "offerId", description = "The offerId to give as a reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "balance", description = "Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "advancedReporting", description = "Flag to mark the mission as eligible for advanced reporting", in = ParameterIn.QUERY) @Valid @RequestParam(value = "advancedReporting", required = false) @Nullable Boolean advancedReporting,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketCount", description = "The number of tickets to reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = false) @Nullable Long ticketCount,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "applicationIds", description = "Comma separated list of application ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "devices", description = "Deprecated parameter for device names", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "Comma separated list of device ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "Comma separated list of device version ranges", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "List of lat/long pairs for mission locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "Comma separated list of radii for locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_MISSION_INVITE = "/api/{version}/mission/invite/create";
    /**
     * POST /api/{version}/mission/invite/create : Create Mission Invite
     * Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param missionId The mission to find the invite for. (optional)
     * @param joinCode code to be entered for user to join the mission (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createMissionInvite",
        summary = "Create Mission Invite",
        description = "Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.",
        tags = { "Mission Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_MISSION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> createMissionInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "missionId", description = "The mission to find the invite for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "joinCode", description = "code to be entered for user to join the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "joinCode", required = false) @Nullable String joinCode,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_NETWORK = "/api/{version}/thirdparty/network/create";
    /**
     * POST /api/{version}/thirdparty/network/create : Create Network
     * Creates a custom third party network.
     *
     * @param version  (required)
     * @param accountId The account id making the request (required)
     * @param name The name of the network (required)
     * @param enableIntrospection Whether the network uses introspection calls (required)
     * @param description The description of the network (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createNetwork",
        summary = "Create Network",
        description = "Creates a custom third party network.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ThirdPartyNetworkResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_NETWORK,
        produces = { "*/*" }
    )
    default ResponseEntity<ThirdPartyNetworkResponse> createNetwork(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the network", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "enableIntrospection", description = "Whether the network uses introspection calls", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableIntrospection", required = true) Boolean enableIntrospection,
        @Parameter(name = "description", description = "The description of the network", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "introspectionMethod", description = "HTTP method to use for introspection calls (e.g., GET, POST)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionMethod", required = false) @Nullable String introspectionMethod,
        @Parameter(name = "introspectionURL", description = "The HTTP URL of the introspection call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionURL", required = false) @Nullable String introspectionURL,
        @Parameter(name = "introspectionParams", description = "The parameters of the introspection call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionParams", required = false) @Nullable String introspectionParams,
        @Parameter(name = "requiredRootField", description = "Required response params", in = ParameterIn.QUERY) @Valid @RequestParam(value = "requiredRootField", required = false) @Nullable String requiredRootField,
        @Parameter(name = "enableMFA", description = "Whether this network uses MFA", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMFA", required = false) @Nullable Boolean enableMFA,
        @Parameter(name = "sizeMFA", description = "Size of the MFA token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sizeMFA", required = false) @Nullable Integer sizeMFA,
        @Parameter(name = "shelfLifeMFA", description = "Shelf life (seconds) of the MFA token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "shelfLifeMFA", required = false) @Nullable Integer shelfLifeMFA,
        @Parameter(name = "oauthTokenURL", description = "OAuth token endpoint URL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthTokenURL", required = false) @Nullable String oauthTokenURL,
        @Parameter(name = "oauthPrivateKey", description = "OAuth private key file (multipart)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthPrivateKey", required = false) @Nullable org.springframework.core.io.Resource oauthPrivateKey,
        @Parameter(name = "oauthPublicKey", description = "OAuth public key file (multipart)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthPublicKey", required = false) @Nullable org.springframework.core.io.Resource oauthPublicKey,
        @Parameter(name = "oauthClientId", description = "OAuth client id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthClientId", required = false) @Nullable String oauthClientId,
        @Parameter(name = "oauthSecretKey", description = "OAuth secret key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthSecretKey", required = false) @Nullable String oauthSecretKey,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_NOTE = "/api/{version}/note/create";
    /**
     * POST /api/{version}/note/create : Create Note
     * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
     *
     * @param version  (required)
     * @param comment The message the user wishes to leave a comment on (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteType The custom string defined by the client (used for differentiating various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param initializeAsset Check true if need to initialize an asset and assign to current note (optional)
     * @param assetReturnNulls Return null fields for asset response when creating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createNote",
        summary = "Create Note",
        description = "This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NoteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_NOTE,
        produces = { "*/*" }
    )
    default ResponseEntity<NoteResponse> createNote(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "comment", description = "The message the user wishes to leave a comment on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "comment", required = true) String comment,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "notableType", description = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableType", required = false) @Nullable String notableType,
        @Parameter(name = "notableId", description = "The id of the notable object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableId", required = false) @Nullable Long notableId,
        @Parameter(name = "noteType", description = "The custom string defined by the client (used for differentiating various note types)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteType", required = false) @Nullable String noteType,
        @Parameter(name = "assetIds", description = "A comma separated list of asset IDs to add with the note", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetIds", required = false) @Nullable String assetIds,
        @Parameter(name = "tags", description = "search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "permissionableType", description = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the permissionable object (for sending group notifications)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "locationDescription", description = "The description of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "receiverAccountIds", description = "Comma separated list of additional account IDs that will receive the note notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountIds", required = false) @Nullable String receiverAccountIds,
        @Parameter(name = "returnFullResponse", description = "whether to return the full response or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false) @Nullable Boolean returnFullResponse,
        @Parameter(name = "initializeAsset", description = "Check true if need to initialize an asset and assign to current note", in = ParameterIn.QUERY) @Valid @RequestParam(value = "initializeAsset", required = false) @Nullable Boolean initializeAsset,
        @Parameter(name = "assetReturnNulls", description = "Return null fields for asset response when creating an asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetReturnNulls", required = false) @Nullable Boolean assetReturnNulls,
        @Parameter(name = "assetAlbumId", description = "the album the asset will be added to (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAlbumId", required = false) @Nullable Long assetAlbumId,
        @Parameter(name = "assetCollectionId", description = "the collection ID that the asset is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetCollectionId", required = false) @Nullable Long assetCollectionId,
        @Parameter(name = "assetAddToDefaultAlbum", description = "the default album to add the asset to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAddToDefaultAlbum", required = false) @Nullable String assetAddToDefaultAlbum,
        @Parameter(name = "assetAddToMediaLibrary", description = "the media library to add the asset to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAddToMediaLibrary", required = false) @Nullable Boolean assetAddToMediaLibrary,
        @Parameter(name = "assetVersionCode", description = "the version code of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetVersionCode", required = false) @Nullable Integer assetVersionCode,
        @Parameter(name = "assetVersionName", description = "the version name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetVersionName", required = false) @Nullable String assetVersionName,
        @Parameter(name = "assetMetaData", description = "the meta data of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMetaData", required = false) @Nullable String assetMetaData,
        @Parameter(name = "assetCaption", description = "the caption of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetCaption", required = false) @Nullable String assetCaption,
        @Parameter(name = "assetMedia", description = "the media of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMedia", required = false) @Nullable org.springframework.core.io.Resource assetMedia,
        @Parameter(name = "assetMediaUrl", description = "the media URL of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaUrl", required = false) @Nullable String assetMediaUrl,
        @Parameter(name = "assetMediaString", description = "the media string of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaString", required = false) @Nullable String assetMediaString,
        @Parameter(name = "assetMediaStringFileName", description = "the media string file name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaStringFileName", required = false) @Nullable String assetMediaStringFileName,
        @Parameter(name = "assetMediaStringContentType", description = "the media string content type of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaStringContentType", required = false) @Nullable String assetMediaStringContentType,
        @Parameter(name = "assetAttachedMedia", description = "the attached media of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMedia", required = false) @Nullable org.springframework.core.io.Resource assetAttachedMedia,
        @Parameter(name = "assetAttachedMediaUrl", description = "the attached media URL of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaUrl", required = false) @Nullable String assetAttachedMediaUrl,
        @Parameter(name = "assetAttachedMediaString", description = "the attached media string of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaString", required = false) @Nullable String assetAttachedMediaString,
        @Parameter(name = "assetAttachedMediaStringFileName", description = "the attached media string file name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaStringFileName", required = false) @Nullable String assetAttachedMediaStringFileName,
        @Parameter(name = "assetAttachedMediaStringContentType", description = "the attached media string content type of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaStringContentType", required = false) @Nullable String assetAttachedMediaStringContentType,
        @Parameter(name = "assetLocationDescription", description = "the location description for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLocationDescription", required = false) @Nullable String assetLocationDescription,
        @Parameter(name = "assetApp", description = "the application for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetApp", required = false) @Nullable String assetApp,
        @Parameter(name = "assetSearchTags", description = "the search tags used for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetSearchTags", required = false) @Nullable String assetSearchTags,
        @Parameter(name = "assetLatitude", description = "the latitude of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLatitude", required = false) @Nullable Double assetLatitude,
        @Parameter(name = "assetLongitude", description = "the longitude of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLongitude", required = false) @Nullable BigDecimal assetLongitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_NOTIFICATION_TEMPLATE = "/api/{version}/notification/template/create";
    /**
     * POST /api/{version}/notification/template/create : Create Notification Template
     * Create a notification template. Developers will only be able to create notification templates for their own applications.
     *
     * @param version  (required)
     * @param accountId The account ID of the user. (required)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (required)
     * @param title title of the notification template (required)
     * @param body body of the notification template (required)
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param tags tags associated with the note template (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createNotificationTemplate",
        summary = "Create Notification Template",
        description = "Create a notification template. Developers will only be able to create notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> createNotificationTemplate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "conduit", description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = true) String conduit,
        @NotNull @Parameter(name = "title", description = "title of the notification template", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "body", description = "body of the notification template", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "body", required = true) String body,
        @Parameter(name = "appKey", description = "Filter results by application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "event", description = "Filter results by event.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "event", required = false) @Nullable String event,
        @Parameter(name = "tags", description = "tags associated with the note template", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OBJECT = "/api/{version}/object/create";
    /**
     * POST /api/{version}/object/create : Create Object
     * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to create (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createObject",
        summary = "Create Object",
        description = "Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. ",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> createObject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to create", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OFFER = "/api/{version}/retailer/offer/create";
    /**
     * POST /api/{version}/retailer/offer/create : Create Offer
     * Create an offer and assign it to the provided retailer locations.
     *
     * @param version  (required)
     * @param includeOfferLocations If true return all the offer locations associated with the offer (required)
     * @param title The title (255 char limit) (required)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (required)
     * @param availableLimit The limit of how many times the offer can be used by consumers (required)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (required)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (required)
     * @param viewLimit The limit of how many times the offer can be viewed (required)
     * @param maxPrints The maximum number of times the offer can be printed (required)
     * @param ticketPrice The cost of the offer in tickets (required)
     * @param fullPrice The retail/full price cost of the offer in real currency (required)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (required)
     * @param offerType The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE} (required)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
     * @param active Sets the active flag (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param parentOfferId the parent offer id (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param externalId an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param ticketPriceType the type of ticket needed to buy offer (optional)
     * @param showRemaining show remaining offers available (optional)
     * @param showRedeemed show how many offers have been redeemed (optional)
     * @param replaced  (optional)
     * @param featured flag if offer is featured or not (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param brand The brand. OfferType PRODUCT only. (optional)
     * @param productType The product type. OfferType PRODUCT only. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param department The department name. The OfferType PRODUCT only. (optional)
     * @param features The list of features, comma seperated. OfferType PRODUCT only. (optional)
     * @param minimumPrice The MAP price. OfferType PRODUCT only. (optional)
     * @param width The width of the item. OfferType PRODUCT only. (optional)
     * @param height The height of the item. OfferType PRODUCT only. (optional)
     * @param depth The depth of the item. OfferType PRODUCT only. (optional)
     * @param weight The weight of the item. OfferType PRODUCT only. (optional)
     * @param unit The unit of measurement. OfferType PRODUCT only. (optional)
     * @param studio The studio name. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param publishDate The date published. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param sizeId  (optional)
     * @param listingId The ID of the event listing (optional)
     * @param mediaType the media type of the offer (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param rebootTimeHour The reboot hour time ranging from 0 to 23 (optional)
     * @param rebootTimeMinute The reboot minute time ranging from 0 to 59 (optional)
     * @param idleTimeoutInSecond If the device is idle for idleTimeoutInSecond then the device should timeout (optional)
     * @param serialNumber The serial number on the device (optional)
     * @param udid The unique device id for the device (optional)
     * @param deviceType The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;. (optional)
     * @param devicePower Edysen device power level setting (optional)
     * @param deviceInterference Edysen device inteference setting (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOffer",
        summary = "Create Offer",
        description = "Create an offer and assign it to the provided retailer locations.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OFFER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerOfferResponse> createOffer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "includeOfferLocations", description = "If true return all the offer locations associated with the offer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeOfferLocations", required = true) Boolean includeOfferLocations,
        @NotNull @Parameter(name = "title", description = "The title (255 char limit)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "barcodeType", description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = true) String barcodeType,
        @NotNull @Parameter(name = "noExpiration", description = "Overrides the expiration date so that the offer does not expire", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "noExpiration", required = true) Boolean noExpiration,
        @NotNull @Parameter(name = "availableLimit", description = "The limit of how many times the offer can be used by consumers", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = true) Integer availableLimit,
        @NotNull @Parameter(name = "availableLimitPerUser", description = "The limit of how many times a user can used the same offer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimitPerUser", required = true) Integer availableLimitPerUser,
        @NotNull @Parameter(name = "addedLimit", description = "The limit of how many times the offer can be added to consumer wallets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "addedLimit", required = true) Integer addedLimit,
        @NotNull @Parameter(name = "viewLimit", description = "The limit of how many times the offer can be viewed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "viewLimit", required = true) Integer viewLimit,
        @NotNull @Parameter(name = "maxPrints", description = "The maximum number of times the offer can be printed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxPrints", required = true) Integer maxPrints,
        @NotNull @Parameter(name = "ticketPrice", description = "The cost of the offer in tickets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPrice", required = true) Long ticketPrice,
        @NotNull @Parameter(name = "fullPrice", description = "The retail/full price cost of the offer in real currency", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullPrice", required = true) Double fullPrice,
        @NotNull @Parameter(name = "discountPrice", description = "The cost of the offer at a discounted price (what the consumer pays)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "discountPrice", required = true) Double discountPrice,
        @NotNull @Parameter(name = "offerType", description = "The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = true) String offerType,
        @NotNull @Parameter(name = "specialOfferType", description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = true) String specialOfferType,
        @NotNull @Parameter(name = "offerVisibility", description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerVisibility", required = true) String offerVisibility,
        @NotNull @Parameter(name = "active", description = "Sets the active flag", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "tags", description = "Custom string field for doing full-text searches", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "parentOfferId", description = "the parent offer id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentOfferId", required = false) @Nullable Long parentOfferId,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "offerLocations", description = "A list of json data that has offer location specific values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocations", required = false) @Nullable String offerLocations,
        @Parameter(name = "subTitle", description = "The sub title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The details", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "subDetails", description = "A string for custom details (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subDetails", required = false) @Nullable String subDetails,
        @Parameter(name = "finePrint", description = "The fine print", in = ParameterIn.QUERY) @Valid @RequestParam(value = "finePrint", required = false) @Nullable String finePrint,
        @Parameter(name = "barcodeEntry", description = "The bar code entry string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "externalRedeemOptions", description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalRedeemOptions", required = false) @Nullable String externalRedeemOptions,
        @Parameter(name = "externalUrl", description = "The clickUrl of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalUrl", required = false) @Nullable String externalUrl,
        @Parameter(name = "externalId", description = "an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "ticketsRewardType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsRewardType", required = false) @Nullable String ticketsRewardType,
        @Parameter(name = "ticketsReward", description = "Determines how many tickets are awarded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsReward", required = false) @Nullable Long ticketsReward,
        @Parameter(name = "activated", description = "The date of when the offer will be visible to consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activated", required = false) @Nullable Long activated,
        @Parameter(name = "expires", description = "The date of when the offer expires", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expires", required = false) @Nullable Long expires,
        @Parameter(name = "ticketPriceType", description = "the type of ticket needed to buy offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPriceType", required = false) @Nullable String ticketPriceType,
        @Parameter(name = "showRemaining", description = "show remaining offers available", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRemaining", required = false) @Nullable Boolean showRemaining,
        @Parameter(name = "showRedeemed", description = "show how many offers have been redeemed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRedeemed", required = false) @Nullable Boolean showRedeemed,
        @Parameter(name = "replaced", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "replaced", required = false) @Nullable Boolean replaced,
        @Parameter(name = "featured", description = "flag if offer is featured or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "barcodeAssetId", description = "The id of the barcode asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeAssetId", required = false) @Nullable Long barcodeAssetId,
        @Parameter(name = "imageAssetId", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "imageAssetId1", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId1", required = false) @Nullable Long imageAssetId1,
        @Parameter(name = "imageAssetId2", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId2", required = false) @Nullable Long imageAssetId2,
        @Parameter(name = "imageAssetId3", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId3", required = false) @Nullable Long imageAssetId3,
        @Parameter(name = "imageAssetId4", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId4", required = false) @Nullable Long imageAssetId4,
        @Parameter(name = "imageAssetId5", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId5", required = false) @Nullable Long imageAssetId5,
        @Parameter(name = "publisher", description = "The maker of the item.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publisher", required = false) @Nullable String publisher,
        @Parameter(name = "redeemableStart", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd,
        @Parameter(name = "brand", description = "The brand. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "brand", required = false) @Nullable String brand,
        @Parameter(name = "productType", description = "The product type. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "productType", required = false) @Nullable String productType,
        @Parameter(name = "conditionType", description = "The condition. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionType", required = false) @Nullable String conditionType,
        @Parameter(name = "isbn", description = "The ISBN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "The ASIN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "catalogNumbers", description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "catalogNumbers", required = false) @Nullable String catalogNumbers,
        @Parameter(name = "department", description = "The department name. The OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "department", required = false) @Nullable String department,
        @Parameter(name = "features", description = "The list of features, comma seperated. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "features", required = false) @Nullable String features,
        @Parameter(name = "minimumPrice", description = "The MAP price. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumPrice", required = false) @Nullable Double minimumPrice,
        @Parameter(name = "width", description = "The width of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "width", required = false) @Nullable Double width,
        @Parameter(name = "height", description = "The height of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable Double height,
        @Parameter(name = "depth", description = "The depth of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "depth", required = false) @Nullable Double depth,
        @Parameter(name = "weight", description = "The weight of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "weight", required = false) @Nullable Double weight,
        @Parameter(name = "unit", description = "The unit of measurement. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "unit", required = false) @Nullable String unit,
        @Parameter(name = "studio", description = "The studio name. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "studio", required = false) @Nullable String studio,
        @Parameter(name = "parentalRating", description = "The parental control rating. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentalRating", required = false) @Nullable String parentalRating,
        @Parameter(name = "publishDate", description = "The date published. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publishDate", required = false) @Nullable Long publishDate,
        @Parameter(name = "availabilityDate", description = "The date available. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilityDate", required = false) @Nullable Long availabilityDate,
        @Parameter(name = "sizeId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sizeId", required = false) @Nullable Long sizeId,
        @Parameter(name = "listingId", description = "The ID of the event listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = false) @Nullable Long listingId,
        @Parameter(name = "mediaType", description = "the media type of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaType", required = false) @Nullable String mediaType,
        @Parameter(name = "duration", description = "The total playing time of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Integer duration,
        @Parameter(name = "author", description = "The created/author of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "author", required = false) @Nullable String author,
        @Parameter(name = "releaseDate", description = "The date/time of when the media item was originally released. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "releaseDate", required = false) @Nullable Long releaseDate,
        @Parameter(name = "collectionIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionIds", required = false) @Nullable String collectionIds,
        @Parameter(name = "rebootTimeHour", description = "The reboot hour time ranging from 0 to 23", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rebootTimeHour", required = false) @Nullable Integer rebootTimeHour,
        @Parameter(name = "rebootTimeMinute", description = "The reboot minute time ranging from 0 to 59", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rebootTimeMinute", required = false) @Nullable Integer rebootTimeMinute,
        @Parameter(name = "idleTimeoutInSecond", description = "If the device is idle for idleTimeoutInSecond then the device should timeout", in = ParameterIn.QUERY) @Valid @RequestParam(value = "idleTimeoutInSecond", required = false) @Nullable Integer idleTimeoutInSecond,
        @Parameter(name = "serialNumber", description = "The serial number on the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "serialNumber", required = false) @Nullable String serialNumber,
        @Parameter(name = "udid", description = "The unique device id for the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid,
        @Parameter(name = "deviceType", description = "The type of the device, for example: \"Kiosk\", \"Beacon\".", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "devicePower", description = "Edysen device power level setting", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devicePower", required = false) @Nullable Double devicePower,
        @Parameter(name = "deviceInterference", description = "Edysen device inteference setting", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceInterference", required = false) @Nullable Double deviceInterference,
        @Parameter(name = "availability", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availability", required = false) @Nullable String availability,
        @Parameter(name = "availabilitySummary", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilitySummary", required = false) @Nullable String availabilitySummary
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OFFER_TRANSACTION = "/api/{version}/wallet/create";
    /**
     * POST /api/{version}/wallet/create : Create Wallet Offers
     * Adds offers to the wallet
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;  (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to CASH)
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOfferTransaction",
        summary = "Create Wallet Offers",
        description = "Adds offers to the wallet",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferTransactionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferTransactionResponse>> createOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "offerId", description = "The id of the offer being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "The id of the offer location being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "offerCart", description = "A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerCart", required = false) @Nullable String offerCart,
        @Parameter(name = "promoCode", description = "The promoCode", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode,
        @Parameter(name = "currencyType", description = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "usePoints", deprecated = true, description = "Sets the currencyType to POINTS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "usePoints", required = false) @Deprecated @Nullable Boolean usePoints,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "appKey", description = "The application requesting the purchase, required when currencyType is TICKETS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "status", description = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable Integer status
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OFFER_TRANSACTION_STATUS = "/api/{version}/offer/status/create";
    /**
     * POST /api/{version}/offer/status/create : Create Offer Status
     * Create an offer status record
     *
     * @param version  (required)
     * @param name The name of the status (required)
     * @param code The status code, must be unique  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param description The description of the status (optional)
     * @param role The actor that uses the status (optional, default to ANY)
     * @param active The active status (optional, default to true)
     * @param applicationIds The applications to associate the status with, if null then for all. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOfferTransactionStatus",
        summary = "Create Offer Status",
        description = "Create an offer status record",
        tags = { "Offer Status" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferTransactionStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OFFER_TRANSACTION_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferTransactionStatusResponse> createOfferTransactionStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "name", description = "The name of the status", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "code", description = "The status code, must be unique ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "code", required = true) Integer code,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "description", description = "The description of the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "role", description = "The actor that uses the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false, defaultValue = "ANY") String role,
        @Parameter(name = "active", description = "The active status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") Boolean active,
        @Parameter(name = "applicationIds", description = "The applications to associate the status with, if null then for all.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS = "/api/{version}/notification/blocked/batch";
    /**
     * POST /api/{version}/notification/blocked/batch : Create or update blocked notification settings
     * Create or update blocked notification settings
     *
     * @param version  (required)
     * @param appKey The application key (required)
     * @param data batch data payload (application specific) (required)
     * @param accountId the account id of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOrUpdateBlockedNotifications",
        summary = "Create or update blocked notification settings",
        description = "Create or update blocked notification settings",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BlockedNotificationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<BlockedNotificationResponse> createOrUpdateBlockedNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "data", description = "batch data payload (application specific)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OR_UPDATE_CONNECTION = "/api/{version}/consumer/connection/add";
    /**
     * POST /api/{version}/consumer/connection/add : Create or Update Connection
     * Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id for editing (optional)
     * @param connectionAccountId the connection account id (i.e. the account id of another user) (optional)
     * @param pendingId the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)
     * @param groupId optional group id if the user wants to add this person into a group (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param isTrusted determines whether the user is trusting this account (optional)
     * @param ignoreFriendRequest determines whether the user has set to ignore the user&#39;s friend request (optional)
     * @param isContact determines whether the user is a contact of this account (optional)
     * @param isBlocked determines whether the user is blocking this account (optional)
     * @param isFollowing determines whether the user is following this account (optional)
     * @param connectionResponse whether to return the connection response or not (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOrUpdateConnection",
        summary = "Create or Update Connection",
        description = "Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OR_UPDATE_CONNECTION,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionResponse> createOrUpdateConnection(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionId", description = "the connection id for editing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionId", required = false) @Nullable Long connectionId,
        @Parameter(name = "connectionAccountId", description = "the connection account id (i.e. the account id of another user)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "pendingId", description = "the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pendingId", required = false) @Nullable Long pendingId,
        @Parameter(name = "groupId", description = "optional group id if the user wants to add this person into a group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = false) @Nullable Long groupId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "isTrusted", description = "determines whether the user is trusting this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isTrusted", required = false) @Nullable Boolean isTrusted,
        @Parameter(name = "ignoreFriendRequest", description = "determines whether the user has set to ignore the user's friend request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ignoreFriendRequest", required = false) @Nullable Boolean ignoreFriendRequest,
        @Parameter(name = "isContact", description = "determines whether the user is a contact of this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isContact", required = false) @Nullable Boolean isContact,
        @Parameter(name = "isBlocked", description = "determines whether the user is blocking this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isBlocked", required = false) @Nullable Boolean isBlocked,
        @Parameter(name = "isFollowing", description = "determines whether the user is following this account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isFollowing", required = false) @Nullable Boolean isFollowing,
        @Parameter(name = "connectionResponse", description = "whether to return the connection response or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionResponse", required = false) @Nullable Boolean connectionResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OR_UPDATE_GROUP = "/api/{version}/consumer/connection/group";
    /**
     * POST /api/{version}/consumer/connection/group : Create or Update Connection Group
     * Creates a new private group.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param name the name of the group (optional)
     * @param groupId the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)
     * @param assetId the asset to attach to the group (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param description the description of the group (optional)
     * @param canViewProfileInfo determines whether the connections in the group can see the user&#39;s profile info (optional)
     * @param canViewGameInfo determines whether the connections in the group can see the user&#39;s game info (optional)
     * @param canViewFriendInfo determines whether the connections in the group can see the user&#39;s friends/connections (optional)
     * @param active Sets whether the connection group is active or inactive (optional)
     * @param latitude the latitude of the group (optional)
     * @param longitude the longitude of the group (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOrUpdateGroup",
        summary = "Create or Update Connection Group",
        description = "Creates a new private group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_OR_UPDATE_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> createOrUpdateGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "the name of the group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "groupId", description = "the group id to update a group (don't pass anything in if you want to create a new group)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = false) @Nullable Long groupId,
        @Parameter(name = "assetId", description = "the asset to attach to the group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "connections", description = "comma separated list of connection IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connections", required = false) @Nullable String connections,
        @Parameter(name = "description", description = "the description of the group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "canViewProfileInfo", description = "determines whether the connections in the group can see the user's profile info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "canViewProfileInfo", required = false) @Nullable Boolean canViewProfileInfo,
        @Parameter(name = "canViewGameInfo", description = "determines whether the connections in the group can see the user's game info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "canViewGameInfo", required = false) @Nullable Boolean canViewGameInfo,
        @Parameter(name = "canViewFriendInfo", description = "determines whether the connections in the group can see the user's friends/connections", in = ParameterIn.QUERY) @Valid @RequestParam(value = "canViewFriendInfo", required = false) @Nullable Boolean canViewFriendInfo,
        @Parameter(name = "active", description = "Sets whether the connection group is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "latitude", description = "the latitude of the group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ORDER = "/api/{version}/order/create";
    /**
     * POST /api/{version}/order/create : Create Order
     * Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
     *
     * @param version  (required)
     * @param appKey The application requesting the purchase (required)
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOrder",
        summary = "Create Order",
        description = "Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ORDER,
        produces = { "*/*" }
    )
    default ResponseEntity<OrderResponse> createOrder(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application requesting the purchase", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "cart", description = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "cart", required = true) String cart,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "description", description = "A description of the purchase", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "currencyType", description = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "paymentMethodId", description = "Use a specific payment method (CASH), if not provided use default", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId,
        @Parameter(name = "externalOrderId", description = "Store identifier from external system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalOrderId", required = false) @Nullable String externalOrderId,
        @Parameter(name = "externalPaymentId", description = "Store identifier from external system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalPaymentId", required = false) @Nullable String externalPaymentId,
        @Parameter(name = "remoteRefType", description = "Remote Reference type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "remoteRefType", required = false) @Nullable String remoteRefType,
        @Parameter(name = "externalDate", description = "External Date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalDate", required = false) @Nullable Long externalDate,
        @Parameter(name = "promoCode", description = "The Promo Code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_PACK = "/api/{version}/pack/create";
    /**
     * POST /api/{version}/pack/create : Create Pack
     * Create a pack.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param title The title of the pack (required)
     * @param packOrder The order of the pack (required)
     * @param price The price in tickets to purchase this pack (required)
     * @param highest The scoring is highest is best (required)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed packs (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param description The description of the pack (optional)
     * @param searchTags The tags for searching the pack, comma separated (optional)
     * @param active Activate/deactivate the pack (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param packType The type of the pack (optional)
     * @param sequenceType The type of game sequence of the pack (optional)
     * @param backgroundId The background asset id of the pack (optional)
     * @param imageId The image asset id of the pack (optional)
     * @param startDate The date/time to start the pack, send 0 to unset (optional)
     * @param endDate The date/time to end the pack, send 0 to unset (optional)
     * @param authorOverride  (optional)
     * @param priceType the type of ticket required to purchase this pack (optional)
     * @param gameLevelIds the game level ids to include in the pack, comma separated (optional)
     * @param inGame  (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a pack (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createPack",
        summary = "Create Pack",
        description = "Create a pack.",
        tags = { "Pack" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PackResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_PACK,
        produces = { "*/*" }
    )
    default ResponseEntity<PackResponse> createPack(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "title", description = "The title of the pack", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "packOrder", description = "The order of the pack", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packOrder", required = true) Long packOrder,
        @NotNull @Parameter(name = "price", description = "The price in tickets to purchase this pack", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "price", required = true) Integer price,
        @NotNull @Parameter(name = "highest", description = "The scoring is highest is best", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "highest", required = true) Boolean highest,
        @NotNull @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed packs", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = true) Boolean allocateTickets,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true) Long ticketCount,
        @Parameter(name = "description", description = "The description of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The tags for searching the pack, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "active", description = "Activate/deactivate the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "packType", description = "The type of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packType", required = false) @Nullable String packType,
        @Parameter(name = "sequenceType", description = "The type of game sequence of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sequenceType", required = false) @Nullable String sequenceType,
        @Parameter(name = "backgroundId", description = "The background asset id of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "backgroundId", required = false) @Nullable Long backgroundId,
        @Parameter(name = "imageId", description = "The image asset id of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageId", required = false) @Nullable Long imageId,
        @Parameter(name = "startDate", description = "The date/time to start the pack, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The date/time to end the pack, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "authorOverride", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorOverride", required = false) @Nullable String authorOverride,
        @Parameter(name = "priceType", description = "the type of ticket required to purchase this pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "priceType", required = false) @Nullable String priceType,
        @Parameter(name = "gameLevelIds", description = "the game level ids to include in the pack, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "inGame", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inGame", required = false) @Nullable Boolean inGame,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_PAYMENT_METHOD = "/api/{version}/billing/create";
    /**
     * POST /api/{version}/billing/create : Create Payment Method
     * Add a new method of payment.
     *
     * @param version  (required)
     * @param accountId The account used to perform the the request (required)
     * @param accountName Account Name of the credit card user (optional)
     * @param firstName The first name on the credit card (optional)
     * @param lastName The last name on the credit card (optional)
     * @param address The billing address of the credit card (optional)
     * @param city The billing city of the credit card (optional)
     * @param state The billing state of the credit card (optional)
     * @param postalCode The billing zip code of the credit card (optional)
     * @param country Country of the credit card (optional)
     * @param phone The billing phone of the credit card (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber The bank routing number (optional)
     * @param paymentMethodNickname The nickname to give the payment method (optional)
     * @param taxId Tax Id (optional)
     * @param defaultPaymentMethod Whether this should be the default payment method (optional, default to true)
     * @param authToken An authorization token for providers that provide this (like Amazon Payments) (optional)
     * @param provider The payment provider (see PaymentMethodProvider) (optional, default to AUTHORIZE_NET)
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @param appKey Application Key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createPaymentMethod",
        summary = "Create Payment Method",
        description = "Add a new method of payment.",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_PAYMENT_METHOD,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> createPaymentMethod(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "accountName", description = "Account Name of the credit card user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountName", required = false) @Nullable String accountName,
        @Parameter(name = "firstName", description = "The first name on the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "lastName", description = "The last name on the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "address", description = "The billing address of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "address", required = false) @Nullable String address,
        @Parameter(name = "city", description = "The billing city of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The billing state of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The billing zip code of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "Country of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "phone", description = "The billing phone of the credit card", in = ParameterIn.QUERY) @Valid @RequestParam(value = "phone", required = false) @Nullable String phone,
        @Parameter(name = "creditCardNumber", description = "The full credit card number to store on file", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creditCardNumber", required = false) @Nullable String creditCardNumber,
        @Parameter(name = "expirationDate", description = "The credit card expiration date YYYY-MM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expirationDate", required = false) @Nullable String expirationDate,
        @Parameter(name = "ccv", description = "The 3 digit confirmation code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ccv", required = false) @Nullable String ccv,
        @Parameter(name = "accountNumber", description = "The bank account number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountNumber", required = false) @Nullable String accountNumber,
        @Parameter(name = "bankName", description = "The bank name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bankName", required = false) @Nullable String bankName,
        @Parameter(name = "routingNumber", description = "The bank routing number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "routingNumber", required = false) @Nullable String routingNumber,
        @Parameter(name = "paymentMethodNickname", description = "The nickname to give the payment method", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodNickname", required = false) @Nullable String paymentMethodNickname,
        @Parameter(name = "taxId", description = "Tax Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "taxId", required = false) @Nullable String taxId,
        @Parameter(name = "defaultPaymentMethod", description = "Whether this should be the default payment method", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultPaymentMethod", required = false, defaultValue = "true") Boolean defaultPaymentMethod,
        @Parameter(name = "authToken", description = "An authorization token for providers that provide this (like Amazon Payments)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authToken", required = false) @Nullable String authToken,
        @Parameter(name = "provider", description = "The payment provider (see PaymentMethodProvider)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "provider", required = false, defaultValue = "AUTHORIZE_NET") String provider,
        @Parameter(name = "providerCustomerProfileId", description = "Provider customer profile Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "providerCustomerProfileId", required = false) @Nullable String providerCustomerProfileId,
        @Parameter(name = "providerPaymentProfileId", description = "Provider customer payment profile Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "providerPaymentProfileId", required = false) @Nullable String providerPaymentProfileId,
        @Parameter(name = "metaData", description = "Meta Data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "appKey", description = "Application Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_PERSONA = "/api/{version}/persona/create";
    /**
     * POST /api/{version}/persona/create : Create Persona
     * Creates a new persona. If the given params are null those attributes will be override by null.
     *
     * @param version  (required)
     * @param accountId the account ID of the user (required)
     * @param title the title of the persona (required)
     * @param previewAccounts the accounts that are able to preview from this persona (optional)
     * @param date the sepcified date that this persona is viewing the app (optional)
     * @param age the specified age of this persona (optional)
     * @param gender the specified gender of this persona (optional)
     * @param gameExperienceLevel the specified experience level of the persona (optional)
     * @param latitude the specified latitude of the persona (optional)
     * @param longitude the specified longitude of the persona (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createPersona",
        summary = "Create Persona",
        description = "Creates a new persona. If the given params are null those attributes will be override by null.",
        tags = { "Preview Persona" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PreviewPersonaResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_PERSONA,
        produces = { "*/*" }
    )
    default ResponseEntity<PreviewPersonaResponse> createPersona(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "title", description = "the title of the persona", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @Parameter(name = "previewAccounts", description = "the accounts that are able to preview from this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "previewAccounts", required = false) @Nullable String previewAccounts,
        @Parameter(name = "date", description = "the sepcified date that this persona is viewing the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "date", required = false) @Nullable Long date,
        @Parameter(name = "age", description = "the specified age of this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "gender", description = "the specified gender of this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "gameExperienceLevel", description = "the specified experience level of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "latitude", description = "the specified latitude of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the specified longitude of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_POSTAL_CODE = "/api/{version}/postalCode/create";
    /**
     * POST /api/{version}/postalCode/create : Create Postal Code
     * Create a Postal Code
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param code the postal code (required)
     * @param latitude the latitude of the postal code (required)
     * @param longitude the longitude of the postal code (required)
     * @param stateCode the state code (e.g WA, WV, WI) that the postal code is located (optional)
     * @param city the city that the postal code is located (optional)
     * @param active whether the postal code created should be active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createPostalCode",
        summary = "Create Postal Code",
        description = "Create a Postal Code",
        tags = { "Postal Code" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PostalCodeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_POSTAL_CODE,
        produces = { "*/*" }
    )
    default ResponseEntity<PostalCodeResponse> createPostalCode(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "code", description = "the postal code", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "code", required = true) String code,
        @NotNull @Parameter(name = "latitude", description = "the latitude of the postal code", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "the longitude of the postal code", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @Parameter(name = "stateCode", description = "the state code (e.g WA, WV, WI) that the postal code is located", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stateCode", required = false) @Nullable String stateCode,
        @Parameter(name = "city", description = "the city that the postal code is located", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "active", description = "whether the postal code created should be active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_PROGRAM = "/api/{version}/program";
    /**
     * POST /api/{version}/program : Create Program
     * Create a new program
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createProgram",
        summary = "Create Program",
        description = "Create a new program",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Program.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_PROGRAM,
        produces = { "*/*" }
    )
    default ResponseEntity<Program> createProgram(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Program body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_PURCHASE_ITEM = "/api/{version}/purchase/create";
    /**
     * POST /api/{version}/purchase/create : Create Purchase
     * Creates a purchase item for in app purchases
     *
     * @param version  (required)
     * @param appKey The application key that the purchase can be used in (required)
     * @param name The name of the purchase item (required)
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional, default to 0)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createPurchaseItem",
        summary = "Create Purchase",
        description = "Creates a purchase item for in app purchases",
        tags = { "Purchase Item" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PurchaseItemFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_PURCHASE_ITEM,
        produces = { "*/*" }
    )
    default ResponseEntity<PurchaseItemFullResponse> createPurchaseItem(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key that the purchase can be used in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "name", description = "The name of the purchase item", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "purchaseType", description = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = true) String purchaseType,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "description", description = "The description of the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "tickets", description = "How much the purchase item is worth in tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tickets", required = false) @Nullable Integer tickets,
        @Parameter(name = "price", description = "How much the purchase item will cost in real money", in = ParameterIn.QUERY) @Valid @RequestParam(value = "price", required = false) @Nullable Float price,
        @Parameter(name = "purchaseCode", description = "The unique identifier used by purchase providers to identify in-app-purchases", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseCode", required = false) @Nullable String purchaseCode,
        @Parameter(name = "secretKey", description = "A secret key from purchase providers that would be used for validation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secretKey", required = false) @Nullable String secretKey,
        @Parameter(name = "purchaseLimit", description = "How many times a user acquire the same purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseLimit", required = false, defaultValue = "0") Integer purchaseLimit,
        @Parameter(name = "serviceAction", description = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", in = ParameterIn.QUERY) @Valid @RequestParam(value = "serviceAction", required = false) @Nullable String serviceAction,
        @Parameter(name = "coverAssetId", description = "The cover image of the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "coverAssetId", required = false) @Nullable Long coverAssetId,
        @Parameter(name = "promoAssetId", description = "An application specific asset that can be used to store/provide additional data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoAssetId", required = false) @Nullable Long promoAssetId,
        @Parameter(name = "giftable", description = "Determines whether the purchase item can be gifted to other users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "giftable", required = false) @Nullable Boolean giftable,
        @Parameter(name = "assetable", description = "Determines whether users can attach their own media/asset to the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetable", required = false) @Nullable Boolean assetable,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false, defaultValue = "false") Boolean allocateTickets,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "offerLocationId", description = "The offer location that will get added to the user's wallet after purchase.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_QUESTION = "/api/{version}/game/question/create";
    /**
     * POST /api/{version}/game/question/create : Create Question
     * Create a question and related answers by the given params.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param question the text of the question (required)
     * @param answers &#x60;&#x60;&#x60;json [   {     \&quot;text\&quot;: \&quot;1942\&quot;,     \&quot;image\&quot;: 123,     \&quot;videoURL\&quot;: \&quot;http://www.here.com\&quot;,     \&quot;correct\&quot;: true   },   {     \&quot;text\&quot;: \&quot;1943\&quot;,     \&quot;image\&quot;: 124,     \&quot;videoURL\&quot;: \&quot;http://www.there.com\&quot;,     \&quot;correct\&quot;: false   } ] &#x60;&#x60;&#x60;  (required)
     * @param active If true set the question to active. Default to false. (required)
     * @param allocateTickets If true then scoring will give tickets. Default to false. (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createQuestion",
        summary = "Create Question",
        description = "Create a question and related answers by the given params.",
        tags = { "Question" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QuestionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_QUESTION,
        produces = { "*/*" }
    )
    default ResponseEntity<QuestionResponse> createQuestion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "question", description = "the text of the question", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "question", required = true) String question,
        @NotNull @Parameter(name = "answers", description = "```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "answers", required = true) String answers,
        @NotNull @Parameter(name = "active", description = "If true set the question to active. Default to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @NotNull @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets. Default to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = true) Boolean allocateTickets,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true) Long ticketCount,
        @Parameter(name = "tags", description = "The tags of the question for search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "videoURL", description = "The video link for the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "videoURL", required = false) @Nullable String videoURL,
        @Parameter(name = "assetId", description = "The asset id of the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_RATING = "/api/{version}/rating/create";
    /**
     * POST /api/{version}/rating/create : Create Rating
     * This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.
     *
     * @param version  (required)
     * @param ratableType The ratable object type {RETAILER_LOCATION} (required)
     * @param ratableId The id of the ratable object (required)
     * @param ratingValue The integer value of 0-100 (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param categoryId  (optional)
     * @param display A subject title for the user rating (limited to 255 characters) (optional)
     * @param description The description of the rating (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRating",
        summary = "Create Rating",
        description = "This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RatingResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_RATING,
        produces = { "*/*" }
    )
    default ResponseEntity<RatingResponse> createRating(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "ratableType", description = "The ratable object type {RETAILER_LOCATION}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableType", required = true) String ratableType,
        @NotNull @Parameter(name = "ratableId", description = "The id of the ratable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableId", required = true) Long ratableId,
        @NotNull @Parameter(name = "ratingValue", description = "The integer value of 0-100", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratingValue", required = true) Integer ratingValue,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "categoryId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = false) @Nullable Long categoryId,
        @Parameter(name = "display", description = "A subject title for the user rating (limited to 255 characters)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "display", required = false) @Nullable String display,
        @Parameter(name = "description", description = "The description of the rating", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "locationDescription", description = "The description of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_REGION = "/api/{version}/region/create";
    /**
     * POST /api/{version}/region/create : Create Region
     * Create a region.
     *
     * @param version  (required)
     * @param accountId The id of the account sending the request (required)
     * @param regionClass RegionClass of this region (required)
     * @param shortName Short name of the region. This is optimized for search (required)
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the id of the retailer location that the region is being created for (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon generated for the region (optional)
     * @param metaData the meta data associated with the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRegion",
        summary = "Create Region",
        description = "Create a region.",
        tags = { "Region" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RegionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_REGION,
        produces = { "*/*" }
    )
    default ResponseEntity<RegionResponse> createRegion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The id of the account sending the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "regionClass", description = "RegionClass of this region", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionClass", required = true) String regionClass,
        @NotNull @Parameter(name = "shortName", description = "Short name of the region. This is optimized for search", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "shortName", required = true) String shortName,
        @Parameter(name = "fullName", description = "Full name of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullName", required = false) @Nullable String fullName,
        @Parameter(name = "parentIds", description = "Comma separated region ids that are parents of this region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "childrenIds", description = "Comma separated region ids that are children of this region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenIds", required = false) @Nullable String childrenIds,
        @Parameter(name = "postalCodeIds", description = "Comma separated postal code ids the region will include", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCodeIds", required = false) @Nullable String postalCodeIds,
        @Parameter(name = "locations", description = "Sets of name,lat,long used to create new postal codes assigned to the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "retailerLocationId", description = "the id of the retailer location that the region is being created for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "visibility", description = "The Visibility of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "categoryIds", description = "the categories that the region is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "the filters that the region is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "start", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "end", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "end", required = false) @Nullable Long end,
        @Parameter(name = "polygon", description = "the polygon generated for the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "polygon", required = false) @Nullable String polygon,
        @Parameter(name = "metaData", description = "the meta data associated with the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "latitude", description = "the latitude of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "versionCode", description = "the version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "root", description = "If this is a root region or not. If true means this region has no parent regions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "root", required = false) @Nullable Boolean root,
        @Parameter(name = "active", description = "Active or inactive status of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_REGION_LEG_SUMMARY_BATCH = "/api/{version}/report/region/summary/batch";
    /**
     * POST /api/{version}/report/region/summary/batch : Create Offline Report
     * Create an entry for the batch for offline report
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRegionLegSummaryBatch",
        summary = "Create Offline Report",
        description = "Create an entry for the batch for offline report",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ReportRegionLegSummaryBatchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_REGION_LEG_SUMMARY_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<ReportRegionLegSummaryBatchResponse> createRegionLegSummaryBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable List<@Valid RegionLegSummary> body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_RESERVATION = "/api/{version}/reservation/create";
    /**
     * POST /api/{version}/reservation/create : Create Reservation
     * Creates a reservation on an offer object
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param startDate The start date (optional)
     * @param endDate The end date (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param appKey The application requesting the reservation (optional)
     * @param metaData External custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createReservation",
        summary = "Create Reservation",
        description = "Creates a reservation on an offer object",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_RESERVATION
    )
    default ResponseEntity<Void> createReservation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "startDate", description = "The start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "offerId", description = "The id of the offer being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "The id of the offer location being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "appKey", description = "The application requesting the reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_RETAILER = "/api/{version}/retailer/create";
    /**
     * POST /api/{version}/retailer/create : Create Retailer
     * Create a retailer record. A billable entity must be created first before a retailer record can be made.
     *
     * @param version  (required)
     * @param name The name of the retailer (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone number of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param categoryIdsToAdd Comma separated list of category IDs to add to the retailer (optional)
     * @param categoryIdsToRemove Comma separated list of category IDs to remove from the retailer (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param createDefaultLocation Determines whether to create a default location using the retailer information (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRetailer",
        summary = "Create Retailer",
        description = "Create a retailer record. A billable entity must be created first before a retailer record can be made.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_RETAILER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerFullResponse> createRetailer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "name", description = "The name of the retailer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "streetAddress", description = "The street address of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "the country of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "businessPhone", description = "The business phone number of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "website", description = "The website of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "website", required = false) @Nullable String website,
        @Parameter(name = "email", description = "The email of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = false) @Nullable String email,
        @Parameter(name = "facebookUrl", description = "The facebook URL of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookUrl", required = false) @Nullable String facebookUrl,
        @Parameter(name = "twitterUrl", description = "The twitter URL of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twitterUrl", required = false) @Nullable String twitterUrl,
        @Parameter(name = "logo", description = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logo", required = false) @Nullable org.springframework.core.io.Resource logo,
        @Parameter(name = "logoAssetId", description = "The retailer logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logoAssetId", required = false) @Nullable Long logoAssetId,
        @Parameter(name = "picture1", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1", required = false) @Nullable org.springframework.core.io.Resource picture1,
        @Parameter(name = "picture1AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1AssetId", required = false) @Nullable Long picture1AssetId,
        @Parameter(name = "picture2", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2", required = false) @Nullable org.springframework.core.io.Resource picture2,
        @Parameter(name = "picture2AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2AssetId", required = false) @Nullable Long picture2AssetId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category IDs used to filter retailers by categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "categoryIdsToAdd", description = "Comma separated list of category IDs to add to the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIdsToAdd", required = false) @Nullable String categoryIdsToAdd,
        @Parameter(name = "categoryIdsToRemove", description = "Comma separated list of category IDs to remove from the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIdsToRemove", required = false) @Nullable String categoryIdsToRemove,
        @Parameter(name = "filterIds", description = "Comma separated list of filter IDs used to filter retailers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "latitude", description = "the latitude of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "searchTags", description = "External custom search keywords", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "retailerType", description = "External custom type identifier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerType", required = false) @Nullable String retailerType,
        @Parameter(name = "visibility", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "createDefaultLocation", description = "Determines whether to create a default location using the retailer information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createDefaultLocation", required = false) @Nullable Boolean createDefaultLocation,
        @Parameter(name = "responseFormat", description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_RETAILER_LOCATION_CONSUMER = "/api/{version}/location/create";
    /**
     * POST /api/{version}/location/create : Create Retailer Location (Consumer)
     * Creates a location record for an application that can support crowd sourced locations.
     *
     * @param version  (required)
     * @param appKey the application key (required)
     * @param name The name of the retailer location (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param metaData External custom client defined data (optional)
     * @param publicLocation Whether the location is public (optional)
     * @param active whether the retailer location created should be active or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param latitude The latitude to center the search on (optional)
     * @param longitude The longitude to center the search on (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRetailerLocationConsumer",
        summary = "Create Retailer Location (Consumer)",
        description = "Creates a location record for an application that can support crowd sourced locations.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_RETAILER_LOCATION_CONSUMER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerLocationResponse> createRetailerLocationConsumer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "name", description = "The name of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "streetAddress", description = "The street address of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "the country of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "businessPhone", description = "The business phone", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "website", description = "The website of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "website", required = false) @Nullable String website,
        @Parameter(name = "email", description = "The email of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = false) @Nullable String email,
        @Parameter(name = "detailsHeader", description = "A brief description about the retailer location (255 character limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsHeader", required = false) @Nullable String detailsHeader,
        @Parameter(name = "detailsBody", description = "A detailed description about the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsBody", required = false) @Nullable String detailsBody,
        @Parameter(name = "hours", description = "The hours of operation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hours", required = false) @Nullable String hours,
        @Parameter(name = "tags", description = "Custom string field for doing full-text searches", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "logoAssetId", description = "The retailer location logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logoAssetId", required = false) @Nullable Long logoAssetId,
        @Parameter(name = "picture1AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1AssetId", required = false) @Nullable Long picture1AssetId,
        @Parameter(name = "picture2AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2AssetId", required = false) @Nullable Long picture2AssetId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category IDs used to filter retailer locations by categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter IDs used to filter retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "publicLocation", description = "Whether the location is public", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicLocation", required = false) @Nullable Boolean publicLocation,
        @Parameter(name = "active", description = "whether the retailer location created should be active or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "locationType", description = "External custom type identifier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "latitude", description = "The latitude to center the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The longitude to center the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_RETAILER_LOCATIONS = "/api/{version}/retailer/location/create";
    /**
     * POST /api/{version}/retailer/location/create : Create Retailer Location
     * Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     *
     * @param version  (required)
     * @param retailerId The ID of the retailer (required)
     * @param name The name of the retailer location (required)
     * @param streetAddress The street address of the retailer location (required)
     * @param city The city of the retailer location (required)
     * @param state The state of the retailer location (required)
     * @param postalCode The postal code of the retailer location (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latitude of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the ID of the Google Place that this retailer location is assigned to (optional)
     * @param yelpId the Yelp ID that this retailer location is assigned to (optional)
     * @param active whether the retailer location should be active or inactive (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param responseIncludes Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRetailerLocations",
        summary = "Create Retailer Location",
        description = "Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_RETAILER_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerLocationResponse> createRetailerLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerId", description = "The ID of the retailer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = true) Long retailerId,
        @NotNull @Parameter(name = "name", description = "The name of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "streetAddress", description = "The street address of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = true) String streetAddress,
        @NotNull @Parameter(name = "city", description = "The city of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = true) String city,
        @NotNull @Parameter(name = "state", description = "The state of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = true) String state,
        @NotNull @Parameter(name = "postalCode", description = "The postal code of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = true) String postalCode,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "country", description = "the country of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "businessPhone", description = "The business phone number of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "website", description = "The website of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "website", required = false) @Nullable String website,
        @Parameter(name = "email", description = "The email of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = false) @Nullable String email,
        @Parameter(name = "internalId", description = "An internal identifier used by the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "internalId", required = false) @Nullable String internalId,
        @Parameter(name = "detailsHeader", description = "A brief description about the retailer location (255 character limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsHeader", required = false) @Nullable String detailsHeader,
        @Parameter(name = "detailsBody", description = "A detailed description about the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsBody", required = false) @Nullable String detailsBody,
        @Parameter(name = "hours", description = "The hours of operation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hours", required = false) @Nullable String hours,
        @Parameter(name = "logo", description = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logo", required = false) @Nullable org.springframework.core.io.Resource logo,
        @Parameter(name = "logoAssetId", description = "The retailer location logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logoAssetId", required = false) @Nullable Long logoAssetId,
        @Parameter(name = "picture1", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1", required = false) @Nullable org.springframework.core.io.Resource picture1,
        @Parameter(name = "picture1AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1AssetId", required = false) @Nullable Long picture1AssetId,
        @Parameter(name = "picture2", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2", required = false) @Nullable org.springframework.core.io.Resource picture2,
        @Parameter(name = "picture2AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2AssetId", required = false) @Nullable Long picture2AssetId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category IDs used to filter retailer locations by categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter IDs used to filter retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "latitude", description = "the latitude of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "building", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "building", required = false) @Nullable String building,
        @Parameter(name = "googlePlaceId", description = "the ID of the Google Place that this retailer location is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googlePlaceId", required = false) @Nullable String googlePlaceId,
        @Parameter(name = "yelpId", description = "the Yelp ID that this retailer location is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "yelpId", required = false) @Nullable String yelpId,
        @Parameter(name = "active", description = "whether the retailer location should be active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "publicLocation", description = "Sets whether the location is public or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicLocation", required = false) @Nullable Boolean publicLocation,
        @Parameter(name = "locationType", description = "External custom type identifier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "audienceIds", description = "Comma separated list of audience IDs used to assign audiences to the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "audienceIdsToAdd", description = "Comma separated list of audience IDs to add to the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "Comma separated list of audience IDs to remove from the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove,
        @Parameter(name = "responseFormat", description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat,
        @Parameter(name = "responseIncludes", description = "Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseIncludes", required = false) @Nullable String responseIncludes
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ROUTE = "/api/{version}/route";
    /**
     * POST /api/{version}/route : Create Route
     * Create new route
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRoute",
        summary = "Create Route",
        description = "Create new route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> createRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Route body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ROUTE_DIRECTIONS = "/api/{version}/route/{routeId}/directions";
    /**
     * PUT /api/{version}/route/{routeId}/directions : Update Route Directions
     * Regenerate the directions of a route
     *
     * @param version  (required)
     * @param routeId the id of the route to update directions for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRouteDirections",
        summary = "Update Route Directions",
        description = "Regenerate the directions of a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Direction.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_CREATE_ROUTE_DIRECTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Direction>> createRouteDirections(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to update directions for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ROUTE_POLYLINE = "/api/{version}/route/{routeId}/polyline";
    /**
     * PUT /api/{version}/route/{routeId}/polyline : Create Route Polyline
     * Update the polyline of the requested route
     *
     * @param version  (required)
     * @param routeId the id of the route to create a polyline for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRoutePolyline",
        summary = "Create Route Polyline",
        description = "Update the polyline of the requested route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_CREATE_ROUTE_POLYLINE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> createRoutePolyline(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to create a polyline for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_ROUTE_SETTINGS = "/api/{version}/route/setting";
    /**
     * POST /api/{version}/route/setting : Create Route Setting
     * Create a new route setting
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createRouteSettings",
        summary = "Create Route Setting",
        description = "Create a new route setting",
        tags = { "Route Setting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RouteSettings.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_ROUTE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<RouteSettings> createRouteSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable RouteSettings body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SCHEDULED_NOTIFICATION = "/api/{version}/notification/schedule/create";
    /**
     * POST /api/{version}/notification/schedule/create : Create Scheduled Notification
     * This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createScheduledNotification",
        summary = "Create Scheduled Notification",
        description = "This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> createScheduledNotification(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the scheduled notification", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "type", description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = true) String type,
        @NotNull @Parameter(name = "message", description = "The message to send", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = true) String message,
        @Parameter(name = "contentId", description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "appKey", description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "connectionGroupIds", description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "connectionAccountIds", description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. The audience used to generate the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "albumIds", description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "reportId", description = "The report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportId", required = false) @Nullable Long reportId,
        @Parameter(name = "reportParams", description = "The parameters to supply to the report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "cronType", description = "The cron expression type: UNIX, CRON4J, QUARTZ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronType", required = false) @Nullable String cronType,
        @Parameter(name = "metaData", description = "Additional metadata for the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "templateType", description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateType", required = false) @Nullable String templateType,
        @Parameter(name = "visibility", description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "sendNow", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendNow", required = false) @Nullable Boolean sendNow,
        @Parameter(name = "eventType", description = "Sets the event type for the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") String eventType,
        @Parameter(name = "deepLinkURI", description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deepLinkURI", required = false) @Nullable String deepLinkURI,
        @Parameter(name = "sendToAll", description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendToAll", required = false) @Nullable Boolean sendToAll
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SCORE = "/api/{version}/score/create";
    /**
     * POST /api/{version}/score/create : Create Score
     * Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The game application key to save the score for. (required)
     * @param points The score (required)
     * @param missionId The missionId to score for, ignore if not playing mission. (optional)
     * @param gameId The gameId to score for, ignore if not playing mission. (optional)
     * @param packId The packId to score for, send -2 if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring. (optional)
     * @param timeTaken The time taken to complete task (optional)
     * @param highest  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createScore",
        summary = "Create Score",
        description = "Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.",
        tags = { "Score" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SCORE,
        produces = { "*/*" }
    )
    default ResponseEntity<ScoreResponse> createScore(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The game application key to save the score for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "points", description = "The score", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = true) Integer points,
        @Parameter(name = "missionId", description = "The missionId to score for, ignore if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "gameId", description = "The gameId to score for, ignore if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "packId", description = "The packId to score for, send -2 if playing community levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "The gameLevelId to score for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "gameObjectId", description = "The gameObjectId to score for, ignore if level based scoring.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = false) @Nullable Long gameObjectId,
        @Parameter(name = "timeTaken", description = "The time taken to complete task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "timeTaken", required = false) @Nullable Integer timeTaken,
        @Parameter(name = "highest", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "highest", required = false) @Nullable Boolean highest
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SECURE_APPLICATION = "/api/{version}/secure/application/create";
    /**
     * POST /api/{version}/secure/application/create : Create Secure Application
     * Create a secure application record.
     *
     * @param version  (required)
     * @param accountId The unique id of the user making the request (required)
     * @param appKey The application to secure (required)
     * @param keyCert  (required)
     * @param trustStore  (required)
     * @param username  (required)
     * @param password  (required)
     * @param active  (optional, default to true)
     * @param biometricType The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL (optional, default to FACIAL)
     * @param biometricPosition The position for the biometric file uploaded (optional, default to UNKNOWN)
     * @param biometricPosition2 The position for each the biometric2 file uploaded (optional, default to UNKNOWN)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createSecureApplication",
        summary = "Create Secure Application",
        description = "Create a secure application record.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SECURE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> createSecureApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The unique id of the user making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to secure", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "keyCert", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyCert", required = true) org.springframework.core.io.Resource keyCert,
        @NotNull @Parameter(name = "trustStore", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "trustStore", required = true) org.springframework.core.io.Resource trustStore,
        @NotNull @Parameter(name = "username", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "active", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") Boolean active,
        @Parameter(name = "biometricType", description = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricType", required = false, defaultValue = "FACIAL") String biometricType,
        @Parameter(name = "biometricPosition", description = "The position for the biometric file uploaded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricPosition", required = false, defaultValue = "UNKNOWN") String biometricPosition,
        @Parameter(name = "biometricPosition2", description = "The position for each the biometric2 file uploaded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricPosition2", required = false, defaultValue = "UNKNOWN") String biometricPosition2
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SERVICE_HUB = "/api/{version}/hub";
    /**
     * POST /api/{version}/hub : Create Service Hub
     * Create new service hub
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createServiceHub",
        summary = "Create Service Hub",
        description = "Create new service hub",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ServiceHub.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SERVICE_HUB,
        produces = { "*/*" }
    )
    default ResponseEntity<ServiceHub> createServiceHub(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable ServiceHub body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SHIPMENT = "/api/{version}/shipment";
    /**
     * POST /api/{version}/shipment : Create Shipment
     * Create new shipment
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createShipment",
        summary = "Create Shipment",
        description = "Create new shipment",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Shipment.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SHIPMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<Shipment> createShipment(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Shipment body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SHIPMENT_BATCH = "/api/{version}/shipment/batch";
    /**
     * POST /api/{version}/shipment/batch : Create Shipment Batch
     * Create a new shipment batch
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createShipmentBatch",
        summary = "Create Shipment Batch",
        description = "Create a new shipment batch",
        tags = { "Shipment Batch" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ShipmentBatch.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SHIPMENT_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<ShipmentBatch> createShipmentBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable ShipmentBatch body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SMART_CONTRACT = "/api/{version}/billing/crypto/transfer";
    /**
     * POST /api/{version}/billing/crypto/transfer : Create Smart Contract
     * Adds a smart contract.
     *
     * @param version  (required)
     * @param accountId The account used to perform the the request (required)
     * @param tokenName The token name (required)
     * @param tokenSymbol The token symbol (required)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createSmartContract",
        summary = "Create Smart Contract",
        description = "Adds a smart contract.",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SMART_CONTRACT,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> createSmartContract(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "tokenName", description = "The token name", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "tokenName", required = true) String tokenName,
        @NotNull @Parameter(name = "tokenSymbol", description = "The token symbol", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "tokenSymbol", required = true) String tokenSymbol,
        @Parameter(name = "paymentMethodId", description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SPACE = "/api/{version}/vatom/b/spaces/create";
    /**
     * POST /api/{version}/vatom/b/spaces/create : Create Vatom Space
     * Create a Vatom space.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createSpace",
        summary = "Create Vatom Space",
        description = "Create a Vatom space.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SPACE
    )
    default ResponseEntity<Void> createSpace(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_STRIPE_CHECKOUT_SESSION = "/api/{version}/stripe/checkout/session/create";
    /**
     * POST /api/{version}/stripe/checkout/session/create : Create Stripe Checkout Session
     * Create a Stripe checkout session
     *
     * @param version  (required)
     * @param appKey Sirqul Application Key (required)
     * @param stripeParameters Stripe Parameters (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createStripeCheckoutSession",
        summary = "Create Stripe Checkout Session",
        description = "Create a Stripe checkout session",
        tags = { "Stripe" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_STRIPE_CHECKOUT_SESSION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> createStripeCheckoutSession(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "stripeParameters", description = "Stripe Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "stripeParameters", required = true) String stripeParameters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SUBSCRIPTION = "/api/{version}/subscription/create";
    /**
     * POST /api/{version}/subscription/create : Create Subscription
     * Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.
     *
     * @param version  (required)
     * @param accountId The account used to perform the create, must be the responsible manager (required)
     * @param planId The plan to subscribe to, if null use default plan (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createSubscription",
        summary = "Create Subscription",
        description = "Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SubscriptionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_SUBSCRIPTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SubscriptionResponse> createSubscription(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the create, must be the responsible manager", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "planId", description = "The plan to subscribe to, if null use default plan", in = ParameterIn.QUERY) @Valid @RequestParam(value = "planId", required = false) @Nullable Long planId,
        @Parameter(name = "promoCode", description = "Set a promo code for a discount.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_TASK = "/api/{version}/task/create";
    /**
     * POST /api/{version}/task/create : Create Task
     * Create a Task
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the task (required)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createTask",
        summary = "Create Task",
        description = "Create a Task",
        tags = { "Task" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TaskResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_TASK,
        produces = { "*/*" }
    )
    default ResponseEntity<TaskResponse> createTask(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the task", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "appKey", description = "The application to target", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping tasks", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The date and time of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The starting date of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The ending date of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the task's schedule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "visibility", description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Task is active or not (inactive Tasks are not processed)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_TERRITORY = "/api/{version}/territory/create";
    /**
     * POST /api/{version}/territory/create : Create Territory
     * Creates a territory.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the territory (required)
     * @param active If true set the game level as active. Default is true. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createTerritory",
        summary = "Create Territory",
        description = "Creates a territory.",
        tags = { "Territory" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TerritoryResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_TERRITORY,
        produces = { "*/*" }
    )
    default ResponseEntity<TerritoryResponse> createTerritory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the territory", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "active", description = "If true set the game level as active. Default is true.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_TOURNAMENT = "/api/{version}/tournament/create";
    /**
     * POST /api/{version}/tournament/create : Create Tournament
     * Create a tournament.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The appKey the tournament is created for. (required)
     * @param title The title of the tournament (required)
     * @param costToPlay The number of tickets required to pay to enter the tournament (required)
     * @param startDate The date/time to start the tournament (required)
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to 1)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createTournament",
        summary = "Create Tournament",
        description = "Create a tournament.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TournamentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_TOURNAMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<TournamentResponse> createTournament(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The appKey the tournament is created for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "title", description = "The title of the tournament", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "costToPlay", description = "The number of tickets required to pay to enter the tournament", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "costToPlay", required = true) Integer costToPlay,
        @NotNull @Parameter(name = "startDate", description = "The date/time to start the tournament", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = true) Long startDate,
        @Parameter(name = "subType", description = "Custom string client apps can use for searching/filtering tournaments", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "imageAssetId", description = "The asset ID to attach to the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "secondsBetweenLevels", description = "The number of seconds in between the start of each tournament game/group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsBetweenLevels", required = false, defaultValue = "600") Integer secondsBetweenLevels,
        @Parameter(name = "secondsForTieBreaker", description = "The number of seconds to extend the round end time in the case of a tie breaker", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsForTieBreaker", required = false, defaultValue = "600") Integer secondsForTieBreaker,
        @Parameter(name = "secondsBetweenPacks", description = "The number of seconds in between the start of each tournament round", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsBetweenPacks", required = false, defaultValue = "86400") Integer secondsBetweenPacks,
        @Parameter(name = "maximumLevelLength", description = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maximumLevelLength", required = false, defaultValue = "1800") Integer maximumLevelLength,
        @Parameter(name = "costToPlayType", description = "The type of ticket required to pay", in = ParameterIn.QUERY) @Valid @RequestParam(value = "costToPlayType", required = false) @Nullable String costToPlayType,
        @Parameter(name = "minimumToPlay", description = "The minimum number of players required to sign up for the tournament to be played", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumToPlay", required = false, defaultValue = "1") Integer minimumToPlay,
        @Parameter(name = "startingLimit", description = "The starting number of players for a tournament (filled with AI's)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startingLimit", required = false) @Nullable Integer startingLimit,
        @Parameter(name = "availableLimit", description = "The maximum number of players for a tournament (currently 128 but not enforced)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = false) @Nullable Integer availableLimit,
        @Parameter(name = "description", description = "The description of the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "audienceIds", description = "The audiences associated with the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "active", description = "Activate/deactivate the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "enableBuyBack", description = "Determines whether to allow players to buy back into a tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableBuyBack", required = false, defaultValue = "false") Boolean enableBuyBack,
        @Parameter(name = "offerIds", description = "The list of offers to give as a reward beyond the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerIds", required = false) @Nullable String offerIds,
        @Parameter(name = "offerAssetId", description = "The artwork ID to attach to the reward tickets offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerAssetId", required = false) @Nullable Long offerAssetId,
        @Parameter(name = "fixedReward", description = "If set then do not update the ticket reward, auto set to true if offerIds provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fixedReward", required = false, defaultValue = "false") Boolean fixedReward,
        @Parameter(name = "splitReward", description = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", in = ParameterIn.QUERY) @Valid @RequestParam(value = "splitReward", required = false, defaultValue = "ALL") String splitReward,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "tournamentData", description = "A text based string that will be passed into each tournament setup to populate the content", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tournamentData", required = false) @Nullable String tournamentData,
        @Parameter(name = "missionType", description = "The style of tournament to build, options are: TOURNAMENT, POOLPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionType", required = false, defaultValue = "MULTISTAGE") String missionType,
        @Parameter(name = "visibility", description = "Sets the visibility flag for the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false, defaultValue = "PUBLIC") String visibility,
        @Parameter(name = "preliminaryGroups", description = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preliminaryGroups", required = false, defaultValue = "1") Integer preliminaryGroups,
        @Parameter(name = "preliminaryGroupAdvancements", description = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preliminaryGroupAdvancements", required = false, defaultValue = "1") String preliminaryGroupAdvancements,
        @Parameter(name = "enableMultipleEntries", description = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMultipleEntries", required = false, defaultValue = "false") Boolean enableMultipleEntries,
        @Parameter(name = "enableMultipleVotes", description = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMultipleVotes", required = false, defaultValue = "false") Boolean enableMultipleVotes,
        @Parameter(name = "featured", description = "This determines whether the tournament is \"featured\" or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false, defaultValue = "false") Boolean featured,
        @Parameter(name = "winnerTag", description = "This sets what analytic tag is used when a winner is determined", in = ParameterIn.QUERY) @Valid @RequestParam(value = "winnerTag", required = false) @Nullable String winnerTag,
        @Parameter(name = "tieTag", description = "This sets what analytic tag is used when a tie has occurred", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tieTag", required = false) @Nullable String tieTag
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_TRIGGER = "/api/{version}/trigger/create";
    /**
     * POST /api/{version}/trigger/create : Create Trigger
     * Create a trigger
     *
     * @param version  (required)
     * @param accountId The logged in user (required)
     * @param name The name of the trigger (required)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createTrigger",
        summary = "Create Trigger",
        description = "Create a trigger",
        tags = { "Trigger" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TriggerResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_TRIGGER,
        produces = { "*/*" }
    )
    default ResponseEntity<TriggerResponse> createTrigger(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the trigger", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "appKey", description = "The application to target", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping triggers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The date and time of the next trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The starting date of the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The ending date of the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the trigger's schedule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "visibility", description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Trigger is active or not (inactive Triggers are not processed)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_TRIP = "/api/{version}/trip";
    /**
     * POST /api/{version}/trip : Create Trip
     * Create a new trip
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createTrip",
        summary = "Create Trip",
        description = "Create a new trip",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_TRIP,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> createTrip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_VATOM_EVENT = "/api/{version}/vatom/b/events/create";
    /**
     * POST /api/{version}/vatom/b/events/create : Create Vatom Event
     * Create a Vatom event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createVatomEvent",
        summary = "Create Vatom Event",
        description = "Create a Vatom event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_VATOM_EVENT
    )
    default ResponseEntity<Void> createVatomEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_VEHICLE = "/api/{version}/vehicle";
    /**
     * POST /api/{version}/vehicle : Create Vehicle
     * Create new vehicle
     *
     * @param version  (required)
     * @param vehicle A JSON representation of cargo type. &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Truck\&quot;,   \&quot;vehicleType\&quot;: { \&quot;id\&quot;: 1 },   \&quot;hub\&quot;: { \&quot;id\&quot;: 1 } } &#x60;&#x60;&#x60;  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createVehicle",
        summary = "Create Vehicle",
        description = "Create new vehicle",
        tags = { "Vehicle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Vehicle.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_VEHICLE,
        produces = { "*/*" }
    )
    default ResponseEntity<Vehicle> createVehicle(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "vehicle", description = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vehicle", required = true) String vehicle,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Vehicle body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_VEHICLE_TYPE = "/api/{version}/vehicle/type";
    /**
     * POST /api/{version}/vehicle/type : Create Vehicle Type
     * Create a new vehicle type
     *
     * @param version  (required)
     * @param vehicleType A JSON representation of cargo type. &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Truck\&quot;,   \&quot;width\&quot;: 100,   \&quot;height\&quot;: 200,   \&quot;depth\&quot;: 200,   \&quot;maxWeight\&quot;: 5000,   \&quot;hub\&quot;: { \&quot;id\&quot;: 1 } } &#x60;&#x60;&#x60;  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createVehicleType",
        summary = "Create Vehicle Type",
        description = "Create a new vehicle type",
        tags = { "Vehicle Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = VehicleType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_VEHICLE_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<VehicleType> createVehicleType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "vehicleType", description = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vehicleType", required = true) String vehicleType,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable VehicleType body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_VOICE_CANVAS = "/api/{version}/orson/ai/voiceCanvas";
    /**
     * POST /api/{version}/orson/ai/voiceCanvas : Create VoiceCanvas images
     * Create VoiceCanvas images for provided text, file upload, or file URL
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param text Provide a transcript or previously extracted topics for image generation (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param fetchFlag When true, fetches images instead of generating them (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createVoiceCanvas",
        summary = "Create VoiceCanvas images",
        description = "Create VoiceCanvas images for provided text, file upload, or file URL",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiVoiceCanvasResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_VOICE_CANVAS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiVoiceCanvasResponse> createVoiceCanvas(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "dimensions", description = "Enum: \"256x256\" \"512x512\" \"1024x1024\"", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "dimensions", required = true) String dimensions,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "text", description = "Provide a transcript or previously extracted topics for image generation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "text", required = false) @Nullable String text,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "parseFlag", description = "When false, uses the raw value from text instead of identifying topics to fetch/generate from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parseFlag", required = false) @Nullable Boolean parseFlag,
        @Parameter(name = "fetchFlag", description = "When true, fetches images instead of generating them", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchFlag", required = false) @Nullable Boolean fetchFlag,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_WORD = "/api/{version}/game/word/create";
    /**
     * POST /api/{version}/game/word/create : Create Word
     * Create a word by the given params.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param word The text of the word. (required)
     * @param definition The definition of the word. (required)
     * @param active If true set the word to active. Default to false. (required)
     * @param allocateTickets If true then scoring will give tickets. Default to false. (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param assetId The asset id of the word. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createWord",
        summary = "Create Word",
        description = "Create a word by the given params.",
        tags = { "Word" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WordzWordResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_CREATE_WORD,
        produces = { "*/*" }
    )
    default ResponseEntity<WordzWordResponse> createWord(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "word", description = "The text of the word.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "word", required = true) String word,
        @NotNull @Parameter(name = "definition", description = "The definition of the word.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "definition", required = true) String definition,
        @NotNull @Parameter(name = "active", description = "If true set the word to active. Default to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true, defaultValue = "false") Boolean active,
        @NotNull @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets. Default to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = true, defaultValue = "false") Boolean allocateTickets,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true, defaultValue = "0") Long ticketCount,
        @Parameter(name = "assetId", description = "The asset id of the word.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE = "/api/{version}/trip/{id}";
    /**
     * DELETE /api/{version}/trip/{id} : Delete Trip
     * Delete an existing trip
     *
     * @param version  (required)
     * @param id the id of the trip to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "delete",
        summary = "Delete Trip",
        description = "Delete an existing trip",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE
    )
    default ResponseEntity<Void> delete(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip to delete", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ACHIEVEMENT = "/api/{version}/achievement/delete";
    /**
     * POST /api/{version}/achievement/delete : Delete Achievement
     * Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
     *
     * @param version  (required)
     * @param achievementId The ID of the achievement (required)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteAchievement",
        summary = "Delete Achievement",
        description = "Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_ACHIEVEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteAchievement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "achievementId", description = "The ID of the achievement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementId", required = true) Long achievementId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ACHIEVEMENT_TIER = "/api/{version}/achievement/tier/delete";
    /**
     * POST /api/{version}/achievement/tier/delete : Delete Achievement Tier
     * Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
     *
     * @param version  (required)
     * @param achievementTierId the achievement id for deletion (required)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteAchievementTier",
        summary = "Delete Achievement Tier",
        description = "Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_ACHIEVEMENT_TIER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteAchievementTier(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "achievementTierId", description = "the achievement id for deletion", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementTierId", required = true) Long achievementTierId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_APPLICATION = "/api/{version}/application/delete";
    /**
     * POST /api/{version}/application/delete : Delete Application
     * Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp
     *
     * @param version  (required)
     * @param accountId The account used to perform the delete, must have rights to edit the application. (optional)
     * @param appKey The key of the application to be deleted (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteApplication",
        summary = "Delete Application",
        description = "Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The key of the application to be deleted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_APPLICATION_CONFIG = "/api/{version}/appconfig/delete";
    /**
     * POST /api/{version}/appconfig/delete : Delete AppConfig
     * Mark the application configuration for deletion.
     *
     * @param version  (required)
     * @param accountId The account ID of the user (required)
     * @param configId The config ID of the application configuration to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteApplicationConfig",
        summary = "Delete AppConfig",
        description = "Mark the application configuration for deletion.",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_APPLICATION_CONFIG,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteApplicationConfig(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "configId", description = "The config ID of the application configuration to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "configId", required = true) Long configId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_APPLICATION_PLACEMENT = "/api/{version}/application/placement/delete";
    /**
     * POST /api/{version}/application/placement/delete : Delete Ad Placement
     * Deletes an ad placement for an application.
     *
     * @param version  (required)
     * @param placementId The id of the placement to delete, the user must have rights to the application the ad placement is for (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteApplicationPlacement",
        summary = "Delete Ad Placement",
        description = "Deletes an ad placement for an application.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PlacementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_APPLICATION_PLACEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<PlacementResponse> deleteApplicationPlacement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "placementId", description = "The id of the placement to delete, the user must have rights to the application the ad placement is for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementId", required = true) Long placementId,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ASSET = "/api/{version}/asset/delete";
    /**
     * POST /api/{version}/asset/delete : Delete Asset
     * Delete an asset.
     *
     * @param version  (required)
     * @param assetId the id of the asset to delete (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteAsset",
        summary = "Delete Asset",
        description = "Delete an asset.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_ASSET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteAsset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "assetId", description = "the id of the asset to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = true) String assetId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_AUDIENCE = "/api/{version}/audience/delete";
    /**
     * POST /api/{version}/audience/delete : Delete Audience
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to delete. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteAudience",
        summary = "Delete Audience",
        description = "Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteAudience(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_BATCH = "/api/{version}/report/batch/delete";
    /**
     * POST /api/{version}/report/batch/delete : Delete Offline Report
     * Deletes a batch report.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param batchId the id of the batch to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteBatch",
        summary = "Delete Offline Report",
        description = "Deletes a batch report.",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "batchId", description = "the id of the batch to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "batchId", required = true) Long batchId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_BID = "/api/{version}/bid/delete";
    /**
     * POST /api/{version}/bid/delete : Delete Bid
     * Deleted a bid on a biddable object
     *
     * @param version  (required)
     * @param bidId The bid id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteBid",
        summary = "Delete Bid",
        description = "Deleted a bid on a biddable object",
        tags = { "Bid" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_BID,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteBid(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "bidId", description = "The bid id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "bidId", required = true) Long bidId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_BILLABLE_ENTITY = "/api/{version}/billable/delete";
    /**
     * POST /api/{version}/billable/delete : Delete Billable
     * Mark the billable as deleted
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the billable entity. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteBillableEntity",
        summary = "Delete Billable",
        description = "Mark the billable as deleted",
        tags = { "Billable Entity" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the billable entity.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_CARGO_TYPE = "/api/{version}/cargo/type/{cargoTypeId}";
    /**
     * DELETE /api/{version}/cargo/type/{cargoTypeId} : Delete Cargo Type
     * Delete a type of cargo
     *
     * @param version  (required)
     * @param cargoTypeId the ID of the cargo type (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteCargoType",
        summary = "Delete Cargo Type",
        description = "Delete a type of cargo",
        tags = { "Cargo Type" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_CARGO_TYPE
    )
    default ResponseEntity<Void> deleteCargoType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "cargoTypeId", description = "the ID of the cargo type", required = true, in = ParameterIn.PATH) @PathVariable("cargoTypeId") Long cargoTypeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_CATEGORY = "/api/{version}/category/delete";
    /**
     * POST /api/{version}/category/delete : Delete Category
     * Delete a category.
     *
     * @param version  (required)
     * @param accountId the ID of the account (required)
     * @param categoryId the ID of the category (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteCategory",
        summary = "Delete Category",
        description = "Delete a category.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_CATEGORY,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteCategory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the ID of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "categoryId", description = "the ID of the category", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = true) Long categoryId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_CONTEST = "/api/{version}/consumer/album/contest/remove";
    /**
     * POST /api/{version}/consumer/album/contest/remove : Delete Contest
     * Deletes a contest.
     *
     * @param version  (required)
     * @param albumContestId the album contest ID (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteContest",
        summary = "Delete Contest",
        description = "Deletes a contest.",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_CONTEST,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteContest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumContestId", description = "the album contest ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = true) Long albumContestId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_CREATIVE = "/api/{version}/creative/delete";
    /**
     * POST /api/{version}/creative/delete : Delete Creative
     * Delete a creative
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param creativeId the id of the creative to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteCreative",
        summary = "Delete Creative",
        description = "Delete a creative",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_CREATIVE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteCreative(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "creativeId", description = "the id of the creative to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = true) Long creativeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_CREDENTIAL = "/api/{version}/thirdparty/credential/delete";
    /**
     * POST /api/{version}/thirdparty/credential/delete : Delete Credential
     * Delete a third party network on a Sirqul account.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param networkUID The third party network identifier (required)
     * @param thirdPartyId The third party user id (required)
     * @param appKey the application key (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteCredential",
        summary = "Delete Credential",
        description = "Delete a third party network on a Sirqul account.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_CREDENTIAL,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteCredential(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "networkUID", description = "The third party network identifier", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @NotNull @Parameter(name = "thirdPartyId", description = "The third party user id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyId", required = true) String thirdPartyId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_DATA = "/api/{version}/object/data/{objectName}/{objectId}";
    /**
     * DELETE /api/{version}/object/data/{objectName}/{objectId} : Delete Data
     * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
     *
     * @param version  (required)
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteData",
        summary = "Delete Data",
        description = "Delete a record for the specified object. Cannot be undone so use only when abolutely sure.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_EMPLOYEE = "/api/{version}/employee/delete";
    /**
     * POST /api/{version}/employee/delete : Delete Employee
     * Set the deleted date field which marks the record as deleted.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param employeeAccountId the id of the employee to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteEmployee",
        summary = "Delete Employee",
        description = "Set the deleted date field which marks the record as deleted.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "employeeAccountId", description = "the id of the employee to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = true) Long employeeAccountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_EVENT = "/api/{version}/event/delete";
    /**
     * POST /api/{version}/event/delete : Delete Event
     * Delete an event that the user has permissions to.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param eventId the id of the event to update (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteEvent",
        summary = "Delete Event",
        description = "Delete an event that the user has permissions to.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_EVENT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "eventId", description = "the id of the event to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventId", required = true) Long eventId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FAVORITE = "/api/{version}/favorite/delete";
    /**
     * POST /api/{version}/favorite/delete : Delete Favorite
     * Removes a favorited item from the user&#39;s favorites list.
     *
     * @param version  (required)
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param favoriteId The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead) (optional)
     * @param favoritableId The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in) (optional)
     * @param favoritableType The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteFavorite",
        summary = "Delete Favorite",
        description = "Removes a favorited item from the user's favorites list.",
        tags = { "Favorite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_FAVORITE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteFavorite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "favoriteId", description = "The ID of the favorite reference record (only optional if favoritableId & favoritableType is pass in instead)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoriteId", required = false) @Nullable Long favoriteId,
        @Parameter(name = "favoritableId", description = "The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableId", required = false) @Nullable Long favoritableId,
        @Parameter(name = "favoritableType", description = "The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableType", required = false) @Nullable String favoritableType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FIELD = "/api/{version}/object/field/delete";
    /**
     * POST /api/{version}/object/field/delete : Delete Field
     * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to remove the field from (required)
     * @param fieldName field name The name of the field to remove. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteField",
        summary = "Delete Field",
        description = "Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_FIELD,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteField(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to remove the field from", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName,
        @NotNull @Parameter(name = "fieldName", description = "field name The name of the field to remove.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldName", required = true) String fieldName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FILTER = "/api/{version}/filter/delete";
    /**
     * POST /api/{version}/filter/delete : Delete Filter
     * Delete a filter.
     *
     * @param version  (required)
     * @param accountId The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param filterId The ID of the filter to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteFilter",
        summary = "Delete Filter",
        description = "Delete a filter.",
        tags = { "Filter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_FILTER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteFilter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user (must have permissions to the filter's assigned application)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "filterId", description = "The ID of the filter to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterId", required = true) Long filterId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FLAG = "/api/{version}/flag/delete";
    /**
     * POST /api/{version}/flag/delete : Delete Flag
     * Deletes a flag.
     *
     * @param version  (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param itemBeingFlaggedType This parameter is deprecated. (optional)
     * @param itemBeingFlaggedId This parameter is deprecated. (optional)
     * @param flagableType The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE} (optional)
     * @param flagableId The flagable object id (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteFlag",
        summary = "Delete Flag",
        description = "Deletes a flag.",
        tags = { "Flag" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_FLAG,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteFlag(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "itemBeingFlaggedType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "itemBeingFlaggedType", required = false) @Nullable String itemBeingFlaggedType,
        @Parameter(name = "itemBeingFlaggedId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "itemBeingFlaggedId", required = false) @Nullable Long itemBeingFlaggedId,
        @Parameter(name = "flagableType", description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableType", required = false) @Nullable String flagableType,
        @Parameter(name = "flagableId", description = "The flagable object id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableId", required = false) @Nullable Long flagableId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FOLLOWING = "/api/{version}/vatom/me/rels/following/delete";
    /**
     * POST /api/{version}/vatom/me/rels/following/delete : Delete following
     * Delete following.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomRelsKey Vatom Rels Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteFollowing",
        summary = "Delete following",
        description = "Delete following.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_FOLLOWING
    )
    default ResponseEntity<Void> deleteFollowing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomRelsKey", description = "Vatom Rels Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomRelsKey", required = true) String vatomRelsKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_GAME = "/api/{version}/game/delete";
    /**
     * POST /api/{version}/game/delete : Delete a Game
     * Delete a game.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param gameId the updating game&#39;s id. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteGame",
        summary = "Delete a Game",
        description = "Delete a game.",
        tags = { "Game" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_GAME,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteGame(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "gameId", description = "the updating game's id.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = true) Long gameId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_GAME_LEVEL = "/api/{version}/level/delete";
    /**
     * POST /api/{version}/level/delete : Delete Game Level
     * Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param levelId The id of the level to return. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteGameLevel",
        summary = "Delete Game Level",
        description = "Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_GAME_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteGameLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "levelId", description = "The id of the level to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_LEADERBOARD = "/api/{version}/leaderboard/delete";
    /**
     * POST /api/{version}/leaderboard/delete : Delete the Leader Board
     * Removes a leader board id.
     *
     * @param version  (required)
     * @param leaderboardId The leaderboard id to delete. (required)
     * @param accountId The account id of the user making the request. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteLeaderboard",
        summary = "Delete the Leader Board",
        description = "Removes a leader board id.",
        tags = { "Leaderboard" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_LEADERBOARD,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteLeaderboard(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "leaderboardId", description = "The leaderboard id to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardId", required = true) Long leaderboardId,
        @Parameter(name = "accountId", description = "The account id of the user making the request.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_LISTING = "/api/{version}/listing/delete";
    /**
     * POST /api/{version}/listing/delete : Delete Listing
     * Delete a listing.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param listingId the id of the listing to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteListing",
        summary = "Delete Listing",
        description = "Delete a listing.",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "listingId", description = "the id of the listing to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = true) Long listingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_MEDIA = "/api/{version}/media/delete";
    /**
     * POST /api/{version}/media/delete : Delete Media
     * Delete a media offering that the user has permissions to.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param mediaId the ID of the media to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteMedia",
        summary = "Delete Media",
        description = "Delete a media offering that the user has permissions to.",
        tags = { "Media" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_MEDIA,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteMedia(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "mediaId", description = "the ID of the media to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaId", required = true) Long mediaId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_MISSION = "/api/{version}/mission/delete";
    /**
     * POST /api/{version}/mission/delete : Delete Mission
     * Delete a mission.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteMission",
        summary = "Delete Mission",
        description = "Delete a mission.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_MISSION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteMission(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "the id of the mission to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_MISSION_INVITE = "/api/{version}/mission/invite/delete";
    /**
     * POST /api/{version}/mission/invite/delete : Delete Mission Invite
     * Update the mission invite status to quit.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param missionId The mission to find the invite for (missionId or missionInviteId requried). (optional)
     * @param missionInviteId The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteMissionInvite",
        summary = "Delete Mission Invite",
        description = "Update the mission invite status to quit.",
        tags = { "Mission Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_MISSION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteMissionInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "missionId", description = "The mission to find the invite for (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "missionInviteId", description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionInviteId", required = false) @Nullable Long missionInviteId,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_NETWORK = "/api/{version}/thirdparty/network/delete";
    /**
     * POST /api/{version}/thirdparty/network/delete : Delete Network
     * Marks a custom third party network as deleted. Only the network owners and managers have access to this.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param networkUID The unique identifier for the third party network defined by Sirqul (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteNetwork",
        summary = "Delete Network",
        description = "Marks a custom third party network as deleted. Only the network owners and managers have access to this.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_NETWORK,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteNetwork(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "networkUID", description = "The unique identifier for the third party network defined by Sirqul", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_NOTE = "/api/{version}/note/delete";
    /**
     * POST /api/{version}/note/delete : Delete Note
     * Sets a comment (note) as deleted.
     *
     * @param version  (required)
     * @param noteId The ID of the note to delete (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param appKey The application key used to identify the application (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteNote",
        summary = "Delete Note",
        description = "Sets a comment (note) as deleted.",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_NOTE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteNote(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "noteId", description = "The ID of the note to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteId", required = true) Long noteId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_NOTIFICATION_TEMPLATE = "/api/{version}/notification/template/delete";
    /**
     * POST /api/{version}/notification/template/delete : Delete Notification Template
     * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param notificationTemplateId the id of the notification template to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteNotificationTemplate",
        summary = "Delete Notification Template",
        description = "Deletes a notification template. Developers will only be able to delete notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> deleteNotificationTemplate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "the id of the notification template to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OBJECT = "/api/{version}/object/delete";
    /**
     * POST /api/{version}/object/delete : Delete Object
     * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param appKey the application key (required)
     * @param objectName the name of the object to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteObject",
        summary = "Delete Object",
        description = "Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteObject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "the name of the object to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OFFER = "/api/{version}/retailer/offer/delete";
    /**
     * POST /api/{version}/retailer/offer/delete : Delete Offer
     * Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.
     *
     * @param version  (required)
     * @param offerId The ID of the offer to be deleted (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the offer. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteOffer",
        summary = "Delete Offer",
        description = "Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_OFFER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteOffer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerId", description = "The ID of the offer to be deleted", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = true) Long offerId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OFFER_LOCATION = "/api/{version}/retailer/offer/location/delete";
    /**
     * POST /api/{version}/retailer/offer/location/delete : Delete Offer Location
     * Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.
     *
     * @param version  (required)
     * @param offerLocationId The ID of the offer location to be deleted (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the offer location. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteOfferLocation",
        summary = "Delete Offer Location",
        description = "Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_OFFER_LOCATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteOfferLocation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerLocationId", description = "The ID of the offer location to be deleted", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = true) Long offerLocationId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the offer location.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OFFER_TRANSACTION = "/api/{version}/wallet/delete";
    /**
     * POST /api/{version}/wallet/delete : Delete Wallet Offer
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     *
     * @param version  (required)
     * @param transactionId The offer transaction id to remove (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteOfferTransaction",
        summary = "Delete Wallet Offer",
        description = "Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "transactionId", description = "The offer transaction id to remove", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionId", required = true) Long transactionId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OFFER_TRANSACTION_STATUS = "/api/{version}/offer/status/delete";
    /**
     * POST /api/{version}/offer/status/delete : Delete Offer Status
     * Mark an offer status record as deleted
     *
     * @param version  (required)
     * @param statusId The id of the record to delete (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteOfferTransactionStatus",
        summary = "Delete Offer Status",
        description = "Mark an offer status record as deleted",
        tags = { "Offer Status" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_OFFER_TRANSACTION_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteOfferTransactionStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "statusId", description = "The id of the record to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "statusId", required = true) Long statusId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ORDER = "/api/{version}/order/delete";
    /**
     * POST /api/{version}/order/delete : Delete Order
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     *
     * @param version  (required)
     * @param orderId Order Id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteOrder",
        summary = "Delete Order",
        description = "Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_ORDER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteOrder(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "orderId", description = "Order Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderId", required = true) Long orderId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_PACK = "/api/{version}/pack/delete";
    /**
     * POST /api/{version}/pack/delete : Delete Pack
     * Delete a pack.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param packId the id of the pack to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deletePack",
        summary = "Delete Pack",
        description = "Delete a pack.",
        tags = { "Pack" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_PACK,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deletePack(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "packId", description = "the id of the pack to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = true) Long packId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_PERSONA = "/api/{version}/persona/delete";
    /**
     * POST /api/{version}/persona/delete : Delete Persona
     * Mark the persona for deletion.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param personaId the id of the persona to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deletePersona",
        summary = "Delete Persona",
        description = "Mark the persona for deletion.",
        tags = { "Preview Persona" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_PERSONA,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deletePersona(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "personaId", description = "the id of the persona to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "personaId", required = true) Long personaId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_POINTS_BALANCE = "/api/{version}/vatom/b/campaign/points/delete";
    /**
     * POST /api/{version}/vatom/b/campaign/points/delete : Reset All Points Balance
     * Reset All Points Balance.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deletePointsBalance",
        summary = "Reset All Points Balance",
        description = "Reset All Points Balance.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_POINTS_BALANCE
    )
    default ResponseEntity<Void> deletePointsBalance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_POSTAL_CODE = "/api/{version}/postalCode/delete";
    /**
     * POST /api/{version}/postalCode/delete : Delete Postal Code
     * Delete a Postal Code
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param postalCodeId the id of the postal code to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deletePostalCode",
        summary = "Delete Postal Code",
        description = "Delete a Postal Code",
        tags = { "Postal Code" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_POSTAL_CODE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deletePostalCode(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "postalCodeId", description = "the id of the postal code to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCodeId", required = true) Long postalCodeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_PROGRAM = "/api/{version}/program/{id}";
    /**
     * DELETE /api/{version}/program/{id} : Delete Program
     * Delete an existing program
     *
     * @param version  (required)
     * @param id the id of the program (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteProgram",
        summary = "Delete Program",
        description = "Delete an existing program",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_PROGRAM
    )
    default ResponseEntity<Void> deleteProgram(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the program", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_PURCHASE_ITEM = "/api/{version}/purchase/delete";
    /**
     * POST /api/{version}/purchase/delete : Delete Purchase
     * Marks the purchase item as deleted
     *
     * @param version  (required)
     * @param purchaseItemId The purchase item id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deletePurchaseItem",
        summary = "Delete Purchase",
        description = "Marks the purchase item as deleted",
        tags = { "Purchase Item" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_PURCHASE_ITEM,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deletePurchaseItem(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "purchaseItemId", description = "The purchase item id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseItemId", required = true) Long purchaseItemId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_QUESTION = "/api/{version}/game/question/delete";
    /**
     * POST /api/{version}/game/question/delete : Delete Question
     * Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.
     *
     * @param version  (required)
     * @param questionId the id of the question to delete (required)
     * @param accountId the id of the account that can execute this request (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteQuestion",
        summary = "Delete Question",
        description = "Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.",
        tags = { "Question" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_QUESTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteQuestion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "questionId", description = "the id of the question to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "questionId", required = true) Long questionId,
        @NotNull @Parameter(name = "accountId", description = "the id of the account that can execute this request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_RATING = "/api/{version}/rating/delete";
    /**
     * POST /api/{version}/rating/delete : Delete Rating
     * Sets a rating as deleted.
     *
     * @param version  (required)
     * @param ratingId The ID of the rating to delete (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRating",
        summary = "Delete Rating",
        description = "Sets a rating as deleted.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_RATING,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteRating(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "ratingId", description = "The ID of the rating to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratingId", required = true) Long ratingId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_REGION = "/api/{version}/region/delete";
    /**
     * POST /api/{version}/region/delete : Delete Region
     * Delete a region.
     *
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param regionId the id of the region (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRegion",
        summary = "Delete Region",
        description = "Delete a region.",
        tags = { "Region" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RegionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_REGION,
        produces = { "*/*" }
    )
    default ResponseEntity<RegionResponse> deleteRegion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account logged in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "regionId", description = "the id of the region", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionId", required = true) Long regionId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_RESERVATION = "/api/{version}/reservation/delete";
    /**
     * POST /api/{version}/reservation/delete : Delete Reservation
     * Deleted a reservation on a reservation object
     *
     * @param version  (required)
     * @param reservationId The reservation id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteReservation",
        summary = "Delete Reservation",
        description = "Deleted a reservation on a reservation object",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_RESERVATION
    )
    default ResponseEntity<Void> deleteReservation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "reservationId", description = "The reservation id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservationId", required = true) Long reservationId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_RETAILER = "/api/{version}/retailer/delete";
    /**
     * POST /api/{version}/retailer/delete : Delete Retailer
     * Set the deleted timestamp to current time.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the retailer. (optional)
     * @param retailerId The ID of the retailer to be deleted (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRetailer",
        summary = "Delete Retailer",
        description = "Set the deleted timestamp to current time.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_RETAILER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteRetailer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the retailer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "retailerId", description = "The ID of the retailer to be deleted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_RETAILER_LOCATION = "/api/{version}/retailer/location/delete";
    /**
     * POST /api/{version}/retailer/location/delete : Delete Retailer Location
     * Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.
     *
     * @param version  (required)
     * @param deviceId the device id (optional)
     * @param accountId the id of the logged in user (optional)
     * @param retailerLocationId the id of the retailer location to delete (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRetailerLocation",
        summary = "Delete Retailer Location",
        description = "Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_RETAILER_LOCATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteRetailerLocation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "retailerLocationId", description = "the id of the retailer location to delete", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ROUTE = "/api/{version}/route/{routeId}";
    /**
     * DELETE /api/{version}/route/{routeId} : Delete Route
     * Delete an existing route
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRoute",
        summary = "Delete Route",
        description = "Delete an existing route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_ROUTE
    )
    default ResponseEntity<Void> deleteRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_ROUTE_SETTINGS = "/api/{version}/route/setting/{routeSettingsId}";
    /**
     * DELETE /api/{version}/route/setting/{routeSettingsId} : Delete Route Setting
     * Delete an existing route setting
     *
     * @param version  (required)
     * @param routeSettingsId the id of the route setting to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteRouteSettings",
        summary = "Delete Route Setting",
        description = "Delete an existing route setting",
        tags = { "Route Setting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_ROUTE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<Object> deleteRouteSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeSettingsId", description = "the id of the route setting to delete", required = true, in = ParameterIn.PATH) @PathVariable("routeSettingsId") Long routeSettingsId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SCHEDULED_NOTIFICATION = "/api/{version}/notification/schedule/delete";
    /**
     * POST /api/{version}/notification/schedule/delete : Delete Scheduled Notification
     * This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteScheduledNotification",
        summary = "Delete Scheduled Notification",
        description = "This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> deleteScheduledNotification(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "scheduledNotificationId", description = "the id of the scheduled notification to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId,
        @Parameter(name = "deleteByGroupingId", description = "If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deleteByGroupingId", required = false) @Nullable Boolean deleteByGroupingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SECURE_APPLICATION = "/api/{version}/secure/application/delete";
    /**
     * POST /api/{version}/secure/application/delete : Delete Secure Application
     * Delete a secure application record.
     *
     * @param version  (required)
     * @param accountId The unique id of the user making the request (required)
     * @param appKey The application to secure (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteSecureApplication",
        summary = "Delete Secure Application",
        description = "Delete a secure application record.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_SECURE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteSecureApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The unique id of the user making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to secure", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SERVICE_HUB = "/api/{version}/hub/{id}";
    /**
     * DELETE /api/{version}/hub/{id} : Delete Service Hub
     * Delete an existing service hub
     *
     * @param version  (required)
     * @param id the id of the service hub to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteServiceHub",
        summary = "Delete Service Hub",
        description = "Delete an existing service hub",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_SERVICE_HUB
    )
    default ResponseEntity<Void> deleteServiceHub(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the service hub to delete", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SHIPMENT = "/api/{version}/shipment/{id}";
    /**
     * DELETE /api/{version}/shipment/{id} : Delete Shipment
     * Delete an existing shipment
     *
     * @param version  (required)
     * @param id the id of the shipment to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteShipment",
        summary = "Delete Shipment",
        description = "Delete an existing shipment",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_SHIPMENT
    )
    default ResponseEntity<Void> deleteShipment(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the shipment to delete", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SHIPMENT_BATCH = "/api/{version}/shipment/batch/{batchId}";
    /**
     * DELETE /api/{version}/shipment/batch/{batchId} : Delete Shipment Batch
     * Search for shipment batches
     *
     * @param version  (required)
     * @param batchId the id of the shipment batch to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteShipmentBatch",
        summary = "Delete Shipment Batch",
        description = "Search for shipment batches",
        tags = { "Shipment Batch" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_SHIPMENT_BATCH
    )
    default ResponseEntity<Void> deleteShipmentBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "batchId", description = "the id of the shipment batch to delete", required = true, in = ParameterIn.PATH) @PathVariable("batchId") Long batchId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SPACE = "/api/{version}/vatom/b/spaces/delete";
    /**
     * POST /api/{version}/vatom/b/spaces/delete : Delete Vatom Space
     * Delete a Vatom space.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomSpaceId Vatom Space Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteSpace",
        summary = "Delete Vatom Space",
        description = "Delete a Vatom space.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_SPACE
    )
    default ResponseEntity<Void> deleteSpace(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomSpaceId", description = "Vatom Space Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomSpaceId", required = true) String vatomSpaceId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SUBSCRIPTION = "/api/{version}/subscription/delete";
    /**
     * POST /api/{version}/subscription/delete : Delete Subscription
     * Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action
     *
     * @param version  (required)
     * @param accountId The account used to perform the delete, must be the responsible manager (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteSubscription",
        summary = "Delete Subscription",
        description = "Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_SUBSCRIPTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteSubscription(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the delete, must be the responsible manager", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_TASK = "/api/{version}/task/delete";
    /**
     * POST /api/{version}/task/delete : Delete Task
     * Delete a Task
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param taskId The id of the Task to delete. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteTask",
        summary = "Delete Task",
        description = "Delete a Task",
        tags = { "Task" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_TASK,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteTask(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "taskId", description = "The id of the Task to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "taskId", required = true) Long taskId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_TERRITORY = "/api/{version}/territory/delete";
    /**
     * POST /api/{version}/territory/delete : Delete Territory
     * Deletes a territory.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param territoryId the id of the territory to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteTerritory",
        summary = "Delete Territory",
        description = "Deletes a territory.",
        tags = { "Territory" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_TERRITORY,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteTerritory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "territoryId", description = "the id of the territory to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "territoryId", required = true) Long territoryId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_TOURNAMENT = "/api/{version}/tournament/delete";
    /**
     * POST /api/{version}/tournament/delete : Delete Tournament
     * Delete a tournament.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteTournament",
        summary = "Delete Tournament",
        description = "Delete a tournament.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_TOURNAMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteTournament(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "the id of the mission to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_TRIGGER = "/api/{version}/trigger/delete";
    /**
     * POST /api/{version}/trigger/delete : Delete Trigger
     * Mark a trigger as deleted.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param triggerId The id of the trigger to delete. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteTrigger",
        summary = "Delete Trigger",
        description = "Mark a trigger as deleted.",
        tags = { "Trigger" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_TRIGGER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteTrigger(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "triggerId", description = "The id of the trigger to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "triggerId", required = true) Long triggerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_VATOM_EVENT = "/api/{version}/vatom/b/events/delete";
    /**
     * POST /api/{version}/vatom/b/events/delete : Delete Vatom Event
     * Delete a Vatom event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomEventId Vatom Event Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteVatomEvent",
        summary = "Delete Vatom Event",
        description = "Delete a Vatom event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_VATOM_EVENT
    )
    default ResponseEntity<Void> deleteVatomEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomEventId", description = "Vatom Event Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomEventId", required = true) String vatomEventId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_VATOM_NFT = "/api/{version}/vatom/vatoms/delete";
    /**
     * POST /api/{version}/vatom/vatoms/delete : Delete Vatom NFT
     * Delete Vatom NFT
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomId Vatom NFT Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteVatomNFT",
        summary = "Delete Vatom NFT",
        description = "Delete Vatom NFT",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DELETE_VATOM_NFT
    )
    default ResponseEntity<Void> deleteVatomNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomId", description = "Vatom NFT Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomId", required = true) String vatomId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_VEHICLE = "/api/{version}/vehicle/{id}";
    /**
     * DELETE /api/{version}/vehicle/{id} : Delete Vehicle
     * Delete an existing vehicle
     *
     * @param version  (required)
     * @param id The id of the vehicle to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteVehicle",
        summary = "Delete Vehicle",
        description = "Delete an existing vehicle",
        tags = { "Vehicle" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_VEHICLE
    )
    default ResponseEntity<Void> deleteVehicle(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "The id of the vehicle to delete", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_VEHICLE_TYPE = "/api/{version}/vehicle/type/{vehicleTypeId}";
    /**
     * DELETE /api/{version}/vehicle/type/{vehicleTypeId} : Delete Vehicle Type
     * Delete a vehicle type
     *
     * @param version  (required)
     * @param vehicleTypeId The id of the requested vehicle type (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteVehicleType",
        summary = "Delete Vehicle Type",
        description = "Delete a vehicle type",
        tags = { "Vehicle Type" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_VEHICLE_TYPE
    )
    default ResponseEntity<Void> deleteVehicleType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "vehicleTypeId", description = "The id of the requested vehicle type", required = true, in = ParameterIn.PATH) @PathVariable("vehicleTypeId") Long vehicleTypeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_WORD = "/api/{version}/game/word/delete";
    /**
     * DELETE /api/{version}/game/word/delete : Delete Word
     * Delete a word by the given id. The accountId given needs to be the owner or executive to delete.
     *
     * @param version  (required)
     * @param wordId The id of the word to delete. (required)
     * @param accountId The account vor validating permission (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteWord",
        summary = "Delete Word",
        description = "Delete a word by the given id. The accountId given needs to be the owner or executive to delete.",
        tags = { "Word" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_DELETE_WORD,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteWord(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "wordId", description = "The id of the word to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "wordId", required = true) Long wordId,
        @NotNull @Parameter(name = "accountId", description = "The account vor validating permission", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DISAPPROVE_ROUTE = "/api/{version}/route/{routeId}/disapprove";
    /**
     * POST /api/{version}/route/{routeId}/disapprove : Disapprove Route
     * Disapprove a route
     *
     * @param version  (required)
     * @param routeId the id of the route to reject (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "disapproveRoute",
        summary = "Disapprove Route",
        description = "Disapprove a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DISAPPROVE_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> disapproveRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to reject", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DRIVE_TRIP = "/api/{version}/trip/{id}/drive";
    /**
     * POST /api/{version}/trip/{id}/drive : Set Trip Preference Driver
     * Update trip preference to drive, also create a route and assign the trip to the route
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param recurrence the frequency of the trip (e.g. weekly, until 2018-08-09) (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "driveTrip",
        summary = "Set Trip Preference Driver",
        description = "Update trip preference to drive, also create a route and assign the trip to the route",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DRIVE_TRIP,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> driveTrip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "recurrence", description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurrence", required = true) Boolean recurrence
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DUPLICATE_CATEGORY = "/api/{version}/category/duplicate";
    /**
     * POST /api/{version}/category/duplicate : Duplicate Category
     * Duplicate a category, including all its children.
     *
     * @param version  (required)
     * @param accountId The account id of the user (must have permissions to the target application) (required)
     * @param categoryId The category ID to duplicate (includes all children) (required)
     * @param appKey The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param parentCategoryId The parent category ID to add the target category to. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "duplicateCategory",
        summary = "Duplicate Category",
        description = "Duplicate a category, including all its children.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CategoryTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_DUPLICATE_CATEGORY,
        produces = { "*/*" }
    )
    default ResponseEntity<CategoryTreeResponse> duplicateCategory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user (must have permissions to the target application)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "categoryId", description = "The category ID to duplicate (includes all children)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = true) Long categoryId,
        @Parameter(name = "appKey", description = "The application to assign the new category to, may be different then the application the source category is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "parentCategoryId", description = "The parent category ID to add the target category to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentCategoryId", required = false) @Nullable Long parentCategoryId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_EDIT_ACCOUNT = "/api/{version}/account/profile/update";
    /**
     * POST /api/{version}/account/profile/update : Update Account
     * Edit the user&#39;s profile information
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The account id used to edit another person&#39;s account (optional)
     * @param role The account role to change to (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param name The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param age This is deperecated, use the birthday parameter (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param makeProfileInfoPublic Allow anyone to view the user&#39;s personal profile (optional)
     * @param makeGameInfoPublic Allow anyone to view the user&#39;s game/app info (optional)
     * @param makeFriendsInfoPublic Allow anyone to view the user&#39;s friends list (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param platforms Platforms (optional)
     * @param tags Tags (optional)
     * @param aboutUs About Us (optional)
     * @param matchToken Match Token (optional)
     * @param gameExperience Game Experience (optional)
     * @param categories Deprecated use categoryIds (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to PROFILE,PROFILE_CONTACT)
     * @param showAsZipcode The user&#39;s preference if they want to be shown by zipcode on a map (optional)
     * @param showExactLocation The user&#39;s preference if they want to be shown by their exact location on a map (optional)
     * @param showOthersExactLocation The user&#39;s preference if they want to see others exact location on a map (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param locationVisibility Location Visibility (optional)
     * @param appBlob App Blob (optional)
     * @param appEnablePush App Enable Push (optional)
     * @param appEnableSMS App Enable SMS (optional)
     * @param appEnableEmail App Enable Email (optional)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional)
     * @param audienceIdsToAdd Audience Ids to add (optional)
     * @param audienceIdsToRemove Audience Ids to remove (optional)
     * @param referralAccountId The account id of the referrer (optional)
     * @param appNickname App nickname (optional)
     * @param personalAudienceId Personal Audience (optional)
     * @param nonGuestUsername The user&#39;s username to update with if they currently have a guest username (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "editAccount",
        summary = "Update Account",
        description = "Edit the user's profile information",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileInfoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_EDIT_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileInfoResponse> editAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "The account id used to edit another person's account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "role", description = "The account role to change to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "assetId", description = "The asset id to set the user's profile image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "name", description = "The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "prefixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "prefixName", required = false) @Nullable String prefixName,
        @Parameter(name = "firstName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "middleName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "middleName", required = false) @Nullable String middleName,
        @Parameter(name = "lastName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "suffixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffixName", required = false) @Nullable String suffixName,
        @Parameter(name = "title", description = "This field will be used to set the user's job title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "gender", description = "The gender of the user AudienceGender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "age", description = "This is deperecated, use the birthday parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "birthday", description = "The birthday date of the user in UTC milliseconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "birthday", required = false) @Nullable Long birthday,
        @Parameter(name = "homePhone", description = "The home phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homePhone", required = false) @Nullable String homePhone,
        @Parameter(name = "cellPhone", description = "The cellular phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "cellPhoneCarrier", description = "The cellular service provider", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhoneCarrier", required = false) @Nullable String cellPhoneCarrier,
        @Parameter(name = "businessPhone", description = "The business phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "emailAddress", description = "The user's contact email address (NOT the username)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "streetAddress", description = "The street address of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "zipcode", description = "The zipcode of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "country", description = "The country of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "makeProfileInfoPublic", description = "Allow anyone to view the user's personal profile", in = ParameterIn.QUERY) @Valid @RequestParam(value = "makeProfileInfoPublic", required = false) @Nullable Boolean makeProfileInfoPublic,
        @Parameter(name = "makeGameInfoPublic", description = "Allow anyone to view the user's game/app info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "makeGameInfoPublic", required = false) @Nullable Boolean makeGameInfoPublic,
        @Parameter(name = "makeFriendsInfoPublic", description = "Allow anyone to view the user's friends list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "makeFriendsInfoPublic", required = false) @Nullable Boolean makeFriendsInfoPublic,
        @Parameter(name = "hometown", description = "The user's hometown", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hometown", required = false) @Nullable String hometown,
        @Parameter(name = "height", description = "The user's height", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable String height,
        @Parameter(name = "heightIndex", description = "The user's height in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "heightIndex", required = false) @Nullable Integer heightIndex,
        @Parameter(name = "ethnicity", description = "The user's ethnicity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ethnicity", required = false) @Nullable String ethnicity,
        @Parameter(name = "bodyType", description = "The user's body type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bodyType", required = false) @Nullable String bodyType,
        @Parameter(name = "maritalStatus", description = "The user's marital status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maritalStatus", required = false) @Nullable String maritalStatus,
        @Parameter(name = "children", description = "The user's children status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "children", required = false) @Nullable String children,
        @Parameter(name = "religion", description = "The user's religion", in = ParameterIn.QUERY) @Valid @RequestParam(value = "religion", required = false) @Nullable String religion,
        @Parameter(name = "education", description = "The user's education", in = ParameterIn.QUERY) @Valid @RequestParam(value = "education", required = false) @Nullable String education,
        @Parameter(name = "educationIndex", description = "The user's education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "educationIndex", required = false) @Nullable Integer educationIndex,
        @Parameter(name = "smoke", description = "The user's smoke status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smoke", required = false) @Nullable String smoke,
        @Parameter(name = "drink", description = "The user's drink status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "drink", required = false) @Nullable String drink,
        @Parameter(name = "companionship", description = "The user's companionship status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionship", required = false) @Nullable String companionship,
        @Parameter(name = "companionshipIndex", description = "The user's companionship index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionshipIndex", required = false) @Nullable Integer companionshipIndex,
        @Parameter(name = "preferredMinAge", description = "The preferred minimum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinAge", required = false) @Nullable Integer preferredMinAge,
        @Parameter(name = "preferredMaxAge", description = "The preferred maximum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxAge", required = false) @Nullable Integer preferredMaxAge,
        @Parameter(name = "preferredMinHeight", description = "The preferred minimum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinHeight", required = false) @Nullable Integer preferredMinHeight,
        @Parameter(name = "preferredMaxHeight", description = "The preferred maximum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxHeight", required = false) @Nullable Integer preferredMaxHeight,
        @Parameter(name = "preferredGender", description = "The preferred gender in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredGender", required = false) @Nullable String preferredGender,
        @Parameter(name = "preferredEducation", description = "The preferred education in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducation", required = false) @Nullable String preferredEducation,
        @Parameter(name = "preferredEducationIndex", description = "The preferred education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducationIndex", required = false) @Nullable Integer preferredEducationIndex,
        @Parameter(name = "preferredBodyType", description = "The preferred body type in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredBodyType", required = false) @Nullable String preferredBodyType,
        @Parameter(name = "preferredEthnicity", description = "The preferred ethnicity in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEthnicity", required = false) @Nullable String preferredEthnicity,
        @Parameter(name = "preferredLocation", description = "The preferred education in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocation", required = false) @Nullable String preferredLocation,
        @Parameter(name = "preferredLocationRange", description = "The preferred location range in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocationRange", required = false) @Nullable Double preferredLocationRange,
        @Parameter(name = "platforms", description = "Platforms", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "tags", description = "Tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "aboutUs", description = "About Us", in = ParameterIn.QUERY) @Valid @RequestParam(value = "aboutUs", required = false) @Nullable String aboutUs,
        @Parameter(name = "matchToken", description = "Match Token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchToken", required = false) @Nullable String matchToken,
        @Parameter(name = "gameExperience", description = "Game Experience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperience", required = false) @Nullable String gameExperience,
        @Parameter(name = "categories", description = "Deprecated use categoryIds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categories", required = false) @Nullable String categories,
        @Parameter(name = "categoryIds", description = "A list of category ids that represent interests and associations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "responseFilters", description = "A comma separated list of ProfileFilters for filtering the returned response data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE,PROFILE_CONTACT") String responseFilters,
        @Parameter(name = "showAsZipcode", description = "The user's preference if they want to be shown by zipcode on a map", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showAsZipcode", required = false) @Nullable Boolean showAsZipcode,
        @Parameter(name = "showExactLocation", description = "The user's preference if they want to be shown by their exact location on a map", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showExactLocation", required = false) @Nullable Boolean showExactLocation,
        @Parameter(name = "showOthersExactLocation", description = "The user's preference if they want to see others exact location on a map", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showOthersExactLocation", required = false) @Nullable Boolean showOthersExactLocation,
        @Parameter(name = "acceptedTerms", description = "Accepted Terms", in = ParameterIn.QUERY) @Valid @RequestParam(value = "acceptedTerms", required = false) @Nullable Boolean acceptedTerms,
        @Parameter(name = "locationVisibility", description = "Location Visibility", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationVisibility", required = false) @Nullable String locationVisibility,
        @Parameter(name = "appBlob", description = "App Blob", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appBlob", required = false) @Nullable String appBlob,
        @Parameter(name = "appEnablePush", description = "App Enable Push", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnablePush", required = false) @Nullable Boolean appEnablePush,
        @Parameter(name = "appEnableSMS", description = "App Enable SMS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnableSMS", required = false) @Nullable Boolean appEnableSMS,
        @Parameter(name = "appEnableEmail", description = "App Enable Email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appEnableEmail", required = false) @Nullable Boolean appEnableEmail,
        @Parameter(name = "gameType", description = "Game Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnProfile", description = "Return Profile", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfile", required = false) @Nullable Boolean returnProfile,
        @Parameter(name = "audienceIdsToAdd", description = "Audience Ids to add", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "Audience Ids to remove", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove,
        @Parameter(name = "referralAccountId", description = "The account id of the referrer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referralAccountId", required = false) @Nullable Long referralAccountId,
        @Parameter(name = "appNickname", description = "App nickname", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appNickname", required = false) @Nullable String appNickname,
        @Parameter(name = "personalAudienceId", description = "Personal Audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "personalAudienceId", required = false) @Nullable Long personalAudienceId,
        @Parameter(name = "nonGuestUsername", description = "The user's username to update with if they currently have a guest username", in = ParameterIn.QUERY) @Valid @RequestParam(value = "nonGuestUsername", required = false) @Nullable String nonGuestUsername
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_EDIT_USERNAME = "/api/{version}/account/username/update";
    /**
     * POST /api/{version}/account/username/update : Update Username and Email
     * Update account&#39;s own username and/or emailAddress
     *
     * @param version  (required)
     * @param deviceId The device id (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param emailAddress the user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param username the user&#39;s username to update with if they currently have a guest username (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "editUsername",
        summary = "Update Username and Email",
        description = "Update account's own username and/or emailAddress",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_EDIT_USERNAME,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> editUsername(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "emailAddress", description = "the user's contact email address (NOT the username) which is also used for email validation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "username", description = "the user's username to update with if they currently have a guest username", in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = false) @Nullable String username
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_EMOTION = "/api/{version}/orson/ai/emotion";
    /**
     * POST /api/{version}/orson/ai/emotion : Detect emotions
     * Detects emotions in an audio or video recording.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "emotion",
        summary = "Detect emotions",
        description = "Detects emotions in an audio or video recording.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiEmotionsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_EMOTION,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiEmotionsResponse> emotion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_EVENT_INVITE = "/api/{version}/invite/event";
    /**
     * POST /api/{version}/invite/event : Invite to Event
     * Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.
     *
     * @param version  (required)
     * @param accountId the account ID of the user making the share (required)
     * @param appKey the application key (required)
     * @param listingId The ID of the event listing (required)
     * @param receiverAccountIds the account ID of a Sirqul user they would like to share an event with (optional)
     * @param retailerLocationId The retailer location id of where the event will take place (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "eventInvite",
        summary = "Invite to Event",
        description = "Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_EVENT_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> eventInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user making the share", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "listingId", description = "The ID of the event listing", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = true) Long listingId,
        @Parameter(name = "receiverAccountIds", description = "the account ID of a Sirqul user they would like to share an event with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountIds", required = false) @Nullable String receiverAccountIds,
        @Parameter(name = "retailerLocationId", description = "The retailer location id of where the event will take place", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_EXECUTE_ACTION_ON_NFT = "/api/{version}/vatom/vatoms/execute-action";
    /**
     * POST /api/{version}/vatom/vatoms/execute-action : Execute Action on NFT
     * Execute Action on NFT.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomId Vatom NFT Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "executeActionOnNFT",
        summary = "Execute Action on NFT",
        description = "Execute Action on NFT.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_EXECUTE_ACTION_ON_NFT
    )
    default ResponseEntity<Void> executeActionOnNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomId", description = "Vatom NFT Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomId", required = true) String vatomId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FILTERED_USAGE = "/api/{version}/analytics/filteredUsage";
    /**
     * GET /api/{version}/analytics/filteredUsage : Get Filtered Usage
     * Query analytics to get data used for graphs and charts
     *
     * @param version  (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param customId The ID for the custom table column (optional)
     * @param customType The type defined for the custom table column (optional)
     * @param customValue The value for the custom table column (optional)
     * @param customValue2 The value for another custom table column (optional)
     * @param customLong The value that supports Longs for custom table column (optional)
     * @param customLong2 The value that supports Longs for custom table column (optional)
     * @param customMessage The message for the custom table column (optional)
     * @param customMessage2 The message for the custom table column (optional)
     * @param groupBy Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param sumColumn sum of the column values (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "filteredUsage",
        summary = "Get Filtered Usage",
        description = "Query analytics to get data used for graphs and charts",
        tags = { "Analytics" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ChartData.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_FILTERED_USAGE,
        produces = { "*/*" }
    )
    default ResponseEntity<ChartData> filteredUsage(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "applicationId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationId", required = false) @Nullable Long applicationId,
        @Parameter(name = "appKey", description = "The application key used to filter results by application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "startDate", description = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "deviceType", description = "The device type to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "device", description = "The device to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = false) @Nullable String device,
        @Parameter(name = "deviceOS", description = "The device OS to filter results by (performs a LIKE search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceOS", required = false) @Nullable String deviceOS,
        @Parameter(name = "gender", description = "The gender to filter results by {MALE, FEMALE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroup", description = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroup", required = false) @Nullable String ageGroup,
        @Parameter(name = "country", description = "The country to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "state", description = "The state to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "city", description = "The city to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "zip", description = "The zip to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zip", required = false) @Nullable String zip,
        @Parameter(name = "model", description = "The model to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "model", required = false) @Nullable String model,
        @Parameter(name = "tag", description = "The tag to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tag", required = false) @Nullable String tag,
        @Parameter(name = "userAccountId", description = "The account id to filter results for a particular user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountId", required = false) @Nullable Long userAccountId,
        @Parameter(name = "userAccountDisplay", description = "The user display to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountDisplay", required = false) @Nullable String userAccountDisplay,
        @Parameter(name = "userAccountUsername", description = "The username to filter results by (performs a wild-card search)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAccountUsername", required = false) @Nullable String userAccountUsername,
        @Parameter(name = "customId", description = "The ID for the custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customId", required = false) @Nullable Long customId,
        @Parameter(name = "customType", description = "The type defined for the custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customType", required = false) @Nullable String customType,
        @Parameter(name = "customValue", description = "The value for the custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customValue", required = false) @Nullable Double customValue,
        @Parameter(name = "customValue2", description = "The value for another custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customValue2", required = false) @Nullable Double customValue2,
        @Parameter(name = "customLong", description = "The value that supports Longs for custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customLong", required = false) @Nullable Long customLong,
        @Parameter(name = "customLong2", description = "The value that supports Longs for custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customLong2", required = false) @Nullable Long customLong2,
        @Parameter(name = "customMessage", description = "The message for the custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = false) @Nullable String customMessage,
        @Parameter(name = "customMessage2", description = "The message for the custom table column", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage2", required = false) @Nullable String customMessage2,
        @Parameter(name = "groupBy", description = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupBy", required = false) @Nullable String groupBy,
        @Parameter(name = "distinctCount", description = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distinctCount", required = false) @Nullable String distinctCount,
        @Parameter(name = "sumColumn", description = "sum of the column values", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sumColumn", required = false) @Nullable String sumColumn,
        @Parameter(name = "sortField", description = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether to return results in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "hideUnknown", description = "Determines whether to return data that has empty or unknown values", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hideUnknown", required = false) @Nullable Boolean hideUnknown,
        @Parameter(name = "responseFormat", description = "Determines whether to return a JOSN or XML representation of the graph results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FIND_MISSIONS = "/api/{version}/mission/find";
    /**
     * GET /api/{version}/mission/find : Find Missions
     * Get a set of ad filtered by the parameters provided.
     *
     * @param version  (required)
     * @param appKey The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic. (required)
     * @param suffix The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip (optional)
     * @param type The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
     * @param accountId The logged in user. (optional)
     * @param appVersion The version of the application, will not return levels newer than the appVersion. (optional)
     * @param latitude The current location of the requesting device (optional)
     * @param longitude The current location of the requesting device (optional)
     * @param device Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
     * @param deviceIdentifier The device ID of the requesting device, use /audience/devices for list (optional)
     * @param deviceVersion The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param allocatesTickets If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
     * @param randomize return a random set of results, default is true. If false returns in natural order. (optional)
     * @param targetedAdsOnly return only ads targeted to the specific app, no global ads. (optional)
     * @param missionIds return only ads from the specified campaigns. (optional)
     * @param audienceOperator will return the items that have at least 1 or all of their audiences exist in the logged in users audiences, depending if the value is OR or AND (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "findMissions",
        summary = "Find Missions",
        description = "Get a set of ad filtered by the parameters provided.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_FIND_MISSIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> findMissions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "suffix", description = "The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffix", required = false) @Nullable String suffix,
        @Parameter(name = "type", description = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appVersion", description = "The version of the application, will not return levels newer than the appVersion.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "latitude", description = "The current location of the requesting device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the requesting device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "device", description = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = false) @Nullable String device,
        @Parameter(name = "deviceIdentifier", description = "The device ID of the requesting device, use /audience/devices for list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdentifier", required = false) @Nullable Long deviceIdentifier,
        @Parameter(name = "deviceVersion", description = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersion", required = false) @Nullable String deviceVersion,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of record to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeAudiences", description = "If true then return the audience data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiences", required = false) @Nullable Boolean includeAudiences,
        @Parameter(name = "allocatesTickets", description = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocatesTickets", required = false) @Nullable Boolean allocatesTickets,
        @Parameter(name = "randomize", description = "return a random set of results, default is true. If false returns in natural order.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "randomize", required = false) @Nullable Boolean randomize,
        @Parameter(name = "targetedAdsOnly", description = "return only ads targeted to the specific app, no global ads.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "targetedAdsOnly", required = false) @Nullable Boolean targetedAdsOnly,
        @Parameter(name = "missionIds", description = "return only ads from the specified campaigns.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionIds", required = false) @Nullable String missionIds,
        @Parameter(name = "audienceOperator", description = "will return the items that have at least 1 or all of their audiences exist in the logged in users audiences, depending if the value is OR or AND", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceOperator", required = false) @Nullable String audienceOperator
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FLEXIBLE_TRIP = "/api/{version}/trip/{id}/flexible";
    /**
     * POST /api/{version}/trip/{id}/flexible : Set Trip Preference Flexible
     * Update trip preference to flexible.
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param recurrence the frequency of the trip (e.g. weekly, until 2018-08-09) (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "flexibleTrip",
        summary = "Set Trip Preference Flexible",
        description = "Update trip preference to flexible.",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FLEXIBLE_TRIP,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> flexibleTrip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "recurrence", description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurrence", required = true) Boolean recurrence
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FOLLOW_ACCEPT = "/api/{version}/consumer/follow/accept";
    /**
     * POST /api/{version}/consumer/follow/accept : Accept Follow Request
     * Accept someone&#39;s follow request.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param connectionAccountId the account ID of the user who initiated the follow (required)
     * @param appKey the application key for sending notifications (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "followAccept",
        summary = "Accept Follow Request",
        description = "Accept someone's follow request.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FOLLOW_ACCEPT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> followAccept(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "connectionAccountId", description = "the account ID of the user who initiated the follow", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = true) Long connectionAccountId,
        @NotNull @Parameter(name = "appKey", description = "the application key for sending notifications", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FOLLOW_REJECT = "/api/{version}/consumer/follow/reject";
    /**
     * POST /api/{version}/consumer/follow/reject : Reject Follow Request
     * Reject someone&#39;s follow request or remove them as a follower.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param connectionAccountId the account ID of the user who initiated the follow (required)
     * @param appKey the application key for sending notifications (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "followReject",
        summary = "Reject Follow Request",
        description = "Reject someone's follow request or remove them as a follower.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FOLLOW_REJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> followReject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "connectionAccountId", description = "the account ID of the user who initiated the follow", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = true) Long connectionAccountId,
        @NotNull @Parameter(name = "appKey", description = "the application key for sending notifications", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FOLLOW_REMOVE = "/api/{version}/consumer/follow/remove";
    /**
     * POST /api/{version}/consumer/follow/remove : Remove Follower / Unfollow
     * Unfollow someone you are following or remove them as a follower.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param connectionAccountId the account ID of the user who you want to unfollow (required)
     * @param appKey the application key for sending notifications (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "followRemove",
        summary = "Remove Follower / Unfollow",
        description = "Unfollow someone you are following or remove them as a follower.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FOLLOW_REMOVE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> followRemove(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "connectionAccountId", description = "the account ID of the user who you want to unfollow", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = true) Long connectionAccountId,
        @NotNull @Parameter(name = "appKey", description = "the application key for sending notifications", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FOLLOW_REQUEST = "/api/{version}/consumer/follow/request";
    /**
     * POST /api/{version}/consumer/follow/request : Send Follow Request
     * Send a request to follow someone.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param connectionAccountId the account ID of the user who you want to follow (required)
     * @param appKey the application key for sending notifications (required)
     * @param approvalNeeded determines if the other user needs to confirm the follow request (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "followRequest",
        summary = "Send Follow Request",
        description = "Send a request to follow someone.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FOLLOW_REQUEST,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> followRequest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "connectionAccountId", description = "the account ID of the user who you want to follow", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = true) Long connectionAccountId,
        @NotNull @Parameter(name = "appKey", description = "the application key for sending notifications", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "approvalNeeded", description = "determines if the other user needs to confirm the follow request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalNeeded", required = false, defaultValue = "true") Boolean approvalNeeded
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FRIEND_ACCEPT = "/api/{version}/consumer/friend/accept";
    /**
     * POST /api/{version}/consumer/friend/accept : Accept Friend
     * Accept a friend request and optionally sends a notification.
     *
     * @param version  (required)
     * @param friendAccountId the friend&#39;s account id (required)
     * @param notifyFriend determines whether to send a notification to the afflicting party (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "friendAccept",
        summary = "Accept Friend",
        description = "Accept a friend request and optionally sends a notification.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FRIEND_ACCEPT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> friendAccept(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "friendAccountId", description = "the friend's account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendAccountId", required = true) Long friendAccountId,
        @NotNull @Parameter(name = "notifyFriend", description = "determines whether to send a notification to the afflicting party", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notifyFriend", required = true) Boolean notifyFriend,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "notificationMessage", description = "optional message to send in a notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationMessage", required = false) @Nullable String notificationMessage
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FRIEND_REJECT = "/api/{version}/consumer/friend/reject";
    /**
     * POST /api/{version}/consumer/friend/reject : Decline Friend
     * Request a friend request and optionally sends a notification.
     *
     * @param version  (required)
     * @param friendAccountId the friend&#39;s account id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notifyFriend determines whether to send a notification to the afflicting party (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "friendReject",
        summary = "Decline Friend",
        description = "Request a friend request and optionally sends a notification.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FRIEND_REJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> friendReject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "friendAccountId", description = "the friend's account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendAccountId", required = true) Long friendAccountId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "notifyFriend", description = "determines whether to send a notification to the afflicting party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notifyFriend", required = false) @Nullable Boolean notifyFriend,
        @Parameter(name = "notificationMessage", description = "optional message to send in a notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationMessage", required = false) @Nullable String notificationMessage
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FRIEND_REMOVE = "/api/{version}/consumer/friend/remove";
    /**
     * POST /api/{version}/consumer/friend/remove : Delete Friend
     * Removes a friend from the user&#39;s friends list.
     *
     * @param version  (required)
     * @param friendAccountId the account ID of the friend to remove (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param notifyFriend optionally notifies the connection that they have been removed as a friend (optional)
     * @param removeFromGroups optionally removes the connection from the user&#39;s groups (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "friendRemove",
        summary = "Delete Friend",
        description = "Removes a friend from the user's friends list.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FRIEND_REMOVE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> friendRemove(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "friendAccountId", description = "the account ID of the friend to remove", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendAccountId", required = true) Long friendAccountId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "notifyFriend", description = "optionally notifies the connection that they have been removed as a friend", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notifyFriend", required = false) @Nullable Boolean notifyFriend,
        @Parameter(name = "removeFromGroups", description = "optionally removes the connection from the user's groups", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFromGroups", required = false) @Nullable Boolean removeFromGroups
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_FRIEND_REQUEST = "/api/{version}/consumer/friend/request";
    /**
     * POST /api/{version}/consumer/friend/request : Request Friend
     * Sends a friend request notification to another user.
     *
     * @param version  (required)
     * @param friendAccountId the friend&#39;s account id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "friendRequest",
        summary = "Request Friend",
        description = "Sends a friend request notification to another user.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_FRIEND_REQUEST,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> friendRequest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "friendAccountId", description = "the friend's account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendAccountId", required = true) Long friendAccountId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "notificationMessage", description = "optional message to send in a notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationMessage", required = false) @Nullable String notificationMessage
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GAME_INVITE = "/api/{version}/invite/gameLevel";
    /**
     * POST /api/{version}/invite/gameLevel : Invite to Game Level
     * Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user&#39;s friend when the invitation is accepted.
     *
     * @param version  (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param appId This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param gameLevelId the game level that the user owns and is giving access to (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "gameInvite",
        summary = "Invite to Game Level",
        description = "Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GAME_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> gameInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appId", required = false) @Nullable Long appId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "gameLevelId", description = "the game level that the user owns and is giving access to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GEOMAP_SEARCH = "/api/{version}/vatom/vatoms/geo-map/search";
    /**
     * GET /api/{version}/vatom/vatoms/geo-map/search : Search Vatom Geo Map
     * Search Vatom Geo Map
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "geomapSearch",
        summary = "Search Vatom Geo Map",
        description = "Search Vatom Geo Map",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GEOMAP_SEARCH
    )
    default ResponseEntity<Void> geomapSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ACCOUNT = "/api/{version}/account/profile/get";
    /**
     * GET /api/{version}/account/profile/get : Get Account
     * Gets a user&#39;s account profile. Application settings and account settings will also be returned for the owner of the account.
     *
     * @param version  (required)
     * @param returnNulls Return Nulls (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail Connection Account Email (optional)
     * @param connectionAccountId The account id used to view another person&#39;s account (optional, default to 0)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to PROFILE)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param purchaseType Purchase Type (optional, default to SIRQUL)
     * @param updateViewedDate Determines whether to track if a person has viewed someone&#39;s profile (optional, default to false)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAccount",
        summary = "Get Account",
        description = "Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> getAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "returnNulls", description = "Return Nulls", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "false") Boolean returnNulls,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountEmail", description = "Connection Account Email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountEmail", required = false) @Nullable String connectionAccountEmail,
        @Parameter(name = "connectionAccountId", description = "The account id used to view another person's account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false, defaultValue = "0") Long connectionAccountId,
        @Parameter(name = "responseFilters", description = "A comma separated list of ProfileFilters for filtering the returned response data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters,
        @Parameter(name = "gameType", description = "Game Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "purchaseType", description = "Purchase Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false, defaultValue = "SIRQUL") String purchaseType,
        @Parameter(name = "updateViewedDate", description = "Determines whether to track if a person has viewed someone's profile", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateViewedDate", required = false, defaultValue = "false") Boolean updateViewedDate,
        @Parameter(name = "latitude", description = "Latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ACHIEVEMENT = "/api/{version}/achievement/get";
    /**
     * GET /api/{version}/achievement/get : Get Achievement
     * Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param achievementId The ID of the achievement (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementType achievementType (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAchievement",
        summary = "Get Achievement",
        description = "Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementTierResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ACHIEVEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementTierResponse> getAchievement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "achievementId", description = "The ID of the achievement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementId", required = true) Long achievementId,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "achievementType", description = "achievementType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementType", required = false) @Nullable String achievementType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ACHIEVEMENT_TIER = "/api/{version}/achievement/tier/get";
    /**
     * POST /api/{version}/achievement/tier/get : Gets an achievement tier
     * Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param accountId the account id of the user (deviceId or accountId required) (required)
     * @param achievementTierId the achievement tier id that is being retrieved (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAchievementTier",
        summary = "Gets an achievement tier",
        description = "Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementTierResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GET_ACHIEVEMENT_TIER,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementTierResponse> getAchievementTier(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "achievementTierId", description = "the achievement tier id that is being retrieved", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementTierId", required = true) Long achievementTierId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ADD_MOVIE_RESULT = "/api/{version}/orson/ai/addMovie/{requestId}";
    /**
     * GET /api/{version}/orson/ai/addMovie/{requestId} : Get Add Movie Result
     * Get the result of an in progress Add Movie request from an earlier POST.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAddMovieResult",
        summary = "Get Add Movie Result",
        description = "Get the result of an in progress Add Movie request from an earlier POST.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiAddMovieResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ADD_MOVIE_RESULT,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiAddMovieResponse> getAddMovieResult(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AGE_GROUPS = "/api/{version}/audience/ageGroups";
    /**
     * GET /api/{version}/audience/ageGroups : Get Age Groups
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     *
     * @param version  (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAgeGroups",
        summary = "Get Age Groups",
        description = "Gets the list of available age groups that can be selected by consumers and retailers targeting offers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AgeGroupResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_AGE_GROUPS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AgeGroupResponse>> getAgeGroups(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ALBUM_COLLECTION = "/api/{version}/album/get";
    /**
     * GET /api/{version}/album/get :  Get Album
     * Get an Album.
     *
     * @param version  (required)
     * @param returnNulls This parameter is deprecated. (required)
     * @param albumId the album to look up (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param likePreviewSize returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param assetPreviewSize returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param notePreviewSize returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param connectionPreviewSize returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param audiencePreviewSize returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAlbumCollection",
        summary = " Get Album",
        description = "Get an Album.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ALBUM_COLLECTION,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumFullResponse> getAlbumCollection(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "This parameter is deprecated.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "albumId", description = "the album to look up", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "likePreviewSize", description = "returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "likePreviewSize", required = false) @Nullable Integer likePreviewSize,
        @Parameter(name = "assetPreviewSize", description = "returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetPreviewSize", required = false) @Nullable Integer assetPreviewSize,
        @Parameter(name = "notePreviewSize", description = "returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notePreviewSize", required = false) @Nullable Integer notePreviewSize,
        @Parameter(name = "connectionPreviewSize", description = "returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionPreviewSize", required = false) @Nullable Integer connectionPreviewSize,
        @Parameter(name = "audiencePreviewSize", description = "returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audiencePreviewSize", required = false) @Nullable Integer audiencePreviewSize
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ALBUM_CONTEST = "/api/{version}/consumer/album/contest/get";
    /**
     * GET /api/{version}/consumer/album/contest/get : Get Contest
     * Gets the contest object including the likes and notes
     *
     * @param version  (required)
     * @param albumContestId the album contest ID (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAlbumContest",
        summary = "Get Contest",
        description = "Gets the contest object including the likes and notes",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumContestResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ALBUM_CONTEST,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumContestResponse> getAlbumContest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumContestId", description = "the album contest ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = true) Long albumContestId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ALBUM_CONTESTS = "/api/{version}/consumer/album/contest/search";
    /**
     * GET /api/{version}/consumer/album/contest/search : Search Contests
     * Searches on contests.
     *
     * @param version  (required)
     * @param filter a comma separated list of Ownership (required)
     * @param sortField the field to sort by. See AlbumContestApiMap (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (there is a hard limit of 30) (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param appType the application type (optional)
     * @param contestType filter contests with this contest type (optional)
     * @param ownerId search on contests that have been created by this account (that the user has permissions to) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword search string (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param dateCreated filter on items that have been created before this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAlbumContests",
        summary = "Search Contests",
        description = "Searches on contests.",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumContestListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ALBUM_CONTESTS,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumContestListResponse> getAlbumContests(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "filter", description = "a comma separated list of Ownership", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = true) String filter,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. See AlbumContestApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination (there is a hard limit of 30)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "appType", description = "the application type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appType", required = false) @Nullable String appType,
        @Parameter(name = "contestType", description = "filter contests with this contest type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contestType", required = false) @Nullable String contestType,
        @Parameter(name = "ownerId", description = "search on contests that have been created by this account (that the user has permissions to)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "keyword search string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "dateCreated", description = "filter on items that have been created before this date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCreated", required = false) @Nullable Long dateCreated,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APP_DATA = "/api/{version}/app/get";
    /**
     * GET /api/{version}/app/get : Get App Data
     * Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user&#39;s profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user&#39;s   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.
     *
     * @param version  (required)
     * @param start start the search results at a record. (required)
     * @param limit limit the search results to some number. (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param gameType the game to retrieve the data for, use your application key. (optional)
     * @param includeGameData if true then include the game data blob, otherwise don&#39;t include. (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword query string used to filter the search results when looking for community and saved levels. (optional)
     * @param sortField how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS. (optional)
     * @param descending order the search results descending or ascending when looking for community and saved levels. (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param gameObjectCount if true then include the game object count, otherwise don&#39;t include. (optional)
     * @param filter restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED (optional)
     * @param dateCreated restrict the search to items created less then date (optional)
     * @param ownerId get levels owned by a particular account (optional)
     * @param missionIds get missions by specified id, comman seperated list of long ids (optional)
     * @param gameIds get games by specified id, comman seperated list of long ids (optional)
     * @param packIds get packs by specified id, comman seperated list of long ids (optional)
     * @param gameLevelIds get game levels by specified id, comman seperated list of long ids (optional)
     * @param appVersion the application version, used to versin the game level data (optional)
     * @param includeHigherVersionPacks default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
     * @param includeHigherVersionLevels default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
     * @param responseGroups use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list  (optional)
     * @param purchaseType the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAppData",
        summary = "Get App Data",
        description = "Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.",
        tags = { "AppData" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AppResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APP_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<AppResponse> getAppData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "start", description = "start the search results at a record.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "limit the search results to some number.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "the game to retrieve the data for, use your application key.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "includeGameData", description = "if true then include the game data blob, otherwise don't include.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "query string used to filter the search results when looking for community and saved levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "order the search results descending or ascending when looking for community and saved levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "gameObjectCount", description = "if true then include the game object count, otherwise don't include.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectCount", required = false) @Nullable Boolean gameObjectCount,
        @Parameter(name = "filter", description = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) @Nullable String filter,
        @Parameter(name = "dateCreated", description = "restrict the search to items created less then date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCreated", required = false) @Nullable Long dateCreated,
        @Parameter(name = "ownerId", description = "get levels owned by a particular account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "missionIds", description = "get missions by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionIds", required = false) @Nullable String missionIds,
        @Parameter(name = "gameIds", description = "get games by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameIds", required = false) @Nullable String gameIds,
        @Parameter(name = "packIds", description = "get packs by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packIds", required = false) @Nullable String packIds,
        @Parameter(name = "gameLevelIds", description = "get game levels by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "appVersion", description = "the application version, used to versin the game level data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "includeHigherVersionPacks", description = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeHigherVersionPacks", required = false) @Nullable Boolean includeHigherVersionPacks,
        @Parameter(name = "includeHigherVersionLevels", description = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeHigherVersionLevels", required = false) @Nullable Boolean includeHigherVersionLevels,
        @Parameter(name = "responseGroups", description = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroups", required = false) @Nullable String responseGroups,
        @Parameter(name = "purchaseType", description = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APPLICATION = "/api/{version}/application/get";
    /**
     * GET /api/{version}/application/get : Get Application
     * Get a specific application by appKey
     *
     * @param version  (required)
     * @param appKey The key of the application (optional)
     * @param applicationId Application Id (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getApplication",
        summary = "Get Application",
        description = "Get a specific application by appKey",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationResponse> getApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "appKey", description = "The key of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "applicationId", description = "Application Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationId", required = false) @Nullable Long applicationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APPLICATION_CONFIG = "/api/{version}/appconfig/get";
    /**
     * GET /api/{version}/appconfig/get : Get AppConfig
     * Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.
     *
     * @param version  (required)
     * @param accountId The account ID of the user (required)
     * @param configId The config ID of the application configuration (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getApplicationConfig",
        summary = "Get AppConfig",
        description = "Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationConfigResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APPLICATION_CONFIG,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationConfigResponse> getApplicationConfig(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "configId", description = "The config ID of the application configuration", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "configId", required = true) Long configId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APPLICATION_CONFIG_BY_CONFIG_VERSION = "/api/{version}/appconfig/getbyversion";
    /**
     * GET /api/{version}/appconfig/getbyversion : Get AppConfig by Version
     * Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 
     *
     * @param version  (required)
     * @param appKey The application key (required)
     * @param configVersion The version of the application configuration (required)
     * @param retailerId Only returns the config that matches the given retailer (optional)
     * @param retailerLocationId Only returns the config that matches the given retailer location (optional)
     * @param udid Only returns only returns the config that matches the given device udid (optional)
     * @param allowOlderVersions Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version. (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getApplicationConfigByConfigVersion",
        summary = "Get AppConfig by Version",
        description = "Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. ",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationConfigResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APPLICATION_CONFIG_BY_CONFIG_VERSION,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationConfigResponse> getApplicationConfigByConfigVersion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "configVersion", description = "The version of the application configuration", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "configVersion", required = true) String configVersion,
        @Parameter(name = "retailerId", description = "Only returns the config that matches the given retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Only returns the config that matches the given retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "udid", description = "Only returns only returns the config that matches the given device udid", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid,
        @Parameter(name = "allowOlderVersions", description = "Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allowOlderVersions", required = false, defaultValue = "false") Boolean allowOlderVersions
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APPLICATION_PLACEMENT = "/api/{version}/application/placement/get";
    /**
     * GET /api/{version}/application/placement/get : Get Ad Placement
     * Get details of an ad placement
     *
     * @param version  (required)
     * @param placementId The id of the placement (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getApplicationPlacement",
        summary = "Get Ad Placement",
        description = "Get details of an ad placement",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PlacementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APPLICATION_PLACEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<PlacementResponse> getApplicationPlacement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "placementId", description = "The id of the placement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementId", required = true) Long placementId,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_APPLICATION_VERSIONS = "/api/{version}/application/versions";
    /**
     * GET /api/{version}/application/versions : Get API versions
     * Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8
     *
     * @param version  (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getApplicationVersions",
        summary = "Get API versions",
        description = "Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_APPLICATION_VERSIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getApplicationVersions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ASSET = "/api/{version}/asset/get";
    /**
     * GET /api/{version}/asset/get : Get Asset
     * Gets the full asset response including attached likes and notes.
     *
     * @param version  (required)
     * @param assetId the asset ID (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param noteDescending determines whether the notes on the asset are in descending order (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAsset",
        summary = "Get Asset",
        description = "Gets the full asset response including attached likes and notes.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssetFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ASSET,
        produces = { "*/*" }
    )
    default ResponseEntity<AssetFullResponse> getAsset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "assetId", description = "the asset ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = true) Long assetId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "noteDescending", description = "determines whether the notes on the asset are in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteDescending", required = false, defaultValue = "false") Boolean noteDescending
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AUDIENCE = "/api/{version}/audience/get";
    /**
     * GET /api/{version}/audience/get : Get Audience
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to return. (required)
     * @param appKey The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAudience",
        summary = "Get Audience",
        description = "Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> getAudience(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId,
        @Parameter(name = "appKey", description = "The application key (optional). If provided, results may be scoped to this application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "returnAccountCount", description = "(boolean) set to true to include the accountCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") Boolean returnAccountCount,
        @Parameter(name = "returnAlbumCount", description = "(boolean) set to true to include the albumCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") Boolean returnAlbumCount,
        @Parameter(name = "albumTypesForCount", description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypesForCount", required = false) @Nullable String albumTypesForCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AUDIENCE_LIST = "/api/{version}/audience/search";
    /**
     * GET /api/{version}/audience/search : Search Audiences
     * Get the list audiences owned by the account
     *
     * @param version  (required)
     * @param accountId The logged in user. (optional)
     * @param albumIds Comma separated list of album IDs to filter results with (optional)
     * @param keyword The keyword used to search (optional)
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to SEARCH_TAGS,NAME,DESCRIPTION)
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to NAME)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional)
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param appKey Filter results by application key (optional)
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param exactKeyword If true, match keyword exactly (optional)
     * @param audienceType (Deprecated) Filter results by audience type (optional)
     * @param audienceTypes comma separated string with the different audience types you want to filter for (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAudienceList",
        summary = "Search Audiences",
        description = "Get the list audiences owned by the account",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = SearchResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_AUDIENCE_LIST,
        produces = { "*/*" }
    )
    default ResponseEntity<List<SearchResponse>> getAudienceList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumIds", description = "Comma separated list of album IDs to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "keywordFields", description = "Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keywordFields", required = false, defaultValue = "SEARCH_TAGS,NAME,DESCRIPTION") String keywordFields,
        @Parameter(name = "sortField", description = "The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "NAME") String sortField,
        @Parameter(name = "descending", description = "The order to return the results. Default is false, which will return the results in ascending order.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The total number of record to return (there is a hard limit of 100).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "sendSuggestion", description = "Filter results based on whether or not the audience is set to send suggestions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false) @Nullable Boolean sendSuggestion,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "groupByGroupingId", description = "Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupByGroupingId", required = false) @Nullable Boolean groupByGroupingId,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "returnGlobal", description = "If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnGlobal", required = false) @Nullable Boolean returnGlobal,
        @Parameter(name = "exactKeyword", description = "If true, match keyword exactly", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exactKeyword", required = false) @Nullable Boolean exactKeyword,
        @Parameter(name = "audienceType", description = "(Deprecated) Filter results by audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "audienceTypes", description = "comma separated string with the different audience types you want to filter for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceTypes", required = false) @Nullable String audienceTypes,
        @Parameter(name = "returnAccountCount", description = "(boolean) set to true to include the accountCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") Boolean returnAccountCount,
        @Parameter(name = "returnAlbumCount", description = "(boolean) set to true to include the albumCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") Boolean returnAlbumCount,
        @Parameter(name = "albumTypesForCount", description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypesForCount", required = false) @Nullable String albumTypesForCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BATCH = "/api/{version}/orson/ai/batch/{requestId}";
    /**
     * GET /api/{version}/orson/ai/batch/{requestId} : Get Batch Analysis Results
     * Gets the completed Video Batch results, if done, or an error or status update if not.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBatch",
        summary = "Get Batch Analysis Results",
        description = "Gets the completed Video Batch results, if done, or an error or status update if not.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiBatchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiBatchResponse> getBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BID = "/api/{version}/bid/get";
    /**
     * GET /api/{version}/bid/get : Get Bid
     * Get the bid details of a biddable object
     *
     * @param version  (required)
     * @param bidId The bid id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBid",
        summary = "Get Bid",
        description = "Get the bid details of a biddable object",
        tags = { "Bid" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BidResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BID,
        produces = { "*/*" }
    )
    default ResponseEntity<BidResponse> getBid(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "bidId", description = "The bid id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "bidId", required = true) Long bidId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BILLABLE_ENTITY = "/api/{version}/billable/get";
    /**
     * GET /api/{version}/billable/get : Get Billable
     * Used to determine the associated BillableEntity of an account
     *
     * @param version  (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param includeCounts Determines whether to include the retailer dash board counts into the response (optional, default to false)
     * @param includePayments Whether to enable payments or not (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBillableEntity",
        summary = "Get Billable",
        description = "Used to determine the associated BillableEntity of an account",
        tags = { "Billable Entity" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BillableEntityResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<BillableEntityResponse> getBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "includeCounts", description = "Determines whether to include the retailer dash board counts into the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCounts", required = false, defaultValue = "false") Boolean includeCounts,
        @Parameter(name = "includePayments", description = "Whether to enable payments or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includePayments", required = false, defaultValue = "true") Boolean includePayments
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BUSINESS_BEHAVIORS = "/api/{version}/vatom/b/behaviors";
    /**
     * GET /api/{version}/vatom/b/behaviors : Get Vatom Business Behaviors
     * Gets the behaviors of a business.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBusinessBehaviors",
        summary = "Get Vatom Business Behaviors",
        description = "Gets the behaviors of a business.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BUSINESS_BEHAVIORS
    )
    default ResponseEntity<Void> getBusinessBehaviors(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BUSINESS_COINS_BALANCE = "/api/{version}/vatom/b/coins/get";
    /**
     * GET /api/{version}/vatom/b/coins/get : Get the coins for a Business
     * Get the coins for a Businesss.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBusinessCoinsBalance",
        summary = "Get the coins for a Business",
        description = "Get the coins for a Businesss.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BUSINESS_COINS_BALANCE
    )
    default ResponseEntity<Void> getBusinessCoinsBalance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BUSINESS_IDS = "/api/{version}/vatom/me/businesses";
    /**
     * GET /api/{version}/vatom/me/businesses : Get the user business ids
     * Get the business ids the logged in user has access to.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBusinessIds",
        summary = "Get the user business ids",
        description = "Get the business ids the logged in user has access to.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BUSINESS_IDS
    )
    default ResponseEntity<Void> getBusinessIds(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BUSINESS_INFO = "/api/{version}/vatom/b/get";
    /**
     * GET /api/{version}/vatom/b/get : Get Vatom Business Info
     * Gets the business info tied to this account.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBusinessInfo",
        summary = "Get Vatom Business Info",
        description = "Gets the business info tied to this account.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BUSINESS_INFO
    )
    default ResponseEntity<Void> getBusinessInfo(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_BUSINESS_USERS = "/api/{version}/vatom/b/users";
    /**
     * GET /api/{version}/vatom/b/users : Get Vatom Business Users
     * Gets the users of a business.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getBusinessUsers",
        summary = "Get Vatom Business Users",
        description = "Gets the users of a business.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_BUSINESS_USERS
    )
    default ResponseEntity<Void> getBusinessUsers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CAMPAIGN_GROUP_ENTITIES = "/api/{version}/vatom/b/campaign-groups/entities";
    /**
     * GET /api/{version}/vatom/b/campaign-groups/entities : Get Campaign Group Entities
     * Get campaign group entities.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCampaignGroupEntities",
        summary = "Get Campaign Group Entities",
        description = "Get campaign group entities.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CAMPAIGN_GROUP_ENTITIES
    )
    default ResponseEntity<Void> getCampaignGroupEntities(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CAMPAIGN_GROUP_RULES = "/api/{version}/vatom/b/campaign-groups/rules";
    /**
     * GET /api/{version}/vatom/b/campaign-groups/rules : Get Campaign Group Rules
     * Get campaign group rules.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCampaignGroupRules",
        summary = "Get Campaign Group Rules",
        description = "Get campaign group rules.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CAMPAIGN_GROUP_RULES
    )
    default ResponseEntity<Void> getCampaignGroupRules(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CAMPAIGN_GROUP_STATS = "/api/{version}/vatom/b/campaign-groups/stats";
    /**
     * GET /api/{version}/vatom/b/campaign-groups/stats : Get Campaign Group Stats
     * Get campaign group stats.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCampaignGroupStats",
        summary = "Get Campaign Group Stats",
        description = "Get campaign group stats.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CAMPAIGN_GROUP_STATS
    )
    default ResponseEntity<Void> getCampaignGroupStats(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CAMPAIGN_INFO = "/api/{version}/vatom/b/campaign-groups/get";
    /**
     * GET /api/{version}/vatom/b/campaign-groups/get : Get Campaign Info
     * Gets the info on a campaign.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCampaignInfo",
        summary = "Get Campaign Info",
        description = "Gets the info on a campaign.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CAMPAIGN_INFO
    )
    default ResponseEntity<Void> getCampaignInfo(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CARGO_TYPE = "/api/{version}/cargo/type/{cargoTypeId}";
    /**
     * GET /api/{version}/cargo/type/{cargoTypeId} : Get Cargo Type
     * Get an existing cargo type
     *
     * @param version  (required)
     * @param cargoTypeId the cargo type ID (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCargoType",
        summary = "Get Cargo Type",
        description = "Get an existing cargo type",
        tags = { "Cargo Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CargoType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CARGO_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<CargoType> getCargoType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "cargoTypeId", description = "the cargo type ID", required = true, in = ParameterIn.PATH) @PathVariable("cargoTypeId") Long cargoTypeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CATEGORY = "/api/{version}/category/get";
    /**
     * GET /api/{version}/category/get : Get Category
     * Get the details of a specific category. Recursively include all child categories and their children.
     *
     * @param version  (required)
     * @param categoryId the ID of the category (required)
     * @param returnExternal Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCategory",
        summary = "Get Category",
        description = "Get the details of a specific category. Recursively include all child categories and their children.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CategoryTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CATEGORY,
        produces = { "*/*" }
    )
    default ResponseEntity<CategoryTreeResponse> getCategory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "categoryId", description = "the ID of the category", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = true) Long categoryId,
        @Parameter(name = "returnExternal", description = "Determines whether to return extra info about the category's \"Participant\" reference", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnExternal", required = false, defaultValue = "true") Boolean returnExternal
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CONNECTION_SENT_FRIEND_REQUESTS = "/api/{version}/consumer/connection/getRequested";
    /**
     * GET /api/{version}/consumer/connection/getRequested : Get Sent Friend Requests
     * Gets the connection sent friend requests.
     *
     * @param version  (required)
     * @param deviceId the ID of the device (optional)
     * @param accountId the id of the account (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getConnectionSentFriendRequests",
        summary = "Get Sent Friend Requests",
        description = "Gets the connection sent friend requests.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CONNECTION_SENT_FRIEND_REQUESTS,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionListResponse> getConnectionSentFriendRequests(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the ID of the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CONNECTIONS = "/api/{version}/consumer/connection/get";
    /**
     * GET /api/{version}/consumer/connection/get : Search Connections
     * Gets the connections.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following) (required)
     * @param sortField sorts the response list by ConnectionApiMap (required)
     * @param descending sorts the response list by descending order if true (required)
     * @param start start index of the pagination (required)
     * @param limit limit of the pagination (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param connectionAccountId optional parameter to search on other account&#39;s connections (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword an optional keyword to search on, this parameter is ignored if empty (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getConnections",
        summary = "Search Connections",
        description = "Gets the connections.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CONNECTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionListResponse> getConnections(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "filter", description = "a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = true) String filter,
        @NotNull @Parameter(name = "sortField", description = "sorts the response list by ConnectionApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "sorts the response list by descending order if true", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "start index of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "optional parameter to search on other account's connections", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "an optional keyword to search on, this parameter is ignored if empty", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CREATIVE = "/api/{version}/creative/get";
    /**
     * GET /api/{version}/creative/get : Get Creative
     * Get a creative
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param creativeId the ID of the creative to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCreative",
        summary = "Get Creative",
        description = "Get a creative",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CreativeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CREATIVE,
        produces = { "*/*" }
    )
    default ResponseEntity<CreativeResponse> getCreative(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "creativeId", description = "the ID of the creative to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = true) Long creativeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CREATIVES_BY_APPLICATION = "/api/{version}/creative/search";
    /**
     * GET /api/{version}/creative/search : Search Creatives
     * Get a list of levels for an application, just those the account has permissions to view.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey the application key (required)
     * @param start Start the result set at some index. (required)
     * @param limit Limit the result to some number. (required)
     * @param missionId Creatives contained in the provided mission. (optional)
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCreativesByApplication",
        summary = "Search Creatives",
        description = "Get a list of levels for an application, just those the account has permissions to view.",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = CreativeResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CREATIVES_BY_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<List<CreativeResponse>> getCreativesByApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "start", description = "Start the result set at some index.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "Limit the result to some number.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "missionId", description = "Creatives contained in the provided mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "keyword", description = "Match the keyword to the owner name or level name.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CREDENTIAL = "/api/{version}/thirdparty/credential/get";
    /**
     * POST /api/{version}/thirdparty/credential/get : Get Credential
     * Gets the account information given a third party token.
     *
     * @param version  (required)
     * @param networkUID the access provider to authenticate against (required)
     * @param appKey the application key (required)
     * @param accountId the unique account id of a specific account that will be bound to the third-party credentials (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyCredentialId the third-party credentials id from the response of the credential/create step (optional)
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartySecret the secret code to authenticate with (used for MFA) (optional)
     * @param createNewAccount flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @param referralAccountId account id of the referrer (inviter-invitee relationship) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCredential",
        summary = "Get Credential",
        description = "Gets the account information given a third party token.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GET_CREDENTIAL,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> getCredential(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "networkUID", description = "the access provider to authenticate against", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "accountId", description = "the unique account id of a specific account that will be bound to the third-party credentials", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "sessionId", description = "the session id for the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sessionId", required = false) @Nullable String sessionId,
        @Parameter(name = "thirdPartyCredentialId", description = "the third-party credentials id from the response of the credential/create step", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyCredentialId", required = false) @Nullable Long thirdPartyCredentialId,
        @Parameter(name = "thirdPartyToken", description = "the access token to authenticate with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyToken", required = false) @Nullable String thirdPartyToken,
        @Parameter(name = "thirdPartySecret", description = "the secret code to authenticate with (used for MFA)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartySecret", required = false) @Nullable String thirdPartySecret,
        @Parameter(name = "createNewAccount", description = "flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createNewAccount", required = false, defaultValue = "false") Boolean createNewAccount,
        @Parameter(name = "responseFilters", description = "this determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false) @Nullable String responseFilters,
        @Parameter(name = "latitude", description = "the latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "audienceIdsToAdd", description = "audience ids to add to the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "audience ids to remove from the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove,
        @Parameter(name = "referralAccountId", description = "account id of the referrer (inviter-invitee relationship)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referralAccountId", required = false) @Nullable Long referralAccountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_CRYPTO_BALANCE = "/api/{version}/billing/crypto/get";
    /**
     * GET /api/{version}/billing/crypto/get : Get Crypto Balances
     * Get the cypto balance details for a user
     *
     * @param version  (required)
     * @param accountId The account used to perform the the request (required)
     * @param ownerAccountId The account to retreive balances for (optional)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getCryptoBalance",
        summary = "Get Crypto Balances",
        description = "Get the cypto balance details for a user",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_CRYPTO_BALANCE,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> getCryptoBalance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "ownerAccountId", description = "The account to retreive balances for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerAccountId", required = false) @Nullable Long ownerAccountId,
        @Parameter(name = "paymentMethodId", description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DATA = "/api/{version}/object/data/{objectName}/{objectId}";
    /**
     * GET /api/{version}/object/data/{objectName}/{objectId} : Get Data
     * Get a specific record from a specified object.
     *
     * @param version  (required)
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @param include  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getData",
        summary = "Get Data",
        description = "Get a specific record from a specified object.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> getData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "include", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "include", required = false) @Nullable String include
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DEPENDENTS = "/api/{version}/cargo/dependent/{accountId}";
    /**
     * GET /api/{version}/cargo/dependent/{accountId} : Get dependent list of an account
     * Get the dependent list of an account
     *
     * @param version  (required)
     * @param accountId the id of the parent account to get a list of dependents (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getDependents",
        summary = "Get dependent list of an account",
        description = "Get the dependent list of an account",
        tags = { "Dependent" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_DEPENDENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getDependents(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the parent account to get a list of dependents", required = true, in = ParameterIn.PATH) @PathVariable("accountId") Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DEVICES = "/api/{version}/audience/devices";
    /**
     * GET /api/{version}/audience/devices : Get Devices
     * Gets the list of available devices that can be selected by consumers and retailers.
     *
     * @param version  (required)
     * @param includeInactive If true return inactive record as well. default is false. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getDevices",
        summary = "Get Devices",
        description = "Gets the list of available devices that can be selected by consumers and retailers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AudienceDeviceResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_DEVICES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AudienceDeviceResponse>> getDevices(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "includeInactive", description = "If true return inactive record as well. default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = true) Boolean includeInactive
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DISBURSEMENT = "/api/{version}/disbursement/get";
    /**
     * GET /api/{version}/disbursement/get : Get Disbursement
     * Get Disbursement details
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param disbursementId the id of the disbursement (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getDisbursement",
        summary = "Get Disbursement",
        description = "Get Disbursement details",
        tags = { "Disbursement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DisbursementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_DISBURSEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<DisbursementResponse> getDisbursement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "disbursementId", description = "the id of the disbursement", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "disbursementId", required = true) Long disbursementId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EMOTION = "/api/{version}/orson/ai/emotion/{requestId}";
    /**
     * GET /api/{version}/orson/ai/emotion/{requestId} : Get Emotion Results
     * Checks the Emotion analysis and returns in progress, results, or error.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getEmotion",
        summary = "Get Emotion Results",
        description = "Checks the Emotion analysis and returns in progress, results, or error.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiEmotionsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_EMOTION,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiEmotionsResponse> getEmotion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EMPLOYEE = "/api/{version}/employee/get";
    /**
     * POST /api/{version}/employee/get : Get Employee
     * Get the account record for the account id provided.
     *
     * @param version  (required)
     * @param accountId the id of logged in user (required)
     * @param employeeAccountId the id of the employee account to get (required)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getEmployee",
        summary = "Get Employee",
        description = "Get the account record for the account id provided.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = EmployeeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GET_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<EmployeeResponse> getEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "employeeAccountId", description = "the id of the employee account to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = true) Long employeeAccountId,
        @Parameter(name = "settingsAppKey", description = "Determines whether to return the application settings for the employee for a particular application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "settingsAppKey", required = false) @Nullable String settingsAppKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EPISODE_STATUS = "/api/{version}/orson/stories/episodes/{episodeId}/status";
    /**
     * GET /api/{version}/orson/stories/episodes/{episodeId}/status : Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     *
     * @param version  (required)
     * @param episodeId Episode ID (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getEpisodeStatus",
        summary = "Check episode status",
        description = "Gets a summary of the episode's status, including any renders.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonEpisodeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_EPISODE_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonEpisodeResponse> getEpisodeStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "episodeId", description = "Episode ID", required = true, in = ParameterIn.PATH) @PathVariable("episodeId") Long episodeId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EVENT = "/api/{version}/event/get";
    /**
     * GET /api/{version}/event/get : Get Event
     * Get an event.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param eventId The id of the event to return (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getEvent",
        summary = "Get Event",
        description = "Get an event.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_EVENT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferResponse> getEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "eventId", description = "The id of the event to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventId", required = true) Long eventId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EVENT_GUEST_LIST = "/api/{version}/vatom/b/events/guests/get";
    /**
     * GET /api/{version}/vatom/b/events/guests/get : Get Vatom Event Guest List
     * Gets the guest list of an event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomEventId Vatom Event Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getEventGuestList",
        summary = "Get Vatom Event Guest List",
        description = "Gets the guest list of an event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_EVENT_GUEST_LIST
    )
    default ResponseEntity<Void> getEventGuestList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomEventId", description = "Vatom Event Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomEventId", required = true) String vatomEventId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EXPERIENCES = "/api/{version}/audience/experiences";
    /**
     * GET /api/{version}/audience/experiences : Get Experiences
     * Gets the list of available experiences that can be selected by consumers and retailers.
     *
     * @param version  (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getExperiences",
        summary = "Get Experiences",
        description = "Gets the list of available experiences that can be selected by consumers and retailers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_EXPERIENCES,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getExperiences(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_FAVORITE = "/api/{version}/favorite/get";
    /**
     * GET /api/{version}/favorite/get : Get Favorite
     * Retrieves a single favorited item.
     *
     * @param version  (required)
     * @param favoriteId The ID of the favorite reference record (required)
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getFavorite",
        summary = "Get Favorite",
        description = "Retrieves a single favorited item.",
        tags = { "Favorite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WrappedResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_FAVORITE,
        produces = { "*/*" }
    )
    default ResponseEntity<WrappedResponse> getFavorite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "favoriteId", description = "The ID of the favorite reference record", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoriteId", required = true) Long favoriteId,
        @Parameter(name = "deviceId", description = "The unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_FILTER = "/api/{version}/filter/get";
    /**
     * GET /api/{version}/filter/get : Get Filter
     * Get the details of a specific filter. Recursively include all child filters and their children.
     *
     * @param version  (required)
     * @param filterId the id of the filter to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getFilter",
        summary = "Get Filter",
        description = "Get the details of a specific filter. Recursively include all child filters and their children.",
        tags = { "Filter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = FilterTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_FILTER,
        produces = { "*/*" }
    )
    default ResponseEntity<FilterTreeResponse> getFilter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "filterId", description = "the id of the filter to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterId", required = true) Long filterId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_FLAG = "/api/{version}/flag/get";
    /**
     * GET /api/{version}/flag/get : Get Flag
     * Gets the details on whether the user has flagged a particular flagable object.
     *
     * @param version  (required)
     * @param flagableType The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER} (required)
     * @param flagableId The flagable object id (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getFlag",
        summary = "Get Flag",
        description = "Gets the details on whether the user has flagged a particular flagable object.",
        tags = { "Flag" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = FlagResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_FLAG,
        produces = { "*/*" }
    )
    default ResponseEntity<FlagResponse> getFlag(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "flagableType", description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableType", required = true) String flagableType,
        @NotNull @Parameter(name = "flagableId", description = "The flagable object id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagableId", required = true) Long flagableId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_FLAG_THRESHOLD = "/api/{version}/flag/threshold/get";
    /**
     * GET /api/{version}/flag/threshold/get : Get Flag Threshold
     * Get the flag threshold value on an object type for a particular application.
     *
     * @param version  (required)
     * @param itemBeingFlaggedType The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE} (required)
     * @param appKey The application key (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getFlagThreshold",
        summary = "Get Flag Threshold",
        description = "Get the flag threshold value on an object type for a particular application.",
        tags = { "Flag" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CountResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_FLAG_THRESHOLD,
        produces = { "*/*" }
    )
    default ResponseEntity<CountResponse> getFlagThreshold(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "itemBeingFlaggedType", description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "itemBeingFlaggedType", required = true) String itemBeingFlaggedType,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GAME = "/api/{version}/game/get";
    /**
     * GET /api/{version}/game/get : Get a Game by id
     * Get a Game by id.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param gameId the updating game&#39;s id. (required)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGame",
        summary = "Get a Game by id",
        description = "Get a Game by id.",
        tags = { "Game" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GAME,
        produces = { "*/*" }
    )
    default ResponseEntity<GameResponse> getGame(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "gameId", description = "the updating game's id.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = true) Long gameId,
        @Parameter(name = "includeGameData", description = "If true include the game level data, otherwise don't. default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GAME_LEVEL = "/api/{version}/level/get";
    /**
     * GET /api/{version}/level/get : Get Game Level
     * Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param levelId The id of the level to return. (required)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGameLevel",
        summary = "Get Game Level",
        description = "Get a game level. The level and account must be valid and have the appropirate permissions to view the content.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameLevelResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GAME_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<GameLevelResponse> getGameLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "levelId", description = "The id of the level to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @Parameter(name = "includeGameData", description = "If true include the game level data, otherwise don't. default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GAME_LEVELS_BY_APPLICATION = "/api/{version}/level/search";
    /**
     * GET /api/{version}/level/search : Search Game Levels
     * Get a list of levels for an application, just those the account has permissions to view.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey the application key (required)
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @param sortField what field to sort on (optional)
     * @param descending whether to return levels in ascending or descending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param appVersion The maximum version of the level to return. (optional)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @param filters  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGameLevelsByApplication",
        summary = "Search Game Levels",
        description = "Get a list of levels for an application, just those the account has permissions to view.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameLevelListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GAME_LEVELS_BY_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<GameLevelListResponse> getGameLevelsByApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "keyword", description = "Match the keyword to the owner name or level name.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "what field to sort on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "whether to return levels in ascending or descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "appVersion", description = "The maximum version of the level to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "includeGameData", description = "If true include the game level data, otherwise don't. default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "filters", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filters", required = false) @Nullable String filters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GAME_LEVELS_BY_BILLABLE_ENTITY = "/api/{version}/level/searchByBillableEntity";
    /**
     * GET /api/{version}/level/searchByBillableEntity : Search Game Level by Billable Entity
     * Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param appKey the application key (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param activeOnly Return only active results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGameLevelsByBillableEntity",
        summary = "Search Game Level by Billable Entity",
        description = "Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameLevelResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GAME_LEVELS_BY_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<GameLevelResponse> getGameLevelsByBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The column to sort the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Long limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GROUP_DETAILS = "/api/{version}/consumer/connection/group/details/get";
    /**
     * GET /api/{version}/consumer/connection/group/details/get : Get Connection Group
     *
     * @param version  (required)
     * @param combineConnections whether to combine connections or not (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param groupId the group id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGroupDetails",
        summary = "Get Connection Group",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionGroupResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GROUP_DETAILS,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionGroupResponse> getGroupDetails(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "combineConnections", description = "whether to combine connections or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "combineConnections", required = true) Boolean combineConnections,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "groupId", description = "the group id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = false) @Nullable Long groupId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GROUPED_AUDIENCES = "/api/{version}/audience/grouped/get";
    /**
     * GET /api/{version}/audience/grouped/get : Get GroupedAudiences
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param audienceGroupingId The audience grouping id to return. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGroupedAudiences",
        summary = "Get GroupedAudiences",
        description = "Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_GROUPED_AUDIENCES,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> getGroupedAudiences(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceGroupingId", description = "The audience grouping id to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceGroupingId", required = true) String audienceGroupingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_HISTORICAL_RANKINGS = "/api/{version}/ranking/historical/search";
    /**
     * GET /api/{version}/ranking/historical/search : Search Historical Rankings
     * Get historical leaderboard rankings by time-frame.
     *
     * @param version  (required)
     * @param appKey the application key for filtering results by application (required)
     * @param rankType the rank type to return (required)
     * @param startDate timestamp in milliseconds to filter results with (required)
     * @param endDate timestamp in milliseconds to filter results with (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to TOTAL)
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getHistoricalRankings",
        summary = "Search Historical Rankings",
        description = "Get historical leaderboard rankings by time-frame.",
        tags = { "Ranking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RankFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_HISTORICAL_RANKINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<RankFullResponse> getHistoricalRankings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key for filtering results by application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "rankType", description = "the rank type to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = true) String rankType,
        @NotNull @Parameter(name = "startDate", description = "timestamp in milliseconds to filter results with", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = true) Long startDate,
        @NotNull @Parameter(name = "endDate", description = "timestamp in milliseconds to filter results with", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = true) Long endDate,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "sortField", description = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") String sortField,
        @Parameter(name = "descending", description = "determines whether to return results in ascending or descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_INVENTORY = "/api/{version}/vatom/me/inventory";
    /**
     * GET /api/{version}/vatom/me/inventory : Get Vatom User&#39;s Inventory
     * Gets the logged in user&#39;s Vatom Inventory.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getInventory",
        summary = "Get Vatom User's Inventory",
        description = "Gets the logged in user's Vatom Inventory.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_INVENTORY
    )
    default ResponseEntity<Void> getInventory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_INVITE = "/api/{version}/invite/get";
    /**
     * GET /api/{version}/invite/get : Get Invite
     * This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.
     *
     * @param version  (required)
     * @param accountId Account ID of the user if they are logged in (optional)
     * @param token the invite token (optional)
     * @param albumId album id to match the invite against (if applicable) (optional)
     * @param missionId mission id to match the invite against (if applicable) (optional)
     * @param albumContestId album contest id to match the invite against (if applicable) (optional)
     * @param offerId offer id to match the invite against (if applicable) (optional)
     * @param offerLocationId offer location id to match the invite against (if applicable) (optional)
     * @param retailerLocationId retailer location id to match the invite against (if applicable) (optional)
     * @param appKey the application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getInvite",
        summary = "Get Invite",
        description = "This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "Account ID of the user if they are logged in", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "token", description = "the invite token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = false) @Nullable String token,
        @Parameter(name = "albumId", description = "album id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "missionId", description = "mission id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "albumContestId", description = "album contest id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = false) @Nullable Long albumContestId,
        @Parameter(name = "offerId", description = "offer id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "offer location id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "retailerLocationId", description = "retailer location id to match the invite against (if applicable)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_LEADERBOARD = "/api/{version}/leaderboard/get";
    /**
     * GET /api/{version}/leaderboard/get : Read a leaderboard by id and retrieve the matching ranking list
     * Read a leaderboard by id and retrieve the matching ranking list
     *
     * @param version  (required)
     * @param leaderboardId The leaderboard id. (required)
     * @param accountId A valid account. (optional)
     * @param includeFullRankingList set to true if need to return the leaderboard&#39;s full ranking list (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getLeaderboard",
        summary = "Read a leaderboard by id and retrieve the matching ranking list",
        description = "Read a leaderboard by id and retrieve the matching ranking list",
        tags = { "Leaderboard" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LeaderboardResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_LEADERBOARD,
        produces = { "*/*" }
    )
    default ResponseEntity<LeaderboardResponse> getLeaderboard(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "leaderboardId", description = "The leaderboard id.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardId", required = true) Long leaderboardId,
        @Parameter(name = "accountId", description = "A valid account.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "includeFullRankingList", description = "set to true if need to return the leaderboard's full ranking list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFullRankingList", required = false) @Nullable Boolean includeFullRankingList
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_LISTING = "/api/{version}/listing/get";
    /**
     * GET /api/{version}/listing/get : Get Listing
     * Get a listing by id.
     *
     * @param version  (required)
     * @param listingId the id of the listing to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getListing",
        summary = "Get Listing",
        description = "Get a listing by id.",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListingFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<ListingFullResponse> getListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "listingId", description = "the id of the listing to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = true) Long listingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_LOCATION_BY_IP = "/api/{version}/location/ip";
    /**
     * GET /api/{version}/location/ip : Get Location by IP
     * Get location information based on an IP address.
     *
     * @param version  (required)
     * @param ip the ip address of the client device (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getLocationByIp",
        summary = "Get Location by IP",
        description = "Get location information based on an IP address.",
        tags = { "Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CoordsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_LOCATION_BY_IP,
        produces = { "*/*" }
    )
    default ResponseEntity<CoordsResponse> getLocationByIp(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "ip", description = "the ip address of the client device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ip", required = false) @Nullable String ip
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_LOCATION_BY_TRILATERATION = "/api/{version}/account/location/trilaterate";
    /**
     * GET /api/{version}/account/location/trilaterate : Get Location by Trilateration
     * Send in device data and calculate a position based on signal strengths.
     *
     * @param version  (required)
     * @param accountId The account making the request, if provided the last know location will be updated (optional)
     * @param latitude The known GPS latitude to compare to the calculated version (optional)
     * @param longitude The known GPS longitude to compare to the calculated version (optional)
     * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param responseFilters Optional response filters (not used currently) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getLocationByTrilateration",
        summary = "Get Location by Trilateration",
        description = "Send in device data and calculate a position based on signal strengths.",
        tags = { "Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GeoPointResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_LOCATION_BY_TRILATERATION,
        produces = { "*/*" }
    )
    default ResponseEntity<GeoPointResponse> getLocationByTrilateration(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account making the request, if provided the last know location will be updated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The known GPS latitude to compare to the calculated version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The known GPS longitude to compare to the calculated version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "data", description = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = false) @Nullable String data,
        @Parameter(name = "responseFilters", description = "Optional response filters (not used currently)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false) @Nullable String responseFilters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_LOCATIONS = "/api/{version}/location/search";
    /**
     * GET /api/{version}/location/search : Search Regions or Postal Codes
     * Searches geographic locations by proximity via address or keyword.
     *
     * @param version  (required)
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param currentlatitude This parameter is deprecated. (optional)
     * @param currentlongitude This parameter is deprecated. (optional)
     * @param currentLatitude the current latitude of the user (optional)
     * @param currentLongitude the current longitude of the user (optional)
     * @param query the query results by keyword or address (optional)
     * @param zipcode This parameter is deprecated. (optional)
     * @param zipCode the zip code to filter results (optional)
     * @param selectedMaplatitude This parameter is deprecated. (optional)
     * @param selectedMaplongitude This parameter is deprecated. (optional)
     * @param selectedMapLatitude the latitude of where the search should originate from (optional)
     * @param selectedMapLongitude the longitude of where the search should originate from (optional)
     * @param searchRange the search range of the search in miles (optional, default to 5)
     * @param useGeocode determines whether to allow searches via address (optional, default to false)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getLocations",
        summary = "Search Regions or Postal Codes",
        description = "Searches geographic locations by proximity via address or keyword.",
        tags = { "Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LocationSearchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<LocationSearchResponse> getLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "currentlatitude", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentlatitude", required = false) @Nullable Double currentlatitude,
        @Parameter(name = "currentlongitude", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentlongitude", required = false) @Nullable Double currentlongitude,
        @Parameter(name = "currentLatitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentLatitude", required = false) @Nullable Double currentLatitude,
        @Parameter(name = "currentLongitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentLongitude", required = false) @Nullable Double currentLongitude,
        @Parameter(name = "query", description = "the query results by keyword or address", in = ParameterIn.QUERY) @Valid @RequestParam(value = "query", required = false) @Nullable String query,
        @Parameter(name = "zipcode", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "zipCode", description = "the zip code to filter results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipCode", required = false) @Nullable String zipCode,
        @Parameter(name = "selectedMaplatitude", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "selectedMaplatitude", required = false) @Nullable Double selectedMaplatitude,
        @Parameter(name = "selectedMaplongitude", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "selectedMaplongitude", required = false) @Nullable Double selectedMaplongitude,
        @Parameter(name = "selectedMapLatitude", description = "the latitude of where the search should originate from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "selectedMapLatitude", required = false) @Nullable Double selectedMapLatitude,
        @Parameter(name = "selectedMapLongitude", description = "the longitude of where the search should originate from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "selectedMapLongitude", required = false) @Nullable Double selectedMapLongitude,
        @Parameter(name = "searchRange", description = "the search range of the search in miles", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5") Double searchRange,
        @Parameter(name = "useGeocode", description = "determines whether to allow searches via address", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useGeocode", required = false, defaultValue = "false") Boolean useGeocode,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_MEDIA = "/api/{version}/media/get";
    /**
     * GET /api/{version}/media/get : Media Get
     * Get a media offering.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param mediaId the id of the media to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getMedia",
        summary = "Media Get",
        description = "Get a media offering.",
        tags = { "Media" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MediaOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_MEDIA,
        produces = { "*/*" }
    )
    default ResponseEntity<MediaOfferResponse> getMedia(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "mediaId", description = "the id of the media to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaId", required = true) Long mediaId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_MISSION = "/api/{version}/mission/get";
    /**
     * GET /api/{version}/mission/get : Get Mission
     * Get a mission.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param missionId The id of the mission to return. (required)
     * @param returnCreative Return creatives associated with the mission when true (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getMission",
        summary = "Get Mission",
        description = "Get a mission.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_MISSION,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> getMission(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "The id of the mission to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @Parameter(name = "returnCreative", description = "Return creatives associated with the mission when true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnCreative", required = false) @Nullable Boolean returnCreative
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_MISSION_INVITE = "/api/{version}/mission/invite/get";
    /**
     * GET /api/{version}/mission/invite/get : Get Mission Invite
     * Get the mission invite. An account can only be invited to a mission one time.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param missionId The mission to find the invite for (missionId or missionInviteId requried). (optional)
     * @param missionInviteId The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @param includeScores include the scores with the mission (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getMissionInvite",
        summary = "Get Mission Invite",
        description = "Get the mission invite. An account can only be invited to a mission one time.",
        tags = { "Mission Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_MISSION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> getMissionInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "missionId", description = "The mission to find the invite for (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "missionInviteId", description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionInviteId", required = false) @Nullable Long missionInviteId,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeScores", description = "include the scores with the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeScores", required = false) @Nullable String includeScores
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_MY_FOLLOWING = "/api/{version}/vatom/me/rels/following";
    /**
     * GET /api/{version}/vatom/me/rels/following : Get following
     * Get following.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getMyFollowing",
        summary = "Get following",
        description = "Get following.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_MY_FOLLOWING
    )
    default ResponseEntity<Void> getMyFollowing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NETWORK = "/api/{version}/thirdparty/network/get";
    /**
     * GET /api/{version}/thirdparty/network/get : Get Network
     * Get the details of a third party network. Only the network owners and managers have access to this.
     *
     * @param version  (required)
     * @param accountId The account id making the request (required)
     * @param networkUID The unique identifier for the third party network defined by Sirqul (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNetwork",
        summary = "Get Network",
        description = "Get the details of a third party network. Only the network owners and managers have access to this.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ThirdPartyNetworkResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_NETWORK,
        produces = { "*/*" }
    )
    default ResponseEntity<ThirdPartyNetworkResponse> getNetwork(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "networkUID", description = "The unique identifier for the third party network defined by Sirqul", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NOTE = "/api/{version}/note/get";
    /**
     * POST /api/{version}/note/get : Get Note
     * Get for a note based on its Id.
     *
     * @param version  (required)
     * @param noteId the id of the note to get (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for the item (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNote",
        summary = "Get Note",
        description = "Get for a note based on its Id.",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GET_NOTE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getNote(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "noteId", description = "the id of the note to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteId", required = true) Long noteId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "returnFullResponse", description = "Determines whether to return the NoteFullResponse for the item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false) @Nullable Boolean returnFullResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NOTIFICATION_TEMPLATE = "/api/{version}/notification/template/get";
    /**
     * GET /api/{version}/notification/template/get : Get Notification Template
     * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param notificationTemplateId the id of the notification template to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNotificationTemplate",
        summary = "Get Notification Template",
        description = "Get the details of a notification template. Developers will only be able to see notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> getNotificationTemplate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "the id of the notification template to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NOTIFICATIONS = "/api/{version}/notification/search";
    /**
     * GET /api/{version}/notification/search : Get Notifications
     * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
     *
     * @param version  (required)
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account id used to view another person&#39;s notifications (optional)
     * @param appKey the application key to filter messages by application (optional)
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
     * @param contentIds comma separated list of content ids to search notifications on (optional)
     * @param contentTypes comma separated list of content types to search notifications on (optional)
     * @param parentIds comma separated list of parent ids to search notifications on (optional)
     * @param parentTypes comma separated list of parent types to search notifications on (optional)
     * @param actionCategory Action category used to filter notifications (optional)
     * @param conduits comma separated list of conduits to search notifications on (optional)
     * @param keyword search notifications via keyword (optional)
     * @param returnReadMessages if set to true, will return notifications that have been marked as read (optional)
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
     * @param fromDate filter notifications from this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @param returnSent whether to include notifications sent by the requester in the response (optional)
     * @param ignoreFlagged whether to ignore flagged notifications (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNotifications",
        summary = "Get Notifications",
        description = "Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationMessageListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationMessageListResponse> getNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "the account id used to view another person's notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "appKey", description = "the application key to filter messages by application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "eventType", description = "comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false) @Nullable String eventType,
        @Parameter(name = "contentIds", description = "comma separated list of content ids to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "contentTypes", description = "comma separated list of content types to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "parentIds", description = "comma separated list of parent ids to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "parentTypes", description = "comma separated list of parent types to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentTypes", required = false) @Nullable String parentTypes,
        @Parameter(name = "actionCategory", description = "Action category used to filter notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionCategory", required = false) @Nullable String actionCategory,
        @Parameter(name = "conduits", description = "comma separated list of conduits to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduits", required = false) @Nullable String conduits,
        @Parameter(name = "keyword", description = "search notifications via keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "returnReadMessages", description = "if set to true, will return notifications that have been marked as read", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnReadMessages", required = false) @Nullable Boolean returnReadMessages,
        @Parameter(name = "markAsRead", description = "if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent", in = ParameterIn.QUERY) @Valid @RequestParam(value = "markAsRead", required = false) @Nullable Boolean markAsRead,
        @Parameter(name = "fromDate", description = "filter notifications from this date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fromDate", required = false) @Nullable Long fromDate,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnSent", description = "whether to include notifications sent by the requester in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnSent", required = false) @Nullable Boolean returnSent,
        @Parameter(name = "ignoreFlagged", description = "whether to ignore flagged notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ignoreFlagged", required = false) @Nullable Boolean ignoreFlagged,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OBJECT = "/api/{version}/object/get";
    /**
     * GET /api/{version}/object/get : Get Object
     * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to get the definition for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getObject",
        summary = "Get Object",
        description = "Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> getObject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to get the definition for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER = "/api/{version}/retailer/offer/get";
    /**
     * GET /api/{version}/retailer/offer/get : Get Offer
     * Gets the details of an offer that the user has access to.
     *
     * @param version  (required)
     * @param offerId The id of the offer (required)
     * @param includeOfferLocations  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOffer",
        summary = "Get Offer",
        description = "Gets the details of an offer that the user has access to.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerOfferResponse> getOffer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerId", description = "The id of the offer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = true) Long offerId,
        @NotNull @Parameter(name = "includeOfferLocations", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeOfferLocations", required = true) Boolean includeOfferLocations,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_DETAILS = "/api/{version}/offer/get";
    /**
     * GET /api/{version}/offer/get : Get Offer
     * Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.
     *
     * @param version  (required)
     * @param deviceId The device id for returning account information (i.e. favorites) (optional)
     * @param accountId The account id for returning account information (i.e. favorites) (optional)
     * @param offerId The offer id (either offeLocationId or offerId must be provided) (optional)
     * @param offerLocationId The offer location id (either offeLocationId or offerId must be provided) (optional)
     * @param distance The distance of the offer from the user&#39;s current location (this is returned when the offer is searched) (optional)
     * @param latitude The latitude to calculate distance from the offer (optional)
     * @param longitude The longitude to calculate distance from the offer (optional)
     * @param includeOfferLocations Determines whether to return offer locations for the offer (optional, default to false)
     * @param includeRetailerLocations Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work) (optional, default to false)
     * @param includeChildOffers Determines whether to include child offers in the response (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferDetails",
        summary = "Get Offer",
        description = "Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_DETAILS,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferResponse> getOfferDetails(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id for returning account information (i.e. favorites)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id for returning account information (i.e. favorites)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "offerId", description = "The offer id (either offeLocationId or offerId must be provided)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "The offer location id (either offeLocationId or offerId must be provided)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "distance", description = "The distance of the offer from the user's current location (this is returned when the offer is searched)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distance", required = false) @Nullable Double distance,
        @Parameter(name = "latitude", description = "The latitude to calculate distance from the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The longitude to calculate distance from the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "includeOfferLocations", description = "Determines whether to return offer locations for the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeOfferLocations", required = false, defaultValue = "false") Boolean includeOfferLocations,
        @Parameter(name = "includeRetailerLocations", description = "Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRetailerLocations", required = false, defaultValue = "false") Boolean includeRetailerLocations,
        @Parameter(name = "includeChildOffers", description = "Determines whether to include child offers in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeChildOffers", required = false, defaultValue = "false") Boolean includeChildOffers
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_LIST_COUNTS = "/api/{version}/offer/lists/count";
    /**
     * GET /api/{version}/offer/lists/count : Get Offers (Counts)
     * Gets the offer list counts.
     *
     * @param version  (required)
     * @param latitude The latitude of where the search will center at (required)
     * @param longitude The longitude of where the search will center at (required)
     * @param searchRange The range of the search (optional, default to 5)
     * @param distanceUnit The units to use for distance calculations (e.g. MILES, KILOMETERS) (optional, default to MILES)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferListCounts",
        summary = "Get Offers (Counts)",
        description = "Gets the offer list counts.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListCountResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_LIST_COUNTS,
        produces = { "*/*" }
    )
    default ResponseEntity<ListCountResponse> getOfferListCounts(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "latitude", description = "The latitude of where the search will center at", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "The longitude of where the search will center at", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @Parameter(name = "searchRange", description = "The range of the search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5") BigDecimal searchRange,
        @Parameter(name = "distanceUnit", description = "The units to use for distance calculations (e.g. MILES, KILOMETERS)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") String distanceUnit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_LOCATION = "/api/{version}/offer/location/get";
    /**
     * GET /api/{version}/offer/location/get : Get Offer Location
     * Gets the offer location by offer location id or udid (of a device)
     *
     * @param version  (required)
     * @param offerLocationId the id of the offer location to get (optional)
     * @param udid the UDID of the device (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferLocation",
        summary = "Get Offer Location",
        description = "Gets the offer location by offer location id or udid (of a device)",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferShortResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_LOCATION,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferShortResponse> getOfferLocation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "offerLocationId", description = "the id of the offer location to get", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "udid", description = "the UDID of the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_LOCATIONS_FOR_RETAILERS = "/api/{version}/retailer/offer/location/search";
    /**
     * GET /api/{version}/retailer/offer/location/search : Search Offer Locations
     * Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.
     *
     * @param version  (required)
     * @param sortField The column to sort the results on. Default is \&quot;TITLE\&quot;, which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (required)
     * @param start The index into the record set to start with. Default is 0. (required)
     * @param limit The total number of records to return. Default is 20. (required)
     * @param activeOnly Determines whether to return only active results. Default is false. (required)
     * @param includeRetailerLocation  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerId Filter results for a specific retailer (optional)
     * @param retailerLocationId Filter results for a specific retailer location (optional)
     * @param offerType Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
     * @param specialOfferType Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
     * @param barcodeType  (optional)
     * @param barcodeEntry  (optional)
     * @param isbn  (optional)
     * @param asin  (optional)
     * @param deviceStatus Edysen device status, running, warning, or down (optional)
     * @param needsNotificationSent  (optional)
     * @param lastNotificationSent  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferLocationsForRetailers",
        summary = "Search Offer Locations",
        description = "Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_LOCATIONS_FOR_RETAILERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferShortResponse>> getOfferLocationsForRetailers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the results. Default is false, which will return the results in ascending order.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The index into the record set to start with. Default is 0.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The total number of records to return. Default is 20.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "includeRetailerLocation", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRetailerLocation", required = true) Boolean includeRetailerLocation,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "Filter results for a specific retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Filter results for a specific retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "offerType", description = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = false) @Nullable String offerType,
        @Parameter(name = "specialOfferType", description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "barcodeType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = false) @Nullable String barcodeType,
        @Parameter(name = "barcodeEntry", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "isbn", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "deviceStatus", description = "Edysen device status, running, warning, or down", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceStatus", required = false) @Nullable String deviceStatus,
        @Parameter(name = "needsNotificationSent", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "needsNotificationSent", required = false) @Nullable Boolean needsNotificationSent,
        @Parameter(name = "lastNotificationSent", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastNotificationSent", required = false) @Nullable Long lastNotificationSent
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_TRANSACTION = "/api/{version}/wallet/get";
    /**
     * GET /api/{version}/wallet/get : Get Wallet Offer
     *
     * @param version  (required)
     * @param transactionId The offer transaction id to get details of (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param includeMission If true then include mission data, false to not include (optional, default to false)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferTransaction",
        summary = "Get Wallet Offer",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferTransactionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferTransactionResponse> getOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "transactionId", description = "The offer transaction id to get details of", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionId", required = true) Long transactionId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "includeMission", description = "If true then include mission data, false to not include", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeMission", required = false, defaultValue = "false") Boolean includeMission,
        @Parameter(name = "latitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnFullResponse", description = "Determines whether to return a detailed version of the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "true") Boolean returnFullResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFER_TRANSACTION_STATUS = "/api/{version}/offer/status/get";
    /**
     * GET /api/{version}/offer/status/get : Get Offer Status
     * Get an offer status record
     *
     * @param version  (required)
     * @param statusId The id of the record to get  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOfferTransactionStatus",
        summary = "Get Offer Status",
        description = "Get an offer status record",
        tags = { "Offer Status" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferTransactionStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFER_TRANSACTION_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferTransactionStatusResponse> getOfferTransactionStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "statusId", description = "The id of the record to get ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "statusId", required = true) Long statusId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OFFERS_FOR_RETAILERS = "/api/{version}/retailer/offer/search";
    /**
     * GET /api/{version}/retailer/offer/search : Search Offers
     * Searches on offers that the account has access to.
     *
     * @param version  (required)
     * @param offerVisibility  (required)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (required)
     * @param descending The order to return the search results (required)
     * @param start The record to begin the return set on (required)
     * @param limit The number of records to return (required)
     * @param availableOnly Return only results that are currently being promoted (is activated and not expired) (required)
     * @param activeOnly Return only active results (required)
     * @param includeCategories  (required)
     * @param includeFilters  (required)
     * @param includeOfferLocations  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param categoryIds  (optional)
     * @param filterIds  (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerId the id of the retailer (optional)
     * @param retailerLocationId the id of the retailer location (optional)
     * @param couponType This parameter is deprecated. (optional)
     * @param offerType This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
     * @param offerTypes Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE} (optional)
     * @param specialOfferType Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param barcodeType  (optional)
     * @param barcodeEntry  (optional)
     * @param isbn  (optional)
     * @param asin  (optional)
     * @param deviceStatus Edysen device status (optional)
     * @param needsNotificationSent  (optional)
     * @param lastNotificationSent  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOffersForRetailers",
        summary = "Search Offers",
        description = "Searches on offers that the account has access to.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OFFERS_FOR_RETAILERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferResponse>> getOffersForRetailers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerVisibility", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerVisibility", required = true) String offerVisibility,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The record to begin the return set on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The number of records to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "availableOnly", description = "Return only results that are currently being promoted (is activated and not expired)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableOnly", required = true) Boolean availableOnly,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "includeCategories", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCategories", required = true) Boolean includeCategories,
        @NotNull @Parameter(name = "includeFilters", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFilters", required = true) Boolean includeFilters,
        @NotNull @Parameter(name = "includeOfferLocations", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeOfferLocations", required = true) Boolean includeOfferLocations,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "categoryIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "the id of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "the id of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "couponType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "couponType", required = false) @Nullable String couponType,
        @Parameter(name = "offerType", description = "This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = false) @Nullable String offerType,
        @Parameter(name = "offerTypes", description = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerTypes", required = false) @Nullable String offerTypes,
        @Parameter(name = "specialOfferType", description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "barcodeType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = false) @Nullable String barcodeType,
        @Parameter(name = "barcodeEntry", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "isbn", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "deviceStatus", description = "Edysen device status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceStatus", required = false) @Nullable String deviceStatus,
        @Parameter(name = "needsNotificationSent", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "needsNotificationSent", required = false) @Nullable Boolean needsNotificationSent,
        @Parameter(name = "lastNotificationSent", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastNotificationSent", required = false) @Nullable Long lastNotificationSent
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OPTIMIZATION_RESULT = "/api/{version}/optimize/result/{batchID}";
    /**
     * GET /api/{version}/optimize/result/{batchID} : Get Optimization Result
     * Get the results of the import batch.
     *
     * @param version  (required)
     * @param batchID The batchID for getting the import status of. (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOptimizationResult",
        summary = "Get Optimization Result",
        description = "Get the results of the import batch.",
        tags = { "Optimize" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ShipmentOrder.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_OPTIMIZATION_RESULT,
        produces = { "*/*" }
    )
    default ResponseEntity<Map<String, ShipmentOrder>> getOptimizationResult(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "batchID", description = "The batchID for getting the import status of.", required = true, in = ParameterIn.PATH) @PathVariable("batchID") String batchID,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ORDER = "/api/{version}/order/get";
    /**
     * GET /api/{version}/order/get : Get Order
     * Get an order record
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param orderId The order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @param externalOrderId The external order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getOrder",
        summary = "Get Order",
        description = "Get an order record",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ORDER,
        produces = { "*/*" }
    )
    default ResponseEntity<OrderResponse> getOrder(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "orderId", description = "The order id to get details of, either orderId or externalOrderId must be provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderId", required = false) @Nullable Long orderId,
        @Parameter(name = "externalOrderId", description = "The external order id to get details of, either orderId or externalOrderId must be provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalOrderId", required = false) @Nullable String externalOrderId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PACK = "/api/{version}/pack/get";
    /**
     * GET /api/{version}/pack/get : Get Pack
     * Get a pack.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param packId The id of the pack to return. (required)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPack",
        summary = "Get Pack",
        description = "Get a pack.",
        tags = { "Pack" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PackResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PACK,
        produces = { "*/*" }
    )
    default ResponseEntity<PackResponse> getPack(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "packId", description = "The id of the pack to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = true) Long packId,
        @NotNull @Parameter(name = "includeGameData", description = "If true include the game level data, otherwise don't. default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = true) Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PAYMENT_METHOD = "/api/{version}/billing/get";
    /**
     * GET /api/{version}/billing/get : Get Payment Method
     * Get the details of the user&#39;s payment method or their current default method of payment
     *
     * @param version  (required)
     * @param accountId The account used to perform the the request (required)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @param getCurrentBalance Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPaymentMethod",
        summary = "Get Payment Method",
        description = "Get the details of the user's payment method or their current default method of payment",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PAYMENT_METHOD,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> getPaymentMethod(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "paymentMethodId", description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId,
        @Parameter(name = "getCurrentBalance", description = "Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "getCurrentBalance", required = false) @Nullable Boolean getCurrentBalance
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PERSONA_LIST = "/api/{version}/persona/get";
    /**
     * GET /api/{version}/persona/get : Get Persona
     * Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.
     *
     * @param version  (required)
     * @param accountId the account ID of the user (required)
     * @param personaId the persona ID of the persona (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPersonaList",
        summary = "Get Persona",
        description = "Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.",
        tags = { "Preview Persona" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PreviewPersonaResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PERSONA_LIST,
        produces = { "*/*" }
    )
    default ResponseEntity<PreviewPersonaResponse> getPersonaList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "personaId", description = "the persona ID of the persona", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "personaId", required = true) Long personaId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_POINTS_BALANCE = "/api/{version}/vatom/u/campaign/points/get";
    /**
     * GET /api/{version}/vatom/u/campaign/points/get : Get Points Balance
     * Gets the points balance of a Vatom user.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPointsBalance",
        summary = "Get Points Balance",
        description = "Gets the points balance of a Vatom user.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_POINTS_BALANCE
    )
    default ResponseEntity<Void> getPointsBalance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_POINTS_BALANCE_AS_BUSINESS = "/api/{version}/vatom/b/campaign/u/points/get";
    /**
     * GET /api/{version}/vatom/b/campaign/u/points/get : Get Points Balance as Business
     * Gets the points balance of a Vatom user.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPointsBalanceAsBusiness",
        summary = "Get Points Balance as Business",
        description = "Gets the points balance of a Vatom user.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_POINTS_BALANCE_AS_BUSINESS
    )
    default ResponseEntity<Void> getPointsBalanceAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_POSTAL_CODE = "/api/{version}/postalCode/get";
    /**
     * GET /api/{version}/postalCode/get : Get Postal Code
     * Get a Postal Code
     *
     * @param version  (required)
     * @param postalCodeId the id of the postal code to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPostalCode",
        summary = "Get Postal Code",
        description = "Get a Postal Code",
        tags = { "Postal Code" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PostalCodeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_POSTAL_CODE,
        produces = { "*/*" }
    )
    default ResponseEntity<PostalCodeResponse> getPostalCode(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "postalCodeId", description = "the id of the postal code to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCodeId", required = true) Long postalCodeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_POSTAL_CODES = "/api/{version}/postalCode/search";
    /**
     * GET /api/{version}/postalCode/search : Search Postal Codes
     * Get the list of regions. If latitude or longitude is null, will return all postal codes in the system with paginated response.
     *
     * @param version  (required)
     * @param sortField the field to sort the results on (required)
     * @param descending whether to order results in ascending or descending order (required)
     * @param latitude the latitude of the postal code to search on (optional)
     * @param longitude the longitude of the postal code to search on (optional)
     * @param keyword the keyword of the postal code to search on (optional)
     * @param miles how far (in miles) to search on for the postal code (optional)
     * @param start the start of the index and/or pagination (optional)
     * @param limit the limit of the index and/or pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPostalCodes",
        summary = "Search Postal Codes",
        description = "Get the list of regions. If latitude or longitude is null, will return all postal codes in the system with paginated response.",
        tags = { "Postal Code" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = PostalCodeResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_POSTAL_CODES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<PostalCodeResponse>> getPostalCodes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "the field to sort the results on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "whether to order results in ascending or descending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @Parameter(name = "latitude", description = "the latitude of the postal code to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the postal code to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "keyword", description = "the keyword of the postal code to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "miles", description = "how far (in miles) to search on for the postal code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "miles", required = false) @Nullable Double miles,
        @Parameter(name = "start", description = "the start of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "the limit of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PREDICTED_LOCATIONS = "/api/{version}/tracking/predicted/get";
    /**
     * GET /api/{version}/tracking/predicted/get : Get Predicted Locations
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     *
     * @param version  (required)
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPredictedLocations",
        summary = "Get Predicted Locations",
        description = "Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PredictedLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PREDICTED_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<PredictedLocationResponse> getPredictedLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the customer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "latitude", description = "latitude to return a more likely result set based on the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude to return a more likely result set based on the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "dateCheck", description = "Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCheck", required = false) @Nullable Long dateCheck,
        @Parameter(name = "hourCheck", description = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hourCheck", required = false) @Nullable String hourCheck,
        @Parameter(name = "threshold", description = "The minimum number matches in 1 hour to be considered a likely location.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "threshold", required = false, defaultValue = "1") Long threshold,
        @Parameter(name = "distanceUnit", description = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") String distanceUnit,
        @Parameter(name = "searchRange", description = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "0") Double searchRange,
        @Parameter(name = "sortOrder", description = "The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortOrder", required = false, defaultValue = "MATCHES") String sortOrder
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PREDICTED_PATH = "/api/{version}/tracking/path/get";
    /**
     * GET /api/{version}/tracking/path/get : Get Tracking Path
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     *
     * @param version  (required)
     * @param accountId The account id of the customer (required)
     * @param startStepId The stepId to begin from (required)
     * @param endStepId The stepId to end with (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPredictedPath",
        summary = "Get Tracking Path",
        description = "Get the path (lat/long coordinates) between 2 steps previously logged for a customer.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = StepResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PREDICTED_PATH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<StepResponse>> getPredictedPath(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the customer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "startStepId", description = "The stepId to begin from", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startStepId", required = true) Long startStepId,
        @NotNull @Parameter(name = "endStepId", description = "The stepId to end with", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endStepId", required = true) Long endStepId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PREFERRED_LOCATIONS = "/api/{version}/tracking/preferred/search";
    /**
     * GET /api/{version}/tracking/preferred/search : Search Preferred Locations
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     *
     * @param version  (required)
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to PREFERRED_DATE)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPreferredLocations",
        summary = "Search Preferred Locations",
        description = "Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = PreferredLocationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PREFERRED_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<PreferredLocationResponse>> getPreferredLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the customer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "latitude", description = "latitude to return a more likely result set based on the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude to return a more likely result set based on the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "dateCheck", description = "Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCheck", required = false) @Nullable Long dateCheck,
        @Parameter(name = "hourCheck", description = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hourCheck", required = false) @Nullable String hourCheck,
        @Parameter(name = "sortField", description = "Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "PREFERRED_DATE") String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "searchRange", description = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "0") Double searchRange,
        @Parameter(name = "distanceUnit", description = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") String distanceUnit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PROFILE_ASSETS = "/api/{version}/account/profile/assets";
    /**
     * GET /api/{version}/account/profile/assets : Get Profile Assets
     * Get a list of assets a person has ever uploaded. Filters the list based on parameters.
     *
     * @param version  (required)
     * @param returnNulls Determines whether to return null fields in the response (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param ownerId The account id of the person the user wants to view (optional)
     * @param mediaTypes Comma separated list of MediaType (optional)
     * @param mimeTypes Comma separated list of mime types (optional)
     * @param sortField Determines what the returning list will be sorted by (see AssetApiMap) (optional, default to CREATED)
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @param i _i (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l _l (optional)
     * @param limit Limit of the pagination (optional, default to 0)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getProfileAssets",
        summary = "Get Profile Assets",
        description = "Get a list of assets a person has ever uploaded. Filters the list based on parameters.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AssetListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PROFILE_ASSETS,
        produces = { "*/*" }
    )
    default ResponseEntity<AssetListResponse> getProfileAssets(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "returnNulls", description = "Determines whether to return null fields in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "false") Boolean returnNulls,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "ownerId", description = "The account id of the person the user wants to view", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "mediaTypes", description = "Comma separated list of MediaType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaTypes", required = false) @Nullable String mediaTypes,
        @Parameter(name = "mimeTypes", description = "Comma separated list of mime types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mimeTypes", required = false) @Nullable String mimeTypes,
        @Parameter(name = "sortField", description = "Determines what the returning list will be sorted by (see AssetApiMap)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") String sortField,
        @Parameter(name = "descending", description = "Determines whether to return the resulting list in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "latitude", description = "Latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "_i", description = "_i", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "Start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", description = "_l", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "Limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "0") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PROGRAM = "/api/{version}/program/{id}";
    /**
     * GET /api/{version}/program/{id} : Get Program
     * Get an existing program
     *
     * @param version  (required)
     * @param id the id of the program (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getProgram",
        summary = "Get Program",
        description = "Get an existing program",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Program.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PROGRAM,
        produces = { "*/*" }
    )
    default ResponseEntity<Program> getProgram(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the program", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_PURCHASE_ITEM = "/api/{version}/purchase/get";
    /**
     * GET /api/{version}/purchase/get : Get Purchase
     * Get detailed information about a purchase item
     *
     * @param version  (required)
     * @param purchaseItemId The purchase item id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getPurchaseItem",
        summary = "Get Purchase",
        description = "Get detailed information about a purchase item",
        tags = { "Purchase Item" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PurchaseItemFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_PURCHASE_ITEM,
        produces = { "*/*" }
    )
    default ResponseEntity<PurchaseItemFullResponse> getPurchaseItem(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "purchaseItemId", description = "The purchase item id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseItemId", required = true) Long purchaseItemId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_QUESTION = "/api/{version}/game/question/get";
    /**
     * GET /api/{version}/game/question/get : Get Question
     * Get a question by the given id.
     *
     * @param version  (required)
     * @param questionId the id of the question to get (required)
     * @param accountId the id of the account that can make this request (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getQuestion",
        summary = "Get Question",
        description = "Get a question by the given id.",
        tags = { "Question" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QuestionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_QUESTION,
        produces = { "*/*" }
    )
    default ResponseEntity<QuestionResponse> getQuestion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "questionId", description = "the id of the question to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "questionId", required = true) Long questionId,
        @NotNull @Parameter(name = "accountId", description = "the id of the account that can make this request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_QUESTIONS_IN_LEVEL = "/api/{version}/level/questions/get";
    /**
     * GET /api/{version}/level/questions/get : Get Level Questions
     * Get questions within a level.
     *
     * @param version  (required)
     * @param levelId the id of the level to get questions from (required)
     * @param accountId the id of the logged in user (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getQuestionsInLevel",
        summary = "Get Level Questions",
        description = "Get questions within a level.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QuestionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_QUESTIONS_IN_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<QuestionResponse> getQuestionsInLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "levelId", description = "the id of the level to get questions from", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RANKINGS = "/api/{version}/ranking/search";
    /**
     * GET /api/{version}/ranking/search : Search Rankings
     * Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
     *
     * @param version  (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search for (optional)
     * @param rankType a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to POINTS,DOWNLOADS,INVITATIONS)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to GLOBAL)
     * @param withinAccountIds comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
     * @param albumId album id to use when performing CUSTOM filters (optional)
     * @param audienceId audience id to use when performing CUSTOM filters (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to TOTAL)
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRankings",
        summary = "Search Rankings",
        description = "Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.",
        tags = { "Ranking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RankFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RANKINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<RankFullResponse> getRankings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key for filtering results by application (required for non-EXECUTIVE users)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "rankType", description = "a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false, defaultValue = "POINTS,DOWNLOADS,INVITATIONS") String rankType,
        @Parameter(name = "leaderboardMode", description = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId", in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardMode", required = false, defaultValue = "GLOBAL") String leaderboardMode,
        @Parameter(name = "withinAccountIds", description = "comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "withinAccountIds", required = false) @Nullable String withinAccountIds,
        @Parameter(name = "returnUserRank", description = "determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnUserRank", required = false, defaultValue = "true") Boolean returnUserRank,
        @Parameter(name = "albumId", description = "album id to use when performing CUSTOM filters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "audienceId", description = "audience id to use when performing CUSTOM filters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "sortField", description = "determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") String sortField,
        @Parameter(name = "descending", description = "determines whether to return results in ascending or descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_REFERRAL_LIST = "/api/{version}/account/referral/list";
    /**
     * GET /api/{version}/account/referral/list : Search Accounts
     * Gets a user&#39;s account profile and their referral List.
     *
     * @param version  (required)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param retrieveType one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it&#39;s parents, recursively - GET_ALL will get all of the above (optional)
     * @param levelLimit level limit for children and ancestors of current account, starts from current account (optional)
     * @param ancestorLevelLimit level limit for ancestors, will override levelLimit if this is set (optional)
     * @param childrenLevelLimit level limit for children, will override levelLimit if this is set (optional)
     * @param ancestorListStart pagination start for children list (optional)
     * @param ancestorListLimit pagination limit for children list (optional)
     * @param childrenListStart pagination start for children list (optional)
     * @param childrenListLimit pagination limit for children list (optional)
     * @param childrenChildren if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getReferralList",
        summary = "Search Accounts",
        description = "Gets a user's account profile and their referral List.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_REFERRAL_LIST
    )
    default ResponseEntity<Void> getReferralList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "retrieveType", description = "one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retrieveType", required = false) @Nullable String retrieveType,
        @Parameter(name = "levelLimit", description = "level limit for children and ancestors of current account, starts from current account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelLimit", required = false) @Nullable BigDecimal levelLimit,
        @Parameter(name = "ancestorLevelLimit", description = "level limit for ancestors, will override levelLimit if this is set", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ancestorLevelLimit", required = false) @Nullable BigDecimal ancestorLevelLimit,
        @Parameter(name = "childrenLevelLimit", description = "level limit for children, will override levelLimit if this is set", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenLevelLimit", required = false) @Nullable BigDecimal childrenLevelLimit,
        @Parameter(name = "ancestorListStart", description = "pagination start for children list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ancestorListStart", required = false) @Nullable BigDecimal ancestorListStart,
        @Parameter(name = "ancestorListLimit", description = "pagination limit for children list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ancestorListLimit", required = false) @Nullable BigDecimal ancestorListLimit,
        @Parameter(name = "childrenListStart", description = "pagination start for children list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenListStart", required = false) @Nullable BigDecimal childrenListStart,
        @Parameter(name = "childrenListLimit", description = "pagination limit for children list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenListLimit", required = false) @Nullable BigDecimal childrenListLimit,
        @Parameter(name = "childrenChildren", description = "if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenChildren", required = false, defaultValue = "true") Boolean childrenChildren
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_REGION = "/api/{version}/region/get";
    /**
     * GET /api/{version}/region/get : Get Region
     * Get a region.
     *
     * @param version  (required)
     * @param regionId the id of the region to get (required)
     * @param accountId the id of the logged in user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRegion",
        summary = "Get Region",
        description = "Get a region.",
        tags = { "Region" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RegionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_REGION,
        produces = { "*/*" }
    )
    default ResponseEntity<RegionResponse> getRegion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "regionId", description = "the id of the region to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionId", required = true) Long regionId,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RENDER_STATUS = "/api/{version}/orson/stories/renders/{renderId}/status";
    /**
     * GET /api/{version}/orson/stories/renders/{renderId}/status : Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     *
     * @param version  (required)
     * @param renderId Render ID (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRenderStatus",
        summary = "Check episode status",
        description = "Gets a summary of the episode's status, including any renders.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonRenderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RENDER_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonRenderResponse> getRenderStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "renderId", description = "Render ID", required = true, in = ParameterIn.PATH) @PathVariable("renderId") String renderId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_REPORT_BATCH = "/api/{version}/report/batch/get";
    /**
     * GET /api/{version}/report/batch/get : Get Offline Report
     * Checks status of batch report.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param batchId returned by /report/batch/create (required)
     * @param allResults whether to return all batch results or not (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getReportBatch",
        summary = "Get Offline Report",
        description = "Checks status of batch report.",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ReportBatchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_REPORT_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<ReportBatchResponse> getReportBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "batchId", description = "returned by /report/batch/create", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "batchId", required = true) Long batchId,
        @NotNull @Parameter(name = "allResults", description = "whether to return all batch results or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "allResults", required = true) Boolean allResults
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RETAILER = "/api/{version}/retailer/get";
    /**
     * GET /api/{version}/retailer/get : Get Retailer
     * Gets a retailer. Only the owner and the employees of a retailer have access to view its information.
     *
     * @param version  (required)
     * @param retailerId the ID of the retailer (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param includeCounts Determines whether to include counts in the response (default true) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRetailer",
        summary = "Get Retailer",
        description = "Gets a retailer. Only the owner and the employees of a retailer have access to view its information.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RETAILER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerFullResponse> getRetailer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerId", description = "the ID of the retailer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = true) Long retailerId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "includeCounts", description = "Determines whether to include counts in the response (default true)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCounts", required = false) @Nullable Boolean includeCounts
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RETAILER_LOCATION = "/api/{version}/retailer/location/get";
    /**
     * GET /api/{version}/retailer/location/get : Get Retailer Location
     * Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.
     *
     * @param version  (required)
     * @param retailerLocationId The ID of the retailer location (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param retailerLocationToken the unique token of the retailer location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRetailerLocation",
        summary = "Get Retailer Location",
        description = "Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RETAILER_LOCATION,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerLocationResponse> getRetailerLocation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerLocationId", description = "The ID of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = true) Long retailerLocationId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "retailerLocationToken", description = "the unique token of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationToken", required = false) @Nullable String retailerLocationToken
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RETAILER_LOCATION_CONSUMER = "/api/{version}/location/get";
    /**
     * GET /api/{version}/location/get : Get Retailer Location (Consumer)
     * Gets the details of a retailer location as a consumer.
     *
     * @param version  (required)
     * @param retailerLocationId The retailer location id (required)
     * @param deviceId The device id for returning account information (i.e. favorites) (optional)
     * @param accountId The account id for returning account information (i.e. favorites) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRetailerLocationConsumer",
        summary = "Get Retailer Location (Consumer)",
        description = "Gets the details of a retailer location as a consumer.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RETAILER_LOCATION_CONSUMER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerLocationResponse> getRetailerLocationConsumer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerLocationId", description = "The retailer location id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = true) Long retailerLocationId,
        @Parameter(name = "deviceId", description = "The device id for returning account information (i.e. favorites)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id for returning account information (i.e. favorites)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RETAILERS = "/api/{version}/retailer/search";
    /**
     * GET /api/{version}/retailer/search : Search Retailers
     * earches on retailers that the account has access to.
     *
     * @param version  (required)
     * @param visibility  (required)
     * @param sortField The column to sort the search on (required)
     * @param descending The order to return the search results (required)
     * @param start The record to begin the return set on (required)
     * @param limit The number of records to return (required)
     * @param activeOnly Return only active results (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param categoryIds the categories that the retailer is associated with (optional)
     * @param filterIds the filters that the retailer is associated with (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRetailers",
        summary = "Search Retailers",
        description = "earches on retailers that the account has access to.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RetailerResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RETAILERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RetailerResponse>> getRetailers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "visibility", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = true) String visibility,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The record to begin the return set on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The number of records to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "categoryIds", description = "the categories that the retailer is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "the filters that the retailer is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_RETAOKILER = "/api/{version}/retailer";
    /**
     * GET /api/{version}/retailer : Get Retailer
     * Gets a retailer. Only the owner and the employees of a retailer have access to view its information.
     *
     * @param version  (required)
     * @param retailerId the id of the retailer (required)
     * @param activeOnly whether to return results that are active only or all (required)
     * @param keyword the keyword to search on to get retailer (optional)
     * @param sortField the field to sort on (optional, default to id)
     * @param start the start of the index and/or pagination (optional, default to 0)
     * @param limit the limit of the index and/or pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRetaokiler",
        summary = "Get Retailer",
        description = "Gets a retailer. Only the owner and the employees of a retailer have access to view its information.",
        tags = { "Retailer V2" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_RETAOKILER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getRetaokiler(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerId", description = "the id of the retailer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = true) Long retailerId,
        @NotNull @Parameter(name = "activeOnly", description = "whether to return results that are active only or all", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "keyword", description = "the keyword to search on to get retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "the field to sort on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "id") String sortField,
        @Parameter(name = "start", description = "the start of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Long start,
        @Parameter(name = "limit", description = "the limit of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Long limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE = "/api/{version}/route/{routeId}";
    /**
     * GET /api/{version}/route/{routeId} : Get Route
     * Get an existing route
     *
     * @param version  (required)
     * @param routeId the id of the route to get (required)
     * @param showInheritedProperties return inherited properties from parent or not (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRoute",
        summary = "Get Route",
        description = "Get an existing route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> getRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to get", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "showInheritedProperties", description = "return inherited properties from parent or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "showInheritedProperties", required = true) Boolean showInheritedProperties
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE_DIRECTIONS = "/api/{version}/route/{routeId}/directions";
    /**
     * GET /api/{version}/route/{routeId}/directions : Get Route Directions
     * Get the directions of a route
     *
     * @param version  (required)
     * @param routeId the id of the route to get directions for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRouteDirections",
        summary = "Get Route Directions",
        description = "Get the directions of a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Direction.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE_DIRECTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Direction>> getRouteDirections(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to get directions for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE_SETTINGS = "/api/{version}/route/setting/{routeSettingsId}";
    /**
     * GET /api/{version}/route/setting/{routeSettingsId} : Get Route Setting
     * Get an existing route settings
     *
     * @param version  (required)
     * @param routeSettingsId the id of the route settings to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRouteSettings",
        summary = "Get Route Setting",
        description = "Get an existing route settings",
        tags = { "Route Setting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RouteSettings.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<RouteSettings> getRouteSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeSettingsId", description = "the id of the route settings to get", required = true, in = ParameterIn.PATH) @PathVariable("routeSettingsId") Long routeSettingsId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE_SHIPMENTS = "/api/{version}/route/{routeId}/shipments";
    /**
     * GET /api/{version}/route/{routeId}/shipments : Get Route Shipments
     * Get the shipments on the requested route
     *
     * @param version  (required)
     * @param routeId the id of the route to get shipments for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRouteShipments",
        summary = "Get Route Shipments",
        description = "Get the shipments on the requested route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Shipment.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE_SHIPMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Shipment>> getRouteShipments(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to get shipments for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE_STOP = "/api/{version}/route/{routeId}/stop/{stopId}";
    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId} : Get Route Stop
     * Get the specific stop on a route
     *
     * @param version  (required)
     * @param routeId the id of the route to get stops for (required)
     * @param stopId the id of the specific stop on the route (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRouteStop",
        summary = "Get Route Stop",
        description = "Get the specific stop on a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Stop.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE_STOP,
        produces = { "*/*" }
    )
    default ResponseEntity<Stop> getRouteStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to get stops for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "stopId", description = "the id of the specific stop on the route", required = true, in = ParameterIn.PATH) @PathVariable("stopId") Long stopId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_ROUTE_STOPS = "/api/{version}/route/{routeId}/stops";
    /**
     * GET /api/{version}/route/{routeId}/stops : Get Route Stops
     * The stops of the route requested
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param confirmedOnly only get stops that have been confirmed or not (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getRouteStops",
        summary = "Get Route Stops",
        description = "The stops of the route requested",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Stop.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_ROUTE_STOPS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Stop>> getRouteStops(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "confirmedOnly", description = "only get stops that have been confirmed or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "confirmedOnly", required = true) Boolean confirmedOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_STT = "/api/{version}/orson/ai/stt/{requestId}";
    /**
     * GET /api/{version}/orson/ai/stt/{requestId} : Get Speach to Text Result
     * The results of the video transcription and optional translation.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSTT",
        summary = "Get Speach to Text Result",
        description = "The results of the video transcription and optional translation.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiSTTResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_STT,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiSTTResponse> getSTT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SCHEDULED_NOTIFICATION = "/api/{version}/notification/schedule/get";
    /**
     * GET /api/{version}/notification/schedule/get : Get Scheduled Notification
     * Get a ScheduledNotification
     *
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getScheduledNotification",
        summary = "Get Scheduled Notification",
        description = "Get a ScheduledNotification",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> getScheduledNotification(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account logged in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "scheduledNotificationId", description = "the id of the scheduled notification to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SCORE = "/api/{version}/score/get";
    /**
     * GET /api/{version}/score/get : Get Score
     * Get the high score for an item.  Pass in the full path IDs for the score.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The game application key to get the level for. (required)
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @param scoreObjectType The object type to filter scores by (TicketObjectType) (optional)
     * @param scoreStatus The status of the score to filter (ScoreStatus) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getScore",
        summary = "Get Score",
        description = "Get the high score for an item.  Pass in the full path IDs for the score.",
        tags = { "Score" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SCORE,
        produces = { "*/*" }
    )
    default ResponseEntity<ScoreResponse> getScore(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The game application key to get the level for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "missionId", description = "The missionId to score for, null if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "gameId", description = "The gameId to score for, null if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "packId", description = "The packId to score for, null if playing community levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "The gameLevelId to score for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "gameObjectId", description = "The gameObjectId to score for, null if level based scoring.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = false) @Nullable Long gameObjectId,
        @Parameter(name = "scoreObjectType", description = "The object type to filter scores by (TicketObjectType)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoreObjectType", required = false) @Nullable String scoreObjectType,
        @Parameter(name = "scoreStatus", description = "The status of the score to filter (ScoreStatus)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoreStatus", required = false) @Nullable String scoreStatus
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SERVICE_HUB = "/api/{version}/hub/{id}";
    /**
     * GET /api/{version}/hub/{id} : Get Service Hub
     * Get an existing service hub
     *
     * @param version  (required)
     * @param id the id of the service hub to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getServiceHub",
        summary = "Get Service Hub",
        description = "Get an existing service hub",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SERVICE_HUB,
        produces = { "*/*" }
    )
    default ResponseEntity<Object> getServiceHub(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the service hub to get", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SETTINGS = "/api/{version}/account/settings/get";
    /**
     * GET /api/{version}/account/settings/get : Get Account Settings
     * Get the account settings for a user
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSettings",
        summary = "Get Account Settings",
        description = "Get the account settings for a user",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = UserSettingsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<UserSettingsResponse> getSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SHIPMENT = "/api/{version}/shipment/{id}";
    /**
     * GET /api/{version}/shipment/{id} : Get Shipment
     * Get an existing shipment
     *
     * @param version  (required)
     * @param id the id of the shipment to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getShipment",
        summary = "Get Shipment",
        description = "Get an existing shipment",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Shipment.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SHIPMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<Shipment> getShipment(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the shipment to get", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SHIPMENT_BATCH = "/api/{version}/shipment/batch/{batchId}";
    /**
     * GET /api/{version}/shipment/batch/{batchId} : Get Shipment Batch
     * Get an existing shipment batch
     *
     * @param version  (required)
     * @param batchId the id of the shipment batch to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getShipmentBatch",
        summary = "Get Shipment Batch",
        description = "Get an existing shipment batch",
        tags = { "Shipment Batch" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ShipmentBatch.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SHIPMENT_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<ShipmentBatch> getShipmentBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "batchId", description = "the id of the shipment batch to get", required = true, in = ParameterIn.PATH) @PathVariable("batchId") Long batchId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SHIPMENT_BATCH_STATUS = "/api/{version}/shipment/batch/{batchId}/status";
    /**
     * GET /api/{version}/shipment/batch/{batchId}/status : Get Shipment Batch Status
     * Get the import status list of the import shipment batch
     *
     * @param version  (required)
     * @param batchId The id of the requested shipment batch (required)
     * @param accountId the id of the logged in user (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param valid Valid import status only or not (optional)
     * @param started Started import status only (optional)
     * @param completed Completed import status only (optional)
     * @param hasShipment Has shipment associate to the status (optional)
     * @param hasRoute Has route associate to the status (optional)
     * @param keyword The keyword to search for (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getShipmentBatchStatus",
        summary = "Get Shipment Batch Status",
        description = "Get the import status list of the import shipment batch",
        tags = { "Shipment Batch" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ShipmentImportStatus.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SHIPMENT_BATCH_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ShipmentImportStatus>> getShipmentBatchStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "batchId", description = "The id of the requested shipment batch", required = true, in = ParameterIn.PATH) @PathVariable("batchId") Long batchId,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "valid", description = "Valid import status only or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "valid", required = false) @Nullable Boolean valid,
        @Parameter(name = "started", description = "Started import status only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "started", required = false) @Nullable Boolean started,
        @Parameter(name = "completed", description = "Completed import status only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "completed", required = false) @Nullable Boolean completed,
        @Parameter(name = "hasShipment", description = "Has shipment associate to the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasShipment", required = false) @Nullable Boolean hasShipment,
        @Parameter(name = "hasRoute", description = "Has route associate to the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasRoute", required = false) @Nullable Boolean hasRoute,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SHIPMENTS_AT_STOP = "/api/{version}/route/{routeId}/stop/{stopId}/shipments";
    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId}/shipments : Get Shipments At Stop
     * Get the list of shipments on the requested route at a stop
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param stopId the id of the stop to get shipments on (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getShipmentsAtStop",
        summary = "Get Shipments At Stop",
        description = "Get the list of shipments on the requested route at a stop",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Shipment.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SHIPMENTS_AT_STOP,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Shipment>> getShipmentsAtStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "stopId", description = "the id of the stop to get shipments on", required = true, in = ParameterIn.PATH) @PathVariable("stopId") Long stopId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SPACE = "/api/{version}/vatom/b/spaces/get";
    /**
     * GET /api/{version}/vatom/b/spaces/get : Get Vatom Space
     * Gets the details of a space.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomSpaceId Vatom Space Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSpace",
        summary = "Get Vatom Space",
        description = "Gets the details of a space.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SPACE
    )
    default ResponseEntity<Void> getSpace(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomSpaceId", description = "Vatom Space Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomSpaceId", required = true) String vatomSpaceId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_STATUS_CSV = "/api/{version}/csvimport/batch/status/details";
    /**
     * GET /api/{version}/csvimport/batch/status/details : Detail Status
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param batchId the id of the batch (required)
     * @param responseGroup The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL (required)
     * @param start the start of the pagination (required)
     * @param limit the limit of the pagination (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getStatusCSV",
        summary = "Detail Status",
        tags = { "CSV Import" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_STATUS_CSV,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getStatusCSV(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "batchId", description = "the id of the batch", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "batchId", required = true) Long batchId,
        @NotNull @Parameter(name = "responseGroup", description = "The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroup", required = true) String responseGroup,
        @NotNull @Parameter(name = "start", description = "the start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Long start,
        @NotNull @Parameter(name = "limit", description = "the limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Long limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_STOP = "/api/{version}/stop/{id}";
    /**
     * GET /api/{version}/stop/{id} : Get Stop
     * Get an existing stop
     *
     * @param version  (required)
     * @param id the id of the stop to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getStop",
        summary = "Get Stop",
        description = "Get an existing stop",
        tags = { "Stop" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Stop.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_STOP,
        produces = { "*/*" }
    )
    default ResponseEntity<Stop> getStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the stop to get", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SUBSCRIPTION = "/api/{version}/subscription/get";
    /**
     * GET /api/{version}/subscription/get : Get Subscription
     * Use the accountId to determine the associated BillableEntity.  Then get the subscription.
     *
     * @param version  (required)
     * @param accountId The account used to perform the lookup (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSubscription",
        summary = "Get Subscription",
        description = "Use the accountId to determine the associated BillableEntity.  Then get the subscription.",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SubscriptionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SUBSCRIPTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SubscriptionResponse> getSubscription(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the lookup", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SUBSCRIPTION_PLAN = "/api/{version}/subscription/plan/get";
    /**
     * GET /api/{version}/subscription/plan/get : Get Subscription Plan
     * Get the matched subscription plan
     *
     * @param version  (required)
     * @param planId The ID of the plan to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSubscriptionPlan",
        summary = "Get Subscription Plan",
        description = "Get the matched subscription plan",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SubscriptionPlanResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SUBSCRIPTION_PLAN,
        produces = { "*/*" }
    )
    default ResponseEntity<SubscriptionPlanResponse> getSubscriptionPlan(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "planId", description = "The ID of the plan to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "planId", required = true) Long planId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SUBSCRIPTION_PLANS = "/api/{version}/subscription/plan/list";
    /**
     * GET /api/{version}/subscription/plan/list : List Subscription Plans
     * Get the matched subscription plan
     *
     * @param version  (required)
     * @param visible Include visible only (true), hidden only (false), or all (null) (optional)
     * @param role The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSubscriptionPlans",
        summary = "List Subscription Plans",
        description = "Get the matched subscription plan",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = SubscriptionPlanResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SUBSCRIPTION_PLANS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<SubscriptionPlanResponse>> getSubscriptionPlans(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "visible", description = "Include visible only (true), hidden only (false), or all (null)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visible", required = false) @Nullable Boolean visible,
        @Parameter(name = "role", description = "The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SUBSCRIPTION_USAGE = "/api/{version}/subscription/usage/get";
    /**
     * GET /api/{version}/subscription/usage/get : Get Subscription Usage
     * Use the accountId to determine the associated BillableEntity.  Then get the application usage.
     *
     * @param version  (required)
     * @param accountId The account used to perform the lookup (required)
     * @param applicationId Get for just 1 application instead of the BillableEntity (optional)
     * @param start The start time frame (optional)
     * @param end The end time frame (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getSubscriptionUsage",
        summary = "Get Subscription Usage",
        description = "Use the accountId to determine the associated BillableEntity.  Then get the application usage.",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationUsageResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_SUBSCRIPTION_USAGE,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationUsageResponse> getSubscriptionUsage(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the lookup", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "applicationId", description = "Get for just 1 application instead of the BillableEntity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationId", required = false) @Nullable Long applicationId,
        @Parameter(name = "start", description = "The start time frame", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "end", description = "The end time frame", in = ParameterIn.QUERY) @Valid @RequestParam(value = "end", required = false) @Nullable Long end
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TTS = "/api/{version}/orson/ai/tts/{requestId}";
    /**
     * GET /api/{version}/orson/ai/tts/{requestId} : Get Text to Speach Result
     * Check the status of an in progress Text-to-Speech call or download the result.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTTS",
        summary = "Get Text to Speach Result",
        description = "Check the status of an in progress Text-to-Speech call or download the result.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTTSResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TTS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTTSResponse> getTTS(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TASK = "/api/{version}/task/get";
    /**
     * GET /api/{version}/task/get : Get Task
     * Get a Task
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param taskId The id of the Task to return. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTask",
        summary = "Get Task",
        description = "Get a Task",
        tags = { "Task" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TaskResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TASK,
        produces = { "*/*" }
    )
    default ResponseEntity<TaskResponse> getTask(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "taskId", description = "The id of the Task to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "taskId", required = true) Long taskId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TECH_TUNE = "/api/{version}/orson/ai/techTune/{requestId}";
    /**
     * GET /api/{version}/orson/ai/techTune/{requestId} : Get TechTune Results
     * Get a result or continue waiting for a pending request for TechTune analysis.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTechTune",
        summary = "Get TechTune Results",
        description = "Get a result or continue waiting for a pending request for TechTune analysis.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTechTuneResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TECH_TUNE,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTechTuneResponse> getTechTune(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TERRITORY = "/api/{version}/territory/get";
    /**
     * GET /api/{version}/territory/get : Get Territory
     * Get a territory.
     *
     * @param version  (required)
     * @param territoryId the id of the territory to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTerritory",
        summary = "Get Territory",
        description = "Get a territory.",
        tags = { "Territory" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TerritoryResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TERRITORY,
        produces = { "*/*" }
    )
    default ResponseEntity<TerritoryResponse> getTerritory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "territoryId", description = "the id of the territory to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "territoryId", required = true) Long territoryId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_THEME_DESCRIPTOR = "/api/{version}/consumer/theme/get";
    /**
     * GET /api/{version}/consumer/theme/get : Get Theme
     * Gets a theme.
     *
     * @param version  (required)
     * @param themeDescriptorId the theme id (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param gameType the application key (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getThemeDescriptor",
        summary = "Get Theme",
        description = "Gets a theme.",
        tags = { "Theme Descriptor" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PurchaseItemListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_THEME_DESCRIPTOR,
        produces = { "*/*" }
    )
    default ResponseEntity<PurchaseItemListResponse> getThemeDescriptor(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "themeDescriptorId", description = "the theme id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "themeDescriptorId", required = true) Long themeDescriptorId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_THEME_DESCRIPTORS = "/api/{version}/consumer/theme/search";
    /**
     * GET /api/{version}/consumer/theme/search : Search Themes
     * Searches for themes.
     *
     * @param version  (required)
     * @param filter a comma separated list of Ownership (required)
     * @param sortField the field to sort by. See ThemeDescriptorApiMap (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param start the start parameter for pagination (required)
     * @param limit the limit parameter for pagination (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType the unique title of an application given from the admin tool (optional)
     * @param contestType contest type (optional)
     * @param ownerId search on contests that an account has access to (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword a keyword to search on (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param dateCreated filter on items that have been created before this date (optional)
     * @param appVersion application version of the theme to filter by (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getThemeDescriptors",
        summary = "Search Themes",
        description = "Searches for themes.",
        tags = { "Theme Descriptor" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PurchaseItemListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_THEME_DESCRIPTORS,
        produces = { "*/*" }
    )
    default ResponseEntity<PurchaseItemListResponse> getThemeDescriptors(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "filter", description = "a comma separated list of Ownership", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = true) String filter,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. See ThemeDescriptorApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "the start parameter for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit parameter for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "the unique title of an application given from the admin tool", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "contestType", description = "contest type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contestType", required = false) @Nullable String contestType,
        @Parameter(name = "ownerId", description = "search on contests that an account has access to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "a keyword to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "dateCreated", description = "filter on items that have been created before this date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCreated", required = false) @Nullable Long dateCreated,
        @Parameter(name = "appVersion", description = "application version of the theme to filter by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TICKET_COUNT = "/api/{version}/ticket/count";
    /**
     * GET /api/{version}/ticket/count : Get Ticket Count
     * Gets the ticket count.
     *
     * @param version  (required)
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param gameType this is deprecated. (optional)
     * @param appKey the applicationkey (optional)
     * @param ticketType the type of ticket (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTicketCount",
        summary = "Get Ticket Count",
        description = "Gets the ticket count.",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CountResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TICKET_COUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<CountResponse> getTicketCount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the id of the device that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the account that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "this is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the applicationkey", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "ticketType", description = "the type of ticket", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TICKET_LIST = "/api/{version}/ticket/getList";
    /**
     * GET /api/{version}/ticket/getList : Get Ticket List
     * Gets the list of tickets.
     *
     * @param version  (required)
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param ticketObjectType comma separated list of TicketObjectType (optional)
     * @param actionType comma separated list of TicketActionType (optional)
     * @param ticketIds the ids of the tickets to get (optional)
     * @param objectIds the ids of the objects to get (optional)
     * @param receiptTokens  (optional)
     * @param gameType  (optional)
     * @param appKey the application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTicketList",
        summary = "Get Ticket List",
        description = "Gets the list of tickets.",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TicketListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TICKET_LIST,
        produces = { "*/*" }
    )
    default ResponseEntity<TicketListResponse> getTicketList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the id of the device that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the account that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "ticketObjectType", description = "comma separated list of TicketObjectType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketObjectType", required = false) @Nullable String ticketObjectType,
        @Parameter(name = "actionType", description = "comma separated list of TicketActionType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionType", required = false) @Nullable String actionType,
        @Parameter(name = "ticketIds", description = "the ids of the tickets to get", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketIds", required = false) @Nullable String ticketIds,
        @Parameter(name = "objectIds", description = "the ids of the objects to get", in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectIds", required = false) @Nullable String objectIds,
        @Parameter(name = "receiptTokens", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiptTokens", required = false) @Nullable String receiptTokens,
        @Parameter(name = "gameType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TOKEN = "/api/{version}/facebook/getfbtoken";
    /**
     * GET /api/{version}/facebook/getfbtoken : Get Facebook Token
     * Gets a user&#39;s Facebook token.
     *
     * @param version  (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude used to update the user&#39;s current location (optional)
     * @param longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getToken",
        summary = "Get Facebook Token",
        description = "Gets a user's Facebook token.",
        tags = { "Facebook" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TokenResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TOKEN,
        produces = { "*/*" }
    )
    default ResponseEntity<TokenResponse> getToken(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TOPICS = "/api/{version}/orson/ai/topics/{requestId}";
    /**
     * GET /api/{version}/orson/ai/topics/{requestId} : Get Topics
     * Get the result of an in progress Topics Analysis from an earlier POST.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTopics",
        summary = "Get Topics",
        description = "Get the result of an in progress Topics Analysis from an earlier POST.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTopicsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TOPICS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTopicsResponse> getTopics(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TOURNAMENT = "/api/{version}/tournament/get";
    /**
     * GET /api/{version}/tournament/get : Get Tournament
     * Get a tournament.
     *
     * @param version  (required)
     * @param accountId The id of the logged in user (required)
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTournament",
        summary = "Get Tournament",
        description = "Get a tournament.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TournamentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TOURNAMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<TournamentResponse> getTournament(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "missionId", description = "The id of the mission to return (either missionId or joinCode is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "joinCode", description = "Optional identifier for getting the tournament (either missionId or joinCode is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "joinCode", required = false) @Nullable String joinCode,
        @Parameter(name = "includeScores", description = "Determines which type of scores are returned. Possible values include: ALL, MINE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeScores", required = false) @Nullable String includeScores,
        @Parameter(name = "objectPreviewSize", description = "Determines the max number of game objects that will get returned for each game level response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectPreviewSize", required = false, defaultValue = "50") Integer objectPreviewSize
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TRACKING_LEGS = "/api/{version}/tracking/search";
    /**
     * GET /api/{version}/tracking/search : Search Tracking
     * Retrieve tracking data to be able to show where a user has been.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTrackingLegs",
        summary = "Search Tracking",
        description = "Retrieve tracking data to be able to show where a user has been.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = LegResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TRACKING_LEGS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<LegResponse>> getTrackingLegs(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "ownerId", description = "the account id of the person the user wants to tracking data for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "trackingDeviceId", description = "the id of the tracking device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trackingDeviceId", required = false) @Nullable String trackingDeviceId,
        @Parameter(name = "startDate", description = "the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date in (UTC milliseconds) to filter the tracking results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tags", description = "filter results by tag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "getLastPoint", description = "gets the last known location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "getLastPoint", required = false, defaultValue = "false") Boolean getLastPoint
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TRIGGER = "/api/{version}/trigger/get";
    /**
     * GET /api/{version}/trigger/get : Get Trigger
     * Get a trigger
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param triggerId The id of the Trigger to return. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTrigger",
        summary = "Get Trigger",
        description = "Get a trigger",
        tags = { "Trigger" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TriggerResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TRIGGER,
        produces = { "*/*" }
    )
    default ResponseEntity<TriggerResponse> getTrigger(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "triggerId", description = "The id of the Trigger to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "triggerId", required = true) Long triggerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TRIP = "/api/{version}/trip/{id}";
    /**
     * GET /api/{version}/trip/{id} : Get Trip
     * Get an existing trip
     *
     * @param version  (required)
     * @param id the id of the trip to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTrip",
        summary = "Get Trip",
        description = "Get an existing trip",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TRIP,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> getTrip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip to get", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_TRIP_MATCHES = "/api/{version}/trip/{id}/match";
    /**
     * GET /api/{version}/trip/{id}/match : Get Trip Matches
     * Get matching trips of specific trip
     *
     * @param version  (required)
     * @param id The id The id of the trip to search for matches for (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param matchedHasRoute Only return matchings that already have route assigned (optional)
     * @param matchedHasDriver Only return matchings that already have driver assigned (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getTripMatches",
        summary = "Get Trip Matches",
        description = "Get matching trips of specific trip",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_TRIP_MATCHES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> getTripMatches(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "The id The id of the trip to search for matches for", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "matchedHasRoute", description = "Only return matchings that already have route assigned", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchedHasRoute", required = false) @Nullable Boolean matchedHasRoute,
        @Parameter(name = "matchedHasDriver", description = "Only return matchings that already have driver assigned", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchedHasDriver", required = false) @Nullable Boolean matchedHasDriver
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_UNIQUE_USERS_BY_APP = "/api/{version}/application/users";
    /**
     * GET /api/{version}/application/users : Search Application Users
     * Get a list of users per application
     *
     * @param version  (required)
     * @param appKey The application key (required)
     * @param q Q (optional)
     * @param keyword The keyword used to search (optional)
     * @param since Return accounts that have been active after this date (UNIX time-stamp in milliseconds) (optional)
     * @param i the start of the index (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param l the limit of the index (optional)
     * @param limit The limit of the pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUniqueUsersByApp",
        summary = "Search Application Users",
        description = "Get a list of users per application",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AccountListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_UNIQUE_USERS_BY_APP,
        produces = { "*/*" }
    )
    default ResponseEntity<AccountListResponse> getUniqueUsersByApp(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "q", deprecated = true, description = "Q", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Deprecated @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "since", description = "Return accounts that have been active after this date (UNIX time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "since", required = false) @Nullable Long since,
        @Parameter(name = "_i", deprecated = true, description = "the start of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Deprecated @Nullable Integer i,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", deprecated = true, description = "the limit of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Deprecated @Nullable Integer l,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_ACHIEVEMENTS = "/api/{version}/achievement/progress/get";
    /**
     * GET /api/{version}/achievement/progress/get : Get Achievement Progress
     * Gets a list of user achievements.
     *
     * @param version  (required)
     * @param returnNulls determines whether to return null fields in the response (required)
     * @param appKey the application key for filtering results by application (required)
     * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail the email of the account to view achievements (optional)
     * @param connectionAccountId the id of the account to view achievements (optional)
     * @param rankType filter results by achievement rankType (optional)
     * @param achievementType filter results by achievement type (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserAchievements",
        summary = "Get Achievement Progress",
        description = "Gets a list of user achievements.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AchievementProgressResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_ACHIEVEMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AchievementProgressResponse>> getUserAchievements(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "determines whether to return null fields in the response", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true, defaultValue = "true") Boolean returnNulls,
        @NotNull @Parameter(name = "appKey", description = "the application key for filtering results by application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "includeUndiscovered", description = "determines whether to return achievements that the user has not discovered yet", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeUndiscovered", required = true, defaultValue = "true") Boolean includeUndiscovered,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountEmail", description = "the email of the account to view achievements", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountEmail", required = false) @Nullable String connectionAccountEmail,
        @Parameter(name = "connectionAccountId", description = "the id of the account to view achievements", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "rankType", description = "filter results by achievement rankType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "achievementType", description = "filter results by achievement type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementType", required = false) @Nullable String achievementType,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_COINS_AS_BUSINESS = "/api/{version}/vatom/b/users/coins/get";
    /**
     * GET /api/{version}/vatom/b/users/coins/get : Get the coins for a user (as a Business)
     * Get the coins for a user (as a Business).
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserCoinsAsBusiness",
        summary = "Get the coins for a user (as a Business)",
        description = "Get the coins for a user (as a Business).",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_COINS_AS_BUSINESS
    )
    default ResponseEntity<Void> getUserCoinsAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_COINS_BALANCE = "/api/{version}/vatom/u/coins/get";
    /**
     * GET /api/{version}/vatom/u/coins/get : Gets the coins balance for a Vatom User
     * Gets the coins balance for a Vatom User.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserCoinsBalance",
        summary = "Gets the coins balance for a Vatom User",
        description = "Gets the coins balance for a Vatom User.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_COINS_BALANCE
    )
    default ResponseEntity<Void> getUserCoinsBalance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_FOLLOWERS = "/api/{version}/vatom/users/rels/followers";
    /**
     * GET /api/{version}/vatom/users/rels/followers : Get user followers
     * Get user followers.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserFollowers",
        summary = "Get user followers",
        description = "Get user followers.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_FOLLOWERS
    )
    default ResponseEntity<Void> getUserFollowers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_FOLLOWING = "/api/{version}/vatom/users/rels/following";
    /**
     * GET /api/{version}/vatom/users/rels/following : Get user following
     * Get user following.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserFollowing",
        summary = "Get user following",
        description = "Get user following.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_FOLLOWING
    )
    default ResponseEntity<Void> getUserFollowing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_INFO = "/api/{version}/vatom/user/get";
    /**
     * GET /api/{version}/vatom/user/get : Get User Info
     * Get a User&#39;s Info.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserInfo",
        summary = "Get User Info",
        description = "Get a User's Info.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_INFO
    )
    default ResponseEntity<Void> getUserInfo(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_PROFILE = "/api/{version}/vatom/me/get";
    /**
     * GET /api/{version}/vatom/me/get : Get Vatom User Profile
     * Gets the logged in user&#39;s profile in Vatom.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserProfile",
        summary = "Get Vatom User Profile",
        description = "Gets the logged in user's profile in Vatom.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_USER_PROFILE
    )
    default ResponseEntity<Void> getUserProfile(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_USER_RANK = "/api/{version}/ranking/personal/ranks";
    /**
     * POST /api/{version}/ranking/personal/ranks : Get Personal Rankings
     * Returns the user&#39;s ranks for one or more rank types and modes.
     *
     * @param version  (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param appKey the application key for filtering results by application (required) (optional)
     * @param rankType pass in all rankTypes and children rankTypes (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to GLOBAL)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to TOTAL)
     * @param keyword keyword to search for (on rankType) (optional)
     * @param descending determines whether to return results in descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getUserRank",
        summary = "Get Personal Rankings",
        description = "Returns the user's ranks for one or more rank types and modes.",
        tags = { "Ranking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GET_USER_RANK,
        produces = { "*/*" }
    )
    default ResponseEntity<Object> getUserRank(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "the application key for filtering results by application (required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "rankType", description = "pass in all rankTypes and children rankTypes", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "returnUserRank", description = "determines whether to return the user's current rank in the response, for each rankType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnUserRank", required = false, defaultValue = "false") Boolean returnUserRank,
        @Parameter(name = "leaderboardMode", description = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardMode", required = false, defaultValue = "GLOBAL") String leaderboardMode,
        @Parameter(name = "sortField", description = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") String sortField,
        @Parameter(name = "keyword", description = "keyword to search for (on rankType)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "descending", description = "determines whether to return results in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_VATOM_EVENT = "/api/{version}/vatom/b/events/get";
    /**
     * GET /api/{version}/vatom/b/events/get : Get Vatom Event
     * Gets the details of a event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomEventId Vatom Event Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getVatomEvent",
        summary = "Get Vatom Event",
        description = "Gets the details of a event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_VATOM_EVENT
    )
    default ResponseEntity<Void> getVatomEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomEventId", description = "Vatom Event Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomEventId", required = true) String vatomEventId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_VATOM_NFT = "/api/{version}/vatom/vatoms/get";
    /**
     * GET /api/{version}/vatom/vatoms/get : Get Vatom NFT Details
     * Get Vatom NFT Details
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomId Vatom NFT Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getVatomNFT",
        summary = "Get Vatom NFT Details",
        description = "Get Vatom NFT Details",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_VATOM_NFT
    )
    default ResponseEntity<Void> getVatomNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomId", description = "Vatom NFT Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomId", required = true) String vatomId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_VEHICLE = "/api/{version}/vehicle/{id}";
    /**
     * GET /api/{version}/vehicle/{id} : Get Vehicle
     * Get an existing vehicle
     *
     * @param version  (required)
     * @param id The id of the vehicle requested (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getVehicle",
        summary = "Get Vehicle",
        description = "Get an existing vehicle",
        tags = { "Vehicle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Vehicle.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_VEHICLE,
        produces = { "*/*" }
    )
    default ResponseEntity<Vehicle> getVehicle(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "The id of the vehicle requested", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_VEHICLE_TYPE = "/api/{version}/vehicle/type/{vehicleTypeId}";
    /**
     * GET /api/{version}/vehicle/type/{vehicleTypeId} : Get Vehicle Type
     * Get a vehicle type
     *
     * @param version  (required)
     * @param vehicleTypeId The id of the requested vehicle type (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getVehicleType",
        summary = "Get Vehicle Type",
        description = "Get a vehicle type",
        tags = { "Vehicle Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = VehicleType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_VEHICLE_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<VehicleType> getVehicleType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "vehicleTypeId", description = "The id of the requested vehicle type", required = true, in = ParameterIn.PATH) @PathVariable("vehicleTypeId") Long vehicleTypeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_VOICE_CANVAS = "/api/{version}/orson/ai/voiceCanvas/{requestId}";
    /**
     * GET /api/{version}/orson/ai/voiceCanvas/{requestId} : Get VoiceCanvas images
     * Get a result or continue waiting for a pending request for VoiceCanvas Images.
     *
     * @param version  (required)
     * @param requestId Orson Request Id (required)
     * @param accountId Sirqul Account Id (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getVoiceCanvas",
        summary = "Get VoiceCanvas images",
        description = "Get a result or continue waiting for a pending request for VoiceCanvas Images.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiVoiceCanvasResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_VOICE_CANVAS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiVoiceCanvasResponse> getVoiceCanvas(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "requestId", description = "Orson Request Id", required = true, in = ParameterIn.PATH) @PathVariable("requestId") String requestId,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_WORD = "/api/{version}/game/word/get";
    /**
     * GET /api/{version}/game/word/get : Get Word
     * Get a word by the given id.
     *
     * @param version  (required)
     * @param wordId The id of the word to get. (required)
     * @param accountId The logged in user. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getWord",
        summary = "Get Word",
        description = "Get a word by the given id.",
        tags = { "Word" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WordzWordResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_WORD,
        produces = { "*/*" }
    )
    default ResponseEntity<WordzWordResponse> getWord(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "wordId", description = "The id of the word to get.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "wordId", required = true) Long wordId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_WORDS = "/api/{version}/game/word/search";
    /**
     * GET /api/{version}/game/word/search : Search Words
     * Search for words by the given params.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param sortField The column to sort the search on (required)
     * @param descending The order to return the search results (required)
     * @param activeOnly Return only active results if set to true. (required)
     * @param start The record to begin the return set on. (required)
     * @param limit The number of records to return. (required)
     * @param keyword The keyword for searching words with matching definition or word text. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getWords",
        summary = "Search Words",
        description = "Search for words by the given params.",
        tags = { "Word" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = WordzWordResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_WORDS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<WordzWordResponse>> getWords(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") Boolean descending,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results if set to true.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "false") Boolean activeOnly,
        @NotNull @Parameter(name = "start", description = "The record to begin the return set on.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") Integer start,
        @NotNull @Parameter(name = "limit", description = "The number of records to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") Integer limit,
        @Parameter(name = "keyword", description = "The keyword for searching words with matching definition or word text.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_WORDS_IN_LEVEL = "/api/{version}/level/words/get";
    /**
     * GET /api/{version}/level/words/get : Get Level Words
     * Get words within a level.
     *
     * @param version  (required)
     * @param levelId the id of the level to get words for (required)
     * @param accountId the id of the logged in user (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getWordsInLevel",
        summary = "Get Level Words",
        description = "Get words within a level.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WordzWordResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GET_WORDS_IN_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<WordzWordResponse> getWordsInLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "levelId", description = "the id of the level to get words for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GIFT_PURCHASE = "/api/{version}/purchase/gift";
    /**
     * POST /api/{version}/purchase/gift : Gift Tickets
     * Gift tickets to another user.
     *
     * @param version  (required)
     * @param receiverAccountId the id of the account receiving the tickets (required)
     * @param ticketId the id of the tickets (required)
     * @param deviceId the id of the device (optional)
     * @param accountId the id of the gift owner (optional)
     * @param assetId the id of the asset (optional)
     * @param customMessage a message that can be written to go along with the gift (optional)
     * @param gameType the type of game associated with the tickets (optional)
     * @param appKey the application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "giftPurchase",
        summary = "Gift Tickets",
        description = "Gift tickets to another user.",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GIFT_PURCHASE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> giftPurchase(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "receiverAccountId", description = "the id of the account receiving the tickets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountId", required = true) Long receiverAccountId,
        @NotNull @Parameter(name = "ticketId", description = "the id of the tickets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketId", required = true) Long ticketId,
        @Parameter(name = "deviceId", description = "the id of the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the gift owner", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "assetId", description = "the id of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "customMessage", description = "a message that can be written to go along with the gift", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = false) @Nullable String customMessage,
        @Parameter(name = "gameType", description = "the type of game associated with the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GRAPH_INTERFACE = "/api/{version}/facebook/graph";
    /**
     * POST /api/{version}/facebook/graph : Post to Facebook
     * Make Facebook posts on behalf of the user.
     *
     * @param version  (required)
     * @param event the type of Sirqul event {DOWNLOADED_APP, CHALLENGE, LEVEL_COMPLETED, LEVEL_CREATED} (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param permissionableType for posting about information related to an object. Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId the object id (optional)
     * @param assetId used to include an asset on a Facebook post (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param latitude used to update the user&#39;s current location (optional)
     * @param longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "graphInterface",
        summary = "Post to Facebook",
        description = "Make Facebook posts on behalf of the user.",
        tags = { "Facebook" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_GRAPH_INTERFACE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> graphInterface(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "event", description = "the type of Sirqul event {DOWNLOADED_APP, CHALLENGE, LEVEL_COMPLETED, LEVEL_CREATED}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "event", required = true) String event,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "permissionableType", description = "for posting about information related to an object. Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "the object id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "assetId", description = "used to include an asset on a Facebook post", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GROUP_SEARCH = "/api/{version}/connection/group/search";
    /**
     * GET /api/{version}/connection/group/search : Search Connection Groups
     * Gets a user&#39;s private groups and default groups.
     *
     * @param version  (required)
     * @param sortField the field to sort by (required)
     * @param descending whether to return results in descending or ascending order (required)
     * @param activeOnly to search on active only or not (required)
     * @param start The start of the pagination (required)
     * @param limit the limit of the pagination (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param keyword keyword search string (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "groupSearch",
        summary = "Search Connection Groups",
        description = "Gets a user's private groups and default groups.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ConnectionInfoResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_GROUP_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ConnectionInfoResponse>> groupSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "whether to return results in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "activeOnly", description = "to search on active only or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "keyword", description = "keyword search string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_IMAGE_GENERATION = "/api/{version}/openai/v1/images/generations";
    /**
     * POST /api/{version}/openai/v1/images/generations : Generate images with OpenAI
     * Generate images with OpenAI.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param postBody Post Body Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "imageGeneration",
        summary = "Generate images with OpenAI",
        description = "Generate images with OpenAI.",
        tags = { "OpenAI" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WrappedProxyItemResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_IMAGE_GENERATION,
        produces = { "*/*" }
    )
    default ResponseEntity<WrappedProxyItemResponse> imageGeneration(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "postBody", description = "Post Body Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "postBody", required = true) String postBody,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_IMPORT_MISSION = "/api/{version}/mission/import";
    /**
     * POST /api/{version}/mission/import : Import Mission
     * Create a mission using a source item such as an offer location.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param latitude The current location of the requesting device (required)
     * @param longitude The current location of the requesting device (required)
     * @param appKey the application key (required)
     * @param keyword the keyword of the mission (optional)
     * @param start The starting index in the result set to return. Default is 0. (optional)
     * @param limit The total number of records to return. Default is 20. (optional)
     * @param adSize the size of the ad (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "importMission",
        summary = "Import Mission",
        description = "Create a mission using a source item such as an offer location.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_IMPORT_MISSION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> importMission(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "latitude", description = "The current location of the requesting device", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "The current location of the requesting device", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "keyword", description = "the keyword of the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "start", description = "The starting index in the result set to return. Default is 0.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of records to return. Default is 20.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "adSize", description = "the size of the ad", in = ParameterIn.QUERY) @Valid @RequestParam(value = "adSize", required = false) @Nullable String adSize
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_INDEXED_RETAILER_LOCATION_DISTANCE_SEARCH = "/api/{version}/retailer/location/idistancesearch";
    /**
     * GET /api/{version}/retailer/location/idistancesearch : Distance Search Retailer Locations (Indexed)
     * Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.
     *
     * @param version  (required)
     * @param latitude The latitude to center the search on (required)
     * @param longitude The longitude to center the search on (required)
     * @param searchRange The search range in the distanceUnit specified; default is MILES. (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param accountId The account id of the user (optional)
     * @param address Used to return results using this address as the center (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param distanceUnit Unit of distance (optional)
     * @param returnFavorited (deprecated) return favorited flag (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "indexedRetailerLocationDistanceSearch",
        summary = "Distance Search Retailer Locations (Indexed)",
        description = "Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RetailerLocationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_INDEXED_RETAILER_LOCATION_DISTANCE_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RetailerLocationResponse>> indexedRetailerLocationDistanceSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "latitude", description = "The latitude to center the search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "The longitude to center the search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @NotNull @Parameter(name = "searchRange", description = "The search range in the distanceUnit specified; default is MILES.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = true) Double searchRange,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "accountId", description = "The account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "address", description = "Used to return results using this address as the center", in = ParameterIn.QUERY) @Valid @RequestParam(value = "address", required = false) @Nullable String address,
        @Parameter(name = "hasOffers", description = "boolean to indicate whether to include retailer locations that have no offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasOffers", required = false) @Nullable Boolean hasOffers,
        @Parameter(name = "categories", description = "Comma separate list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categories", required = false) @Nullable String categories,
        @Parameter(name = "filters", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filters", required = false) @Nullable String filters,
        @Parameter(name = "audiences", description = "Comma separated list of audience ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audiences", required = false) @Nullable String audiences,
        @Parameter(name = "retailerIds", description = "Comma separated list of retailer ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerIds", required = false) @Nullable String retailerIds,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "tags", description = "Does a full-text search on tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "locationType", description = "Location type filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "sortField", description = "The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "Search by keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "keywordOperator", description = "Determines the operator used when there are multiple words in the 'keyword' parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keywordOperator", required = false) @Nullable String keywordOperator,
        @Parameter(name = "searchExpression", description = "Search expression to further refine results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchExpression", required = false) @Nullable String searchExpression,
        @Parameter(name = "distanceUnit", description = "Unit of distance", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = false) @Nullable String distanceUnit,
        @Parameter(name = "returnFavorited", description = "(deprecated) return favorited flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFavorited", required = false) @Nullable Boolean returnFavorited,
        @Parameter(name = "returnRetailer", description = "Return retailer info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRetailer", required = false) @Nullable Boolean returnRetailer,
        @Parameter(name = "returnAssets", description = "Return assets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAssets", required = false) @Nullable Boolean returnAssets,
        @Parameter(name = "returnOffers", description = "Return offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOffers", required = false) @Nullable Boolean returnOffers,
        @Parameter(name = "returnCategories", description = "Return categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnCategories", required = false) @Nullable Boolean returnCategories,
        @Parameter(name = "returnFilters", description = "Return filters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFilters", required = false) @Nullable Boolean returnFilters,
        @Parameter(name = "returnAudiences", description = "Return audiences", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAudiences", required = false) @Nullable Boolean returnAudiences,
        @Parameter(name = "returnQrCode", description = "Return QR code info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnQrCode", required = false) @Nullable Boolean returnQrCode,
        @Parameter(name = "returnExternalCategoryData", description = "Return external category data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnExternalCategoryData", required = false) @Nullable Boolean returnExternalCategoryData,
        @Parameter(name = "includeFavorite", description = "Include favorites in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFavorite", required = false) @Nullable Boolean includeFavorite,
        @Parameter(name = "includeLiked", description = "Include liked flag in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeLiked", required = false) @Nullable Boolean includeLiked,
        @Parameter(name = "includeRating", description = "Include rating info in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRating", required = false) @Nullable Boolean includeRating
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_INDEXED_RETAILER_LOCATION_SEARCH = "/api/{version}/retailer/location/isearch";
    /**
     * GET /api/{version}/retailer/location/isearch : Keyword Search Retailer Locations (Indexed)
     * Retailer location (faster) indexed search. This searches all retailer locations.
     *
     * @param version  (required)
     * @param accountId The account id of the user (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "indexedRetailerLocationSearch",
        summary = "Keyword Search Retailer Locations (Indexed)",
        description = "Retailer location (faster) indexed search. This searches all retailer locations.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RetailerLocationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_INDEXED_RETAILER_LOCATION_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RetailerLocationResponse>> indexedRetailerLocationSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "hasOffers", description = "boolean to indicate whether to include retailer locations that have no offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasOffers", required = false) @Nullable Boolean hasOffers,
        @Parameter(name = "categories", description = "Comma separate list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categories", required = false) @Nullable String categories,
        @Parameter(name = "filters", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filters", required = false) @Nullable String filters,
        @Parameter(name = "audiences", description = "Comma separated list of audience ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audiences", required = false) @Nullable String audiences,
        @Parameter(name = "retailerIds", description = "Comma separated list of retailer ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerIds", required = false) @Nullable String retailerIds,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "tags", description = "Does a full-text search on tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "locationType", description = "Location type filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "sortField", description = "The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "Search by keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "keywordOperator", description = "Determines the operator used when there are multiple words in the 'keyword' parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keywordOperator", required = false) @Nullable String keywordOperator,
        @Parameter(name = "searchExpression", description = "Search expression to further refine results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchExpression", required = false) @Nullable String searchExpression,
        @Parameter(name = "returnRetailer", description = "Return retailer info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRetailer", required = false) @Nullable Boolean returnRetailer,
        @Parameter(name = "returnAssets", description = "Return assets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAssets", required = false) @Nullable Boolean returnAssets,
        @Parameter(name = "returnOffers", description = "Return offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOffers", required = false) @Nullable Boolean returnOffers,
        @Parameter(name = "returnCategories", description = "Return categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnCategories", required = false) @Nullable Boolean returnCategories,
        @Parameter(name = "returnFilters", description = "Return filters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFilters", required = false) @Nullable Boolean returnFilters,
        @Parameter(name = "returnAudiences", description = "Return audiences", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAudiences", required = false) @Nullable Boolean returnAudiences,
        @Parameter(name = "returnQrCode", description = "Return QR code info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnQrCode", required = false) @Nullable Boolean returnQrCode,
        @Parameter(name = "returnExternalCategoryData", description = "Return external category data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnExternalCategoryData", required = false) @Nullable Boolean returnExternalCategoryData,
        @Parameter(name = "includeFavorite", description = "Include favorites in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFavorite", required = false) @Nullable Boolean includeFavorite,
        @Parameter(name = "includeLiked", description = "Include liked flag in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeLiked", required = false) @Nullable Boolean includeLiked,
        @Parameter(name = "includeRating", description = "Include rating info in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRating", required = false) @Nullable Boolean includeRating
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LEAVE_ALBUM = "/api/{version}/album/user/leave";
    /**
     * POST /api/{version}/album/user/leave : Leave Album
     *  Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.
     *
     * @param version  (required)
     * @param albumId the album ID (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "leaveAlbum",
        summary = "Leave Album",
        description = " Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LEAVE_ALBUM,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> leaveAlbum(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "the album ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LEAVE_FROM_PERMISSIONABLE = "/api/{version}/consumer/permissions/leave";
    /**
     * POST /api/{version}/consumer/permissions/leave : Leave
     * Used when the user wants to leave from someone else&#39;s permissionable object
     *
     * @param version  (required)
     * @param permissionableType the permissionable type PermissionableType (required)
     * @param permissionableId the id of the permissionable object (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "leaveFromPermissionable",
        summary = "Leave",
        description = "Used when the user wants to leave from someone else's permissionable object",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LEAVE_FROM_PERMISSIONABLE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> leaveFromPermissionable(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "permissionableType", description = "the permissionable type PermissionableType", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = true) String permissionableType,
        @NotNull @Parameter(name = "permissionableId", description = "the id of the permissionable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = true) Long permissionableId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_ACHIEVEMENT_TAGS = "/api/{version}/achievement/tag/list";
    /**
     * GET /api/{version}/achievement/tag/list : List Achievement Tags
     * List achievement tags by application
     *
     * @param version  (required)
     * @param appKey filter results by application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listAchievementTags",
        summary = "List Achievement Tags",
        description = "List achievement tags by application",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_ACHIEVEMENT_TAGS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> listAchievementTags(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "appKey", description = "filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_ACHIEVEMENTS = "/api/{version}/achievement/list";
    /**
     * GET /api/{version}/achievement/list : List Achievements
     * List achievements by billable.
     *
     * @param version  (required)
     * @param sortField the field to sort by. See AchievementApiMap (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (has a hard limit of 1000) (required)
     * @param activeOnly Filter results to only return active achievements (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listAchievements",
        summary = "List Achievements",
        description = "List achievements by billable.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AchievementShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_ACHIEVEMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AchievementShortResponse>> listAchievements(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. See AchievementApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination (has a hard limit of 1000)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Filter results to only return active achievements", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "achievementType", description = "filter results by the achievementType (these are exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementType", required = false) @Nullable String achievementType,
        @Parameter(name = "rankType", description = "filter results by the rankType (these are exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_APPLICATIONS = "/api/{version}/application/list";
    /**
     * GET /api/{version}/application/list : List Applications
     * List active applications matching the criteria (as a consumer)
     *
     * @param version  (required)
     * @param accountId The account id of the application owner/manager (optional)
     * @param q Q (optional)
     * @param keyword The keyword used to search for title, about, and description fields (optional)
     * @param platforms Deprecated, use deviceIds and deviceVersions (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum.  (optional)
     * @param categoryIds The list of category ids to filter the list by (optional)
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE (optional, default to UPDATED)
     * @param hasAds Filter results on whether the application supports ads or not. Ignore this parameter to return all results. (optional)
     * @param publicNotifications Filter results on whether the application is available for public trigger notifications (optional)
     * @param filterBillable Determines whether to only return applications that the user has access to (optional)
     * @param filterContentAdmin Determines whether to only return applications that the user is a content admin of (optional)
     * @param descending The order to return the search results (optional, default to true)
     * @param i the start of the index (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param l The limit of the index (optional)
     * @param limit The limit of the pagination (optional, default to 20)
     * @param applicationIds The list of application ids, comma separated. If provided will ignore all other params. (optional)
     * @param hasObjectStore Only include applications with a object store (default is false) (optional, default to false)
     * @param activeOnly Return only active results (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listApplications",
        summary = "List Applications",
        description = "List active applications matching the criteria (as a consumer)",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ApplicationShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_APPLICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ApplicationShortResponse>> listApplications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the application owner/manager", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", deprecated = true, description = "Q", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Deprecated @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search for title, about, and description fields", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "platforms", description = "Deprecated, use deviceIds and deviceVersions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "deviceIds", description = "The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "categoryIds", description = "The list of category ids to filter the list by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "sortField", description = "The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "UPDATED") String sortField,
        @Parameter(name = "hasAds", description = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasAds", required = false) @Nullable Boolean hasAds,
        @Parameter(name = "publicNotifications", description = "Filter results on whether the application is available for public trigger notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicNotifications", required = false) @Nullable Boolean publicNotifications,
        @Parameter(name = "filterBillable", description = "Determines whether to only return applications that the user has access to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterBillable", required = false) @Nullable Boolean filterBillable,
        @Parameter(name = "filterContentAdmin", description = "Determines whether to only return applications that the user is a content admin of", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterContentAdmin", required = false) @Nullable Boolean filterContentAdmin,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "_i", deprecated = true, description = "the start of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Deprecated @Nullable Integer i,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", deprecated = true, description = "The limit of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Deprecated @Nullable Integer l,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "applicationIds", description = "The list of application ids, comma separated. If provided will ignore all other params.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "hasObjectStore", description = "Only include applications with a object store (default is false)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasObjectStore", required = false, defaultValue = "false") Boolean hasObjectStore,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_BY_ACCOUNT = "/api/{version}/audience/suggestion/list";
    /**
     * POST /api/{version}/audience/suggestion/list : List Suggestions by Audience
     * List either Missions or Offers that the user matches the assigned audience.
     *
     * @param version  (required)
     * @param accountId The account to match offers for. (required)
     * @param limit the limit of the index (required)
     * @param suggestionType the type of suggestion (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listByAccount",
        summary = "List Suggestions by Audience",
        description = "List either Missions or Offers that the user matches the assigned audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LIST_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listByAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "limit", description = "the limit of the index", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "suggestionType", description = "the type of suggestion", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionType", required = true) String suggestionType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_BY_AUDIENCE = "/api/{version}/audience/suggestion/offersByAudience";
    /**
     * GET /api/{version}/audience/suggestion/offersByAudience : List Offers by Audience
     * Get a list of offer locations based on audience information provided.
     *
     * @param version  (required)
     * @param limit this is the limit of the index (required)
     * @param gender this is the gender to list offers by (optional)
     * @param age this is the age to list offers by (optional)
     * @param categoryIds this is the category IDs to list offers by (optional)
     * @param latitude this is the latitude to list offers by (optional)
     * @param longitude this is the longitude to list offers by (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listByAudience",
        summary = "List Offers by Audience",
        description = "Get a list of offer locations based on audience information provided.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_BY_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listByAudience(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "limit", description = "this is the limit of the index", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "gender", description = "this is the gender to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "age", description = "this is the age to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "categoryIds", description = "this is the category IDs to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "latitude", description = "this is the latitude to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "this is the longitude to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_COMMUNITIES = "/api/{version}/vatom/b/communities/search";
    /**
     * GET /api/{version}/vatom/b/communities/search : List Vatom Communities
     * Gets the communities tied to a business.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listCommunities",
        summary = "List Vatom Communities",
        description = "Gets the communities tied to a business.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_COMMUNITIES
    )
    default ResponseEntity<Void> listCommunities(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_EVENTS = "/api/{version}/vatom/b/events/search";
    /**
     * GET /api/{version}/vatom/b/events/search : List Vatom Events
     * Gets the events tied to a business.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listEvents",
        summary = "List Vatom Events",
        description = "Gets the events tied to a business.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_EVENTS
    )
    default ResponseEntity<Void> listEvents(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_LASTEST_BY_ACCOUNT = "/api/{version}/audience/suggestion/latest";
    /**
     * GET /api/{version}/audience/suggestion/latest : List Sent Suggestions 
     * Return list of recent trigger suggestions that have been sent to the user.
     *
     * @param version  (required)
     * @param accountId The account to match offers for. (required)
     * @param timeframe The timeframe in seconds of the latest suggestions (required)
     * @param suggestionType The type of trigger suggestions to return (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listLastestByAccount",
        summary = "List Sent Suggestions ",
        description = "Return list of recent trigger suggestions that have been sent to the user.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_LASTEST_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listLastestByAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "timeframe", description = "The timeframe in seconds of the latest suggestions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "timeframe", required = true) Integer timeframe,
        @NotNull @Parameter(name = "suggestionType", description = "The type of trigger suggestions to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionType", required = true) String suggestionType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_SPACES = "/api/{version}/vatom/b/spaces/search";
    /**
     * GET /api/{version}/vatom/b/spaces/search : List Vatom Spaces
     * Gets the spaces tied to a business.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listSpaces",
        summary = "List Vatom Spaces",
        description = "Gets the spaces tied to a business.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_SPACES
    )
    default ResponseEntity<Void> listSpaces(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_STATUS_CSV = "/api/{version}/csvimport/batch/list";
    /**
     * GET /api/{version}/csvimport/batch/list : Search Status
     * Retrieves batches for a user.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param start the start of the pagination (required)
     * @param limit the limit of the pagination (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listStatusCSV",
        summary = "Search Status",
        description = "Retrieves batches for a user.",
        tags = { "CSV Import" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CsvImportResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_STATUS_CSV,
        produces = { "*/*" }
    )
    default ResponseEntity<CsvImportResponse> listStatusCSV(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "start", description = "the start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_USER_COIN_TRANSACTIONS = "/api/{version}/vatom/u/coins/txns/search";
    /**
     * GET /api/{version}/vatom/u/coins/txns/search : List Coin Transactions for a Vatom User
     * Gets the logged in user&#39;s Vatom coin transactions.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listUserCoinTransactions",
        summary = "List Coin Transactions for a Vatom User",
        description = "Gets the logged in user's Vatom coin transactions.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_USER_COIN_TRANSACTIONS
    )
    default ResponseEntity<Void> listUserCoinTransactions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_USER_COIN_TRANSACTIONS_AS_BUSINESS = "/api/{version}/vatom/b/users/coins/txns/search";
    /**
     * GET /api/{version}/vatom/b/users/coins/txns/search : List coin transactions for a user (as a Business)
     * List coin transactions for a user (as a Business).
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listUserCoinTransactionsAsBusiness",
        summary = "List coin transactions for a user (as a Business)",
        description = "List coin transactions for a user (as a Business).",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_LIST_USER_COIN_TRANSACTIONS_AS_BUSINESS
    )
    default ResponseEntity<Void> listUserCoinTransactionsAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGIN_DELEGATE = "/api/{version}/account/login/delegate";
    /**
     * POST /api/{version}/account/login/delegate : Login as Account
     * A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
     *
     * @param version  (required)
     * @param accessToken  (required)
     * @param appKey  (required)
     * @param deviceId  (optional)
     * @param accessTokenSecret  (optional)
     * @param delegatedAccountId  (optional)
     * @param delegatedUsername  (optional)
     * @param networkUID The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE (optional, default to USERNAME)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to PROFILE)
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "loginDelegate",
        summary = "Login as Account",
        description = "A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGIN_DELEGATE,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> loginDelegate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accessToken", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessToken", required = true) String accessToken,
        @NotNull @Parameter(name = "appKey", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accessTokenSecret", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessTokenSecret", required = false) @Nullable String accessTokenSecret,
        @Parameter(name = "delegatedAccountId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "delegatedAccountId", required = false) @Nullable Long delegatedAccountId,
        @Parameter(name = "delegatedUsername", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "delegatedUsername", required = false) @Nullable String delegatedUsername,
        @Parameter(name = "networkUID", description = "The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = false, defaultValue = "USERNAME") String networkUID,
        @Parameter(name = "ageRestriction", description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") Integer ageRestriction,
        @Parameter(name = "responseFilters", description = "This determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters,
        @Parameter(name = "latitude", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGIN_GENERAL = "/api/{version}/account/login";
    /**
     * POST /api/{version}/account/login : Login Account
     * General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
     *
     * @param version  (required)
     * @param accessToken The access token to authenticate with (ex: username or fb token) (required)
     * @param networkUID The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (required)
     * @param appKey The application key (required)
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param accessTokenSecret The secret to authenticate with (ex: password) (optional)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to PROFILE)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param emailMatch Option to check for email if username doesn&#39;t match, also support multiple accounts (optional, default to false)
     * @param chosenAccountId Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request (optional, default to 0)
     * @param thirdPartyCredentialId Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object (optional, default to 0)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "loginGeneral",
        summary = "Login Account",
        description = "General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGIN_GENERAL,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> loginGeneral(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accessToken", description = "The access token to authenticate with (ex: username or fb token)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessToken", required = true) String accessToken,
        @NotNull @Parameter(name = "networkUID", description = "The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true, defaultValue = "USERNAME") String networkUID,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "deviceIdType", description = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdType", required = false) @Nullable String deviceIdType,
        @Parameter(name = "accessTokenSecret", description = "The secret to authenticate with (ex: password)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessTokenSecret", required = false) @Nullable String accessTokenSecret,
        @Parameter(name = "ageRestriction", description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") Integer ageRestriction,
        @Parameter(name = "responseFilters", description = "This determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "emailMatch", description = "Option to check for email if username doesn't match, also support multiple accounts", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailMatch", required = false, defaultValue = "false") Boolean emailMatch,
        @Parameter(name = "chosenAccountId", description = "Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "chosenAccountId", required = false, defaultValue = "0") Long chosenAccountId,
        @Parameter(name = "thirdPartyCredentialId", description = "Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyCredentialId", required = false, defaultValue = "0") Long thirdPartyCredentialId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGIN_SECURE = "/api/{version}/secure/login";
    /**
     * POST /api/{version}/secure/login : Login Clear
     * Login via Clear.me. Creates a new account if logging in for the first time.
     *
     * @param version  (required)
     * @param appKey The application making the request, defines what type and position is required to make a secure login the request. (required)
     * @param biometricFile The data file used to perform authentication (required)
     * @param deviceId The unique id of the device making the request (optional)
     * @param biometricFile2 The data file used to perform authentication (optional)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param returnProfile Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse (optional, default to false)
     * @param responseFilters If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters (optional, default to PROFILE)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "loginSecure",
        summary = "Login Clear",
        description = "Login via Clear.me. Creates a new account if logging in for the first time.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGIN_SECURE,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> loginSecure(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application making the request, defines what type and position is required to make a secure login the request.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "biometricFile", description = "The data file used to perform authentication", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricFile", required = true) org.springframework.core.io.Resource biometricFile,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "biometricFile2", description = "The data file used to perform authentication", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricFile2", required = false) @Nullable org.springframework.core.io.Resource biometricFile2,
        @Parameter(name = "ageRestriction", description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") Integer ageRestriction,
        @Parameter(name = "returnProfile", description = "Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfile", required = false, defaultValue = "false") Boolean returnProfile,
        @Parameter(name = "responseFilters", description = "If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGIN_TWITTER = "/api/{version}/twitter/login";
    /**
     * POST /api/{version}/twitter/login : Login Twitter
     * Returns the user profile information given an access token and the secret access token. This call verifies the tokens with twitter and creates a Sirqul account for the user if its their first time logging in.
     *
     * @param version  (required)
     * @param accessToken The access token (required)
     * @param accessTokenSecret The secret access token (required)
     * @param appKey The application key (required)
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data (required)
     * @param deviceId The device id (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "loginTwitter",
        summary = "Login Twitter",
        description = "Returns the user profile information given an access token and the secret access token. This call verifies the tokens with twitter and creates a Sirqul account for the user if its their first time logging in.",
        tags = { "Twitter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGIN_TWITTER,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> loginTwitter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accessToken", description = "The access token", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessToken", required = true) String accessToken,
        @NotNull @Parameter(name = "accessTokenSecret", description = "The secret access token", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accessTokenSecret", required = true) String accessTokenSecret,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "responseFilters", description = "a comma separated list of ProfileFilters for filtering the returned response data", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = true) String responseFilters,
        @Parameter(name = "deviceId", description = "The device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGIN_USERNAME = "/api/{version}/account/get";
    /**
     * POST /api/{version}/account/get : Login Account (Username)
     * Login to system with an account
     *
     * @param version  (required)
     * @param username the user&#39;s email address they used to sign-up (required)
     * @param password the password (required)
     * @param deviceId the device id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param app the app (optional)
     * @param gameType This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey the application key (optional)
     * @param returnProfile the profile to return (optional)
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "loginUsername",
        summary = "Login Account (Username)",
        description = "Login to system with an account",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGIN_USERNAME,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> loginUsername(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "username", description = "the user's email address they used to sign-up", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "the password", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "deviceId", description = "the device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "app", description = "the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "app", required = false) @Nullable String app,
        @Parameter(name = "gameType", description = "This parameter is deprecated. This is deprecated, use appKey.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "returnProfile", description = "the profile to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfile", required = false) @Nullable Boolean returnProfile,
        @Parameter(name = "responseFilters", description = "a comma separated list of ProfileFilters for filtering the returned response data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false) @Nullable String responseFilters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LOGOUT = "/api/{version}/account/logout";
    /**
     * POST /api/{version}/account/logout : Logout Account
     * Cleans up the users data for logging out.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "logout",
        summary = "Logout Account",
        description = "Cleans up the users data for logging out.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_LOGOUT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> logout(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "deviceIdType", description = "Device Id Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdType", required = false) @Nullable String deviceIdType,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_MERGE_ACCOUNT = "/api/{version}/account/merge";
    /**
     * POST /api/{version}/account/merge : Merge Account
     * Merges the analytics, achievements, leaderboards of two accounts.
     *
     * @param version  (required)
     * @param mergeAccountId The id of the account to being merged (required)
     * @param appKey The application key (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "mergeAccount",
        summary = "Merge Account",
        description = "Merges the analytics, achievements, leaderboards of two accounts.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_MERGE_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> mergeAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "mergeAccountId", description = "The id of the account to being merged", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "mergeAccountId", required = true) Long mergeAccountId,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_MISSION_INVITE = "/api/{version}/invite/mission";
    /**
     * POST /api/{version}/invite/mission : Invite to Mission
     * Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user&#39;s friend when the invitation is accepted.
     *
     * @param version  (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param appId This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param missionId the mission to share (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "missionInvite",
        summary = "Invite to Mission",
        description = "Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_MISSION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> missionInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appId", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appId", required = false) @Nullable Long appId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "missionId", description = "the mission to share", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_OFFER_INVITE = "/api/{version}/invite/offer";
    /**
     * POST /api/{version}/invite/offer : Invite to Offer
     * Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite&#39;s list.
     *
     * @param version  (required)
     * @param accountId the account ID of the user making the share (required)
     * @param appKey the application key (required)
     * @param offerId the ID of the offer used to invite to favorite (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "offerInvite",
        summary = "Invite to Offer",
        description = "Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_OFFER_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> offerInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user making the share", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "offerId", description = "the ID of the offer used to invite to favorite", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = true) Long offerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_OFFER_LOCATION_INVITE = "/api/{version}/invite/offerLocation";
    /**
     * POST /api/{version}/invite/offerLocation : Invite to Offer Location
     * Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite&#39;s list.
     *
     * @param version  (required)
     * @param accountId the account ID of the user making the share (required)
     * @param appKey the application key (required)
     * @param offerLocationId the id of the offer location to share (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "offerLocationInvite",
        summary = "Invite to Offer Location",
        description = "Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_OFFER_LOCATION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> offerLocationInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user making the share", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "offerLocationId", description = "the id of the offer location to share", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = true) Long offerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_OPTIMIZE_ROUTE = "/api/{version}/route/{routeId}/optimize";
    /**
     * POST /api/{version}/route/{routeId}/optimize : Optimize Route
     * Optimize a route. The optimization method based on how the server is configured.
     *
     * @param version  (required)
     * @param routeId the id of the route to optimize (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "optimizeRoute",
        summary = "Optimize Route",
        description = "Optimize a route. The optimization method based on how the server is configured.",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_OPTIMIZE_ROUTE
    )
    default ResponseEntity<Void> optimizeRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to optimize", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_OVERRIDE_USER_RANK = "/api/{version}/ranking/override";
    /**
     * POST /api/{version}/ranking/override : Override User Rank
     * Allows an admin of an application to override a user&#39;s scores for a leaderboard.
     *
     * @param version  (required)
     * @param accountId the logged in user&#39;s account id (must have permissions to manage data for the application) (required)
     * @param ownerAccountId the end user&#39;s account id to override (required)
     * @param appKey the application key the leaderboard is for (required)
     * @param rankType the rankType of the leaderboard (required)
     * @param totalScore the total score to update (optional)
     * @param totalCount the total count to update (optional)
     * @param totalTime the total time to update (optional)
     * @param dailyScore the daily score to update (optional)
     * @param dailyCount the daily count to update (optional)
     * @param dailyTime the daily time to update (optional)
     * @param weeklyScore the weekly score to update (optional)
     * @param weeklyCount the weekly count to update (optional)
     * @param weeklyTime the weekly time to update (optional)
     * @param monthlyScore the monthly score to update (optional)
     * @param monthlyCount the monthly count to update (optional)
     * @param monthlyTime the monthly time to update (optional)
     * @param topScore the top score to update (optional)
     * @param lowestScore the lowest score to update (optional)
     * @param streakCount the streak count to update (optional)
     * @param streakBestCount the best streak count to update (optional)
     * @param startDate the start date to update (optional)
     * @param endDate the end date to update (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "overrideUserRank",
        summary = "Override User Rank",
        description = "Allows an admin of an application to override a user's scores for a leaderboard.",
        tags = { "Ranking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_OVERRIDE_USER_RANK,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> overrideUserRank(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the logged in user's account id (must have permissions to manage data for the application)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "ownerAccountId", description = "the end user's account id to override", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerAccountId", required = true) Long ownerAccountId,
        @NotNull @Parameter(name = "appKey", description = "the application key the leaderboard is for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "rankType", description = "the rankType of the leaderboard", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = true) String rankType,
        @Parameter(name = "totalScore", description = "the total score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "totalScore", required = false) @Nullable Long totalScore,
        @Parameter(name = "totalCount", description = "the total count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "totalCount", required = false) @Nullable Long totalCount,
        @Parameter(name = "totalTime", description = "the total time to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "totalTime", required = false) @Nullable Long totalTime,
        @Parameter(name = "dailyScore", description = "the daily score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dailyScore", required = false) @Nullable Long dailyScore,
        @Parameter(name = "dailyCount", description = "the daily count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dailyCount", required = false) @Nullable Long dailyCount,
        @Parameter(name = "dailyTime", description = "the daily time to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dailyTime", required = false) @Nullable Long dailyTime,
        @Parameter(name = "weeklyScore", description = "the weekly score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "weeklyScore", required = false) @Nullable Long weeklyScore,
        @Parameter(name = "weeklyCount", description = "the weekly count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "weeklyCount", required = false) @Nullable Long weeklyCount,
        @Parameter(name = "weeklyTime", description = "the weekly time to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "weeklyTime", required = false) @Nullable Long weeklyTime,
        @Parameter(name = "monthlyScore", description = "the monthly score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "monthlyScore", required = false) @Nullable Long monthlyScore,
        @Parameter(name = "monthlyCount", description = "the monthly count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "monthlyCount", required = false) @Nullable Long monthlyCount,
        @Parameter(name = "monthlyTime", description = "the monthly time to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "monthlyTime", required = false) @Nullable Long monthlyTime,
        @Parameter(name = "topScore", description = "the top score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "topScore", required = false) @Nullable Long topScore,
        @Parameter(name = "lowestScore", description = "the lowest score to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lowestScore", required = false) @Nullable Long lowestScore,
        @Parameter(name = "streakCount", description = "the streak count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streakCount", required = false) @Nullable Long streakCount,
        @Parameter(name = "streakBestCount", description = "the best streak count to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streakBestCount", required = false) @Nullable Long streakBestCount,
        @Parameter(name = "startDate", description = "the start date to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PASSWORD_CHANGE = "/api/{version}/account/passwordchange";
    /**
     * POST /api/{version}/account/passwordchange : Update Password
     * Update the account password.
     *
     * @param version  (required)
     * @param accountId The account to update (required)
     * @param oldPassword The current password, used to validate access (required)
     * @param newPassword The new password to set, cannot be empty (required)
     * @param confirmPassword The new password to confirm, must match newPassword (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "passwordChange",
        summary = "Update Password",
        description = "Update the account password.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PASSWORD_CHANGE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> passwordChange(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "oldPassword", description = "The current password, used to validate access", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "oldPassword", required = true) String oldPassword,
        @NotNull @Parameter(name = "newPassword", description = "The new password to set, cannot be empty", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "newPassword", required = true) String newPassword,
        @NotNull @Parameter(name = "confirmPassword", description = "The new password to confirm, must match newPassword", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "confirmPassword", required = true) String confirmPassword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PASSWORD_RESET = "/api/{version}/account/passwordreset";
    /**
     * POST /api/{version}/account/passwordreset : Reset Password
     * Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
     *
     * @param version  (required)
     * @param token The token associated with the account to update, good for 24 hours (required)
     * @param password The new password to set, cannot be empty (required)
     * @param confirm The new password to confirm, must match newPassword (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "passwordReset",
        summary = "Reset Password",
        description = "Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PASSWORD_RESET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> passwordReset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "token", description = "The token associated with the account to update, good for 24 hours", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token,
        @NotNull @Parameter(name = "password", description = "The new password to set, cannot be empty", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @NotNull @Parameter(name = "confirm", description = "The new password to confirm, must match newPassword", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "confirm", required = true) String confirm
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PERFORM_ACTION_ON_NFT = "/api/{version}/vatom/me/vatoms/actions";
    /**
     * POST /api/{version}/vatom/me/vatoms/actions : Perform Action on NFT
     * Perform Action on NFT.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomId Vatom NFT Id (required)
     * @param vatomAction Vatom Action (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "performActionOnNFT",
        summary = "Perform Action on NFT",
        description = "Perform Action on NFT.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PERFORM_ACTION_ON_NFT
    )
    default ResponseEntity<Void> performActionOnNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomId", description = "Vatom NFT Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomId", required = true) String vatomId,
        @NotNull @Parameter(name = "vatomAction", description = "Vatom Action", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomAction", required = true) String vatomAction,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_POST_APP_DATA = "/api/{version}/app/post";
    /**
     * POST /api/{version}/app/post : Create App Data
     * Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user&#39;s profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user&#39;s   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application
     *
     * @param version  (required)
     * @param gameType the game to retrieve the data for, use your application key. (required)
     * @param start start the search results at a record. (required)
     * @param limit limit the search results to some number. (required)
     * @param data The analytic data AnalyticListResponse (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param includeGameData if true then include the game data blob, otherwise don&#39;t include. (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword query string used to filter the search results when looking for community and saved levels. (optional)
     * @param sortField how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS. (optional)
     * @param descending order the search results descending or ascending when looking for community and saved levels. (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param gameObjectCount if true then include the game object count, otherwise don&#39;t include. (optional)
     * @param filter restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED (optional)
     * @param dateCreated restrict the search to items created less then date (optional)
     * @param ownerId get levels owned by a particular account (optional)
     * @param missionIds get missions by specified id, comman seperated list of long ids (optional)
     * @param gameIds get games by specified id, comman seperated list of long ids (optional)
     * @param packIds get packs by specified id, comman seperated list of long ids (optional)
     * @param gameLevelIds get game levels by specified id, comman seperated list of long ids (optional)
     * @param appVersion the application version, used to versin the game level data (optional)
     * @param includeHigherVersionPacks default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
     * @param includeHigherVersionLevels default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
     * @param responseGroups use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list  (optional)
     * @param purchaseType the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "postAppData",
        summary = "Create App Data",
        description = "Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application",
        tags = { "AppData" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AppResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_POST_APP_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<AppResponse> postAppData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "gameType", description = "the game to retrieve the data for, use your application key.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = true) String gameType,
        @NotNull @Parameter(name = "start", description = "start the search results at a record.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "limit the search results to some number.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "data", description = "The analytic data AnalyticListResponse", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "includeGameData", description = "if true then include the game data blob, otherwise don't include.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "query string used to filter the search results when looking for community and saved levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "order the search results descending or ascending when looking for community and saved levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "gameObjectCount", description = "if true then include the game object count, otherwise don't include.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectCount", required = false) @Nullable Boolean gameObjectCount,
        @Parameter(name = "filter", description = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) @Nullable String filter,
        @Parameter(name = "dateCreated", description = "restrict the search to items created less then date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCreated", required = false) @Nullable Long dateCreated,
        @Parameter(name = "ownerId", description = "get levels owned by a particular account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "missionIds", description = "get missions by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionIds", required = false) @Nullable String missionIds,
        @Parameter(name = "gameIds", description = "get games by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameIds", required = false) @Nullable String gameIds,
        @Parameter(name = "packIds", description = "get packs by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packIds", required = false) @Nullable String packIds,
        @Parameter(name = "gameLevelIds", description = "get game levels by specified id, comman seperated list of long ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "appVersion", description = "the application version, used to versin the game level data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "includeHigherVersionPacks", description = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeHigherVersionPacks", required = false) @Nullable Boolean includeHigherVersionPacks,
        @Parameter(name = "includeHigherVersionLevels", description = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeHigherVersionLevels", required = false) @Nullable Boolean includeHigherVersionLevels,
        @Parameter(name = "responseGroups", description = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroups", required = false) @Nullable String responseGroups,
        @Parameter(name = "purchaseType", description = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_POST_PROGRAM = "/api/{version}/program/{id}";
    /**
     * POST /api/{version}/program/{id} : Update Program
     * Update an existing program
     *
     * @param version  (required)
     * @param id the id of the program (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "postProgram",
        summary = "Update Program",
        description = "Update an existing program",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Program.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_POST_PROGRAM,
        produces = { "*/*" }
    )
    default ResponseEntity<Program> postProgram(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the program", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Program body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_POST_SERVICE_HUB = "/api/{version}/hub/{id}";
    /**
     * POST /api/{version}/hub/{id} : Update Service Hub
     * Update an existing service hub
     *
     * @param version  (required)
     * @param id the id of the service hub (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "postServiceHub",
        summary = "Update Service Hub",
        description = "Update an existing service hub",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ServiceHub.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_POST_SERVICE_HUB,
        produces = { "*/*" }
    )
    default ResponseEntity<ServiceHub> postServiceHub(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the service hub", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable ServiceHub body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PREVIEW_OFFER_TRANSACTION = "/api/{version}/wallet/preview";
    /**
     * POST /api/{version}/wallet/preview : Preview Wallet Offers
     * Preview the final cost of a transaction without charging the user
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to CASH)
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "previewOfferTransaction",
        summary = "Preview Wallet Offers",
        description = "Preview the final cost of a transaction without charging the user",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferTransactionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PREVIEW_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferTransactionResponse>> previewOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "offerId", description = "The id of the offer being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "The id of the offer location being added (offerId or offeLocationId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "offerCart", description = "A JSON list of offers to purchase.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerCart", required = false) @Nullable String offerCart,
        @Parameter(name = "promoCode", description = "The promoCode", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode,
        @Parameter(name = "currencyType", description = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "usePoints", deprecated = true, description = "Sets the currencyType to POINTS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "usePoints", required = false) @Deprecated @Nullable Boolean usePoints,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "appKey", description = "The application requesting the purchase, required when currencyType is TICKETS", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PREVIEW_ORDER = "/api/{version}/order/preview";
    /**
     * POST /api/{version}/order/preview : Preview Order
     * Previews a purchase to see the total cost before making it.
     *
     * @param version  (required)
     * @param appKey The application requesting the purchase (required)
     * @param cart A JSON list of items to purchase (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60;  (optional, default to CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "previewOrder",
        summary = "Preview Order",
        description = "Previews a purchase to see the total cost before making it.",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PREVIEW_ORDER,
        produces = { "*/*" }
    )
    default ResponseEntity<OrderResponse> previewOrder(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application requesting the purchase", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "cart", description = "A JSON list of items to purchase", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "cart", required = true) String cart,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "description", description = "A description of the purchase", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "currencyType", description = "Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "paymentMethodId", description = "Use a specific payment method (CASH), if not provided use default", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId,
        @Parameter(name = "externalOrderId", description = "Store identifier from external system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalOrderId", required = false) @Nullable String externalOrderId,
        @Parameter(name = "externalPaymentId", description = "Store identifier from external system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalPaymentId", required = false) @Nullable String externalPaymentId,
        @Parameter(name = "remoteRefType", description = "Remote Reference type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "remoteRefType", required = false) @Nullable String remoteRefType,
        @Parameter(name = "externalDate", description = "External Date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalDate", required = false) @Nullable Long externalDate,
        @Parameter(name = "promoCode", description = "The Promo Code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PROCESS_ALL_PARTICIPANTS = "/api/{version}/participant/process/all";
    /**
     * POST /api/{version}/participant/process/all : Process All Participant Feeds
     * Processes all supported participant feeds.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param appKey The application key used to identify the application (optional)
     * @param useShortNameAsID Whether to use short name as the participant ID (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "processAllParticipants",
        summary = "Process All Participant Feeds",
        description = "Processes all supported participant feeds.",
        tags = { "Participants" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PROCESS_ALL_PARTICIPANTS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> processAllParticipants(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "useShortNameAsID", description = "Whether to use short name as the participant ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useShortNameAsID", required = false) @Nullable Boolean useShortNameAsID
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PROCESS_PARTICIPANTS = "/api/{version}/participant/process";
    /**
     * POST /api/{version}/participant/process : Process Participants Feed
     * Processes a participant feed or uploaded file for a specific league.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param league The league identifier to process (required)
     * @param appKey The application key used to identify the application (optional)
     * @param useShortNameAsID Whether to use short name as the participant ID (optional)
     * @param file Multipart file containing participant feed contents (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "processParticipants",
        summary = "Process Participants Feed",
        description = "Processes a participant feed or uploaded file for a specific league.",
        tags = { "Participants" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PROCESS_PARTICIPANTS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> processParticipants(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "league", description = "The league identifier to process", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "league", required = true) String league,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "useShortNameAsID", description = "Whether to use short name as the participant ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useShortNameAsID", required = false) @Nullable Boolean useShortNameAsID,
        @Parameter(name = "file", description = "Multipart file containing participant feed contents", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PROCESS_TRIP_MATCHES = "/api/{version}/trip/match/process";
    /**
     * POST /api/{version}/trip/match/process : Process Trip Matches
     * Process trip matching, assign trips with no route to matched trips with route.
     *
     * @param version  (required)
     * @param startDate The lower bound date to process matchings (optional)
     * @param endDate The upper bound date to process matchings (optional)
     * @param tripId the id of the trip to process (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "processTripMatches",
        summary = "Process Trip Matches",
        description = "Process trip matching, assign trips with no route to matched trips with route.",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PROCESS_TRIP_MATCHES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> processTripMatches(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "startDate", description = "The lower bound date to process matchings", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The upper bound date to process matchings", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tripId", description = "the id of the trip to process", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tripId", required = false) @Nullable Long tripId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PURCHASE_SECURE = "/api/{version}/secure/purchase";
    /**
     * POST /api/{version}/secure/purchase : Purchase Clear
     * Purchase via Clear.me. Creates a new account if purchasing for the first time.
     *
     * @param version  (required)
     * @param body The payment request object (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "purchaseSecure",
        summary = "Purchase Clear",
        description = "Purchase via Clear.me. Creates a new account if purchasing for the first time.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_PURCHASE_SECURE,
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    default ResponseEntity<ProfileResponse> purchaseSecure(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "The payment request object", required = true) @Valid @RequestBody PaymentRequest body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PUT_PROGRAM = "/api/{version}/program/{id}";
    /**
     * PUT /api/{version}/program/{id} : Update Program
     * Update an existing program
     *
     * @param version  (required)
     * @param id the id of the program (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "putProgram",
        summary = "Update Program",
        description = "Update an existing program",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Program.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_PUT_PROGRAM,
        produces = { "*/*" }
    )
    default ResponseEntity<Program> putProgram(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the program", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Program body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_PUT_SERVICE_HUB = "/api/{version}/hub/{id}";
    /**
     * PUT /api/{version}/hub/{id} : Update Service Hub
     * Update an existing service hub
     *
     * @param version  (required)
     * @param id the id of the service hub (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "putServiceHub",
        summary = "Update Service Hub",
        description = "Update an existing service hub",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ServiceHub.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_PUT_SERVICE_HUB,
        produces = { "*/*" }
    )
    default ResponseEntity<ServiceHub> putServiceHub(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the service hub", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable ServiceHub body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_CREATE = "/api/{version}/queue/create";
    /**
     * POST /api/{version}/queue/create : Create Queue
     * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
     *
     * @param version  (required)
     * @param appKey The application key unique to each application. (required)
     * @param name The name of the queue to create (required)
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL Use SSL (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queueCreate",
        summary = "Create Queue",
        description = "Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_QUEUE_CREATE,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> queueCreate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key unique to each application.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "name", description = "The name of the queue to create", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "deviceId", description = "The client deviceID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "workers", description = "The number of workers to generate ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "workers", required = false, defaultValue = "1") Integer workers,
        @Parameter(name = "analyticTags", description = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "analyticTags", required = false) @Nullable String analyticTags,
        @Parameter(name = "hostname", description = "The hostname of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hostname", required = false) @Nullable String hostname,
        @Parameter(name = "port", description = "The port of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "port", required = false) @Nullable Integer port,
        @Parameter(name = "username", description = "The username to access the server that the queue is on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = false) @Nullable String username,
        @Parameter(name = "password", description = "The password to access the queue to connect to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = false) @Nullable String password,
        @Parameter(name = "virtualHost", description = "The virtual host defined on the server to queue", in = ParameterIn.QUERY) @Valid @RequestParam(value = "virtualHost", required = false) @Nullable String virtualHost,
        @Parameter(name = "useSSL", description = "Use SSL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useSSL", required = false) @Nullable Boolean useSSL
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_DELETE = "/api/{version}/queue/delete";
    /**
     * POST /api/{version}/queue/delete : Delete Queue
     * Delete the stored queue record and close any active connections to the AMQP servers.
     *
     * @param version  (required)
     * @param queueId The id of the queue to find (required)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queueDelete",
        summary = "Delete Queue",
        description = "Delete the stored queue record and close any active connections to the AMQP servers.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_QUEUE_DELETE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> queueDelete(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "queueId", description = "The id of the queue to find", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = true) Long queueId,
        @Parameter(name = "deviceId", description = "The client device ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_GET = "/api/{version}/queue/get";
    /**
     * GET /api/{version}/queue/get : Get Queue
     * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     *
     * @param version  (required)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param queueId The id of the queue to find (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to find (optional)
     * @param hostname The hostname of the queue to find (optional)
     * @param virtualHost The virtual host of the queue to find (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queueGet",
        summary = "Get Queue",
        description = "Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_QUEUE_GET,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> queueGet(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The client device ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "queueId", description = "The id of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = false) @Nullable Long queueId,
        @Parameter(name = "appKey", description = "The application key the queue was assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "name", description = "The name of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "hostname", description = "The hostname of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hostname", required = false) @Nullable String hostname,
        @Parameter(name = "virtualHost", description = "The virtual host of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "virtualHost", required = false) @Nullable String virtualHost
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_PUBLISH = "/api/{version}/queue/publish";
    /**
     * POST /api/{version}/queue/publish : Publish Queue
     * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     *
     * @param version  (required)
     * @param message The payload to send to the queue (required)
     * @param queueId The id of the queue to publish to (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queuePublish",
        summary = "Publish Queue",
        description = "Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_QUEUE_PUBLISH,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> queuePublish(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "message", description = "The payload to send to the queue", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = true) String message,
        @Parameter(name = "queueId", description = "The id of the queue to publish to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = false) @Nullable Long queueId,
        @Parameter(name = "appKey", description = "The application key the queue was assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "name", description = "The name of the queue to publish to or the analytic tag to handle if the analytic param is true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "hostname", description = "The hostname of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hostname", required = false) @Nullable String hostname,
        @Parameter(name = "virtualHost", description = "The virtual host defined on the server to queue", in = ParameterIn.QUERY) @Valid @RequestParam(value = "virtualHost", required = false) @Nullable String virtualHost
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_SEARCH = "/api/{version}/queue/search";
    /**
     * GET /api/{version}/queue/search : Search Queue
     * Get the queues setup for the BillableEntity&#39;s applications.
     *
     * @param version  (required)
     * @param queueId The id of the queue to find (optional)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param name The name of the queue to find (optional)
     * @param start Start of the index (optional, default to 0)
     * @param limit Limit of the index (optional, default to 10)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queueSearch",
        summary = "Search Queue",
        description = "Get the queues setup for the BillableEntity's applications.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_QUEUE_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> queueSearch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "queueId", description = "The id of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = false) @Nullable Long queueId,
        @Parameter(name = "deviceId", description = "The client device ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the queue to find", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "start", description = "Start of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "Limit of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "10") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_QUEUE_UPDATE = "/api/{version}/queue/update";
    /**
     * POST /api/{version}/queue/update : Update Queue
     * Update the basic AMQP queue.
     *
     * @param version  (required)
     * @param queueId The id of the queue to update (required)
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param workers The number of workers to generate (optional)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL the SSL to use (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "queueUpdate",
        summary = "Update Queue",
        description = "Update the basic AMQP queue.",
        tags = { "AMQP" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QueueResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_QUEUE_UPDATE,
        produces = { "*/*" }
    )
    default ResponseEntity<QueueResponse> queueUpdate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "queueId", description = "The id of the queue to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "queueId", required = true) Long queueId,
        @Parameter(name = "deviceId", description = "The client deviceID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key unique to each application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "workers", description = "The number of workers to generate", in = ParameterIn.QUERY) @Valid @RequestParam(value = "workers", required = false) @Nullable Integer workers,
        @Parameter(name = "analyticTags", description = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "analyticTags", required = false) @Nullable String analyticTags,
        @Parameter(name = "hostname", description = "The hostname of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hostname", required = false) @Nullable String hostname,
        @Parameter(name = "port", description = "The port of the server the queue is hosted on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "port", required = false) @Nullable Integer port,
        @Parameter(name = "username", description = "The username to access the server that the queue is on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = false) @Nullable String username,
        @Parameter(name = "password", description = "The password to access the queue to connect to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = false) @Nullable String password,
        @Parameter(name = "virtualHost", description = "The virtual host defined on the server to queue", in = ParameterIn.QUERY) @Valid @RequestParam(value = "virtualHost", required = false) @Nullable String virtualHost,
        @Parameter(name = "useSSL", description = "the SSL to use", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useSSL", required = false) @Nullable Boolean useSSL
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REDEEM_NFT = "/api/{version}/vatom/b/redemptions";
    /**
     * POST /api/{version}/vatom/b/redemptions : Redeem NFT
     * Redeem an NFT.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "redeemNFT",
        summary = "Redeem NFT",
        description = "Redeem an NFT.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REDEEM_NFT
    )
    default ResponseEntity<Void> redeemNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REDEEM_OFFER_TRANSACTION = "/api/{version}/retailer/offer/transaction/update";
    /**
     * POST /api/{version}/retailer/offer/transaction/update : Update Offer Transaction
     * Redeems an offer.
     *
     * @param version  (required)
     * @param offerTransactionId the OfferTransaction ID of the transaction being redeemed (required)
     * @param status the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param offerLocationId the OfferLocation ID where the offer is being redeemed (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "redeemOfferTransaction",
        summary = "Update Offer Transaction",
        description = "Redeems an offer.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REDEEM_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> redeemOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerTransactionId", description = "the OfferTransaction ID of the transaction being redeemed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerTransactionId", required = true) Long offerTransactionId,
        @NotNull @Parameter(name = "status", description = "the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = true) Integer status,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "offerLocationId", description = "the OfferLocation ID where the offer is being redeemed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REDEEM_USER_COINS_AS_BUSINESS = "/api/{version}/vatom/b/users/coins/redeem";
    /**
     * POST /api/{version}/vatom/b/users/coins/redeem : Redeem the coins for a user (as a Business)
     * Redeem the coins for a user (as a Business).
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "redeemUserCoinsAsBusiness",
        summary = "Redeem the coins for a user (as a Business)",
        description = "Redeem the coins for a user (as a Business).",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REDEEM_USER_COINS_AS_BUSINESS
    )
    default ResponseEntity<Void> redeemUserCoinsAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REGEN_APP_DATA = "/api/{version}/app/regen";
    /**
     * POST /api/{version}/app/regen : Regenerate App Data
     * Regenerate the app data cache for apps
     *
     * @param version  (required)
     * @param accountId the account id of the user (optional)
     * @param appKey process a specific application, if null process all apps with caches (optional)
     * @param buildVersion create a specific version, if null use current version. Be careful if processing all (optional)
     * @param apiVersion create a specific version, if null use current version. Be careful if processing all (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "regenAppData",
        summary = "Regenerate App Data",
        description = "Regenerate the app data cache for apps",
        tags = { "AppData" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REGEN_APP_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> regenAppData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "process a specific application, if null process all apps with caches", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "buildVersion", description = "create a specific version, if null use current version. Be careful if processing all", in = ParameterIn.QUERY) @Valid @RequestParam(value = "buildVersion", required = false) @Nullable String buildVersion,
        @Parameter(name = "apiVersion", description = "create a specific version, if null use current version. Be careful if processing all", in = ParameterIn.QUERY) @Valid @RequestParam(value = "apiVersion", required = false) @Nullable String apiVersion
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REGISTER_LIKE = "/api/{version}/like";
    /**
     * POST /api/{version}/like : Create Like
     * Allows a user to like or dislike accounts, albums, album contests, assets, game levels, notes, and theme descriptors. Multiple likes\\dislikes on the same object will replace the previous one.
     *
     * @param version  (required)
     * @param likableType The type of likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR} (required)
     * @param likableId The id of the likable object (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone likes an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param like determines whether the user likes or dislikes the object (optional)
     * @param app This parameter is deprecated. This is deprecated, use \&quot;appKey\&quot; instead. (optional)
     * @param gameType This parameter is deprecated. This is deprecated, use \&quot;appKey\&quot; instead. (optional)
     * @param appKey the application key (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "registerLike",
        summary = "Create Like",
        description = "Allows a user to like or dislike accounts, albums, album contests, assets, game levels, notes, and theme descriptors. Multiple likes\\dislikes on the same object will replace the previous one.",
        tags = { "Like" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LikableResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REGISTER_LIKE,
        produces = { "*/*" }
    )
    default ResponseEntity<LikableResponse> registerLike(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "likableType", description = "The type of likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableType", required = true) String likableType,
        @NotNull @Parameter(name = "likableId", description = "The id of the likable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableId", required = true) Long likableId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "permissionableType", description = "This is used for sending out group notifications. For example, when someone likes an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the permissionable object (for sending group notifications)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "like", description = "determines whether the user likes or dislikes the object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "like", required = false) @Nullable Boolean like,
        @Parameter(name = "app", description = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "app", required = false) @Nullable String app,
        @Parameter(name = "gameType", description = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REGISTER_NOTIFICATION_TOKEN = "/api/{version}/notification/token";
    /**
     * POST /api/{version}/notification/token : Register Notification Token
     * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
     *
     * @param version  (required)
     * @param token A token that is generated by the device to sign requests for the notification service providers (required)
     * @param pushType The type of push notification. Possible values include: APNS, GCM (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
     * @param appKey The application key (optional)
     * @param gameType This parameter is deprecated (use appKey instead) (optional)
     * @param active Sets whether the token is active or not (non-active tokens are not used) (optional)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "registerNotificationToken",
        summary = "Register Notification Token",
        description = "Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REGISTER_NOTIFICATION_TOKEN,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> registerNotificationToken(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "token", description = "A token that is generated by the device to sign requests for the notification service providers", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token,
        @NotNull @Parameter(name = "pushType", description = "The type of push notification. Possible values include: APNS, GCM", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "pushType", required = true) String pushType,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "environment", description = "Determines if the token is a DEVELOPMENT or PRODUCTION token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "environment", required = false) @Nullable String environment,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "gameType", description = "This parameter is deprecated (use appKey instead)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "active", description = "Sets whether the token is active or not (non-active tokens are not used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "latitude", description = "Latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_ALBUM = "/api/{version}/album/delete";
    /**
     * POST /api/{version}/album/delete : Delete Album
     * Deletes an Album
     *
     * @param version  (required)
     * @param albumId the album ID to delete (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeAlbum",
        summary = "Delete Album",
        description = "Deletes an Album",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_ALBUM,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeAlbum(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "the album ID to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_ALBUM_USERS = "/api/{version}/album/user/delete";
    /**
     * POST /api/{version}/album/user/delete : Remove Album Users
     * Remove participants of an album.
     *
     * @param version  (required)
     * @param albumId the album ID (required)
     * @param removeFriendGroup remove friend group (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param connectionGroups comma separated list of connection group IDs (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeAlbumUsers",
        summary = "Remove Album Users",
        description = "Remove participants of an album.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_ALBUM_USERS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeAlbumUsers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "the album ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @NotNull @Parameter(name = "removeFriendGroup", description = "remove friend group", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFriendGroup", required = true) Boolean removeFriendGroup,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connections", description = "comma separated list of connection IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connections", required = false) @Nullable String connections,
        @Parameter(name = "connectionGroups", description = "comma separated list of connection group IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroups", required = false) @Nullable String connectionGroups
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_ASSET = "/api/{version}/asset/remove";
    /**
     * POST /api/{version}/asset/remove : Remove Asset from Collection
     * Remove assets from collections
     *
     * @param version  (required)
     * @param assetId the id of the asset to remove (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param albumId the album id to remove the asset from (optional)
     * @param collectionId the collection id to remove the asset from (optional)
     * @param removeFromDefaultAlbums remove from the user&#39;s profile album (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeAsset",
        summary = "Remove Asset from Collection",
        description = "Remove assets from collections",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_ASSET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeAsset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "assetId", description = "the id of the asset to remove", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = true) String assetId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumId", description = "the album id to remove the asset from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "collectionId", description = "the collection id to remove the asset from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionId", required = false) @Nullable Long collectionId,
        @Parameter(name = "removeFromDefaultAlbums", description = "remove from the user's profile album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFromDefaultAlbums", required = false) @Nullable Boolean removeFromDefaultAlbums,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_CONNECTION_FROM_GROUP = "/api/{version}/consumer/connection/group/removeConnection";
    /**
     * POST /api/{version}/consumer/connection/group/removeConnection : Delete Connection
     * Removes the connection from group.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param groupId the group id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeConnectionFromGroup",
        summary = "Delete Connection",
        description = "Removes the connection from group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_CONNECTION_FROM_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeConnectionFromGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "groupId", description = "the group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = true) Long groupId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionId", description = "the connection id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionId", required = false) @Nullable Long connectionId,
        @Parameter(name = "connectionAccountId", description = "the connection account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "pendingId", description = "the pending id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pendingId", required = false) @Nullable Long pendingId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_CONNECTIONS_FROM_GROUP = "/api/{version}/connection/group/removeConnections";
    /**
     * POST /api/{version}/connection/group/removeConnections : Remove Connections
     * Remove a list of connections from a group.
     *
     * @param version  (required)
     * @param connectionGroupId connection group id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeConnectionsFromGroup",
        summary = "Remove Connections",
        description = "Remove a list of connections from a group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_CONNECTIONS_FROM_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeConnectionsFromGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "connectionGroupId", description = "connection group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupId", required = true) Long connectionGroupId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionIds", description = "comma separated list of connection ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionAccountIds", description = "comma separated list of connection account ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_DEPENDENT = "/api/{version}/cargo/dependent/{accountId}";
    /**
     * DELETE /api/{version}/cargo/dependent/{accountId} : Delete Dependent
     * Delete the Dependent
     *
     * @param version  (required)
     * @param accountId the id of the parent account tied to the dependent (required)
     * @param dependentId the id of the dependent to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeDependent",
        summary = "Delete Dependent",
        description = "Delete the Dependent",
        tags = { "Dependent" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_REMOVE_DEPENDENT
    )
    default ResponseEntity<Void> removeDependent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the parent account tied to the dependent", required = true, in = ParameterIn.PATH) @PathVariable("accountId") Long accountId,
        @NotNull @Parameter(name = "dependentId", description = "the id of the dependent to delete", required = true, in = ParameterIn.PATH) @PathVariable("dependentId") Long dependentId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_GROUP = "/api/{version}/consumer/connection/group/remove";
    /**
     * POST /api/{version}/consumer/connection/group/remove : Delete Connection Group
     * Remove a user&#39;s group.
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param groupId the group id (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeGroup",
        summary = "Delete Connection Group",
        description = "Remove a user's group.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_GROUP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeGroup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "groupId", description = "the group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = true) Long groupId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_LIKE = "/api/{version}/like/delete";
    /**
     * POST /api/{version}/like/delete : Delete Like
     * Removes a like. This will make the user \&quot;neutral\&quot;.
     *
     * @param version  (required)
     * @param likableType The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR} (required)
     * @param likableId The id of the likable object (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeLike",
        summary = "Delete Like",
        description = "Removes a like. This will make the user \"neutral\".",
        tags = { "Like" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LikableResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_LIKE,
        produces = { "*/*" }
    )
    default ResponseEntity<LikableResponse> removeLike(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "likableType", description = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableType", required = true) String likableType,
        @NotNull @Parameter(name = "likableId", description = "The id of the likable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableId", required = true) Long likableId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_PREVIEW = "/api/{version}/creative/removepreview";
    /**
     * POST /api/{version}/creative/removepreview : Remove Preview
     * Remove this ad for preview for this account.
     *
     * @param version  (required)
     * @param accountId the ID of the logged in user (required)
     * @param creativeId the ID of the creative to remove preview (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removePreview",
        summary = "Remove Preview",
        description = "Remove this ad for preview for this account.",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_PREVIEW,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removePreview(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the ID of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "creativeId", description = "the ID of the creative to remove preview", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = true) Long creativeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_STOP = "/api/{version}/route/{routeId}/stop/{stopId}";
    /**
     * DELETE /api/{version}/route/{routeId}/stop/{stopId} : Delete Stop
     * Delete a stop on a route
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param stopId the id of the specific stop to delete on the route (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeStop",
        summary = "Delete Stop",
        description = "Delete a stop on a route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ApiApi.PATH_REMOVE_STOP
    )
    default ResponseEntity<Void> removeStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "stopId", description = "the id of the specific stop to delete on the route", required = true, in = ParameterIn.PATH) @PathVariable("stopId") Long stopId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_SUB_GROUPS = "/api/{version}/consumer/connection/group/removeSubGroup";
    /**
     * POST /api/{version}/consumer/connection/group/removeSubGroup : Remove Connection Groups
     * Remove sub groups from a group
     *
     * @param version  (required)
     * @param returnNulls whether to return nulls or not (required)
     * @param groupId the parent group id (required)
     * @param subGroupIds comma separated list of group IDs to remove from the parent group (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeSubGroups",
        summary = "Remove Connection Groups",
        description = "Remove sub groups from a group",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_SUB_GROUPS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeSubGroups(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "whether to return nulls or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "groupId", description = "the parent group id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupId", required = true) Long groupId,
        @NotNull @Parameter(name = "subGroupIds", description = "comma separated list of group IDs to remove from the parent group", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "subGroupIds", required = true) String subGroupIds,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_THEME_DESCRIPTOR = "/api/{version}/consumer/theme/remove";
    /**
     * POST /api/{version}/consumer/theme/remove : Delete Theme
     * Removes a theme.
     *
     * @param version  (required)
     * @param themeDescriptorId the theme id to remove (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType the unique title of an application given from the admin tool (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeThemeDescriptor",
        summary = "Delete Theme",
        description = "Removes a theme.",
        tags = { "Theme Descriptor" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_THEME_DESCRIPTOR,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeThemeDescriptor(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "themeDescriptorId", description = "the theme id to remove", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "themeDescriptorId", required = true) Long themeDescriptorId,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "the unique title of an application given from the admin tool", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REMOVE_USERS_FROM_PERMISSIONABLE = "/api/{version}/consumer/permissions/remove";
    /**
     * POST /api/{version}/consumer/permissions/remove : Remove User
     * Used to remove someone (assuming they have permission) from a permissionable object
     *
     * @param version  (required)
     * @param permissionableType the permissionable type of the object (required)
     * @param permissionableId the id of the permissionable object (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param removeFriendGroup flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "removeUsersFromPermissionable",
        summary = "Remove User",
        description = "Used to remove someone (assuming they have permission) from a permissionable object",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REMOVE_USERS_FROM_PERMISSIONABLE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> removeUsersFromPermissionable(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "permissionableType", description = "the permissionable type of the object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = true) String permissionableType,
        @NotNull @Parameter(name = "permissionableId", description = "the id of the permissionable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = true) Long permissionableId,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionIds", description = "a comma separated list of connection ids (NOT the account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionAccountIds", description = "a comma separated list of account ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "connectionGroupIds", description = "a comma separated list of connection group ids (these are groups made by the user)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "removeFriendGroup", description = "flag to determine whether to remove the built-in \"friends\" group", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFriendGroup", required = false, defaultValue = "false") Boolean removeFriendGroup,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "audienceIds", description = "comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REORDER_ROUTE_STOPS_PATCH = "/api/{version}/route/{routeId}/stops/reorder";
    /**
     * PATCH /api/{version}/route/{routeId}/stops/reorder : Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "reorderRouteStopsPatch",
        summary = "Reorder Route Stops",
        description = "Reordering the stops on the route with and update route distance, time, direction, and polyline",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Stop.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PATCH,
        value = ApiApi.PATH_REORDER_ROUTE_STOPS_PATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Stop>> reorderRouteStopsPatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable List<@Valid Stop> body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REORDER_ROUTE_STOPS_POST = "/api/{version}/route/{routeId}/stops/reorder";
    /**
     * POST /api/{version}/route/{routeId}/stops/reorder : Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "reorderRouteStopsPost",
        summary = "Reorder Route Stops",
        description = "Reordering the stops on the route with and update route distance, time, direction, and polyline",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Stop.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REORDER_ROUTE_STOPS_POST,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Stop>> reorderRouteStopsPost(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable List<@Valid Stop> body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REQUEST_OPTIMIZATION = "/api/{version}/optimize/request";
    /**
     * POST /api/{version}/optimize/request : Request Optimization
     * Request and upload of shipment orders and create ShipmentImportBatch for optimization.
     *
     * @param version  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "requestOptimization",
        summary = "Request Optimization",
        description = "Request and upload of shipment orders and create ShipmentImportBatch for optimization.",
        tags = { "Optimize" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ImportStatuses.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REQUEST_OPTIMIZATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ImportStatuses> requestOptimization(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Orders body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REQUEST_PASSWORD_RESET = "/api/{version}/account/requestpasswordreset";
    /**
     * POST /api/{version}/account/requestpasswordreset : Request Password Reset
     * Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
     *
     * @param version  (required)
     * @param email The email/username of the account (required)
     * @param from this is the sender email (optional, default to Sirqul)
     * @param domain this is the domain (like dev.sirqul.com) used to generate the password reset link (optional)
     * @param subUrl this is the the subUrl (like resetpassword) used to generate a password reset link (optional)
     * @param referer this is used to generate a password reset link (optional, default to http://dev.sirqul.com/resetpassword)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "requestPasswordReset",
        summary = "Request Password Reset",
        description = "Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REQUEST_PASSWORD_RESET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> requestPasswordReset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "email", description = "The email/username of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = true) String email,
        @Parameter(name = "from", description = "this is the sender email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "from", required = false, defaultValue = "Sirqul") String from,
        @Parameter(name = "domain", description = "this is the domain (like dev.sirqul.com) used to generate the password reset link", in = ParameterIn.QUERY) @Valid @RequestParam(value = "domain", required = false) @Nullable String domain,
        @Parameter(name = "subUrl", description = "this is the the subUrl (like resetpassword) used to generate a password reset link", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subUrl", required = false) @Nullable String subUrl,
        @Parameter(name = "referer", description = "this is used to generate a password reset link", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referer", required = false, defaultValue = "http://dev.sirqul.com/resetpassword") String referer
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REQUEST_VALIDATE_ACCOUNT = "/api/{version}/account/requestValidateAccount";
    /**
     * POST /api/{version}/account/requestValidateAccount : Send Validation Request
     * Send an email to validate a user&#39;s account.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "requestValidateAccount",
        summary = "Send Validation Request",
        description = "Send an email to validate a user's account.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_REQUEST_VALIDATE_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> requestValidateAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RESERVABLE_AVAILABILITY = "/api/{version}/reservable/availability/update";
    /**
     * POST /api/{version}/reservable/availability/update : Update Availability
     *
     * @param version  (required)
     * @param reservableId the id of the reservation (required)
     * @param reservableType the type of reservation (required)
     * @param deviceId the device id of the reservation (optional)
     * @param accountId the id of the logged in user (optional)
     * @param availability Availability (optional)
     * @param availabilitySummary Availability Summary (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "reservableAvailability",
        summary = "Update Availability",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AvailabilityResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RESERVABLE_AVAILABILITY,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AvailabilityResponse>> reservableAvailability(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "reservableId", description = "the id of the reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableId", required = true) Long reservableId,
        @NotNull @Parameter(name = "reservableType", description = "the type of reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableType", required = true) String reservableType,
        @Parameter(name = "deviceId", description = "the device id of the reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "availability", description = "Availability", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availability", required = false) @Nullable String availability,
        @Parameter(name = "availabilitySummary", description = "Availability Summary", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilitySummary", required = false) @Nullable String availabilitySummary
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RESET_SECURE = "/api/{version}/secure/application/reset";
    /**
     * POST /api/{version}/secure/application/reset : Rest Secure Application
     * Reset a secure application client.
     *
     * @param version  (required)
     * @param accountId The unique id of the user making the request (required)
     * @param appKey The application to secure (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "resetSecure",
        summary = "Rest Secure Application",
        description = "Reset a secure application client.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RESET_SECURE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> resetSecure(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The unique id of the user making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to secure", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RETAILER_LOCATION_INVITE = "/api/{version}/invite/retailerLocation";
    /**
     * POST /api/{version}/invite/retailerLocation : Invite to Retailer Location
     * Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite&#39;s list.
     *
     * @param version  (required)
     * @param accountId the account ID of the user making the share (required)
     * @param appKey the application key (required)
     * @param retailerLocationId The retailer location id of where the event will take place (required)
     * @param albumId Optional album id to link with the invite (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "retailerLocationInvite",
        summary = "Invite to Retailer Location",
        description = "Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.",
        tags = { "Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = InviteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RETAILER_LOCATION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<InviteResponse> retailerLocationInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user making the share", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "retailerLocationId", description = "The retailer location id of where the event will take place", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = true) Long retailerLocationId,
        @Parameter(name = "albumId", description = "Optional album id to link with the invite", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RETAILER_LOGIN_CHECK = "/api/{version}/retailer/login";
    /**
     * POST /api/{version}/retailer/login : Login Retailer
     * Retailer login check.
     *
     * @param version  (required)
     * @param username the user&#39;s email address they used to sign-up (required)
     * @param password the password (required)
     * @param deviceId the device id (optional) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param appKey the application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "retailerLoginCheck",
        summary = "Login Retailer",
        description = "Retailer login check.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AccountLoginResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RETAILER_LOGIN_CHECK,
        produces = { "*/*" }
    )
    default ResponseEntity<AccountLoginResponse> retailerLoginCheck(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "username", description = "the user's email address they used to sign-up", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "the password", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "deviceId", description = "the device id (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RIDE = "/api/{version}/trip/{id}/ride";
    /**
     * POST /api/{version}/trip/{id}/ride : Set Trip Preference Rider
     * Update trip preference to ride.
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param recurrence the frequency of the trip (e.g. weekly, until 2018-08-09) (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "ride",
        summary = "Set Trip Preference Rider",
        description = "Update trip preference to ride.",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RIDE,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> ride(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "recurrence", description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurrence", required = true) Boolean recurrence
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RUN_REPORT = "/api/{version}/report/run";
    /**
     * POST /api/{version}/report/run : Run Report
     *  This endpoint allows you to run a set of predefined reports that can be used to understand your users&#39; behavior as well as trends within your application.
     *
     * @param version  (required)
     * @param desc If true then descending order, false is ascending (required)
     * @param accountId The account id of the user for passing account related params (optional)
     * @param query The named identifier of the query (optional)
     * @param parameters Parameter values used in the query in JSON format, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param order The order to use, must be a column name (see response results for list of column names) (optional)
     * @param start The start of the pagination (optional)
     * @param limit The limit of the pagination (optional)
     * @param responseFormat Determines what response format to return. Options are: JSON or CSV (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "runReport",
        summary = "Run Report",
        description = " This endpoint allows you to run a set of predefined reports that can be used to understand your users' behavior as well as trends within your application.",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ReportResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RUN_REPORT,
        produces = { "*/*" }
    )
    default ResponseEntity<ReportResponse> runReport(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "desc", description = "If true then descending order, false is ascending", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "desc", required = true) Boolean desc,
        @Parameter(name = "accountId", description = "The account id of the user for passing account related params", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "query", description = "The named identifier of the query", in = ParameterIn.QUERY) @Valid @RequestParam(value = "query", required = false) @Nullable String query,
        @Parameter(name = "parameters", description = "Parameter values used in the query in JSON format, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parameters", required = false) @Nullable String parameters,
        @Parameter(name = "order", description = "The order to use, must be a column name (see response results for list of column names)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "order", required = false) @Nullable String order,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Long limit,
        @Parameter(name = "responseFormat", description = "Determines what response format to return. Options are: JSON or CSV", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_RUN_WORKFLOW = "/api/{version}/workflow/run";
    /**
     * POST /api/{version}/workflow/run : Run Workflow
     * Runs a published executable workflow
     *
     * @param version  (required)
     * @param accountId the account ID of the user (required)
     * @param workflowId the workflow to run (required)
     * @param skuId this runs a particular sku on the workflow (optional)
     * @param versionCode this runs a particular sku version on the workflow (optional)
     * @param parameters Override parameters in JSON format. Example: &#x60;&#x60;&#x60;json {   \&quot;arguments_81\&quot;: { \&quot;filter\&quot;: \&quot;PUBLIC\&quot; },   \&quot;arguments_87\&quot;: { \&quot;tag\&quot;: \&quot;custom_tag\&quot; } } &#x60;&#x60;&#x60;  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "runWorkflow",
        summary = "Run Workflow",
        description = "Runs a published executable workflow",
        tags = { "Workflow" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_RUN_WORKFLOW,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> runWorkflow(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "workflowId", description = "the workflow to run", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "workflowId", required = true) Long workflowId,
        @Parameter(name = "skuId", description = "this runs a particular sku on the workflow", in = ParameterIn.QUERY) @Valid @RequestParam(value = "skuId", required = false) @Nullable Long skuId,
        @Parameter(name = "versionCode", description = "this runs a particular sku version on the workflow", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "parameters", description = "Override parameters in JSON format. Example: ```json {   \"arguments_81\": { \"filter\": \"PUBLIC\" },   \"arguments_87\": { \"tag\": \"custom_tag\" } } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parameters", required = false) @Nullable String parameters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SAVE_TICKET = "/api/{version}/ticket/save";
    /**
     * POST /api/{version}/ticket/save : Save Ticket
     * Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
     *
     * @param version  (required)
     * @param actionType the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER (required)
     * @param ticketObjectType the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM (required)
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id that owns the tickets (optional)
     * @param accountId the account id that owns the tickets (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format. (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "saveTicket",
        summary = "Save Ticket",
        description = "Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SAVE_TICKET,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> saveTicket(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "actionType", description = "the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionType", required = true) String actionType,
        @NotNull @Parameter(name = "ticketObjectType", description = "the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketObjectType", required = true) String ticketObjectType,
        @Parameter(name = "returnNulls", description = "whether to return nulls or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false) @Nullable Boolean returnNulls,
        @Parameter(name = "deviceId", description = "the device id that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id that owns the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated. deprecated, use the appKey", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "objectId", description = "the ID of the item being purchased", in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectId", required = false) @Nullable Long objectId,
        @Parameter(name = "purchaseCode", description = "a unique string identifier defined by the application owner or Executive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseCode", required = false) @Nullable String purchaseCode,
        @Parameter(name = "receiptToken", description = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiptToken", required = false) @Nullable String receiptToken,
        @Parameter(name = "receiptData", description = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiptData", required = false) @Nullable String receiptData,
        @Parameter(name = "count", description = "the count of tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = false) @Nullable Long count,
        @Parameter(name = "ticketType", description = "the ticket type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "purchaseProvider", description = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseProvider", required = false) @Nullable String purchaseProvider,
        @Parameter(name = "purchaseType", description = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType,
        @Parameter(name = "returnProfileResponse", description = "returns a ProfileResponse if true, otherwise will return an AppResponse", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfileResponse", required = false) @Nullable Boolean returnProfileResponse,
        @Parameter(name = "includeProfileResponse", description = "if returnProfileResponse is false, will return an AppResponse with profile data if true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeProfileResponse", required = false) @Nullable Boolean includeProfileResponse,
        @Parameter(name = "appVersion", description = "the application version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SAVE_TICKET_VIA_FILE_UPLOAD = "/api/{version}/ticket/save/fileUpload";
    /**
     * POST /api/{version}/ticket/save/fileUpload : Save Ticket with Reciept
     * Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
     *
     * @param version  (required)
     * @param actionType the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER } (required)
     * @param ticketObjectType the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM} (required)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format. (required)
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "saveTicketViaFileUpload",
        summary = "Save Ticket with Reciept",
        description = "Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SAVE_TICKET_VIA_FILE_UPLOAD,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> saveTicketViaFileUpload(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "actionType", description = "the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionType", required = true) String actionType,
        @NotNull @Parameter(name = "ticketObjectType", description = "the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketObjectType", required = true) String ticketObjectType,
        @NotNull @Parameter(name = "receiptData", description = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiptData", required = true) org.springframework.core.io.Resource receiptData,
        @Parameter(name = "returnNulls", description = "whether to return nulls or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false) @Nullable Boolean returnNulls,
        @Parameter(name = "deviceId", description = "the device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameType", description = "This parameter is deprecated. deprecated, use the appKey", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "objectId", description = "the ID of the item being purchased", in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectId", required = false) @Nullable Long objectId,
        @Parameter(name = "purchaseCode", description = "a unique string identifier defined by the application owner or Executive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseCode", required = false) @Nullable String purchaseCode,
        @Parameter(name = "receiptToken", description = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiptToken", required = false) @Nullable String receiptToken,
        @Parameter(name = "count", description = "the count of tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = false) @Nullable Long count,
        @Parameter(name = "ticketType", description = "the ticket type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "purchaseProvider", description = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseProvider", required = false) @Nullable String purchaseProvider,
        @Parameter(name = "purchaseType", description = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType,
        @Parameter(name = "returnProfileResponse", description = "returns a ProfileResponse if true, otherwise will return an AppResponse", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfileResponse", required = false) @Nullable Boolean returnProfileResponse,
        @Parameter(name = "includeProfileResponse", description = "if returnProfileResponse is false, will return an AppResponse with profile data if true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeProfileResponse", required = false) @Nullable Boolean includeProfileResponse,
        @Parameter(name = "appVersion", description = "the application version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SAVE_TRACKING_LEG = "/api/{version}/tracking/leg/create";
    /**
     * POST /api/{version}/tracking/leg/create : Create Tracking Leg
     * Send tracking points to be able to generate pathing data
     *
     * @param version  (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "saveTrackingLeg",
        summary = "Create Tracking Leg",
        description = "Send tracking points to be able to generate pathing data",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SAVE_TRACKING_LEG,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> saveTrackingLeg(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "startLat", description = "the latitude of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startLat", required = true) Double startLat,
        @NotNull @Parameter(name = "startLng", description = "the longitude of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startLng", required = true) Double startLng,
        @NotNull @Parameter(name = "startDate", description = "the start date (in UTC milliseconds) of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = true) Long startDate,
        @NotNull @Parameter(name = "endLat", description = "the latitude of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endLat", required = true) Double endLat,
        @NotNull @Parameter(name = "endLng", description = "the longitude of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endLng", required = true) Double endLng,
        @NotNull @Parameter(name = "endDate", description = "the end date (in UTC milliseconds) of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = true) Long endDate,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "distance", description = "the total distance", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distance", required = false) @Nullable Double distance,
        @Parameter(name = "duration", description = "the total duration", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Long duration,
        @Parameter(name = "steps", description = "JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "steps", required = false) @Nullable String steps,
        @Parameter(name = "tags", description = "name the leg for searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SAVE_TRACKING_STEP = "/api/{version}/tracking/step/create";
    /**
     * POST /api/{version}/tracking/step/create : Create Tracking Step
     * Send tracking points to be able to generate pathing data
     *
     * @param version  (required)
     * @param legId the leg to add the step to (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "saveTrackingStep",
        summary = "Create Tracking Step",
        description = "Send tracking points to be able to generate pathing data",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SAVE_TRACKING_STEP,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> saveTrackingStep(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "legId", description = "the leg to add the step to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "legId", required = true) Long legId,
        @NotNull @Parameter(name = "startLat", description = "the latitude of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startLat", required = true) Double startLat,
        @NotNull @Parameter(name = "startLng", description = "the longitude of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startLng", required = true) Double startLng,
        @NotNull @Parameter(name = "startDate", description = "the start date (in UTC milliseconds) of the first point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = true) Long startDate,
        @NotNull @Parameter(name = "endLat", description = "the latitude of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endLat", required = true) Double endLat,
        @NotNull @Parameter(name = "endLng", description = "the longitude of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endLng", required = true) Double endLng,
        @NotNull @Parameter(name = "endDate", description = "the end date (in UTC milliseconds) of the last point", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = true) Long endDate,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "distance", description = "the total distance", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distance", required = false) @Nullable Double distance,
        @Parameter(name = "duration", description = "the total duration", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Long duration
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SCHEDULE_NOTIFICATION_LISTINGS = "/api/{version}/notification/schedule/generate";
    /**
     * POST /api/{version}/notification/schedule/generate : Generate Schedule Notifications
     * Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "scheduleNotificationListings",
        summary = "Generate Schedule Notifications",
        description = "Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SCHEDULE_NOTIFICATION_LISTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> scheduleNotificationListings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to target", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "reportName", description = "The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportName", required = true) String reportName,
        @NotNull @Parameter(name = "message", description = "The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = true) String message,
        @NotNull @Parameter(name = "offset", description = "Time in munites before the event starts to notify recipients", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = true) Integer offset,
        @NotNull @Parameter(name = "recipientReportId", description = "The report id used to generate the recipient list", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recipientReportId", required = true) Long recipientReportId,
        @Parameter(name = "reportParams", description = "The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "type", description = "The type of scheduled notification; supported values are: MOBILE_NOTIFICATION", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH = "/api/{version}/trip";
    /**
     * GET /api/{version}/trip : Search Trips
     * Search for trips
     *
     * @param version  (required)
     * @param accountId The owner of the trips (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param startDate The lower bound limit of time (optional)
     * @param endDate The upper bound limit of time (optional)
     * @param hasNotifications whether to search on trips that have notifications or not (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "search",
        summary = "Search Trips",
        description = "Search for trips",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> search(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The owner of the trips", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "startDate", description = "The lower bound limit of time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The upper bound limit of time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "hasNotifications", description = "whether to search on trips that have notifications or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasNotifications", required = false) @Nullable Boolean hasNotifications
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ACCOUNTS = "/api/{version}/account/profile/search";
    /**
     * GET /api/{version}/account/profile/search : Search Accounts
     * Search for account profiles.
     *
     * @param version  (required)
     * @param accountId The id of the account requesting (required)
     * @param appKey The application key (required)
     * @param keyword The keyword for for querying the account (optional)
     * @param latitude the latitude (optional)
     * @param longitude the longitude (optional)
     * @param radius the radius (optional, default to 5)
     * @param gender the user&#39;s gender (optional)
     * @param gameExperience the user&#39;s Game Experience (optional)
     * @param age the user&#39;s age (optional)
     * @param categoryIds the user&#39;s Category Ids (optional)
     * @param returnNulls Return Nulls (optional, default to true)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to PROFILE)
     * @param purchaseType A comma separated list of PurchaseType (optional, default to SIRQUL)
     * @param sortField The field to sort by (optional, default to id)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAccounts",
        summary = "Search Accounts",
        description = "Search for account profiles.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ProfileResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ACCOUNTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ProfileResponse>> searchAccounts(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The id of the account requesting", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "keyword", description = "The keyword for for querying the account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "latitude", description = "the latitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "radius", description = "the radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false, defaultValue = "5") Double radius,
        @Parameter(name = "gender", description = "the user's gender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "gameExperience", description = "the user's Game Experience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperience", required = false) @Nullable String gameExperience,
        @Parameter(name = "age", description = "the user's age", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "categoryIds", description = "the user's Category Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "returnNulls", description = "Return Nulls", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "true") Boolean returnNulls,
        @Parameter(name = "responseFilters", description = "A comma separated list of ProfileFilters for filtering the returned response data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters,
        @Parameter(name = "purchaseType", description = "A comma separated list of PurchaseType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false, defaultValue = "SIRQUL") String purchaseType,
        @Parameter(name = "sortField", description = "The field to sort by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "id") String sortField,
        @Parameter(name = "descending", description = "The order to return the results. Default is false, which will return the results in ascending order.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The total number of record to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ACCOUNTS_WITH_TRACKING_LEGS = "/api/{version}/tracking/list";
    /**
     * GET /api/{version}/tracking/list : List Tracking
     * Search for all accounts that have tracking legs data by the given constraints.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to LEG_START_DATE)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAccountsWithTrackingLegs",
        summary = "List Tracking",
        description = "Search for all accounts that have tracking legs data by the given constraints.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AccountMiniResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ACCOUNTS_WITH_TRACKING_LEGS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AccountMiniResponse>> searchAccountsWithTrackingLegs(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "Used for LIKE search of first or last name on the acocunt", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "startDate", description = "Range to begin in UTC milliseconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "Range to end in UTC milliseconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tags", description = "Exact match on tag field of Legs's searchTag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "audienceIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "latitude", description = "Origin latitude to perform searching constraints with given range", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Origin longitude to perform searching constraints with given range", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "range", description = "The radius, in miles, to perform the search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "range", required = false, defaultValue = "5") Double range,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "LEG_START_DATE") String sortField,
        @Parameter(name = "descending", description = "The order to return the results. Default is false, which will return the results in ascending order.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "The index into the record set to start with. Default is 0.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The total number of records to return. Default is 20.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ACHIEVEMENTS = "/api/{version}/achievement/search";
    /**
     * GET /api/{version}/achievement/search : Search Achievements
     * Searches achievements by application for consumers.
     *
     * @param version  (required)
     * @param appKey the application key (required)
     * @param sortField the field to sort by. See AchievementApiMap (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param includeTiers return tiers, only applicable for version &gt;3.18 (required)
     * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (has a hard limit of 1000) (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAchievements",
        summary = "Search Achievements",
        description = "Searches achievements by application for consumers.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AchievementShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ACHIEVEMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AchievementShortResponse>> searchAchievements(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. See AchievementApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "TITLE") String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") Boolean descending,
        @NotNull @Parameter(name = "includeTiers", description = "return tiers, only applicable for version >3.18", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeTiers", required = true, defaultValue = "false") Boolean includeTiers,
        @NotNull @Parameter(name = "includeInactiveTiers", description = "return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactiveTiers", required = true, defaultValue = "false") Boolean includeInactiveTiers,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination (has a hard limit of 1000)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true, defaultValue = "100") Integer limit,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "achievementType", description = "filter results by the achievementType (these are exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementType", required = false) @Nullable String achievementType,
        @Parameter(name = "rankType", description = "filter results by the rankType (these are exact case sensitive matches)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ALBUMS = "/api/{version}/album/search";
    /**
     * GET /api/{version}/album/search : Search Albums
     * Searches on Albums.
     *
     * @param version  (required)
     * @param filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums.  (required)
     * @param albumTypeId id of custom albumType (required)
     * @param subType filter albums with this album sub type (required)
     * @param includeInactive determines whether to return inactive albums (required)
     * @param sortField the field to sort by. See AlbumApiMap (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (There is a hard limit of 100) (required)
     * @param range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param includeLiked returns whether or not the current logged in user has liked the album (required)
     * @param includeFavorited returns whether or not the current logged in user has favorited the album (required)
     * @param includePermissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param likePreviewSize returns the last X likes (required)
     * @param assetPreviewSize returns the first X assets (required)
     * @param notePreviewSize returns the last X notes (required)
     * @param connectionPreviewSize returns the first X users/connections (required)
     * @param audiencePreviewSize returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param ownerId search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param albumIds search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param excludeAlbumIds Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param mediaId search on albums that are in a particular media offering (optional)
     * @param keyword keyword search string (optional)
     * @param albumType filter albums with this album type (optional)
     * @param limitPerAlbumType When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param dateCreated return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param createdSince return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param createdBefore return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param startedSince return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param startedBefore return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param endedSince return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param endedBefore return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param appKey the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param categoryIds return results with categories matching this list (optional)
     * @param categoryFilterIds return results with filters matching this list (optional)
     * @param audienceIds return results with audiences matching this list (optional)
     * @param excludeAudienceIds exclude audiences with ids matching this list (optional)
     * @param includeCompletable returns the user&#39;s completable object for the album if it exists (optional)
     * @param includeRating returns the user&#39;s rating for the album if it exists (optional)
     * @param searchMode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param stackSearch groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param stackWindowSize size of each window for each stack (optional)
     * @param minStackPerPage The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param stackPaginationIdentifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param stackDetails set this to true when making the call to view the albums in the stack (optional)
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param removeFlaggedContent return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param verifiedFilter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param linkedObjectType filter results by the linkedObjectType (optional)
     * @param linkedObjectId filter results by the linkedObjectId (optional)
     * @param orderAudienceId determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param ignoreDefaultAppFilter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param searchExpression Advanced search expression to be used by the server (optional)
     * @param generateAlbums If true and results are empty, attempt to generate albums via templates (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAlbums",
        summary = "Search Albums",
        description = "Searches on Albums.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AlbumFullResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ALBUMS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AlbumFullResponse>> searchAlbums(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "filter", description = "a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = true) String filter,
        @NotNull @Parameter(name = "albumTypeId", description = "id of custom albumType", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypeId", required = true) Long albumTypeId,
        @NotNull @Parameter(name = "subType", description = "filter albums with this album sub type", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = true) String subType,
        @NotNull @Parameter(name = "includeInactive", description = "determines whether to return inactive albums", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = true) Boolean includeInactive,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. See AlbumApiMap", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination (There is a hard limit of 100)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "range", description = "the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "range", required = true) Double range,
        @NotNull @Parameter(name = "includeLiked", description = "returns whether or not the current logged in user has liked the album", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeLiked", required = true) Boolean includeLiked,
        @NotNull @Parameter(name = "includeFavorited", description = "returns whether or not the current logged in user has favorited the album", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFavorited", required = true) Boolean includeFavorited,
        @NotNull @Parameter(name = "includePermissions", description = "returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includePermissions", required = true) Boolean includePermissions,
        @NotNull @Parameter(name = "likePreviewSize", description = "returns the last X likes", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likePreviewSize", required = true) Integer likePreviewSize,
        @NotNull @Parameter(name = "assetPreviewSize", description = "returns the first X assets", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetPreviewSize", required = true) Integer assetPreviewSize,
        @NotNull @Parameter(name = "notePreviewSize", description = "returns the last X notes", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notePreviewSize", required = true) Integer notePreviewSize,
        @NotNull @Parameter(name = "connectionPreviewSize", description = "returns the first X users/connections", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionPreviewSize", required = true) Integer connectionPreviewSize,
        @NotNull @Parameter(name = "audiencePreviewSize", description = "returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audiencePreviewSize", required = true) Integer audiencePreviewSize,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "ownerId", description = "search on albums that have been created by this account (that the user has permissions to)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "albumIds", description = "search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "excludeAlbumIds", description = "Only for CLOUDINDEX mode, exclude albums with ids matching this list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "excludeAlbumIds", required = false) @Nullable String excludeAlbumIds,
        @Parameter(name = "mediaId", description = "search on albums that are in a particular media offering", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaId", required = false) @Nullable Long mediaId,
        @Parameter(name = "keyword", description = "keyword search string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "albumType", description = "filter albums with this album type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumType", required = false) @Nullable String albumType,
        @Parameter(name = "limitPerAlbumType", description = "When using multiple album types this sets a per-album-type limit (used with cloud index mode)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limitPerAlbumType", required = false) @Nullable Integer limitPerAlbumType,
        @Parameter(name = "dateCreated", description = "return items that have been created before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "dateCreated", required = false) @Nullable Long dateCreated,
        @Parameter(name = "updatedSince", description = "return items that have been updated since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedSince", required = false) @Nullable Long updatedSince,
        @Parameter(name = "updatedBefore", description = "return items that have been updated before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedBefore", required = false) @Nullable Long updatedBefore,
        @Parameter(name = "createdSince", description = "return items that have been created since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createdSince", required = false) @Nullable Long createdSince,
        @Parameter(name = "createdBefore", description = "return items that have been created before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createdBefore", required = false) @Nullable Long createdBefore,
        @Parameter(name = "startedSince", description = "return items that have been started since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedSince", required = false) @Nullable Long startedSince,
        @Parameter(name = "startedBefore", description = "return items that have been started before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedBefore", required = false) @Nullable Long startedBefore,
        @Parameter(name = "endedSince", description = "return items that have been ended since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedSince", required = false) @Nullable Long endedSince,
        @Parameter(name = "endedBefore", description = "return items that have been ended before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedBefore", required = false) @Nullable Long endedBefore,
        @Parameter(name = "latitude", description = "the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "appKey", description = "the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "categoryIds", description = "return results with categories matching this list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "categoryFilterIds", description = "return results with filters matching this list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryFilterIds", required = false) @Nullable String categoryFilterIds,
        @Parameter(name = "audienceIds", description = "return results with audiences matching this list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "excludeAudienceIds", description = "exclude audiences with ids matching this list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "excludeAudienceIds", required = false) @Nullable String excludeAudienceIds,
        @Parameter(name = "includeCompletable", description = "returns the user's completable object for the album if it exists", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCompletable", required = false) @Nullable Boolean includeCompletable,
        @Parameter(name = "includeRating", description = "returns the user's rating for the album if it exists", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRating", required = false) @Nullable Boolean includeRating,
        @Parameter(name = "searchMode", description = "The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMode", required = false) @Nullable String searchMode,
        @Parameter(name = "stackSearch", description = "groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stackSearch", required = false) @Nullable Boolean stackSearch,
        @Parameter(name = "stackWindowSize", description = "size of each window for each stack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stackWindowSize", required = false) @Nullable Integer stackWindowSize,
        @Parameter(name = "minStackPerPage", description = "The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minStackPerPage", required = false) @Nullable Integer minStackPerPage,
        @Parameter(name = "stackPaginationIdentifier", description = "this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stackPaginationIdentifier", required = false) @Nullable String stackPaginationIdentifier,
        @Parameter(name = "stackDetails", description = "set this to true when making the call to view the albums in the stack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stackDetails", required = false) @Nullable Boolean stackDetails,
        @Parameter(name = "flagCountMinimum", description = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagCountMinimum", required = false) @Nullable Long flagCountMinimum,
        @Parameter(name = "removeFlaggedContent", description = "return items that have flagCount >= flagThreshold (controls removal of flagged content)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "removeFlaggedContent", required = false, defaultValue = "true") Boolean removeFlaggedContent,
        @Parameter(name = "verifiedFilter", description = "setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "verifiedFilter", required = false) @Nullable Boolean verifiedFilter,
        @Parameter(name = "linkedObjectType", description = "filter results by the linkedObjectType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectType", required = false) @Nullable String linkedObjectType,
        @Parameter(name = "linkedObjectId", description = "filter results by the linkedObjectId", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectId", required = false) @Nullable Long linkedObjectId,
        @Parameter(name = "orderAudienceId", description = "determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderAudienceId", required = false) @Nullable Long orderAudienceId,
        @Parameter(name = "ignoreDefaultAppFilter", description = "if true, ignore the application's default app filter when searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ignoreDefaultAppFilter", required = false) @Nullable Boolean ignoreDefaultAppFilter,
        @Parameter(name = "searchExpression", description = "Advanced search expression to be used by the server", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchExpression", required = false) @Nullable String searchExpression,
        @Parameter(name = "generateAlbums", description = "If true and results are empty, attempt to generate albums via templates", in = ParameterIn.QUERY) @Valid @RequestParam(value = "generateAlbums", required = false) @Nullable Boolean generateAlbums
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_APPLICATION_CONFIG = "/api/{version}/appconfig/search";
    /**
     * GET /api/{version}/appconfig/search : Search AppConfigs
     * Gets all versions of application configurations in a particular app by the given appKey.
     *
     * @param version  (required)
     * @param accountId The account ID of the user (required)
     * @param appKey The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only) (optional)
     * @param retailerId Only returns the configs that matches the given retailer (optional)
     * @param retailerLocationId Only returns the configs that matches the given retailer location (optional)
     * @param udid Only returns only returns the configs that matches the given device udid (optional)
     * @param configVersion Config Version (optional)
     * @param sortField Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX  (optional, default to CONFIG_VERSION_INDEX)
     * @param descending Determines whether the results are in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (There is a hard limit of 100) (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchApplicationConfig",
        summary = "Search AppConfigs",
        description = "Gets all versions of application configurations in a particular app by the given appKey.",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ApplicationConfigResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_APPLICATION_CONFIG,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ApplicationConfigResponse>> searchApplicationConfig(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "appKey", description = "The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "retailerId", description = "Only returns the configs that matches the given retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Only returns the configs that matches the given retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "udid", description = "Only returns only returns the configs that matches the given device udid", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid,
        @Parameter(name = "configVersion", description = "Config Version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "configVersion", required = false) @Nullable String configVersion,
        @Parameter(name = "sortField", description = "Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CONFIG_VERSION_INDEX") String sortField,
        @Parameter(name = "descending", description = "Determines whether the results are in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination (There is a hard limit of 100)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_APPLICATION_PLACEMENT = "/api/{version}/application/placement/search";
    /**
     * GET /api/{version}/application/placement/search : Search for Ad Placements
     * Searches placements for an application.
     *
     * @param version  (required)
     * @param appKey The key of the application (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param limit The limit of the pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchApplicationPlacement",
        summary = "Search for Ad Placements",
        description = "Searches placements for an application.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = PlacementResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_APPLICATION_PLACEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<List<PlacementResponse>> searchApplicationPlacement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The key of the application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_APPLICATION_SETTINGS = "/api/{version}/application/settings/search";
    /**
     * GET /api/{version}/application/settings/search : Search for Application Settings
     * Returns a list of applications that the user has logged into before, and returns specific settings for that application and user
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The account id used to view another person&#39;s account (optional)
     * @param keyword The string to search applications on (optional)
     * @param sortField The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE (optional, default to APPLICATION_TITLE)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit per result set for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchApplicationSettings",
        summary = "Search for Application Settings",
        description = "Returns a list of applications that the user has logged into before, and returns specific settings for that application and user",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationSettingsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_APPLICATION_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationSettingsResponse> searchApplicationSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "The account id used to view another person's account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "keyword", description = "The string to search applications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "APPLICATION_TITLE") String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit per result set for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_APPLICATIONS = "/api/{version}/application/search";
    /**
     * GET /api/{version}/application/search : Search Applications
     * Search for applications matching the criteria that the logged in user has access to
     *
     * @param version  (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The location of the device (optional)
     * @param longitude The location of the device (optional)
     * @param q Q (optional)
     * @param keyword The keyword used to search (optional)
     * @param qSearchFields The columns to applied the keyword search to (optional, default to NAME,ABOUT,BILLABLE_ENTITY_NAME)
     * @param sortField The column to sort the search on (optional, default to APPLICATION_ID)
     * @param descending The order to return the search results (optional, default to false)
     * @param i the start of the index (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param l the limit of the index (optional)
     * @param limit The limit of the pagination (optional, default to 100)
     * @param hasAds Filter results on whether the application supports ads or not. Ignore this parameter to return all results. (optional)
     * @param publicNotifications Filter results on whether the application is available for public trigger notifications (optional)
     * @param activeOnly Return only active results (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchApplications",
        summary = "Search Applications",
        description = "Search for applications matching the criteria that the logged in user has access to",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ApplicationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_APPLICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ApplicationResponse>> searchApplications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The location of the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The location of the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "q", deprecated = true, description = "Q", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Deprecated @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "qSearchFields", description = "The columns to applied the keyword search to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "qSearchFields", required = false, defaultValue = "NAME,ABOUT,BILLABLE_ENTITY_NAME") String qSearchFields,
        @Parameter(name = "sortField", description = "The column to sort the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "APPLICATION_ID") String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "_i", deprecated = true, description = "the start of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Deprecated @Nullable Integer i,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", deprecated = true, description = "the limit of the index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Deprecated @Nullable Integer l,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit,
        @Parameter(name = "hasAds", description = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasAds", required = false) @Nullable Boolean hasAds,
        @Parameter(name = "publicNotifications", description = "Filter results on whether the application is available for public trigger notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicNotifications", required = false) @Nullable Boolean publicNotifications,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ASSETS = "/api/{version}/asset/search";
    /**
     * GET /api/{version}/asset/search : Search Assets
     * Searches for assets
     *
     * @param version  (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumIds comma separated list of album ids to search on (optional)
     * @param assetIds comma separated list of asset ids to search on (optional)
     * @param appKey the application key to filter results by application. (optional)
     * @param mediaType filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT (optional)
     * @param mimeType filter results by mime type (optional)
     * @param keyword keyword search string (optional)
     * @param versionCode filter results by version code (optional)
     * @param versionName filter results by version name (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param sortField the field to sort by. See AssetApiMap (optional)
     * @param descending determines whether the sorted list is in descending or ascending order (optional)
     * @param searchMediaLibrary determines whether to search on the media library album (optional)
     * @param filterByBillable filter results by billable entity (optional)
     * @param activeOnly if only searching for active assets (optional)
     * @param returnApp determines whether to include the application response as part of the asset response (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (there is a hard limit of 200) (optional)
     * @param searchMode search mode for index (SearchIndexMode) (optional)
     * @param assetType filter by asset type (optional)
     * @param approvalStatus filter by approval status (optional)
     * @param assignedAccountId filter results by an assigned account id (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAssets",
        summary = "Search Assets",
        description = "Searches for assets",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AssetResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ASSETS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AssetResponse>> searchAssets(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumIds", description = "comma separated list of album ids to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "assetIds", description = "comma separated list of asset ids to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetIds", required = false) @Nullable String assetIds,
        @Parameter(name = "appKey", description = "the application key to filter results by application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "mediaType", description = "filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaType", required = false) @Nullable String mediaType,
        @Parameter(name = "mimeType", description = "filter results by mime type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mimeType", required = false) @Nullable String mimeType,
        @Parameter(name = "keyword", description = "keyword search string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "versionCode", description = "filter results by version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "versionName", description = "filter results by version name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionName", required = false) @Nullable String versionName,
        @Parameter(name = "updatedSince", description = "return items that have been updated since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedSince", required = false) @Nullable Long updatedSince,
        @Parameter(name = "updatedBefore", description = "return items that have been updated before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedBefore", required = false) @Nullable Long updatedBefore,
        @Parameter(name = "sortField", description = "the field to sort by. See AssetApiMap", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "searchMediaLibrary", description = "determines whether to search on the media library album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMediaLibrary", required = false) @Nullable Boolean searchMediaLibrary,
        @Parameter(name = "filterByBillable", description = "filter results by billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterByBillable", required = false) @Nullable Boolean filterByBillable,
        @Parameter(name = "activeOnly", description = "if only searching for active assets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "returnApp", description = "determines whether to include the application response as part of the asset response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnApp", required = false) @Nullable Boolean returnApp,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "the limit for pagination (there is a hard limit of 200)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "searchMode", description = "search mode for index (SearchIndexMode)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMode", required = false) @Nullable String searchMode,
        @Parameter(name = "assetType", description = "filter by asset type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetType", required = false) @Nullable String assetType,
        @Parameter(name = "approvalStatus", description = "filter by approval status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false) @Nullable String approvalStatus,
        @Parameter(name = "assignedAccountId", description = "filter results by an assigned account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignedAccountId", required = false) @Nullable Long assignedAccountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_AVAILABILITY = "/api/{version}/reservable/availability/search";
    /**
     * GET /api/{version}/reservable/availability/search : Search Availability
     *
     * @param version  (required)
     * @param reservableId the id of the reservation (required)
     * @param reservableType the reservable type (required)
     * @param deviceId the device ID that the reservation is on (optional)
     * @param accountId the id of the logged in user (optional)
     * @param startDate the start date of the reservation (optional)
     * @param endDate the end date of the reservation (optional)
     * @param start the start of the index and/or pagination (optional, default to 0)
     * @param limit the limit of the index and/or pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchAvailability",
        summary = "Search Availability",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AvailabilityResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_AVAILABILITY,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AvailabilityResponse>> searchAvailability(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "reservableId", description = "the id of the reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableId", required = true) Long reservableId,
        @NotNull @Parameter(name = "reservableType", description = "the reservable type", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableType", required = true) String reservableType,
        @Parameter(name = "deviceId", description = "the device ID that the reservation is on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "startDate", description = "the start date of the reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date of the reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "start", description = "the start of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_BATCH = "/api/{version}/report/batch/search";
    /**
     * GET /api/{version}/report/batch/search : Search Offline Reports
     * Retrieves batches for a user..
     *
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param start the start of the index and/or pagination (required)
     * @param limit the limit of the index and/or pagination (required)
     * @param names the names of the report batch to search on (optional)
     * @param appKey the application key (optional)
     * @param status the report batch status (optional)
     * @param globalAppSearch the global app to search on (optional)
     * @param startDate the start date of the report batch to search on (optional)
     * @param endDate the end date of the report batch to search on (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchBatch",
        summary = "Search Offline Reports",
        description = "Retrieves batches for a user..",
        tags = { "Reporting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ReportBatchResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ReportBatchResponse>> searchBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account logged in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "start", description = "the start of the index and/or pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit of the index and/or pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "names", description = "the names of the report batch to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "names", required = false) @Nullable String names,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "status", description = "the report batch status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "globalAppSearch", description = "the global app to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalAppSearch", required = false) @Nullable Boolean globalAppSearch,
        @Parameter(name = "startDate", description = "the start date of the report batch to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date of the report batch to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_BLOCKED_NOTIFICATIONS = "/api/{version}/notification/blocked/search";
    /**
     * GET /api/{version}/notification/blocked/search : Search on the user&#39;s blocked notification settings
     * Search on the user&#39;s blocked notification settings
     *
     * @param version  (required)
     * @param appKey The application key (required)
     * @param accountId the account id of the user (optional)
     * @param searchTags search tags to filter results (optional)
     * @param events events to filter by (comma separated) (optional)
     * @param conduits conduits to filter by (comma separated) (optional)
     * @param customTypes custom types to filter by (comma separated) (optional)
     * @param contentTypes content types to filter by (comma separated) (optional)
     * @param contentIds content ids to filter by (comma separated) (optional)
     * @param sortField sort field for results (optional)
     * @param descending whether to sort descending (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchBlockedNotifications",
        summary = "Search on the user's blocked notification settings",
        description = "Search on the user's blocked notification settings",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BlockedNotificationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_BLOCKED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<BlockedNotificationResponse> searchBlockedNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "searchTags", description = "search tags to filter results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "events", description = "events to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "events", required = false) @Nullable String events,
        @Parameter(name = "conduits", description = "conduits to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduits", required = false) @Nullable String conduits,
        @Parameter(name = "customTypes", description = "custom types to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customTypes", required = false) @Nullable String customTypes,
        @Parameter(name = "contentTypes", description = "content types to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "contentIds", description = "content ids to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "sortField", description = "sort field for results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "whether to sort descending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_BUSINESSES = "/api/{version}/vatom/b/search";
    /**
     * GET /api/{version}/vatom/b/search : Search for Vatom Businesses
     * Searches for Vatom businesses.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchBusinesses",
        summary = "Search for Vatom Businesses",
        description = "Searches for Vatom businesses.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_BUSINESSES
    )
    default ResponseEntity<Void> searchBusinesses(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CAMPAIGN_GROUPS = "/api/{version}/vatom/b/campaign-groups/search";
    /**
     * GET /api/{version}/vatom/b/campaign-groups/search : Search Campaign Groups
     * Search campaign groups.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchCampaignGroups",
        summary = "Search Campaign Groups",
        description = "Search campaign groups.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CAMPAIGN_GROUPS
    )
    default ResponseEntity<Void> searchCampaignGroups(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CARGO_TYPES = "/api/{version}/cargo/type";
    /**
     * GET /api/{version}/cargo/type : Search Cargo Type
     * Search for types of cargo
     *
     * @param version  (required)
     * @param sortField the sort field to use for the cargo type (required)
     * @param descending if the cargo type should be should be in descending order (required)
     * @param start the start of the search (required)
     * @param limit the limit of the search (required)
     * @param activeOnly if search should be on active only (required)
     * @param retailerId the id of the retailer location (optional)
     * @param hubId the ID of the hub (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchCargoTypes",
        summary = "Search Cargo Type",
        description = "Search for types of cargo",
        tags = { "Cargo Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = CargoType.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CARGO_TYPES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<CargoType>> searchCargoTypes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "the sort field to use for the cargo type", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "if the cargo type should be should be in descending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "the start of the search", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit of the search", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "if search should be on active only", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "retailerId", description = "the id of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "hubId", description = "the ID of the hub", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = false) @Nullable Long hubId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CARRIERS = "/api/{version}/carrier/search";
    /**
     * GET /api/{version}/carrier/search : Search Carriers
     * Search on supported mobile telephone carriers that can be used to send SMS notifications via email.
     *
     * @param version  (required)
     * @param keyword The keyword to search on (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to false)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param activeOnly Determines whether to return inactive results (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchCarriers",
        summary = "Search Carriers",
        description = "Search on supported mobile telephone carriers that can be used to send SMS notifications via email.",
        tags = { "Carrier" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = CellCarrierResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CARRIERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<CellCarrierResponse>> searchCarriers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "keyword", description = "The keyword to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return inactive results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CATEGORIES = "/api/{version}/category/search";
    /**
     * GET /api/{version}/category/search : Search Categories
     * Search for categories.
     *
     * @param version  (required)
     * @param accountId The account id of the user (optional)
     * @param keyword The string to search on (optional)
     * @param appKey the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param categoryId @Deprecated, use parentCategoryIds instead (optional)
     * @param categoryIds Restrict the search by specific categories (optional)
     * @param parentCategoryIds Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param rootOnly Restrict the search to only those categories with no parent category assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to DISPLAY)
     * @param responseGroup The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @param returnExternal Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param exactMatch If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param type Filters results by the Category&#39;s type (optional)
     * @param externalType Filters results by externalType (optional)
     * @param excludeExternalType Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param minOfferCount Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param searchDepth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param searchMode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchCategories",
        summary = "Search Categories",
        description = "Search for categories.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = CategoryResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CATEGORIES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<CategoryResponse>> searchCategories(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "The string to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "appKey", description = "the appKey of the application to retrieve categories for, if not specified then search on the global application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "categoryId", description = "@Deprecated, use parentCategoryIds instead", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = false) @Nullable String categoryId,
        @Parameter(name = "categoryIds", description = "Restrict the search by specific categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "parentCategoryIds", description = "Restrict the search by specific parent categories so that only its sub children are searched.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentCategoryIds", required = false) @Nullable String parentCategoryIds,
        @Parameter(name = "rootOnly", description = "Restrict the search to only those categories with no parent category assigned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rootOnly", required = false) @Nullable Boolean rootOnly,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") String sortField,
        @Parameter(name = "responseGroup", description = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroup", required = false) @Nullable String responseGroup,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "returnExternal", description = "Determines whether to return extra info about the category's \"Participant\" reference", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnExternal", required = false, defaultValue = "true") Boolean returnExternal,
        @Parameter(name = "exactMatch", description = "If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exactMatch", required = false, defaultValue = "false") Boolean exactMatch,
        @Parameter(name = "type", description = "Filters results by the Category's type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "externalType", description = "Filters results by externalType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "excludeExternalType", description = "Determines whether the \"externalType\" param is excluded from the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "excludeExternalType", required = false) @Nullable Boolean excludeExternalType,
        @Parameter(name = "minOfferCount", description = "Filters results to only return Categories that have been referenced by a minimum number of Offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minOfferCount", required = false) @Nullable Integer minOfferCount,
        @Parameter(name = "searchDepth", description = "When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchDepth", required = false, defaultValue = "4") Integer searchDepth,
        @Parameter(name = "searchMode", description = "The search index mode to use (e.g. OPENSEARCH or RDS)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMode", required = false) @Nullable String searchMode
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CONNECTIONS = "/api/{version}/connection/search";
    /**
     * GET /api/{version}/connection/search : Search Possible Connections
     * Search for accounts that the user may not have a connection with.
     *
     * @param version  (required)
     * @param returnNulls return all json attributes if true. defualt is true. (required)
     * @param start start index of the pagination (required)
     * @param limit limit of the pagination (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search on, optional and this parameter is ignored if empt (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the public application key, if provided only looks for users of that application (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param sortField the field to sort on (optional)
     * @param hasLocation whether the search has location or not (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchConnections",
        summary = "Search Possible Connections",
        description = "Search for accounts that the user may not have a connection with.",
        tags = { "Connection" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ConnectionListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CONNECTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<ConnectionListResponse> searchConnections(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "returnNulls", description = "return all json attributes if true. defualt is true.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnNulls", required = true) Boolean returnNulls,
        @NotNull @Parameter(name = "start", description = "start index of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "keyword to search on, optional and this parameter is ignored if empt", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "the public application key, if provided only looks for users of that application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "sortField", description = "the field to sort on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "hasLocation", description = "whether the search has location or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasLocation", required = false) @Nullable Boolean hasLocation
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_CREDENTIALS = "/api/{version}/thirdparty/credential/search";
    /**
     * GET /api/{version}/thirdparty/credential/search : Search Credentials
     * Search on a user&#39;s linked third party networks.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param keyword The keyword used to search on the third party name and network string (optional)
     * @param networkUID The network UID to filter results with (optional)
     * @param descending The order to return the search results (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param limit The limit of the pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchCredentials",
        summary = "Search Credentials",
        description = "Search on a user's linked third party networks.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ThirdPartyCredentialResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_CREDENTIALS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ThirdPartyCredentialResponse>> searchCredentials(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "The keyword used to search on the third party name and network string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "networkUID", description = "The network UID to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = false) @Nullable String networkUID,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "The start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_DATA = "/api/{version}/object/data/{objectName}";
    /**
     * GET /api/{version}/object/data/{objectName} : Search Data
     * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
     *
     * @param version  (required)
     * @param objectName The name of the object to search upon (required)
     * @param count If true just return the record count of the search. False (default) will return the actual records (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param accountId The account id of the logged in user (optional)
     * @param criteria The search criteria (optional)
     * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional)
     * @param include  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchData",
        summary = "Search Data",
        description = "Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> searchData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "count", description = "If true just return the record count of the search. False (default) will return the actual records", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = true) Boolean count,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Long start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Long limit,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "criteria", description = "The search criteria", in = ParameterIn.QUERY) @Valid @RequestParam(value = "criteria", required = false) @Nullable String criteria,
        @Parameter(name = "order", description = "The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "order", required = false) @Nullable String order,
        @Parameter(name = "include", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "include", required = false) @Nullable String include
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_DISBURSEMENTS = "/api/{version}/disbursement/search";
    /**
     * GET /api/{version}/disbursement/search : Search Disbursements
     * Search Disbursements
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param receiverAccountId filter results by the id of the account receiving the disbursement (optional)
     * @param statuses comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED (optional)
     * @param providers comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM (optional)
     * @param beforeDate the date for searching disbursements before it has been processed (optional)
     * @param afterDate the date for searching disbursements before it has been processed (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit per result set for pagination (optional, default to 20)
     * @param activeOnly search on disbursements that are active only (optional, default to false)
     * @param externalId search results by this external ID (that can be used to reference the disbursement) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchDisbursements",
        summary = "Search Disbursements",
        description = "Search Disbursements",
        tags = { "Disbursement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = DisbursementResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_DISBURSEMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<DisbursementResponse>> searchDisbursements(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "receiverAccountId", description = "filter results by the id of the account receiving the disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountId", required = false) @Nullable Long receiverAccountId,
        @Parameter(name = "statuses", description = "comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "providers", description = "comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "providers", required = false) @Nullable String providers,
        @Parameter(name = "beforeDate", description = "the date for searching disbursements before it has been processed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "beforeDate", required = false) @Nullable Long beforeDate,
        @Parameter(name = "afterDate", description = "the date for searching disbursements before it has been processed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "afterDate", required = false) @Nullable Long afterDate,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit per result set for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "search on disbursements that are active only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly,
        @Parameter(name = "externalId", description = "search results by this external ID (that can be used to reference the disbursement)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_EMPLOYEES = "/api/{version}/employee/search";
    /**
     * POST /api/{version}/employee/search : Search Employees
     * Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param role The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles. (optional)
     * @param retailerId Filters employees by retailer (optional)
     * @param retailerLocationId Filter employees by retailer locations (optional)
     * @param q Deprecated parameter (optional)
     * @param keyword an optional keyword to search on; ignored if empty (optional)
     * @param sortField The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to false)
     * @param i Deprecated parameter (optional)
     * @param start Start the result set at some index (optional, default to 0)
     * @param l Deprecated parameter (optional)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param activeOnly Filter results to only return active employees (optional, default to true)
     * @param managedOnly Filter results to only employees that you manage (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param categoryIds Comma separated list of category ids to filter results (optional)
     * @param query Legacy/reporting query parameter used for formatting employee responses (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchEmployees",
        summary = "Search Employees",
        description = "Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = EmployeeResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEARCH_EMPLOYEES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<EmployeeResponse>> searchEmployees(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "role", description = "The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "retailerId", description = "Filters employees by retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Filter employees by retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "q", description = "Deprecated parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "an optional keyword to search on; ignored if empty", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "_i", description = "Deprecated parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "Start the result set at some index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "_l", description = "Deprecated parameter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "Limit the result to some number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Filter results to only return active employees", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "managedOnly", description = "Filter results to only employees that you manage", in = ParameterIn.QUERY) @Valid @RequestParam(value = "managedOnly", required = false) @Nullable Boolean managedOnly,
        @Parameter(name = "settingsAppKey", description = "Determines whether to return the application settings for the employee for a particular application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "settingsAppKey", required = false) @Nullable String settingsAppKey,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids to filter results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "query", description = "Legacy/reporting query parameter used for formatting employee responses", in = ParameterIn.QUERY) @Valid @RequestParam(value = "query", required = false) @Nullable String query
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_EVENT_TRANSACTIONS = "/api/{version}/event/attendance/search";
    /**
     * GET /api/{version}/event/attendance/search : Search Event Attendance
     * Searches on event type transactions. This can be used to see who is attending an event.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param excludeRetailerLocationId Exclude results from this retailer location (optional)
     * @param listingId Filter results for this event listing (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param customerAccountIds Filter results by accounts (optional)
     * @param affiliatedCategoryIds Comma separated list of category ids to determine whether the attendee is affiliated with the category (optional)
     * @param startDate Filter on attendance starting on or after this date (milliseconds since epoch) (optional)
     * @param endDate Filter on attendance starting on or before this date (milliseconds since epoch) (optional)
     * @param statuses Comma separated list of transaction statuses to filter on (optional)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (optional)
     * @param descending Determines whether the results are in descending order (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchEventTransactions",
        summary = "Search Event Attendance",
        description = "Searches on event type transactions. This can be used to see who is attending an event.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = EventAttendanceResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_EVENT_TRANSACTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<EventAttendanceResponse>> searchEventTransactions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "Filter results for this retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Filter results for this retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "excludeRetailerLocationId", description = "Exclude results from this retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "excludeRetailerLocationId", required = false) @Nullable Long excludeRetailerLocationId,
        @Parameter(name = "listingId", description = "Filter results for this event listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = false) @Nullable Long listingId,
        @Parameter(name = "offerId", description = "Filter results for this offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "Filter results for this offer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "customerAccountIds", description = "Filter results by accounts", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customerAccountIds", required = false) @Nullable String customerAccountIds,
        @Parameter(name = "affiliatedCategoryIds", description = "Comma separated list of category ids to determine whether the attendee is affiliated with the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "affiliatedCategoryIds", required = false) @Nullable String affiliatedCategoryIds,
        @Parameter(name = "startDate", description = "Filter on attendance starting on or after this date (milliseconds since epoch)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "Filter on attendance starting on or before this date (milliseconds since epoch)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "statuses", description = "Comma separated list of transaction statuses to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "sortField", description = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the results are in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_EVENTS = "/api/{version}/event/search";
    /**
     * GET /api/{version}/event/search : Search Events
     * Searches on events that the account has access to.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param keyword The keyword used to search (optional)
     * @param activeOnly Return only active results (optional)
     * @param categoryIds the IDs of the categories that this event is associated with (optional)
     * @param filterIds the IDs of the filters that this event is associated with (optional)
     * @param offerAudienceIds Offer audience ids to filter on (optional)
     * @param transactionAudienceIds Transaction audience ids to filter on (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional)
     * @param descending The order to return the search results (optional)
     * @param startDate Filter the events to return only those that start on or after the date (optional)
     * @param endDate Filter the events to return only those that start on or before the date (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchEvents",
        summary = "Search Events",
        description = "Searches on events that the account has access to.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_EVENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferShortResponse>> searchEvents(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "categoryIds", description = "the IDs of the categories that this event is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "the IDs of the filters that this event is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "offerAudienceIds", description = "Offer audience ids to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerAudienceIds", required = false) @Nullable String offerAudienceIds,
        @Parameter(name = "transactionAudienceIds", description = "Transaction audience ids to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionAudienceIds", required = false) @Nullable String transactionAudienceIds,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "startDate", description = "Filter the events to return only those that start on or after the date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "Filter the events to return only those that start on or before the date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_FAVORITES = "/api/{version}/favorite/search";
    /**
     * GET /api/{version}/favorite/search : Search Favorites
     * Searches on the user&#39;s favorites.
     *
     * @param version  (required)
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (required)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, DISPLAY} (required)
     * @param descending Determines whether the results are in descending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (there is a hard limit of 1000) (required)
     * @param activeOnly Determines whether to only return active favorites (required)
     * @param returnFullResponse Determines whether to return a detailed version of the response list (required)
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The ID of an account the user would like to view favorites for (optional)
     * @param secondaryType  (optional)
     * @param keyword The keyword to search for (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchFavorites",
        summary = "Search Favorites",
        description = "Searches on the user's favorites.",
        tags = { "Favorite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SearchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_FAVORITES,
        produces = { "*/*" }
    )
    default ResponseEntity<SearchResponse> searchFavorites(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "favoritableType", description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableType", required = true) String favoritableType,
        @NotNull @Parameter(name = "sortField", description = "Determines what to sort the results by {CREATED, UPDATED, DISPLAY}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the results are in descending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination (there is a hard limit of 1000)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Determines whether to only return active favorites", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "returnFullResponse", description = "Determines whether to return a detailed version of the response list", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = true) Boolean returnFullResponse,
        @Parameter(name = "deviceId", description = "The unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "The ID of an account the user would like to view favorites for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "secondaryType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondaryType", required = false) @Nullable String secondaryType,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_FILTERS = "/api/{version}/filter/search";
    /**
     * GET /api/{version}/filter/search : Search Filters
     * Search for filters.
     *
     * @param version  (required)
     * @param accountId The account id of the user (optional)
     * @param keyword The string to search on (optional)
     * @param appKey the appKey of the application to retrieve filters for (optional)
     * @param responseGroup The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param rootOnly Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to DISPLAY)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchFilters",
        summary = "Search Filters",
        description = "Search for filters.",
        tags = { "Filter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = FilterResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_FILTERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<FilterResponse>> searchFilters(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "The string to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "appKey", description = "the appKey of the application to retrieve filters for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "responseGroup", description = "The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseGroup", required = false) @Nullable String responseGroup,
        @Parameter(name = "rootOnly", description = "Restrict the search to only those filters with no parent filter assigned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rootOnly", required = false) @Nullable Boolean rootOnly,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_GAMES = "/api/{version}/game/search";
    /**
     * GET /api/{version}/game/search : Search a Game
     * Get a list of games for an application, just those the account has permissions to view.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey the application key (required)
     * @param start Start the result set at some index. (required)
     * @param limit Limit the result to some number. (required)
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @param appVersion The maximum version of the level to return. (optional)
     * @param includeGameData more details in response (optional)
     * @param includeInactive more details in response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchGames",
        summary = "Search a Game",
        description = "Get a list of games for an application, just those the account has permissions to view.",
        tags = { "Game" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_GAMES,
        produces = { "*/*" }
    )
    default ResponseEntity<GameResponse> searchGames(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "start", description = "Start the result set at some index.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "Limit the result to some number.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "keyword", description = "Match the keyword to the owner name or level name.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "appVersion", description = "The maximum version of the level to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "includeGameData", description = "more details in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeInactive", description = "more details in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_IDENTITIES = "/api/{version}/vatom/me/identities/search";
    /**
     * GET /api/{version}/vatom/me/identities/search : Search User Identities
     * Search User Identities.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchIdentities",
        summary = "Search User Identities",
        description = "Search User Identities.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_IDENTITIES
    )
    default ResponseEntity<Void> searchIdentities(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_INVENTORY = "/api/{version}/vatom/user-inventory/search";
    /**
     * GET /api/{version}/vatom/user-inventory/search : Search Vatom User&#39;s Inventory
     * Searches the logged in user&#39;s Vatom Inventory.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (optional)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchInventory",
        summary = "Search Vatom User's Inventory",
        description = "Searches the logged in user's Vatom Inventory.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_INVENTORY
    )
    default ResponseEntity<Void> searchInventory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "vatomParameters", description = "Vatom Parameters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = false) @Nullable String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_LEADERBOARDS = "/api/{version}/leaderboard/search";
    /**
     * GET /api/{version}/leaderboard/search : Search leaderboard and retrieve the matching ranking list
     * Search leaderboard and retrieve the matching ranking list
     *
     * @param version  (required)
     * @param accountId The account id of the user requesting the search. (optional)
     * @param appKey The application key. (optional)
     * @param globalOnly only include global leaderboards (this overrides the appKey filter) (optional)
     * @param keyword keyword to search by title (optional)
     * @param leaderboardIds comma separated list of leaderboard ids to filter results with (optional)
     * @param rankTypes comma separated list of rankType to filter results with (optional)
     * @param sortField sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param includeInactive include inactive in the result (optional)
     * @param includeAppResponse determines whether to include the application response for each leaderboard (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchLeaderboards",
        summary = "Search leaderboard and retrieve the matching ranking list",
        description = "Search leaderboard and retrieve the matching ranking list",
        tags = { "Leaderboard" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LeaderboardResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_LEADERBOARDS,
        produces = { "*/*" }
    )
    default ResponseEntity<LeaderboardResponse> searchLeaderboards(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The account id of the user requesting the search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "globalOnly", description = "only include global leaderboards (this overrides the appKey filter)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalOnly", required = false) @Nullable Boolean globalOnly,
        @Parameter(name = "keyword", description = "keyword to search by title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "leaderboardIds", description = "comma separated list of leaderboard ids to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardIds", required = false) @Nullable String leaderboardIds,
        @Parameter(name = "rankTypes", description = "comma separated list of rankType to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankTypes", required = false) @Nullable String rankTypes,
        @Parameter(name = "sortField", description = "sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "includeInactive", description = "include inactive in the result", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive,
        @Parameter(name = "includeAppResponse", description = "determines whether to include the application response for each leaderboard", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAppResponse", required = false) @Nullable Boolean includeAppResponse,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_LIKES = "/api/{version}/like/search";
    /**
     * GET /api/{version}/like/search : Search Likes
     * Search for likes on a likable object.
     *
     * @param version  (required)
     * @param likableType The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR} (required)
     * @param likableId The id of the likable object (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param connectionAccountIds Comma separated list of account IDs for filtering on users (optional)
     * @param sortField The field to sort by. Possible values include: ID (optional, default to ID)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchLikes",
        summary = "Search Likes",
        description = "Search for likes on a likable object.",
        tags = { "Like" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SearchResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_LIKES,
        produces = { "*/*" }
    )
    default ResponseEntity<SearchResponse> searchLikes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "likableType", description = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableType", required = true) String likableType,
        @NotNull @Parameter(name = "likableId", description = "The id of the likable object", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "likableId", required = true) Long likableId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountIds", description = "Comma separated list of account IDs for filtering on users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "ID") String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "updatedSince", description = "return items that have been updated since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedSince", required = false) @Nullable Long updatedSince,
        @Parameter(name = "updatedBefore", description = "return items that have been updated before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedBefore", required = false) @Nullable Long updatedBefore,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_LISTING = "/api/{version}/listing/search";
    /**
     * GET /api/{version}/listing/search : Search Listings
     * Search for event listings from the start time to end time
     *
     * @param version  (required)
     * @param accountId the account id of the user (optional)
     * @param keyword search the event name and description for this keyword (optional)
     * @param start the record to begin the return set on (optional, default to 0)
     * @param limit the number of records to return (optional, default to 20)
     * @param activeOnly whether to search on active listings only (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param startDate the start date to search from (optional)
     * @param endDate the end date to search to (optional)
     * @param categoryIds only return items of these categories (optional)
     * @param filterIds  (optional)
     * @param useListingOrderIds determines whether to use configured listing order ids (optional, default to true)
     * @param externalId external identifier used by a third party (optional)
     * @param externalId2 secondary external identifier used by a third party (optional)
     * @param externalGroupId external group identifier used by a third party (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchListing",
        summary = "Search Listings",
        description = "Search for event listings from the start time to end time",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ListingResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ListingResponse>> searchListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "search the event name and description for this keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "start", description = "the record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "whether to search on active listings only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly,
        @Parameter(name = "latitude", description = "the current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "startDate", description = "the start date to search from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date to search to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "categoryIds", description = "only return items of these categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "useListingOrderIds", description = "determines whether to use configured listing order ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useListingOrderIds", required = false, defaultValue = "true") Boolean useListingOrderIds,
        @Parameter(name = "externalId", description = "external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalId2", description = "secondary external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId2", required = false) @Nullable String externalId2,
        @Parameter(name = "externalGroupId", description = "external group identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalGroupId", required = false) @Nullable String externalGroupId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_LOCATION_RATING_INDEXES = "/api/{version}/location/rating/index/search";
    /**
     * GET /api/{version}/location/rating/index/search : Search Location Rating Indexes
     * Search for retailer locations by averages near you.
     *
     * @param version  (required)
     * @param categoryIds Comma separated list of category ids to filter the results by (optional)
     * @param keyword The keyword used to search (optional)
     * @param locationType The type of location to filter the results by (optional)
     * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE} (optional)
     * @param descending The order to return the search results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @param searchRange The search radius in kilometers to filter results (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param returnOverallRating Determines whether to return the overall rating record instead (optional)
     * @param distanceUnit  (optional)
     * @param returnRetailer whether to return the retailer or not (optional)
     * @param returnAssets whether to return the assets or not (optional)
     * @param returnOffers whether to return the offers or not (optional)
     * @param returnCategories whether to return the categories or not (optional)
     * @param returnFilters whether to return the filters or not (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchLocationRatingIndexes",
        summary = "Search Location Rating Indexes",
        description = "Search for retailer locations by averages near you.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RatingIndexResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_LOCATION_RATING_INDEXES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RatingIndexResponse>> searchLocationRatingIndexes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "locationType", description = "The type of location to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "sortField", description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "searchRange", description = "The search radius in kilometers to filter results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false) @Nullable Double searchRange,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnOverallRating", description = "Determines whether to return the overall rating record instead", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOverallRating", required = false) @Nullable Boolean returnOverallRating,
        @Parameter(name = "distanceUnit", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = false) @Nullable String distanceUnit,
        @Parameter(name = "returnRetailer", description = "whether to return the retailer or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRetailer", required = false) @Nullable Boolean returnRetailer,
        @Parameter(name = "returnAssets", description = "whether to return the assets or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAssets", required = false) @Nullable Boolean returnAssets,
        @Parameter(name = "returnOffers", description = "whether to return the offers or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOffers", required = false) @Nullable Boolean returnOffers,
        @Parameter(name = "returnCategories", description = "whether to return the categories or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnCategories", required = false) @Nullable Boolean returnCategories,
        @Parameter(name = "returnFilters", description = "whether to return the filters or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFilters", required = false) @Nullable Boolean returnFilters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_MEDIA = "/api/{version}/media/search";
    /**
     * GET /api/{version}/media/search : Search Media
     * Searches on events that the account has access to.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param activeOnly Return only active results (required)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE (required)
     * @param descending The order to return the search results (required)
     * @param keyword The keyword used to search (optional)
     * @param categoryIds  (optional)
     * @param filterIds  (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchMedia",
        summary = "Search Media",
        description = "Searches on events that the account has access to.",
        tags = { "Media" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MediaOfferResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_MEDIA,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MediaOfferResponse>> searchMedia(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "categoryIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_MISSION_FORMATS = "/api/{version}/mission/format/search";
    /**
     * GET /api/{version}/mission/format/search : Search Mission Formats
     * Searches on pre-defined mission formats
     *
     * @param version  (required)
     * @param start The starting index in the result set to return. Default is 0. (required)
     * @param limit The total number of records to return. Default is 20. (required)
     * @param activeOnly Determines whether to return only active results. Default is false. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchMissionFormats",
        summary = "Search Mission Formats",
        description = "Searches on pre-defined mission formats",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MissionFormatResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_MISSION_FORMATS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MissionFormatResponse>> searchMissionFormats(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "start", description = "The starting index in the result set to return. Default is 0.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The total number of records to return. Default is 20.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_MISSION_INVITES = "/api/{version}/mission/invite/search";
    /**
     * GET /api/{version}/mission/invite/search : Search Mission Invites
     * Get a list of mission invites that the account has.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param appKey the app to retrieve the data for, use your application key. (optional)
     * @param appVersion the application version, used to version the game level data (optional)
     * @param missionId the mission id to filter on (optional)
     * @param status The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED} (optional)
     * @param lastUpdated Only return invites that have been updated since this date/time (long) (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param keyword the keyword to search on (optional)
     * @param missionTypes  (optional)
     * @param filterByBillable filter results by the account&#39;s billable (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchMissionInvites",
        summary = "Search Mission Invites",
        description = "Get a list of mission invites that the account has.",
        tags = { "Mission Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MissionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_MISSION_INVITES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MissionResponse>> searchMissionInvites(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "the app to retrieve the data for, use your application key.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "appVersion", description = "the application version, used to version the game level data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "missionId", description = "the mission id to filter on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "status", description = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "lastUpdated", description = "Only return invites that have been updated since this date/time (long)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastUpdated", required = false) @Nullable Long lastUpdated,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of record to return.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "keyword", description = "the keyword to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "missionTypes", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionTypes", required = false) @Nullable String missionTypes,
        @Parameter(name = "filterByBillable", description = "filter results by the account's billable", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterByBillable", required = false) @Nullable Boolean filterByBillable,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_MISSIONS = "/api/{version}/mission/search";
    /**
     * GET /api/{version}/mission/search : Search Missions
     * Get the list missions available to the account.  
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param keyword Filter by keyword (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default is 20, maximum is 100. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchMissions",
        summary = "Search Missions",
        description = "Get the list missions available to the account.  ",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MissionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_MISSIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MissionResponse>> searchMissions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "Filter by keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "subType", description = "Custom string client apps can use for searching/filtering missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "start", description = "The index into the record set to start with. Default is 0.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of record to return. Default is 20, maximum is 100.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "includeGameData", description = "If true then return the game level data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeAudiences", description = "If true then return the audience data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiences", required = false) @Nullable Boolean includeAudiences,
        @Parameter(name = "includeInactive", description = "If true then include inactive missions. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive,
        @Parameter(name = "suffix", description = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffix", required = false) @Nullable String suffix,
        @Parameter(name = "sortField", description = "The field to sort the search on (for example TITLE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Whether to sort in descending order (default true)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_MISSIONS_BY_BILLABLE_ENTITY = "/api/{version}/mission/searchByBillableEntity";
    /**
     * GET /api/{version}/mission/searchByBillableEntity : Search Missions by Billable Entity
     * Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param keyword Filter by keyword (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default id 20. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchMissionsByBillableEntity",
        summary = "Search Missions by Billable Entity",
        description = "Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = MissionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_MISSIONS_BY_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<List<MissionResponse>> searchMissionsByBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "keyword", description = "Filter by keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "start", description = "The index into the record set to start with. Default is 0.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The total number of record to return. Default id 20.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "includeGameData", description = "If true then return the game level data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeAudiences", description = "If true then return the audience data in the response. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiences", required = false) @Nullable Boolean includeAudiences,
        @Parameter(name = "includeInactive", description = "If true then include inactive missions. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive,
        @Parameter(name = "suffix", description = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffix", required = false) @Nullable String suffix,
        @Parameter(name = "sortField", description = "The field to sort the search on (for example TITLE)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Whether to sort in descending order (default true)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_NETWORKS = "/api/{version}/thirdparty/network/search";
    /**
     * GET /api/{version}/thirdparty/network/search : Search Networks
     * Search on supported third party networks and custom networks from external users.
     *
     * @param version  (required)
     * @param accountId The account id making the request (required)
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME (required)
     * @param descending The order to return the search results (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param activeOnly Return only active results (required)
     * @param keyword The keyword used to search on the network name and description fields (optional)
     * @param filterBillable Determines whether to only return applications that the user has access to (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchNetworks",
        summary = "Search Networks",
        description = "Search on supported third party networks and custom networks from external users.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ThirdPartyNetworkShortResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_NETWORKS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ThirdPartyNetworkShortResponse>> searchNetworks(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "keyword", description = "The keyword used to search on the network name and description fields", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "filterBillable", description = "Determines whether to only return applications that the user has access to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterBillable", required = false) @Nullable Boolean filterBillable
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_NOTES = "/api/{version}/note/search";
    /**
     * POST /api/{version}/note/search : Search Notes
     * Search for notes on a notable object.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteTypes Comma separated list of noteType strings to filter results with (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param keyword The keyword used to search (optional)
     * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold (optional)
     * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default (optional)
     * @param includeInactive include inactive in the result (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchNotes",
        summary = "Search Notes",
        description = "Search for notes on a notable object.",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = NoteResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEARCH_NOTES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<NoteResponse>> searchNotes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "notableType", description = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableType", required = false) @Nullable String notableType,
        @Parameter(name = "notableId", description = "The id of the notable object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notableId", required = false) @Nullable Long notableId,
        @Parameter(name = "noteTypes", description = "Comma separated list of noteType strings to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteTypes", required = false) @Nullable String noteTypes,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "flagCountMinimum", description = "return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagCountMinimum", required = false) @Nullable Long flagCountMinimum,
        @Parameter(name = "flagsExceedThreshold", description = "return items that has flagCount >= flagThreshold, which are hidden by default", in = ParameterIn.QUERY) @Valid @RequestParam(value = "flagsExceedThreshold", required = false) @Nullable Boolean flagsExceedThreshold,
        @Parameter(name = "includeInactive", description = "include inactive in the result", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive,
        @Parameter(name = "sortField", description = "The column to sort the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "returnFullResponse", description = "Determines whether to return the NoteFullResponse for each search item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false) @Nullable Boolean returnFullResponse,
        @Parameter(name = "updatedSince", description = "return items that have been updated since this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedSince", required = false) @Nullable Long updatedSince,
        @Parameter(name = "updatedBefore", description = "return items that have been updated before this date (time-stamp in milliseconds)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedBefore", required = false) @Nullable Long updatedBefore,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_NOTIFICATION_TEMPLATE = "/api/{version}/notification/template/search";
    /**
     * GET /api/{version}/notification/template/search : Search Notification Templates
     * Search for notification templates on owned applications.
     *
     * @param version  (required)
     * @param accountId The account ID of the user. (required)
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false. (required)
     * @param descending Specified whether the results are returned in descending or ascending order. (required)
     * @param start The start of the pagination. (required)
     * @param limit The limit of the pagination. (required)
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
     * @param reservedOnly Returns only templates that use reserved events. (optional)
     * @param keyword Filter results by keyword on the title, tags. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchNotificationTemplate",
        summary = "Search Notification Templates",
        description = "Search for notification templates on owned applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> searchNotificationTemplate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Specified whether the results are returned in descending or ascending order.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start of the pagination.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "appKey", description = "Filter results by application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "event", description = "Filter results by event.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "event", required = false) @Nullable String event,
        @Parameter(name = "conduit", description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "globalOnly", description = "Returns only templates that have been reserved for system use on all applications (only for admin accounts).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalOnly", required = false) @Nullable Boolean globalOnly,
        @Parameter(name = "reservedOnly", description = "Returns only templates that use reserved events.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservedOnly", required = false) @Nullable Boolean reservedOnly,
        @Parameter(name = "keyword", description = "Filter results by keyword on the title, tags.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OBJECT = "/api/{version}/object/search";
    /**
     * GET /api/{version}/object/search : Search Objects
     * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param keyword The name of the object(s) to search for, can be a partial match (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchObject",
        summary = "Search Objects",
        description = "Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> searchObject(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Long start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Long limit,
        @Parameter(name = "keyword", description = "The name of the object(s) to search for, can be a partial match", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OBJECTS = "/api/{version}/tournament/object/search";
    /**
     * GET /api/{version}/tournament/object/search : Search Tournament Objects
     * Search on game objects of tournaments
     *
     * @param version  (required)
     * @param accountId the account ID (required)
     * @param gameLevelId the game level id to filter results by (required)
     * @param sortField the field to sort by (optional, default to PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchObjects",
        summary = "Search Tournament Objects",
        description = "Search on game objects of tournaments",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OBJECTS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> searchObjects(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "gameLevelId", description = "the game level id to filter results by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = true) Long gameLevelId,
        @Parameter(name = "sortField", description = "the field to sort by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "PLAYER_SCORE_COUNT") String sortField,
        @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OFFER_TRANSACTION_STATUSES = "/api/{version}/offer/status/search";
    /**
     * GET /api/{version}/offer/status/search : Search Offer Status
     * Search for the available offer statuses
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param keyword Search the name and description fields (optional)
     * @param role The actors role, possible values are: CUSTOMER, RETAILER, or ANY (optional)
     * @param appKey The application making the request (optional)
     * @param sortField The field to sort on, possible values are: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE (optional, default to CODE)
     * @param descending Determines whether the results are in descending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param includeInactive If true include inactive items (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchOfferTransactionStatuses",
        summary = "Search Offer Status",
        description = "Search for the available offer statuses",
        tags = { "Offer Status" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferTransactionStatusResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OFFER_TRANSACTION_STATUSES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferTransactionStatusResponse>> searchOfferTransactionStatuses(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "keyword", description = "Search the name and description fields", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "role", description = "The actors role, possible values are: CUSTOMER, RETAILER, or ANY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "appKey", description = "The application making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "sortField", description = "The field to sort on, possible values are: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CODE") String sortField,
        @Parameter(name = "descending", description = "Determines whether the results are in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "includeInactive", description = "If true include inactive items", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false, defaultValue = "false") Boolean includeInactive
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OFFER_TRANSACTIONS = "/api/{version}/wallet/search";
    /**
     * GET /api/{version}/wallet/search : Search Wallet Offers
     * Search on active offers currently in the user&#39;s wallet, or past offers the user has already redeemed.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerIds Filter results for a list of retailers (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param retailerLocationIds Filter results for a list of retailer locations (optional)
     * @param excludeRetailerLocationIds Filter results to exclude retailer locations (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerIds Filter results for a list of offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param offerLocationIds Filter results for a list of offer locations (optional)
     * @param offerType Filter results to return a specific offer type (optional)
     * @param offerTypes Filter results to return specific offer types (optional)
     * @param specialOfferType Filter results to return a specific special offer type (optional)
     * @param specialOfferTypes Filter results to return specific special offer types (optional)
     * @param categoryIds Category Ids (optional)
     * @param filterIds Filter Ids (optional)
     * @param offerAudienceIds Offer Audience Ids (optional)
     * @param sortField Determines what to sort the results by (optional, default to CREATED)
     * @param descending Determines whether the results are in descending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param filterByParentOffer Apply params to offer&#39;s parent (optional, default to false)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1) (optional, default to false)
     * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @param reservationsOnly Returns only reservation transactions if true (optional, default to false)
     * @param activeOnly Active Only (optional, default to false)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param recurringStartedSince Filter results by the recurring billing start date (optional)
     * @param recurringStartedBefore Filter results by the recurring billing start date (optional)
     * @param recurringExpirationSince Filter results by the recurring billing expiration date (optional)
     * @param recurringExpirationBefore Filter results by the recurring billing expiration date (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchOfferTransactions",
        summary = "Search Wallet Offers",
        description = "Search on active offers currently in the user's wallet, or past offers the user has already redeemed.",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferTransactionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OFFER_TRANSACTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferTransactionResponse>> searchOfferTransactions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "Filter results for this retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerIds", description = "Filter results for a list of retailers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerIds", required = false) @Nullable String retailerIds,
        @Parameter(name = "retailerLocationId", description = "Filter results for this retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "retailerLocationIds", description = "Filter results for a list of retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "excludeRetailerLocationIds", description = "Filter results to exclude retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "excludeRetailerLocationIds", required = false) @Nullable String excludeRetailerLocationIds,
        @Parameter(name = "offerId", description = "Filter results for this offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerIds", description = "Filter results for a list of offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerIds", required = false) @Nullable String offerIds,
        @Parameter(name = "offerLocationId", description = "Filter results for this offer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "offerLocationIds", description = "Filter results for a list of offer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationIds", required = false) @Nullable String offerLocationIds,
        @Parameter(name = "offerType", description = "Filter results to return a specific offer type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = false) @Nullable String offerType,
        @Parameter(name = "offerTypes", description = "Filter results to return specific offer types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerTypes", required = false) @Nullable String offerTypes,
        @Parameter(name = "specialOfferType", description = "Filter results to return a specific special offer type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "specialOfferTypes", description = "Filter results to return specific special offer types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferTypes", required = false) @Nullable String specialOfferTypes,
        @Parameter(name = "categoryIds", description = "Category Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Filter Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "offerAudienceIds", description = "Offer Audience Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerAudienceIds", required = false) @Nullable String offerAudienceIds,
        @Parameter(name = "sortField", description = "Determines what to sort the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") String sortField,
        @Parameter(name = "descending", description = "Determines whether the results are in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "latitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "redeemableStartDate", description = "Filter results by the offer redeemable date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStartDate", required = false) @Nullable Long redeemableStartDate,
        @Parameter(name = "redeemableEndDate", description = "Filter results by the offer redeemable date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEndDate", required = false) @Nullable Long redeemableEndDate,
        @Parameter(name = "filterByParentOffer", description = "Apply params to offer's parent", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterByParentOffer", required = false, defaultValue = "false") Boolean filterByParentOffer,
        @Parameter(name = "startedSince", description = "Filter results by the offer start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedSince", required = false) @Nullable Long startedSince,
        @Parameter(name = "startedBefore", description = "Filter results by the offer start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedBefore", required = false) @Nullable Long startedBefore,
        @Parameter(name = "endedSince", description = "Filter results by the offer end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedSince", required = false) @Nullable Long endedSince,
        @Parameter(name = "endedBefore", description = "Filter results by the offer end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedBefore", required = false) @Nullable Long endedBefore,
        @Parameter(name = "redeemed", description = "If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemed", required = false, defaultValue = "false") Boolean redeemed,
        @Parameter(name = "statuses", description = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "reservationsOnly", description = "Returns only reservation transactions if true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservationsOnly", required = false, defaultValue = "false") Boolean reservationsOnly,
        @Parameter(name = "activeOnly", description = "Active Only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly,
        @Parameter(name = "returnFullResponse", description = "Determines whether to return a detailed version of the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "false") Boolean returnFullResponse,
        @Parameter(name = "recurringStartedSince", description = "Filter results by the recurring billing start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurringStartedSince", required = false) @Nullable Long recurringStartedSince,
        @Parameter(name = "recurringStartedBefore", description = "Filter results by the recurring billing start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurringStartedBefore", required = false) @Nullable Long recurringStartedBefore,
        @Parameter(name = "recurringExpirationSince", description = "Filter results by the recurring billing expiration date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurringExpirationSince", required = false) @Nullable Long recurringExpirationSince,
        @Parameter(name = "recurringExpirationBefore", description = "Filter results by the recurring billing expiration date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recurringExpirationBefore", required = false) @Nullable Long recurringExpirationBefore
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OFFER_TRANSACTIONS_FOR_RETAILERS = "/api/{version}/retailer/offer/transaction/search";
    /**
     * GET /api/{version}/retailer/offer/transaction/search : Search Offer Transactions
     * Searches on offer transactions for offers that the account has access to.
     *
     * @param version  (required)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
     * @param descending Determines whether the results are in descending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Determines whether to only return active offer transactions (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param redeemed if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1) (optional)
     * @param reservationsOnly returns only reservation transactions if true (optional)
     * @param couponType This parameter is deprecated. (optional)
     * @param offerType Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
     * @param specialOfferType Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
     * @param customerAccountIds Filter results by accounts (optional)
     * @param categoryIds  (optional)
     * @param redeemableStartDate  (optional)
     * @param redeemableEndDate  (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchOfferTransactionsForRetailers",
        summary = "Search Offer Transactions",
        description = "Searches on offer transactions for offers that the account has access to.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OfferTransactionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OFFER_TRANSACTIONS_FOR_RETAILERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OfferTransactionResponse>> searchOfferTransactionsForRetailers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the results are in descending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Determines whether to only return active offer transactions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "Filter results for this retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "Filter results for this retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "offerId", description = "Filter results for this offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "offerLocationId", description = "Filter results for this offer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "redeemed", description = "if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemed", required = false) @Nullable Boolean redeemed,
        @Parameter(name = "reservationsOnly", description = "returns only reservation transactions if true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservationsOnly", required = false) @Nullable Boolean reservationsOnly,
        @Parameter(name = "couponType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "couponType", required = false) @Nullable String couponType,
        @Parameter(name = "offerType", description = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = false) @Nullable String offerType,
        @Parameter(name = "specialOfferType", description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "customerAccountIds", description = "Filter results by accounts", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customerAccountIds", required = false) @Nullable String customerAccountIds,
        @Parameter(name = "categoryIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "redeemableStartDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStartDate", required = false) @Nullable Long redeemableStartDate,
        @Parameter(name = "redeemableEndDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEndDate", required = false) @Nullable Long redeemableEndDate,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OFFERS_FOR_CONSUMER = "/api/{version}/offer/lists";
    /**
     * GET /api/{version}/offer/lists : Search Offers
     * Searches for offers as a consumer.
     *
     * @param version  (required)
     * @param latitude The latitude of where the search will center at (required)
     * @param longitude The longitude of where the search will center at (required)
     * @param recommendationType The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available (required)
     * @param locationId This parameter is deprecated. The location id (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param maxRecommendations  (required)
     * @param distanceUnit  (required)
     * @param appKey The application key used to identify the application (optional)
     * @param deviceId The device id for returning account information (i.e. offer transactions made by the user) (optional)
     * @param accountId The account id for returning account information (i.e. offer transactions made by the user) (optional)
     * @param searchRange The range of the search (optional, default to 5)
     * @param tags Does a full-text search on tags (optional)
     * @param supportedPostalCodes supported postal codes (optional)
     * @param keyword The keyword to filter results by (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param offerTypes Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE} (optional, default to COUPON, VOUCHER)
     * @param type The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param sortField The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations (optional)
     * @param recommendOfferIds Return recommendations based on these offers IDs (optional)
     * @param retailerLocationIds Only return offer locations for the specific retailer locations. (optional)
     * @param offerId Only return offer locations for the specific offer. (optional)
     * @param includeMission If true include the mission response as part of the offer. Default is false. (optional)
     * @param includeCategories If true include the category list response as part of the offer. Default is false. (optional)
     * @param includeFilters If true include the filter list response as part of the offer. Default is false. (optional)
     * @param includeExpired If true then ignore the expired dates. Default is false. (optional)
     * @param includeFavorite If true then ignore the favorite. Default is false. (optional)
     * @param closestOfferOnly This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon (optional)
     * @param searchExpression  (optional)
     * @param groupBy groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy&#x3D;OFFER_ID and sortField&#x3D;DISTANCE (to sort by distance). (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchOffersForConsumer",
        summary = "Search Offers",
        description = "Searches for offers as a consumer.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_OFFERS_FOR_CONSUMER,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> searchOffersForConsumer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "latitude", description = "The latitude of where the search will center at", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "The longitude of where the search will center at", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @NotNull @Parameter(name = "recommendationType", description = "The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recommendationType", required = true) String recommendationType,
        @NotNull @Parameter(name = "locationId", description = "This parameter is deprecated. The location id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationId", required = true) Long locationId,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "maxRecommendations", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxRecommendations", required = true) Integer maxRecommendations,
        @NotNull @Parameter(name = "distanceUnit", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "distanceUnit", required = true) String distanceUnit,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "deviceId", description = "The device id for returning account information (i.e. offer transactions made by the user)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id for returning account information (i.e. offer transactions made by the user)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "searchRange", description = "The range of the search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5") Double searchRange,
        @Parameter(name = "tags", description = "Does a full-text search on tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "supportedPostalCodes", description = "supported postal codes", in = ParameterIn.QUERY) @Valid @RequestParam(value = "supportedPostalCodes", required = false) @Nullable String supportedPostalCodes,
        @Parameter(name = "keyword", description = "The keyword to filter results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "categories", description = "Comma separate list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categories", required = false) @Nullable String categories,
        @Parameter(name = "filters", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filters", required = false) @Nullable String filters,
        @Parameter(name = "offerTypes", description = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerTypes", required = false, defaultValue = "COUPON, VOUCHER") String offerTypes,
        @Parameter(name = "type", description = "The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "sortField", description = "The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "recommendOfferIds", description = "Return recommendations based on these offers IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recommendOfferIds", required = false) @Nullable String recommendOfferIds,
        @Parameter(name = "retailerLocationIds", description = "Only return offer locations for the specific retailer locations.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "offerId", description = "Only return offer locations for the specific offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "includeMission", description = "If true include the mission response as part of the offer. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeMission", required = false) @Nullable Boolean includeMission,
        @Parameter(name = "includeCategories", description = "If true include the category list response as part of the offer. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeCategories", required = false) @Nullable Boolean includeCategories,
        @Parameter(name = "includeFilters", description = "If true include the filter list response as part of the offer. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFilters", required = false) @Nullable Boolean includeFilters,
        @Parameter(name = "includeExpired", description = "If true then ignore the expired dates. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeExpired", required = false) @Nullable Boolean includeExpired,
        @Parameter(name = "includeFavorite", description = "If true then ignore the favorite. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFavorite", required = false) @Nullable Boolean includeFavorite,
        @Parameter(name = "closestOfferOnly", description = "This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon", in = ParameterIn.QUERY) @Valid @RequestParam(value = "closestOfferOnly", required = false) @Nullable Boolean closestOfferOnly,
        @Parameter(name = "searchExpression", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchExpression", required = false) @Nullable String searchExpression,
        @Parameter(name = "groupBy", description = "groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupBy", required = false) @Nullable String groupBy
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ORDERS = "/api/{version}/order/search";
    /**
     * GET /api/{version}/order/search : Search Orders
     * Search on active orders by customer
     *
     * @param version  (required)
     * @param appKey The application requesting the purchase (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param activeOnly Only return active orders (optional, default to false)
     * @param ignoreCustomerFilter Determines whether to ignore the customer filter (requires an Admin/Exec account) (optional, default to false)
     * @param orderItemTypes Filter results by orderItemTypes (optional)
     * @param orderItemIds Filter results by orderItemIds (optional)
     * @param orderCustomTypes Filter results by orderCustomTypes (optional)
     * @param orderCustomIds Filter results by orderCustomIds (optional)
     * @param sortField Determines what to sort the results by (optional, default to ID)
     * @param offerTypes Filter results by offer type (optional)
     * @param specialOfferTypes Filter results by special offer type (optional)
     * @param categoryIds Filter results by category Ids (optional)
     * @param filterIds Filter results by filter Ids (optional)
     * @param offerAudienceIds Filter results by offer audience Ids (optional)
     * @param transactionAudienceIds Filter results by transaction audience Ids (optional)
     * @param offerIds Filter results by offer Ids (optional)
     * @param offerLocationIds Filter results by offer location Ids (optional)
     * @param retailerIds Filter results by retailer Ids (optional)
     * @param retailerLocationIds Filter results by retailer location Ids (optional)
     * @param statuses Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled) (optional)
     * @param keyword The keyword to search for (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchOrders",
        summary = "Search Orders",
        description = "Search on active orders by customer",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = OrderResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ORDERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<OrderResponse>> searchOrders(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application requesting the purchase", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "descending", description = "Determines whether to return the resulting list in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "activeOnly", description = "Only return active orders", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly,
        @Parameter(name = "ignoreCustomerFilter", description = "Determines whether to ignore the customer filter (requires an Admin/Exec account)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ignoreCustomerFilter", required = false, defaultValue = "false") Boolean ignoreCustomerFilter,
        @Parameter(name = "orderItemTypes", description = "Filter results by orderItemTypes", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderItemTypes", required = false) @Nullable String orderItemTypes,
        @Parameter(name = "orderItemIds", description = "Filter results by orderItemIds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderItemIds", required = false) @Nullable String orderItemIds,
        @Parameter(name = "orderCustomTypes", description = "Filter results by orderCustomTypes", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderCustomTypes", required = false) @Nullable String orderCustomTypes,
        @Parameter(name = "orderCustomIds", description = "Filter results by orderCustomIds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderCustomIds", required = false) @Nullable String orderCustomIds,
        @Parameter(name = "sortField", description = "Determines what to sort the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "ID") String sortField,
        @Parameter(name = "offerTypes", description = "Filter results by offer type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerTypes", required = false) @Nullable String offerTypes,
        @Parameter(name = "specialOfferTypes", description = "Filter results by special offer type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferTypes", required = false) @Nullable String specialOfferTypes,
        @Parameter(name = "categoryIds", description = "Filter results by category Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Filter results by filter Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "offerAudienceIds", description = "Filter results by offer audience Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerAudienceIds", required = false) @Nullable String offerAudienceIds,
        @Parameter(name = "transactionAudienceIds", description = "Filter results by transaction audience Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionAudienceIds", required = false) @Nullable String transactionAudienceIds,
        @Parameter(name = "offerIds", description = "Filter results by offer Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerIds", required = false) @Nullable String offerIds,
        @Parameter(name = "offerLocationIds", description = "Filter results by offer location Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationIds", required = false) @Nullable String offerLocationIds,
        @Parameter(name = "retailerIds", description = "Filter results by retailer Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerIds", required = false) @Nullable String retailerIds,
        @Parameter(name = "retailerLocationIds", description = "Filter results by retailer location Ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "statuses", description = "Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "redeemableStartDate", description = "Filter results by the offer redeemable date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStartDate", required = false) @Nullable Long redeemableStartDate,
        @Parameter(name = "redeemableEndDate", description = "Filter results by the offer redeemable date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEndDate", required = false) @Nullable Long redeemableEndDate,
        @Parameter(name = "startedSince", description = "Filter results by the offer start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedSince", required = false) @Nullable Long startedSince,
        @Parameter(name = "startedBefore", description = "Filter results by the offer start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startedBefore", required = false) @Nullable Long startedBefore,
        @Parameter(name = "endedSince", description = "Filter results by the offer end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedSince", required = false) @Nullable Long endedSince,
        @Parameter(name = "endedBefore", description = "Filter results by the offer end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endedBefore", required = false) @Nullable Long endedBefore
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PACKS = "/api/{version}/pack/search";
    /**
     * GET /api/{version}/pack/search : Search Packs
     * Search on packs.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param sortField The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param keyword Keyword search on the pack name (optional)
     * @param packType Filters results on pack type (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param includeGameData Determines whether to include game data in the results (optional)
     * @param includeInactive Determines whether to include inactive results (optional)
     * @param appKey The application to filter results on (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPacks",
        summary = "Search Packs",
        description = "Search on packs.",
        tags = { "Pack" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = PackResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PACKS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<PackResponse>> searchPacks(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @Parameter(name = "keyword", description = "Keyword search on the pack name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "packType", description = "Filters results on pack type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packType", required = false) @Nullable String packType,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "includeGameData", description = "Determines whether to include game data in the results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData,
        @Parameter(name = "includeInactive", description = "Determines whether to include inactive results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false) @Nullable Boolean includeInactive,
        @Parameter(name = "appKey", description = "The application to filter results on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PAYMENT_METHOD = "/api/{version}/billing/search";
    /**
     * GET /api/{version}/billing/search : Search Payment Methods
     * Search the payment methods of an account
     *
     * @param version  (required)
     * @param accountId Account Id to search on (required)
     * @param provider Provider to search on (optional, default to AUTHORIZE_NET)
     * @param type the type to search on (optional)
     * @param keyword the keyword to search on (optional)
     * @param sortField the sort field to use for the search (optional, default to UPDATED)
     * @param descending if the results should be in descending order (optional, default to true)
     * @param start the start of the search (optional, default to 0)
     * @param limit the limit of the search (optional, default to 5)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPaymentMethod",
        summary = "Search Payment Methods",
        description = "Search the payment methods of an account",
        tags = { "Billing Info" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PaymentTypesResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PAYMENT_METHOD,
        produces = { "*/*" }
    )
    default ResponseEntity<PaymentTypesResponse> searchPaymentMethod(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Account Id to search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "provider", description = "Provider to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "provider", required = false, defaultValue = "AUTHORIZE_NET") String provider,
        @Parameter(name = "type", description = "the type to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "keyword", description = "the keyword to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "the sort field to use for the search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "UPDATED") String sortField,
        @Parameter(name = "descending", description = "if the results should be in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "the start of the search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit of the search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "5") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PERMISSIONABLES = "/api/{version}/permissions/search";
    /**
     * GET /api/{version}/permissions/search : Search Permissionables
     * Search on UserPermissions
     *
     * @param version  (required)
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param sortField Field to sort results on (optional)
     * @param descending Sort descending when true (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPermissionables",
        summary = "Search Permissionables",
        description = "Search on UserPermissions",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = UserPermissionsResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PERMISSIONABLES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<UserPermissionsResponse>> searchPermissionables(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "A unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "Filter results for a specific user account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "connectionAccountIds", description = "Comma separated list of account IDs to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "permissionableType", description = "Filter user permissions by the permissionable object type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the permissionable object to filter by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "keyword", description = "Keyword to search within permissionable records", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "Field to sort results on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Sort descending when true", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "pending", description = "Return user permissions that are pending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pending", required = false) @Nullable Boolean pending,
        @Parameter(name = "admin", description = "Return user permissions that are admins", in = ParameterIn.QUERY) @Valid @RequestParam(value = "admin", required = false) @Nullable Boolean admin,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PERMISSIONABLES_FOLLOWING_DISTANCE = "/api/{version}/permissions/distancesearch";
    /**
     * GET /api/{version}/permissions/distancesearch : Search Permissionables by Distnace
     * Search on UserPermissions by distance
     *
     * @param version  (required)
     * @param latitude The latitude of the current account (required)
     * @param longitude The longitude of the current account (required)
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param searchRange The search range in miles (optional, default to 5)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPermissionablesFollowingDistance",
        summary = "Search Permissionables by Distnace",
        description = "Search on UserPermissions by distance",
        tags = { "User Permissions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = UserPermissionsResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PERMISSIONABLES_FOLLOWING_DISTANCE,
        produces = { "*/*" }
    )
    default ResponseEntity<List<UserPermissionsResponse>> searchPermissionablesFollowingDistance(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "latitude", description = "The latitude of the current account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "The longitude of the current account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude,
        @Parameter(name = "deviceId", description = "A unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "Filter results for a specific user account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "connectionAccountIds", description = "Comma separated list of account IDs to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "permissionableType", description = "Filter user permissions by the permissionable object type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the permissionable object to filter by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "searchRange", description = "The search range in miles", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5") Double searchRange,
        @Parameter(name = "keyword", description = "Keyword to search within permissionable records", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "pending", description = "Return user permissions that are pending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "pending", required = false) @Nullable Boolean pending,
        @Parameter(name = "admin", description = "Return user permissions that are admins", in = ParameterIn.QUERY) @Valid @RequestParam(value = "admin", required = false) @Nullable Boolean admin,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PERSONA = "/api/{version}/persona/search";
    /**
     * GET /api/{version}/persona/search : Search Personas
     * Search for persona that the account owns by the given account ID.
     *
     * @param version  (required)
     * @param accountId the account ID of the user (required)
     * @param start the start index for pagination (required)
     * @param limit the limit for pagination (There is a hard limit of 100) (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPersona",
        summary = "Search Personas",
        description = "Search for persona that the account owns by the given account ID.",
        tags = { "Preview Persona" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PreviewPersonaResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PERSONA,
        produces = { "*/*" }
    )
    default ResponseEntity<PreviewPersonaResponse> searchPersona(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "start", description = "the start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "the limit for pagination (There is a hard limit of 100)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PROGRAMS = "/api/{version}/program";
    /**
     * GET /api/{version}/program : Search Programs
     * Search for programs
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param keyword The keyword to filter results by (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPrograms",
        summary = "Search Programs",
        description = "Search for programs",
        tags = { "Program" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Program.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PROGRAMS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Program>> searchPrograms(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "keyword", description = "The keyword to filter results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_PURCHASE_ITEMS = "/api/{version}/purchase/search";
    /**
     * GET /api/{version}/purchase/search : Search Purchases
     * Search for purchasable items from the system
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key to filter results by application (optional)
     * @param filterByBillable Determines whether to filter results by the user&#39;s billable entity (optional, default to false)
     * @param purchaseType A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param serviceAction A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional, default to NAME)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Return only active results (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchPurchaseItems",
        summary = "Search Purchases",
        description = "Search for purchasable items from the system",
        tags = { "Purchase Item" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = PurchaseItemResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_PURCHASE_ITEMS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<PurchaseItemResponse>> searchPurchaseItems(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key to filter results by application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "filterByBillable", description = "Determines whether to filter results by the user's billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterByBillable", required = false, defaultValue = "false") Boolean filterByBillable,
        @Parameter(name = "purchaseType", description = "A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType,
        @Parameter(name = "serviceAction", description = "A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>", in = ParameterIn.QUERY) @Valid @RequestParam(value = "serviceAction", required = false) @Nullable String serviceAction,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "NAME") String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_QUESTIONS = "/api/{version}/game/question/search";
    /**
     * GET /api/{version}/game/question/search : Search Questions
     * Search for questions by the given params.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param sortField The column to sort the search on (required)
     * @param descending The order to return the search results (required)
     * @param activeOnly Return only active results if set to true. (required)
     * @param start The record to begin the return set on. (required)
     * @param limit The number of records to return. (required)
     * @param keyword The keyword for searching questions with matching tags or question text. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchQuestions",
        summary = "Search Questions",
        description = "Search for questions by the given params.",
        tags = { "Question" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = QuestionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_QUESTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<QuestionResponse>> searchQuestions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The column to sort the search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "The order to return the search results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results if set to true.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "start", description = "The record to begin the return set on.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The number of records to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "keyword", description = "The keyword for searching questions with matching tags or question text.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RATING_INDEXES = "/api/{version}/rating/index/search";
    /**
     * GET /api/{version}/rating/index/search : Search Rating Indexes
     * Search for ratable items by averages.
     *
     * @param version  (required)
     * @param ratableType Filter results by a ratable type {RETAILER_LOCATION} (required)
     * @param ratableIds Comma separated list of ratable ids to filter the resuts by (optional)
     * @param categoryIds Comma separated list of category ids to filter the results by (optional)
     * @param secondaryType  (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE} (optional)
     * @param descending The order to return the search results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @param returnRatable Determines whether to return the ratable object in the response (optional)
     * @param returnOverallRating Determines whether to return the overall rating record instead (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRatingIndexes",
        summary = "Search Rating Indexes",
        description = "Search for ratable items by averages.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RatingIndexResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RATING_INDEXES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RatingIndexResponse>> searchRatingIndexes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "ratableType", description = "Filter results by a ratable type {RETAILER_LOCATION}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableType", required = true) String ratableType,
        @Parameter(name = "ratableIds", description = "Comma separated list of ratable ids to filter the resuts by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableIds", required = false) @Nullable String ratableIds,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "secondaryType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondaryType", required = false) @Nullable String secondaryType,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "latitude", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnRatable", description = "Determines whether to return the ratable object in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRatable", required = false) @Nullable Boolean returnRatable,
        @Parameter(name = "returnOverallRating", description = "Determines whether to return the overall rating record instead", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOverallRating", required = false) @Nullable Boolean returnOverallRating
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RATINGS = "/api/{version}/rating/search";
    /**
     * GET /api/{version}/rating/search : Search Ratings
     * Search for ratings on a ratable object.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param filterAccountId Filter results for a particular account (optional)
     * @param ratableType The ratable object type {RETAILER_LOCATION} (optional)
     * @param ratableId The id of the ratable object (optional)
     * @param categoryIds Comma separated list of category ids to filter the results by (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE} (optional)
     * @param descending The order to return the search results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRatings",
        summary = "Search Ratings",
        description = "Search for ratings on a ratable object.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RatingResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RATINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RatingResponse>> searchRatings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "filterAccountId", description = "Filter results for a particular account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterAccountId", required = false) @Nullable Long filterAccountId,
        @Parameter(name = "ratableType", description = "The ratable object type {RETAILER_LOCATION}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableType", required = false) @Nullable String ratableType,
        @Parameter(name = "ratableId", description = "The id of the ratable object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratableId", required = false) @Nullable Long ratableId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RECIPIENTS = "/api/{version}/notification/recipient/search";
    /**
     * GET /api/{version}/notification/recipient/search : Search for Recipients
     * Search for application users to send notifications.
     *
     * @param version  (required)
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} (required)
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (hard limit of 1000) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRecipients",
        summary = "Search for Recipients",
        description = "Search for application users to send notifications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = NotificationRecipientResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RECIPIENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<NotificationRecipientResponse>> searchRecipients(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "keyword", description = "search by keyword on user's display name and email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "filter results by audiences (comma separated list of audience ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "connectionGroupIds", description = "filter results by connection groups (comma separated list of connection group ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "recipientAccountIds", description = "filter results by accounts (comma separated list of account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recipientAccountIds", required = false) @Nullable String recipientAccountIds,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination (hard limit of 1000)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RECIPIENTS_COUNT = "/api/{version}/notification/recipient/search/count";
    /**
     * GET /api/{version}/notification/recipient/search/count : Search for Recipients (Counts/Grouped)
     * Search for application users to send notifications (count/grouped variant).
     *
     * @param version  (required)
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param sortField The field to sort by (see API docs for allowed values). (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRecipientsCount",
        summary = "Search for Recipients (Counts/Grouped)",
        description = "Search for application users to send notifications (count/grouped variant).",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationRecipientResponseListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RECIPIENTS_COUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationRecipientResponseListResponse> searchRecipientsCount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "keyword", description = "search by keyword on user's display name and email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "filter results by audiences (comma separated list of audience ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "connectionGroupIds", description = "filter results by connection groups (comma separated list of connection group ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "sortField", description = "The field to sort by (see API docs for allowed values).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_REGIONS = "/api/{version}/region/search";
    /**
     * GET /api/{version}/region/search : Search Regions
     * Get the list of regions.
     *
     * @param version  (required)
     * @param accountId the owner account id of the region to be created (optional)
     * @param query This parameter is deprecated. deprecated - use \&quot;keyword\&quot; (optional)
     * @param keyword the keyword to filter results on (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param range the search radius (optional)
     * @param regionClass  (optional)
     * @param visibility  (optional)
     * @param searchMode the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (optional)
     * @param sortField the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (optional)
     * @param descending determines if the results get ordered in descending order (optional)
     * @param includeParent include the parent region or not (optional)
     * @param includeChildren include the chidren regions or not (optional)
     * @param includePostalCodes include the postal codes associated with the region or not (optional)
     * @param categoryIds search on the categories associated with the region (optional)
     * @param filterIds search on the filters associated with the region (optional)
     * @param versionCode filter by a specific version code (optional)
     * @param activeOnly filter to show only active results (optional)
     * @param showDeleted If showDeleted is true and activeOnly is false, will return regions that have been deleted (optional)
     * @param lastUpdatedSince only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRegions",
        summary = "Search Regions",
        description = "Get the list of regions.",
        tags = { "Region" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RegionResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_REGIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RegionResponse>> searchRegions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "the owner account id of the region to be created", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "query", description = "This parameter is deprecated. deprecated - use \"keyword\"", in = ParameterIn.QUERY) @Valid @RequestParam(value = "query", required = false) @Nullable String query,
        @Parameter(name = "keyword", description = "the keyword to filter results on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "latitude", description = "the latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "range", description = "the search radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "range", required = false) @Nullable Double range,
        @Parameter(name = "regionClass", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionClass", required = false) @Nullable String regionClass,
        @Parameter(name = "visibility", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "searchMode", description = "the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchMode", required = false) @Nullable String searchMode,
        @Parameter(name = "sortField", description = "the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "determines if the results get ordered in descending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "includeParent", description = "include the parent region or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeParent", required = false) @Nullable Boolean includeParent,
        @Parameter(name = "includeChildren", description = "include the chidren regions or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeChildren", required = false) @Nullable Boolean includeChildren,
        @Parameter(name = "includePostalCodes", description = "include the postal codes associated with the region or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includePostalCodes", required = false) @Nullable Boolean includePostalCodes,
        @Parameter(name = "categoryIds", description = "search on the categories associated with the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "search on the filters associated with the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "versionCode", description = "filter by a specific version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "activeOnly", description = "filter to show only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "showDeleted", description = "If showDeleted is true and activeOnly is false, will return regions that have been deleted", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showDeleted", required = false) @Nullable Boolean showDeleted,
        @Parameter(name = "lastUpdatedSince", description = "only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastUpdatedSince", required = false) @Nullable Long lastUpdatedSince,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RESERVATIONS = "/api/{version}/reservation/search";
    /**
     * GET /api/{version}/reservation/search : Search Reservations
     *
     * @param version  (required)
     * @param deviceId Device Id (optional)
     * @param appKey Appilcation Key (optional)
     * @param accountId the id of the logged in user (optional)
     * @param filterAccountId filter reservations by account ID (optional)
     * @param reservableId the reservation ID (optional)
     * @param reservableType the type of reservation (optional)
     * @param keyword the keyword to search the reservation on (optional)
     * @param startDate the start date of the reservation search (optional)
     * @param endDate the end date of the reservation search (optional)
     * @param start the start of the index and/or pagination (optional, default to 0)
     * @param limit the limit of the index and/or pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchReservations",
        summary = "Search Reservations",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ReservationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RESERVATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ReservationResponse>> searchReservations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "Device Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "appKey", description = "Appilcation Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "filterAccountId", description = "filter reservations by account ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterAccountId", required = false) @Nullable Long filterAccountId,
        @Parameter(name = "reservableId", description = "the reservation ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableId", required = false) @Nullable Long reservableId,
        @Parameter(name = "reservableType", description = "the type of reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableType", required = false) @Nullable String reservableType,
        @Parameter(name = "keyword", description = "the keyword to search the reservation on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "startDate", description = "the start date of the reservation search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date of the reservation search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "start", description = "the start of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit of the index and/or pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RETAILER_LOCATIONS = "/api/{version}/retailer/location/search";
    /**
     * GET /api/{version}/retailer/location/search : Search Retailer Locations (Owned)
     * Searches on retailer locations that the account has access to.
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerIds Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers. (optional)
     * @param retailerLocationIds Comma separated list of retailer location IDs (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param i This parameter is deprecated. (optional)
     * @param start The record to begin the return set on (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit The number of records to return (optional)
     * @param showPublicLocations Whether to include public locations in the results (optional)
     * @param activeOnly Return only active results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRetailerLocations",
        summary = "Search Retailer Locations (Owned)",
        description = "Searches on retailer locations that the account has access to.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RetailerLocationResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_RETAILER_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RetailerLocationResponse>> searchRetailerLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "q", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) @Nullable String q,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerIds", description = "Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerIds", required = false) @Nullable String retailerIds,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "locationType", description = "Location type filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "sortField", description = "The column to sort the search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "The order to return the search results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "_i", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_i", required = false) @Nullable Integer i,
        @Parameter(name = "start", description = "The record to begin the return set on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "_l", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "_l", required = false) @Nullable Integer l,
        @Parameter(name = "limit", description = "The number of records to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "showPublicLocations", description = "Whether to include public locations in the results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showPublicLocations", required = false) @Nullable Boolean showPublicLocations,
        @Parameter(name = "activeOnly", description = "Return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "returnRetailer", description = "Return retailer info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRetailer", required = false) @Nullable Boolean returnRetailer,
        @Parameter(name = "returnAssets", description = "Return assets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAssets", required = false) @Nullable Boolean returnAssets,
        @Parameter(name = "returnOffers", description = "Return offers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnOffers", required = false) @Nullable Boolean returnOffers,
        @Parameter(name = "returnCategories", description = "Return categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnCategories", required = false) @Nullable Boolean returnCategories,
        @Parameter(name = "returnFilters", description = "Return filters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFilters", required = false) @Nullable Boolean returnFilters,
        @Parameter(name = "returnAudiences", description = "Return audiences", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAudiences", required = false) @Nullable Boolean returnAudiences,
        @Parameter(name = "returnQrCode", description = "Return QR code info", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnQrCode", required = false) @Nullable Boolean returnQrCode,
        @Parameter(name = "includeFavorite", description = "Include favorites in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFavorite", required = false) @Nullable Boolean includeFavorite,
        @Parameter(name = "includeLiked", description = "Include liked flag in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeLiked", required = false) @Nullable Boolean includeLiked,
        @Parameter(name = "includeRating", description = "Include rating info in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeRating", required = false) @Nullable Boolean includeRating
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ROUNDS = "/api/{version}/tournament/round/search";
    /**
     * GET /api/{version}/tournament/round/search : Search Tournament Rounds
     * Search for the user&#39;s tournament games.
     *
     * @param version  (required)
     * @param accountId the account ID (required)
     * @param appKey the application key (required)
     * @param status comma separated list of statuses to filter results by (optional, default to ACCEPTED,ACTIVE)
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to PUBLIC)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRounds",
        summary = "Search Tournament Rounds",
        description = "Search for the user's tournament games.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ROUNDS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> searchRounds(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "status", description = "comma separated list of statuses to filter results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false, defaultValue = "ACCEPTED,ACTIVE") String status,
        @Parameter(name = "missionType", description = "The style of tournament to search for, options are: TOURNAMENT, POOLPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionType", required = false) @Nullable String missionType,
        @Parameter(name = "currentOnly", description = "search for games that are flagged current only", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currentOnly", required = false, defaultValue = "true") Boolean currentOnly,
        @Parameter(name = "visibilities", description = "Filter tournament rounds by the mission visibility flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibilities", required = false, defaultValue = "PUBLIC") String visibilities,
        @Parameter(name = "start", description = "the start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "the limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ROUTE_SETTINGS = "/api/{version}/route/setting";
    /**
     * GET /api/{version}/route/setting : Search Route Settings
     * Search for route settings
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param hubId The service hub that the route belongs under (optional)
     * @param programId The program that the route belongs under (optional)
     * @param keyword The keyword to search for the route (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRouteSettings",
        summary = "Search Route Settings",
        description = "Search for route settings",
        tags = { "Route Setting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = RouteSettings.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ROUTE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<RouteSettings>> searchRouteSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "hubId", description = "The service hub that the route belongs under", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = false) @Nullable Long hubId,
        @Parameter(name = "programId", description = "The program that the route belongs under", in = ParameterIn.QUERY) @Valid @RequestParam(value = "programId", required = false) @Nullable Long programId,
        @Parameter(name = "keyword", description = "The keyword to search for the route", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_ROUTES = "/api/{version}/route";
    /**
     * GET /api/{version}/route : Search Routes
     * Search for routes.
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param includesEmpty Include empty routes or not (required)
     * @param rootOnly Only return root instance routes (required)
     * @param showInheritedProperties Display root route properties (required)
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRoutes",
        summary = "Search Routes",
        description = "Search for routes.",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Route.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_ROUTES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Route>> searchRoutes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @NotNull @Parameter(name = "includesEmpty", description = "Include empty routes or not", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includesEmpty", required = true) Boolean includesEmpty,
        @NotNull @Parameter(name = "rootOnly", description = "Only return root instance routes", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "rootOnly", required = true) Boolean rootOnly,
        @NotNull @Parameter(name = "showInheritedProperties", description = "Display root route properties", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "showInheritedProperties", required = true) Boolean showInheritedProperties,
        @Parameter(name = "hubId", description = "Filter results by service hub", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = false) @Nullable Long hubId,
        @Parameter(name = "programId", description = "Filter results by program", in = ParameterIn.QUERY) @Valid @RequestParam(value = "programId", required = false) @Nullable Long programId,
        @Parameter(name = "scheduledStart", description = "The start date to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledStart", required = false) @Nullable Long scheduledStart,
        @Parameter(name = "scheduledEnd", description = "The end date to filter the results by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledEnd", required = false) @Nullable Long scheduledEnd,
        @Parameter(name = "updatedStart", description = "The lower bound of updated date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedStart", required = false) @Nullable Long updatedStart,
        @Parameter(name = "updatedEnd", description = "The upper bound of updated date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedEnd", required = false) @Nullable Long updatedEnd,
        @Parameter(name = "featured", description = "The route is featured or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "seatCount", description = "Has at least this many seat available", in = ParameterIn.QUERY) @Valid @RequestParam(value = "seatCount", required = false) @Nullable Integer seatCount,
        @Parameter(name = "approved", description = "Has been approved or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approved", required = false) @Nullable Boolean approved,
        @Parameter(name = "started", description = "Has started or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "started", required = false) @Nullable Boolean started,
        @Parameter(name = "completed", description = "Has completed or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "completed", required = false) @Nullable Boolean completed,
        @Parameter(name = "valid", description = "Is valid or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "valid", required = false) @Nullable Boolean valid,
        @Parameter(name = "parentId", description = "If it is a recurring route based on the parent route", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SCHEDULE = "/api/{version}/reservable/schedule/search";
    /**
     * GET /api/{version}/reservable/schedule/search : Search Schedule
     *
     * @param version  (required)
     * @param reservableId the id of the reservation (required)
     * @param reservableType the reservation type (required)
     * @param startDate the start date of the reservation (required)
     * @param endDate the end date of the reservation (required)
     * @param deviceId the id of the device that the reservation is on (optional)
     * @param accountId the id of the logged in user (optional)
     * @param timeBucketMins the length of time in minutes to search on for reservation (optional, default to 30)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchSchedule",
        summary = "Search Schedule",
        tags = { "Reservation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = TimeSlotResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SCHEDULE,
        produces = { "*/*" }
    )
    default ResponseEntity<List<TimeSlotResponse>> searchSchedule(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "reservableId", description = "the id of the reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableId", required = true) Long reservableId,
        @NotNull @Parameter(name = "reservableType", description = "the reservation type", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservableType", required = true) String reservableType,
        @NotNull @Parameter(name = "startDate", description = "the start date of the reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = true) Long startDate,
        @NotNull @Parameter(name = "endDate", description = "the end date of the reservation", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = true) Long endDate,
        @Parameter(name = "deviceId", description = "the id of the device that the reservation is on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "timeBucketMins", description = "the length of time in minutes to search on for reservation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "timeBucketMins", required = false, defaultValue = "30") Integer timeBucketMins
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SCHEDULED_NOTIFICATIONS = "/api/{version}/notification/schedule/search";
    /**
     * GET /api/{version}/notification/schedule/search : Search Scheduled Notifications
     * This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchScheduledNotifications",
        summary = "Search Scheduled Notifications",
        description = "This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SCHEDULED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> searchScheduledNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "groupingId", description = "Filter results by a grouping identifier defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "audienceId", description = "Filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "filter", description = "a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) @Nullable String filter,
        @Parameter(name = "types", description = "Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION", in = ParameterIn.QUERY) @Valid @RequestParam(value = "types", required = false) @Nullable String types,
        @Parameter(name = "contentIds", description = "search using content IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "contentTypes", description = "search using content types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "parentIds", description = "search using parent IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "parentTypes", description = "search using parent types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentTypes", required = false) @Nullable String parentTypes,
        @Parameter(name = "statuses", description = "Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "templateTypes", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateTypes", required = false) @Nullable String templateTypes,
        @Parameter(name = "appKey", description = "Filter the list by a specific application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "Keyword search on the scheduled notification names.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "groupByGroupingId", description = "Determines whether to group results with the same groupingId together.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupByGroupingId", required = false) @Nullable Boolean groupByGroupingId,
        @Parameter(name = "returnAudienceAccountCount", description = "If true, include audience account counts in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAudienceAccountCount", required = false) @Nullable Boolean returnAudienceAccountCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SCORES = "/api/{version}/score/search";
    /**
     * GET /api/{version}/score/search : Search Score
     * Search the scores for an item.  Pass in the full path IDs for the scores.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The game application key to get the level for. (required)
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchScores",
        summary = "Search Score",
        description = "Search the scores for an item.  Pass in the full path IDs for the scores.",
        tags = { "Score" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ScoreResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SCORES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ScoreResponse>> searchScores(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The game application key to get the level for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "missionId", description = "The missionId to score for, null if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "gameId", description = "The gameId to score for, null if not playing mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "packId", description = "The packId to score for, null if playing community levels.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "The gameLevelId to score for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "gameObjectId", description = "The gameObjectId to score for, null if level based scoring.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = false) @Nullable Long gameObjectId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SERVICE_HUBS = "/api/{version}/hub";
    /**
     * GET /api/{version}/hub : Search Service Hubs
     * Search for service hubs.
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param keyword The keyword to search for (optional)
     * @param retailerId The retailer belongs to (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchServiceHubs",
        summary = "Search Service Hubs",
        description = "Search for service hubs.",
        tags = { "Service Hub" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ServiceHub.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SERVICE_HUBS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ServiceHub>> searchServiceHubs(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "retailerId", description = "The retailer belongs to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SHIPMENT_BATCH = "/api/{version}/shipment/batch";
    /**
     * GET /api/{version}/shipment/batch : Search Shipment Batch
     * Search for shipment batches
     *
     * @param version  (required)
     * @param hubId The associated service hub (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchShipmentBatch",
        summary = "Search Shipment Batch",
        description = "Search for shipment batches",
        tags = { "Shipment Batch" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ShipmentBatch.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SHIPMENT_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ShipmentBatch>> searchShipmentBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "hubId", description = "The associated service hub", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = true) Long hubId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SHIPMENTS = "/api/{version}/shipment";
    /**
     * GET /api/{version}/shipment : Search Shipments
     * Search for shipments
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param ownerId The owner of the shipment (optional)
     * @param riderId The rider associate to this shipment (optional)
     * @param routeId The route associate to this shipment (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchShipments",
        summary = "Search Shipments",
        description = "Search for shipments",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Shipment.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_SHIPMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Shipment>> searchShipments(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "ownerId", description = "The owner of the shipment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ownerId", required = false) @Nullable Long ownerId,
        @Parameter(name = "riderId", description = "The rider associate to this shipment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "riderId", required = false) @Nullable Long riderId,
        @Parameter(name = "routeId", description = "The route associate to this shipment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "routeId", required = false) @Nullable Long routeId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TASKS = "/api/{version}/task/search";
    /**
     * GET /api/{version}/task/search : Search Tasks
     * Search on Tasks
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks  (optional, default to MINE)
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to NEW,ERROR,COMPLETE,PROCESSING)
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the task names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to CREATED)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTasks",
        summary = "Search Tasks",
        description = "Search on Tasks",
        tags = { "Task" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = TaskResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TASKS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<TaskResponse>> searchTasks(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "groupingId", description = "Filter results by a grouping identifier defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "filter", description = "A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false, defaultValue = "MINE") String filter,
        @Parameter(name = "statuses", description = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false, defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") String statuses,
        @Parameter(name = "templateTypes", description = "Template Types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateTypes", required = false) @Nullable String templateTypes,
        @Parameter(name = "appKey", description = "Filter the list by a specific application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "Keyword search on the task names.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TERRITORIES = "/api/{version}/territory/search";
    /**
     * GET /api/{version}/territory/search : Search Territories
     * Searches on territories.
     *
     * @param version  (required)
     * @param sortField the field to sort by. Supported values include: ID, CREATED, UPDATED, NAME (required)
     * @param descending determines whether the sorted list is in descending or ascending order (required)
     * @param keyword Return results that match this keyword. (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTerritories",
        summary = "Search Territories",
        description = "Searches on territories.",
        tags = { "Territory" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = TerritoryResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TERRITORIES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<TerritoryResponse>> searchTerritories(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "the field to sort by. Supported values include: ID, CREATED, UPDATED, NAME", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @Parameter(name = "keyword", description = "Return results that match this keyword.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TOURNAMENTS = "/api/{version}/tournament/search";
    /**
     * GET /api/{version}/tournament/search : Search Tournaments
     * Search for tournaments
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application key (required)
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to MULTISTAGE,TOURNAMENT,POOLPLAY)
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)
     * @param sortField which field to sort on (optional, default to START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to PUBLIC)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTournaments",
        summary = "Search Tournaments",
        description = "Search for tournaments",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionShortResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TOURNAMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionShortResponse> searchTournaments(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "keyword", description = "the keyword to search tournament on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "subType", description = "filter results by subType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "includeInactive", description = "whether to include inactives in the search or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = false, defaultValue = "false") Boolean includeInactive,
        @Parameter(name = "missionTypes", description = "comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionTypes", required = false, defaultValue = "MULTISTAGE,TOURNAMENT,POOLPLAY") String missionTypes,
        @Parameter(name = "filter", description = "filter tournaments by the tournament's current state", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false, defaultValue = "UPCOMING") String filter,
        @Parameter(name = "sortField", description = "which field to sort on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "START_DATE") String sortField,
        @Parameter(name = "descending", description = "Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "visibility", description = "Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false, defaultValue = "PUBLIC") String visibility,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TRACKING_LEGS = "/api/{version}/tracking/searchByBillable";
    /**
     * GET /api/{version}/tracking/searchByBillable : Search Tracking (Billable)
     * Retrieve tracking data for billable/account scoped queries.
     *
     * @param version  (required)
     * @param accountId The account id to search tracking for (required)
     * @param appKey The application key (required)
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTrackingLegs",
        summary = "Search Tracking (Billable)",
        description = "Retrieve tracking data for billable/account scoped queries.",
        tags = { "Tracking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = LegResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TRACKING_LEGS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<LegResponse>> searchTrackingLegs(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id to search tracking for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "trackingDeviceId", description = "The id of the tracking device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trackingDeviceId", required = false) @Nullable String trackingDeviceId,
        @Parameter(name = "startDate", description = "The start date in (UTC milliseconds) to filter the tracking results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end date in (UTC milliseconds) to filter the tracking results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tags", description = "Filter results by tag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "start", description = "The start index for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The limit for pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TRIGGERS = "/api/{version}/trigger/search";
    /**
     * GET /api/{version}/trigger/search : Search Triggers
     * Search for triggers
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to MINE)
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to NEW,ERROR,COMPLETE,PROCESSING)
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the trigger names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to CREATED)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTriggers",
        summary = "Search Triggers",
        description = "Search for triggers",
        tags = { "Trigger" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = TriggerResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TRIGGERS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<TriggerResponse>> searchTriggers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "groupingId", description = "Filter results by a grouping identifier defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "filter", description = "A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false, defaultValue = "MINE") String filter,
        @Parameter(name = "statuses", description = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false, defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") String statuses,
        @Parameter(name = "templateTypes", description = "Template Types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateTypes", required = false) @Nullable String templateTypes,
        @Parameter(name = "appKey", description = "Filter the list by a specific application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "Keyword search on the trigger names.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") Boolean descending,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") Boolean activeOnly
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_TRIPS = "/api/{version}/trip/match";
    /**
     * GET /api/{version}/trip/match : Search Trips
     * Search for trips with matching information.
     *
     * @param version  (required)
     * @param accountId The owner of the trips (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param startDate The lower bound limit of time (optional)
     * @param endDate The upper bound limit of time (optional)
     * @param matchedHasRoute Only return matchings that already have route assigned (optional)
     * @param matchedHasDriver Only return matchings that already have driver assigned (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchTrips",
        summary = "Search Trips",
        description = "Search for trips with matching information.",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_TRIPS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> searchTrips(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The owner of the trips", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true) Boolean activeOnly,
        @Parameter(name = "startDate", description = "The lower bound limit of time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The upper bound limit of time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "matchedHasRoute", description = "Only return matchings that already have route assigned", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchedHasRoute", required = false) @Nullable Boolean matchedHasRoute,
        @Parameter(name = "matchedHasDriver", description = "Only return matchings that already have driver assigned", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchedHasDriver", required = false) @Nullable Boolean matchedHasDriver
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_VEHICLE = "/api/{version}/vehicle";
    /**
     * GET /api/{version}/vehicle : Search Vehicle
     * Search for vehicles
     *
     * @param version  (required)
     * @param hubId Filter by service hub (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param keyword The keyword to search for (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchVehicle",
        summary = "Search Vehicle",
        description = "Search for vehicles",
        tags = { "Vehicle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Vehicle.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_VEHICLE,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Vehicle>> searchVehicle(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "hubId", description = "Filter by service hub", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = true) Long hubId,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "keyword", description = "The keyword to search for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_VEHICLE_TYPES = "/api/{version}/vehicle/type";
    /**
     * GET /api/{version}/vehicle/type : Search Vehicle Type
     * Search for types of vehicles
     *
     * @param version  (required)
     * @param sortField The field to sort by (required)
     * @param descending Determines whether the sorted list is in descending or ascending order (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param activeOnly Return only active results (required)
     * @param retailerId Filter by retailer (optional)
     * @param hubId Filter by service hub (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchVehicleTypes",
        summary = "Search Vehicle Type",
        description = "Search for types of vehicles",
        tags = { "Vehicle Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = VehicleType.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_VEHICLE_TYPES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<VehicleType>> searchVehicleTypes(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "sortField", description = "The field to sort by", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") String sortField,
        @NotNull @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") Integer limit,
        @NotNull @Parameter(name = "activeOnly", description = "Return only active results", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") Boolean activeOnly,
        @Parameter(name = "retailerId", description = "Filter by retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "hubId", description = "Filter by service hub", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hubId", required = false) @Nullable Long hubId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_WEATHER = "/api/{version}/weather/search";
    /**
     * GET /api/{version}/weather/search : Search Weather
     * Search the weather forcast for the next 5 days
     *
     * @param version  (required)
     * @param regionId Region Id (optional)
     * @param latitude Latitude (optional)
     * @param longitude Longitude (optional)
     * @param timezoneOffset Timezone Offset (optional, default to -6)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchWeather",
        summary = "Search Weather",
        description = "Search the weather forcast for the next 5 days",
        tags = { "Weather" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WeatherResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SEARCH_WEATHER,
        produces = { "*/*" }
    )
    default ResponseEntity<WeatherResponse> searchWeather(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "regionId", description = "Region Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionId", required = false) @Nullable Long regionId,
        @Parameter(name = "latitude", description = "Latitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Longitude", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "timezoneOffset", description = "Timezone Offset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "timezoneOffset", required = false, defaultValue = "-6") Long timezoneOffset
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SECURE_LOGIN = "/api/{version}/account/login/validate";
    /**
     * POST /api/{version}/account/login/validate : Login Account (Encrypted Username)
     * ogin with encrypted user-name and password.
     *
     * @param version  (required)
     * @param username The user&#39;s encrypted email address they used to sign-up (required)
     * @param password The encrypted password (required)
     * @param gameType The application key (required)
     * @param deviceId The device id (optional)
     * @param charsetName Charset Name (optional, default to UTF-8)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional, default to false)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to PROFILE)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "secureLogin",
        summary = "Login Account (Encrypted Username)",
        description = "ogin with encrypted user-name and password.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SECURE_LOGIN,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> secureLogin(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "username", description = "The user's encrypted email address they used to sign-up", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "The encrypted password", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @NotNull @Parameter(name = "gameType", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = true) String gameType,
        @Parameter(name = "deviceId", description = "The device id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "charsetName", description = "Charset Name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "charsetName", required = false, defaultValue = "UTF-8") String charsetName,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnProfile", description = "Return Profile", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProfile", required = false, defaultValue = "false") Boolean returnProfile,
        @Parameter(name = "responseFilters", description = "A comma separated list of ProfileFilters for filtering the returned response data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") String responseFilters
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SECURE_SIGNUP = "/api/{version}/account/create/validate";
    /**
     * POST /api/{version}/account/create/validate : Create Account (Encrypted Username)
     * Create a new account by role (with encrypted user-name and password)
     *
     * @param version  (required)
     * @param deviceId The device id (required)
     * @param username The encrypted email of the user, this is what will be used when they login (required)
     * @param password The encrypted password of the user (required)
     * @param name The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param inviteToken the inviteToken that the referrer use for this account to sign up (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title Title (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param address the user&#39;s address (optional)
     * @param zipcode The street zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param birthday The birthday date of the user in milliseconds (optional)
     * @param homePhone the user&#39;s home phone number (optional)
     * @param cellPhone the user&#39;s cell phone number (optional)
     * @param cellPhoneCarrier the user&#39;s Cell Phone Carrier (optional)
     * @param businessPhone the user&#39;s Business Phone Number (optional)
     * @param role The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST (optional, default to MEMBER)
     * @param platforms Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About Us information (optional)
     * @param gameExperience Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s maritial status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional, default to true)
     * @param charsetName Charset Name (optional, default to UTF-8)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param appVersion App Version (optional)
     * @param responseType Response Type (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "secureSignup",
        summary = "Create Account (Encrypted Username)",
        description = "Create a new account by role (with encrypted user-name and password)",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileInfoResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SECURE_SIGNUP,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileInfoResponse> secureSignup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "deviceId", description = "The device id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = true) String deviceId,
        @NotNull @Parameter(name = "username", description = "The encrypted email of the user, this is what will be used when they login", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = true) String username,
        @NotNull @Parameter(name = "password", description = "The encrypted password of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = true) String password,
        @Parameter(name = "name", description = "The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "inviteToken", description = "the inviteToken that the referrer use for this account to sign up", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inviteToken", required = false) @Nullable String inviteToken,
        @Parameter(name = "prefixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "prefixName", required = false) @Nullable String prefixName,
        @Parameter(name = "firstName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "middleName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "middleName", required = false) @Nullable String middleName,
        @Parameter(name = "lastName", description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "suffixName", description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffixName", required = false) @Nullable String suffixName,
        @Parameter(name = "title", description = "Title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "deviceIdType", description = "Device Id Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIdType", required = false) @Nullable String deviceIdType,
        @Parameter(name = "emailAddress", description = "The user's contact email address (NOT the username) which is also used for email validation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "assetId", description = "The asset id to set the user's profile image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "address", description = "the user's address", in = ParameterIn.QUERY) @Valid @RequestParam(value = "address", required = false) @Nullable String address,
        @Parameter(name = "zipcode", description = "The street zipcode of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "gender", description = "The gender of the user AudienceGender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "birthday", description = "The birthday date of the user in milliseconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "birthday", required = false) @Nullable Long birthday,
        @Parameter(name = "homePhone", description = "the user's home phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homePhone", required = false) @Nullable String homePhone,
        @Parameter(name = "cellPhone", description = "the user's cell phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "cellPhoneCarrier", description = "the user's Cell Phone Carrier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhoneCarrier", required = false) @Nullable String cellPhoneCarrier,
        @Parameter(name = "businessPhone", description = "the user's Business Phone Number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "role", description = "The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false, defaultValue = "MEMBER") String role,
        @Parameter(name = "platforms", description = "Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "tags", description = "Search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "aboutUs", description = "About Us information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "aboutUs", required = false) @Nullable String aboutUs,
        @Parameter(name = "gameExperience", description = "Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperience", required = false) @Nullable String gameExperience,
        @Parameter(name = "categoryIds", description = "A list of category ids that represent interests and associations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "hometown", description = "The user's hometown", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hometown", required = false) @Nullable String hometown,
        @Parameter(name = "height", description = "The user's height", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable String height,
        @Parameter(name = "heightIndex", description = "The user's height in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "heightIndex", required = false) @Nullable Integer heightIndex,
        @Parameter(name = "ethnicity", description = "The user's ethnicity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ethnicity", required = false) @Nullable String ethnicity,
        @Parameter(name = "bodyType", description = "The user's body type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bodyType", required = false) @Nullable String bodyType,
        @Parameter(name = "maritalStatus", description = "The user's maritial status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maritalStatus", required = false) @Nullable String maritalStatus,
        @Parameter(name = "children", description = "The user's children status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "children", required = false) @Nullable String children,
        @Parameter(name = "religion", description = "The user's religion", in = ParameterIn.QUERY) @Valid @RequestParam(value = "religion", required = false) @Nullable String religion,
        @Parameter(name = "education", description = "The user's education", in = ParameterIn.QUERY) @Valid @RequestParam(value = "education", required = false) @Nullable String education,
        @Parameter(name = "educationIndex", description = "The user's education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "educationIndex", required = false) @Nullable Integer educationIndex,
        @Parameter(name = "smoke", description = "The user's smoke status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smoke", required = false) @Nullable String smoke,
        @Parameter(name = "drink", description = "The user's drink status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "drink", required = false) @Nullable String drink,
        @Parameter(name = "companionship", description = "The user's companionship status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionship", required = false) @Nullable String companionship,
        @Parameter(name = "companionshipIndex", description = "The user's companionship index", in = ParameterIn.QUERY) @Valid @RequestParam(value = "companionshipIndex", required = false) @Nullable Integer companionshipIndex,
        @Parameter(name = "preferredMinAge", description = "The preferred minimum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinAge", required = false) @Nullable Integer preferredMinAge,
        @Parameter(name = "preferredMaxAge", description = "The preferred maximum age in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxAge", required = false) @Nullable Integer preferredMaxAge,
        @Parameter(name = "preferredMinHeight", description = "The preferred minimum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMinHeight", required = false) @Nullable Integer preferredMinHeight,
        @Parameter(name = "preferredMaxHeight", description = "The preferred maximum height in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredMaxHeight", required = false) @Nullable Integer preferredMaxHeight,
        @Parameter(name = "preferredGender", description = "The preferred gender in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredGender", required = false) @Nullable String preferredGender,
        @Parameter(name = "preferredEducation", description = "The preferred education in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducation", required = false) @Nullable String preferredEducation,
        @Parameter(name = "preferredEducationIndex", description = "The preferred education in a numerical value that can be used for ordering/searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEducationIndex", required = false) @Nullable Integer preferredEducationIndex,
        @Parameter(name = "preferredBodyType", description = "The preferred body type in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredBodyType", required = false) @Nullable String preferredBodyType,
        @Parameter(name = "preferredEthnicity", description = "The preferred ethnicity in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredEthnicity", required = false) @Nullable String preferredEthnicity,
        @Parameter(name = "preferredLocation", description = "The preferred education in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocation", required = false) @Nullable String preferredLocation,
        @Parameter(name = "preferredLocationRange", description = "The preferred location range in the account location search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preferredLocationRange", required = false) @Nullable Double preferredLocationRange,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "acceptedTerms", description = "Accepted Terms", in = ParameterIn.QUERY) @Valid @RequestParam(value = "acceptedTerms", required = false, defaultValue = "true") Boolean acceptedTerms,
        @Parameter(name = "charsetName", description = "Charset Name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "charsetName", required = false, defaultValue = "UTF-8") String charsetName,
        @Parameter(name = "gameType", description = "Game Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "appVersion", description = "App Version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "responseType", description = "Response Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseType", required = false) @Nullable String responseType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_BATCH_NOTIFICATIONS = "/api/{version}/notification/batch";
    /**
     * POST /api/{version}/notification/batch : Send Batch Notifications
     * Send notifications to all users of an application. Only someone with permissions to the application can do this.
     *
     * @param version  (required)
     * @param accountId The account id of the application owner/manager (required)
     * @param appKey The application key for updating an existing application (required)
     * @param customMessage Message string that will be displayed in on the notification (required)
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendBatchNotifications",
        summary = "Send Batch Notifications",
        description = "Send notifications to all users of an application. Only someone with permissions to the application can do this.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEND_BATCH_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendBatchNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the application owner/manager", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "customMessage", description = "Message string that will be displayed in on the notification", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = true) String customMessage,
        @Parameter(name = "conduit", description = "The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "contentId", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_BY_ACCOUNT = "/api/{version}/audience/suggestion/send";
    /**
     * POST /api/{version}/audience/suggestion/send : Send Suggestions
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     *
     * @param version  (required)
     * @param accountId The account to match offers for. (required)
     * @param latitude the latitude (required)
     * @param longitude the longitude (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendByAccount",
        summary = "Send Suggestions",
        description = "Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEND_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendByAccount(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "latitude", description = "the latitude", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "the longitude", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_CUSTOM_NOTIFICATIONS = "/api/{version}/notification/custom";
    /**
     * POST /api/{version}/notification/custom : Send Custom Notifications
     * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
     *
     * @param version  (required)
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification (optional)
     * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
     * @param appKey the application key (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param actionCategory  (optional)
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
     * @param customMessage message string that will be displayed in on the notification (optional)
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendCustomNotifications",
        summary = "Send Custom Notifications",
        description = "Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEND_CUSTOM_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendCustomNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "receiverAccountIds", description = "comma separated list of account IDs that will receive the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountIds", required = false) @Nullable String receiverAccountIds,
        @Parameter(name = "includeFriendGroup", description = "determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = false) @Nullable Boolean includeFriendGroup,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "contentId", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "actionCategory", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionCategory", required = false) @Nullable String actionCategory,
        @Parameter(name = "subject", description = "the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subject", required = false) @Nullable String subject,
        @Parameter(name = "customMessage", description = "message string that will be displayed in on the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = false) @Nullable String customMessage,
        @Parameter(name = "friendOnlyAPNS", description = "only sends APNS to people who are friends of the user (still saves the notification message for feed polling)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendOnlyAPNS", required = false) @Nullable Boolean friendOnlyAPNS,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_MFA_CHALLENGE = "/api/{version}/thirdparty/credential/mfa/send";
    /**
     * POST /api/{version}/thirdparty/credential/mfa/send : Send MFA Challenge
     * Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
     *
     * @param version  (required)
     * @param networkUID the third party network provider that has MFA enabled (required)
     * @param appKey the application key (required)
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartyCredentialId optional id of the existing third party credential (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendMFAChallenge",
        summary = "Send MFA Challenge",
        description = "Sends an MFA challenge (SMS or Email) for networks with MFA enabled.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEND_MFA_CHALLENGE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendMFAChallenge(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "networkUID", description = "the third party network provider that has MFA enabled", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "thirdPartyToken", description = "the access token to authenticate with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyToken", required = false) @Nullable String thirdPartyToken,
        @Parameter(name = "thirdPartyCredentialId", description = "optional id of the existing third party credential", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyCredentialId", required = false) @Nullable Long thirdPartyCredentialId,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_NFT = "/api/{version}/vatom/b/campaigns/send";
    /**
     * POST /api/{version}/vatom/b/campaigns/send : Send NFT
     * Send an NFT.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendNFT",
        summary = "Send NFT",
        description = "Send an NFT.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SEND_NFT
    )
    default ResponseEntity<Void> sendNFT(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SET_DRIVER = "/api/{version}/route/{id}/driver/{driverId}";
    /**
     * POST /api/{version}/route/{id}/driver/{driverId} : Set Driver
     * Update the driver of the route.
     *
     * @param version  (required)
     * @param id the id of the route (required)
     * @param driverId the id of the driver (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "setDriver",
        summary = "Set Driver",
        description = "Update the driver of the route.",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SET_DRIVER
    )
    default ResponseEntity<Void> setDriver(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "driverId", description = "the id of the driver", required = true, in = ParameterIn.PATH) @PathVariable("driverId") Long driverId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SET_MATCH_TOKEN = "/api/{version}/consumer/profile/matchToken";
    /**
     * POST /api/{version}/consumer/profile/matchToken : Save Match Token
     * Save user&#39;s match token to be used for profile match making
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param matchToken A string of numbers (optional)
     * @param gameType Game Type (deprecated) (optional, default to BOOPY)
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "setMatchToken",
        summary = "Save Match Token",
        description = "Save user's match token to be used for profile match making",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SET_MATCH_TOKEN,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> setMatchToken(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "matchToken", description = "A string of numbers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "matchToken", required = false) @Nullable String matchToken,
        @Parameter(name = "gameType", description = "Game Type (deprecated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false, defaultValue = "BOOPY") String gameType,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SET_POINTS_BALANCE_AS_BUSINESS = "/api/{version}/vatom/b/campaign/u/points/update";
    /**
     * POST /api/{version}/vatom/b/campaign/u/points/update : Set Points Balance as Business
     * Sets the points balance of a Vatom user.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomCampaignId Vatom Campaign Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "setPointsBalanceAsBusiness",
        summary = "Set Points Balance as Business",
        description = "Sets the points balance of a Vatom user.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SET_POINTS_BALANCE_AS_BUSINESS
    )
    default ResponseEntity<Void> setPointsBalanceAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "vatomCampaignId", description = "Vatom Campaign Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomCampaignId", required = true) String vatomCampaignId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SIMULATION = "/api/{version}/simulation/routing";
    /**
     * POST /api/{version}/simulation/routing : Routing Simulation
     * Simulates routing requests.
     *
     * @param version  (required)
     * @param data JSON string in the following format: &#x60;&#x60;&#x60;json {   \&quot;startDate\&quot;: 1474268400000,   \&quot;endDate\&quot;: 1474268700000,   \&quot;checkoutStops\&quot;: [     {       \&quot;latitude\&quot;: 25.060453943481615,       \&quot;longitude\&quot;: 121.57487118216957     }   ],   \&quot;requests\&quot;: [     {       \&quot;vehicles\&quot;: [         {           \&quot;id\&quot;: \&quot;customer1\&quot;,           \&quot;name\&quot;: \&quot;Customer 1\&quot;,           \&quot;depot\&quot;: {             \&quot;latitude\&quot;: 25.060453943481615,             \&quot;longitude\&quot;: 121.57487118216957           },           \&quot;startWindow\&quot;: 1474268464537         }       ],       \&quot;items\&quot;: [         {           \&quot;id\&quot;: 152712,           \&quot;name\&quot;: \&quot;Appliance Product\&quot;,           \&quot;pickup\&quot;: {             \&quot;latitude\&quot;: 25.060306635544144,             \&quot;longitude\&quot;: 121.5750770690688           }         },         {           \&quot;id\&quot;: 152711,           \&quot;name\&quot;: \&quot;TV product\&quot;,           \&quot;pickup\&quot;: {             \&quot;latitude\&quot;: 25.060126352576326,             \&quot;longitude\&quot;: 121.57505023621624           }         }       ]     }   ],   \&quot;featuredItems\&quot;: [],   \&quot;floorPlan\&quot;: {     \&quot;metersPerX\&quot;: 0.81493109028875,     \&quot;metersPerY\&quot;: 1.8525267552262,     \&quot;width\&quot;: 75,     \&quot;height\&quot;: 50,     \&quot;exclusions\&quot;: [       { \&quot;x\&quot;: 14, \&quot;y\&quot;: 49 }     ],     \&quot;southwest\&quot;: {       \&quot;x\&quot;: 0,       \&quot;y\&quot;: 0,       \&quot;latitude\&quot;: 25.05961539530497,       \&quot;longitude\&quot;: 121.57487591737885     }   } } &#x60;&#x60;&#x60;  (required)
     * @param realTime determines whether to run the simulation and return the results in the same request (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "simulation",
        summary = "Routing Simulation",
        description = "Simulates routing requests.",
        tags = { "Simulation" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SIMULATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> simulation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "data", description = "JSON string in the following format: ```json {   \"startDate\": 1474268400000,   \"endDate\": 1474268700000,   \"checkoutStops\": [     {       \"latitude\": 25.060453943481615,       \"longitude\": 121.57487118216957     }   ],   \"requests\": [     {       \"vehicles\": [         {           \"id\": \"customer1\",           \"name\": \"Customer 1\",           \"depot\": {             \"latitude\": 25.060453943481615,             \"longitude\": 121.57487118216957           },           \"startWindow\": 1474268464537         }       ],       \"items\": [         {           \"id\": 152712,           \"name\": \"Appliance Product\",           \"pickup\": {             \"latitude\": 25.060306635544144,             \"longitude\": 121.5750770690688           }         },         {           \"id\": 152711,           \"name\": \"TV product\",           \"pickup\": {             \"latitude\": 25.060126352576326,             \"longitude\": 121.57505023621624           }         }       ]     }   ],   \"featuredItems\": [],   \"floorPlan\": {     \"metersPerX\": 0.81493109028875,     \"metersPerY\": 1.8525267552262,     \"width\": 75,     \"height\": 50,     \"exclusions\": [       { \"x\": 14, \"y\": 49 }     ],     \"southwest\": {       \"x\": 0,       \"y\": 0,       \"latitude\": 25.05961539530497,       \"longitude\": 121.57487591737885     }   } } ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @NotNull @Parameter(name = "realTime", description = "determines whether to run the simulation and return the results in the same request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "realTime", required = true) Boolean realTime
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SMS_BUY_OFFER = "/api/{version}/sms/buyoffer/{appKey}";
    /**
     * POST /api/{version}/sms/buyoffer/{appKey} : Buy Offer by SMS
     * Recieve an SMS payload from Twillio to purchase an offer.
     *
     * @param version  (required)
     * @param appKey the application key (required)
     * @param body the message of the text (required)
     * @param from the sender of the sms (required)
     * @param currencyType the type of currency (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "smsBuyOffer",
        summary = "Buy Offer by SMS",
        description = "Recieve an SMS payload from Twillio to purchase an offer.",
        tags = { "Twilio" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "application/xml", schema = @Schema(implementation = TwiMLResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SMS_BUY_OFFER,
        produces = { "application/xml" }
    )
    default ResponseEntity<TwiMLResponse> smsBuyOffer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.PATH) @PathVariable("appKey") String appKey,
        @NotNull @Parameter(name = "Body", description = "the message of the text", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "Body", required = true) String body,
        @NotNull @Parameter(name = "From", description = "the sender of the sms", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "From", required = true) String from,
        @NotNull @Parameter(name = "currencyType", description = "the type of currency", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = true) String currencyType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_START_VIDEO_RENDER = "/api/{version}/orson/stories/renders";
    /**
     * POST /api/{version}/orson/stories/renders : Starts a StoryStitch video render
     * Starts a StoryStitch video render to produce your final video, returning the status details.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param data Request Data String (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "startVideoRender",
        summary = "Starts a StoryStitch video render",
        description = "Starts a StoryStitch video render to produce your final video, returning the status details.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonRenderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_START_VIDEO_RENDER,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonRenderResponse> startVideoRender(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "data", description = "Request Data String", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_STATUS_CSV = "/api/{version}/csvimport/batch/status";
    /**
     * GET /api/{version}/csvimport/batch/status : Batch Status
     * Checks status of batch upload.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param batchId the id of the batch to get its status (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "statusCSV",
        summary = "Batch Status",
        description = "Checks status of batch upload.",
        tags = { "CSV Import" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CsvImportResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_STATUS_CSV,
        produces = { "*/*" }
    )
    default ResponseEntity<CsvImportResponse> statusCSV(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "batchId", description = "the id of the batch to get its status", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "batchId", required = true) Long batchId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_STT = "/api/{version}/orson/ai/stt";
    /**
     * POST /api/{version}/orson/ai/stt : Speach to Text
     * Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param sourceLanguage Source Language (optional)
     * @param targetLanguage Target Language (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "stt",
        summary = "Speach to Text",
        description = "Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiSTTResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_STT,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiSTTResponse> stt(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "sourceLanguage", description = "Source Language", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sourceLanguage", required = false) @Nullable String sourceLanguage,
        @Parameter(name = "targetLanguage", description = "Target Language", in = ParameterIn.QUERY) @Valid @RequestParam(value = "targetLanguage", required = false) @Nullable String targetLanguage,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SUBMIT_TOURNAMENT_SCORE = "/api/{version}/tournament/score";
    /**
     * POST /api/{version}/tournament/score : Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     *
     * @param version  (required)
     * @param accountId The logged in user account ID. (required)
     * @param appKey The application key. (required)
     * @param missionId The missionId to score for (required)
     * @param gameId The gameId to score for (required)
     * @param packId The packId to score for (required)
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "submitTournamentScore",
        summary = "Submit Tournament Score",
        description = "Submit an array of scores for a tournament match. ",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SUBMIT_TOURNAMENT_SCORE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> submitTournamentScore(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user account ID.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "missionId", description = "The missionId to score for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @NotNull @Parameter(name = "gameId", description = "The gameId to score for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = true) Long gameId,
        @NotNull @Parameter(name = "packId", description = "The packId to score for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = true) Long packId,
        @NotNull @Parameter(name = "scores", description = "a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scores", required = true) String scores,
        @Parameter(name = "gameLevelId", description = "The gameLevelId to score for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SUBMIT_TOURNAMENT_VOTE = "/api/{version}/tournament/vote";
    /**
     * POST /api/{version}/tournament/vote : Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param missionId The tournament&#39;s primary id (required)
     * @param gameObjectId The tournament game object the user wants to vote on (required)
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "submitTournamentVote",
        summary = "Submit a vote for a multi-stage album tournament.",
        description = "Submit a vote for a multi-stage album tournament.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SUBMIT_TOURNAMENT_VOTE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> submitTournamentVote(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to target", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "missionId", description = "The tournament's primary id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @NotNull @Parameter(name = "gameObjectId", description = "The tournament game object the user wants to vote on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = true) Long gameObjectId,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "checkIfDeviceAlreadyVoted", description = "When true, check if the device already voted to prevent duplicate votes from the same device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "checkIfDeviceAlreadyVoted", required = false, defaultValue = "false") Boolean checkIfDeviceAlreadyVoted
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SUBSTITUTE_TOURNAMENT_PLAYER = "/api/{version}/tournament/substitute";
    /**
     * POST /api/{version}/tournament/substitute : Substitute Tournament Player
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission (required)
     * @param packId the id of the pack (required)
     * @param gameLevelId the id of the game level (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "substituteTournamentPlayer",
        summary = "Substitute Tournament Player",
        description = "Service to replace the user's opponent in the current level - pack - mission with an AI account.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SUBSTITUTE_TOURNAMENT_PLAYER,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> substituteTournamentPlayer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "the id of the mission", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @NotNull @Parameter(name = "packId", description = "the id of the pack", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = true) Long packId,
        @NotNull @Parameter(name = "gameLevelId", description = "the id of the game level", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = true) Long gameLevelId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SUMMARIZE_TOPICS = "/api/{version}/orson/ai/topics";
    /**
     * POST /api/{version}/orson/ai/topics : Summarize Topics
     * Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param doc The text to get topics for. (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param limit The number of results to return (optional)
     * @param offset The starting offset into the total result set to start from (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "summarizeTopics",
        summary = "Summarize Topics",
        description = "Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTopicsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_SUMMARIZE_TOPICS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTopicsResponse> summarizeTopics(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "doc", description = "The text to get topics for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "doc", required = false) @Nullable String doc,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "limit", description = "The number of results to return", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "offset", description = "The starting offset into the total result set to start from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) @Nullable Integer offset,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SUMMARY_LISTING = "/api/{version}/listing/summary";
    /**
     * GET /api/{version}/listing/summary : Summary Listing
     * Search for a list of summary listings from the start time up to 8 days out.
     *
     * @param version  (required)
     * @param accountId the account id of the user (optional)
     * @param startDate the start date to search from (optional)
     * @param categoryIds the list of categories to search on (optional)
     * @param daysToInclude how far out to search, in days (optional, default to 15)
     * @param useListingOrderIds determines whether to use configured listing order ids (optional, default to true)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "summaryListing",
        summary = "Summary Listing",
        description = "Search for a list of summary listings from the start time up to 8 days out.",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = ListingGroupResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_SUMMARY_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<List<ListingGroupResponse>> summaryListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "startDate", description = "the start date to search from", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "categoryIds", description = "the list of categories to search on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "daysToInclude", description = "how far out to search, in days", in = ParameterIn.QUERY) @Valid @RequestParam(value = "daysToInclude", required = false, defaultValue = "15") Integer daysToInclude,
        @Parameter(name = "useListingOrderIds", description = "determines whether to use configured listing order ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useListingOrderIds", required = false, defaultValue = "true") Boolean useListingOrderIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_TECH_TUNE = "/api/{version}/orson/ai/techTune";
    /**
     * POST /api/{version}/orson/ai/techTune : Detect Technical Issues
     * Analyses a movie file to detect technical issues, such as too few people in frame.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param numFacesExpected Number of expected faces (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "techTune",
        summary = "Detect Technical Issues",
        description = "Analyses a movie file to detect technical issues, such as too few people in frame.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTechTuneResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_TECH_TUNE,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTechTuneResponse> techTune(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "numFacesExpected", description = "Number of expected faces", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "numFacesExpected", required = true) Integer numFacesExpected,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "file", description = "An uploaded recording to analyze (Currently limited to 10MB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "file", required = false) @Nullable org.springframework.core.io.Resource file,
        @Parameter(name = "url", description = "A recording file to download and analyze (Size limit: 1GB)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "url", required = false) @Nullable String url,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_TICKET_OFFERS = "/api/{version}/ticket/ticketoffers";
    /**
     * GET /api/{version}/ticket/ticketoffers : Get Ticket Offers
     * Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
     *
     * @param version  (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "ticketOffers",
        summary = "Get Ticket Offers",
        description = "Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.",
        tags = { "Ticket" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TicketOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_TICKET_OFFERS,
        produces = { "*/*" }
    )
    default ResponseEntity<TicketOfferResponse> ticketOffers(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_TOP_OFFER_TRANSACTIONS = "/api/{version}/offer/top";
    /**
     * GET /api/{version}/offer/top : Get Offers (Top)
     * Gets the top active offers.
     *
     * @param version  (required)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of record to return. Default id 20. (optional, default to 20)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "topOfferTransactions",
        summary = "Get Offers (Top)",
        description = "Gets the top active offers.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_TOP_OFFER_TRANSACTIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> topOfferTransactions(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "start", description = "The index into the record set to start with. Default is 0.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The total number of record to return. Default id 20.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_TRANSFER_USER_COINS = "/api/{version}/vatom/u/coins/transfer";
    /**
     * POST /api/{version}/vatom/u/coins/transfer : Transfer coins from Vatom Users
     * Transfer coins from Vatom Users.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "transferUserCoins",
        summary = "Transfer coins from Vatom Users",
        description = "Transfer coins from Vatom Users.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_TRANSFER_USER_COINS
    )
    default ResponseEntity<Void> transferUserCoins(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_TTS = "/api/{version}/orson/ai/tts";
    /**
     * POST /api/{version}/orson/ai/tts : Text to Speach
     * Creates an audio file for the given text, with the option of language and voice selection.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param text Text (required)
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param language The language to use for the speaker and incoming text (optional)
     * @param voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "tts",
        summary = "Text to Speach",
        description = "Creates an audio file for the given text, with the option of language and voice selection.",
        tags = { "Orson" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrsonAiTTSResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_TTS,
        produces = { "*/*" }
    )
    default ResponseEntity<OrsonAiTTSResponse> tts(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "text", description = "Text", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "text", required = true) String text,
        @Parameter(name = "thirdPartyAccountId", description = "A third-party account id that is meaningful to your systems", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyAccountId", required = false) @Nullable String thirdPartyAccountId,
        @Parameter(name = "language", description = "The language to use for the speaker and incoming text", in = ParameterIn.QUERY) @Valid @RequestParam(value = "language", required = false) @Nullable String language,
        @Parameter(name = "voice", description = "A language-specific voice to use, or picks the language default if not provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "voice", required = false) @Nullable String voice,
        @Parameter(name = "callback", description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open", in = ParameterIn.QUERY) @Valid @RequestParam(value = "callback", required = false) @Nullable String paramCallback
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UNASSIGN_EMPLOYEE = "/api/{version}/employee/unassign";
    /**
     * POST /api/{version}/employee/unassign : Unassign Employee
     * Unassign An existing account to be an employee
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param employeeAccountId The account id of the user to be unassigned (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "unassignEmployee",
        summary = "Unassign Employee",
        description = "Unassign An existing account to be an employee",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = EmployeeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UNASSIGN_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<EmployeeResponse> unassignEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "employeeAccountId", description = "The account id of the user to be unassigned", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = true) Long employeeAccountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ACHIEVEMENT = "/api/{version}/achievement/update";
    /**
     * POST /api/{version}/achievement/update : Update Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementId the achievement ID for updating an existing achievement (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param title the title of the achievement (255 character limit) (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param nullMinIncrement enable to ignore usage of minIncrement (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param nullMaxIncrement enable to ignore usage of maxIncrement (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active if it&#39;s active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAchievement",
        summary = "Update Achievement",
        description = "Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ACHIEVEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementResponse> updateAchievement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "achievementId", description = "the achievement ID for updating an existing achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementId", required = false) @Nullable Long achievementId,
        @Parameter(name = "analyticsTag", description = "the analytics tag that will trigger when a user's achievement count gets updated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "analyticsTag", required = false) @Nullable String analyticsTag,
        @Parameter(name = "title", description = "the title of the achievement (255 character limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "the description of the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "rankType", description = "the rank type for updating leader boards", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "rankIncrement", description = "determines how much the rank count is incremented", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankIncrement", required = false) @Nullable Integer rankIncrement,
        @Parameter(name = "minIncrement", description = "restrict scores to be above or equal to this minimum value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minIncrement", required = false) @Nullable Integer minIncrement,
        @Parameter(name = "nullMinIncrement", description = "enable to ignore usage of minIncrement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "nullMinIncrement", required = false) @Nullable Boolean nullMinIncrement,
        @Parameter(name = "maxIncrement", description = "restrict scores to be below or equal to this maximum value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxIncrement", required = false) @Nullable Integer maxIncrement,
        @Parameter(name = "nullMaxIncrement", description = "enable to ignore usage of maxIncrement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "nullMaxIncrement", required = false) @Nullable Boolean nullMaxIncrement,
        @Parameter(name = "validate", description = "determines whether the customId on analytics are used to validate a user's achievement progress.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "validate", required = false) @Nullable Boolean validate,
        @Parameter(name = "active", description = "if it's active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "triggerDefinition", description = "if provided will define what triggers to run after a tier is completed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "triggerDefinition", required = false) @Nullable String triggerDefinition
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ACHIEVEMENT_TIER = "/api/{version}/achievement/tier/update";
    /**
     * POST /api/{version}/achievement/tier/update : Update Achievement Tier
     * Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     *
     * @param version  (required)
     * @param achievementTierId the achievement tier id for updating (required)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @param scoreAllInstances score all instances (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAchievementTier",
        summary = "Update Achievement Tier",
        description = "Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AchievementTierResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ACHIEVEMENT_TIER,
        produces = { "*/*" }
    )
    default ResponseEntity<AchievementTierResponse> updateAchievementTier(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "achievementTierId", description = "the achievement tier id for updating", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementTierId", required = true) Long achievementTierId,
        @Parameter(name = "deviceId", description = "a unique id given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "icon", description = "achievement tier icon image file", in = ParameterIn.QUERY) @Valid @RequestParam(value = "icon", required = false) @Nullable org.springframework.core.io.Resource icon,
        @Parameter(name = "iconAssetId", description = "the icon assetId, if icon is provided, icon will overrule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconAssetId", required = false) @Nullable Long iconAssetId,
        @Parameter(name = "title", description = "the title of the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "the description of the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "goalCount", description = "the count requirement for completing the achievement tier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "goalCount", required = false) @Nullable Long goalCount,
        @Parameter(name = "missionId", description = "The ID of the mission to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "gameId", description = "The ID of the game to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "packId", description = "The ID of the pack to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "The ID of the game level to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "gameObjectId", description = "The ID of the game object to associate with the achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameObjectId", required = false) @Nullable Long gameObjectId,
        @Parameter(name = "scoreAllInstances", description = "score all instances", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoreAllInstances", required = false) @Nullable Boolean scoreAllInstances
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ACTVE_STATUS = "/api/{version}/account/active/update";
    /**
     * POST /api/{version}/account/active/update : Update Account Active Status
     * Activate or deactivate an account (requires appropriate permissions).
     *
     * @param version  (required)
     * @param accountId the account id of the user (deviceId or accountId required) (required)
     * @param connectionAccountId The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead) (required)
     * @param active true will activate the user and false will deactivate (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param appKey the application key that the user belongs to (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateActveStatus",
        summary = "Update Account Active Status",
        description = "Activate or deactivate an account (requires appropriate permissions).",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ACTVE_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateActveStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "connectionAccountId", description = "The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = true) Long connectionAccountId,
        @NotNull @Parameter(name = "active", description = "true will activate the user and false will deactivate", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "appKey", description = "the application key that the user belongs to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ALBUM_COLLECTION = "/api/{version}/album/update";
    /**
     * POST /api/{version}/album/update : Update Album
     * Update an Album.
     *
     * @param version  (required)
     * @param albumId the ID of the album to update (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param assetsToAdd Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param assetsToRemove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param assetId the cover asset ID (optional)
     * @param media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param mediaURL this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param active determines whether the album is active or inactive (optional)
     * @param title the title of the album (optional)
     * @param startDate the start date (optional)
     * @param endDate the end date (optional)
     * @param tags the tags (optional)
     * @param description the description of the album (optional)
     * @param albumType a custom field used for aggregation and searching (optional)
     * @param albumTypeId a custom indexed number used for aggregation and searching (optional)
     * @param subType a custom string field used for aggregation and searching (optional)
     * @param publicRead determines whether the album&#39;s participants have read permissions (optional)
     * @param publicWrite determines whether the album&#39;s participants have write permissions (optional)
     * @param publicDelete determines whether the album&#39;s participants have delete permissions (optional)
     * @param publicAdd determines whether the album&#39;s participants have add permissions (optional)
     * @param latitude latitude used to update the album&#39;s location (optional)
     * @param longitude longitude used to update the album&#39;s location (optional)
     * @param locationDescription the location description (optional)
     * @param visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param cellPhone the cell phone number (optional)
     * @param streetAddress The street address of the location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the location (optional)
     * @param state The state of of the location (optional)
     * @param postalCode The postal code of the location (optional)
     * @param fullAddress The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param anonymous determines whether the album is posted anonymously (optional)
     * @param metaData External custom client defined data (optional)
     * @param categoryIds comma separated category ids string associated with the Album (optional)
     * @param categoryFilterIds comma separated filter ids string associated with the Album (optional)
     * @param audienceIds comma separated audience ids string associated with the album (optional)
     * @param audienceIdsToAdd comma separated audience ids to add to the album (optional)
     * @param audienceIdsToRemove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param includeAllAppUsersAsMembers determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param includeAudiencesAsMembers determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param audienceOperator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param linkedObjectType sets a linked object so that it can be returned as part of the album response (optional)
     * @param linkedObjectId sets a linked object id so that it can be returned as part of the album response (optional)
     * @param indexNow determines whether the album should be indexed immediately (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAlbumCollection",
        summary = "Update Album",
        description = "Update an Album.",
        tags = { "Album" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ALBUM_COLLECTION,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumResponse> updateAlbumCollection(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumId", description = "the ID of the album to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "assetsToAdd", description = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetsToAdd", required = false) @Nullable String assetsToAdd,
        @Parameter(name = "assetsToRemove", description = "Comma separated list of asset IDs to remove from the album's asset list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetsToRemove", required = false) @Nullable String assetsToRemove,
        @Parameter(name = "assetId", description = "the cover asset ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "media", description = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "media", required = false) @Nullable org.springframework.core.io.Resource media,
        @Parameter(name = "mediaURL", description = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaURL", required = false) @Nullable String mediaURL,
        @Parameter(name = "active", description = "determines whether the album is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "title", description = "the title of the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "startDate", description = "the start date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "the end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "tags", description = "the tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "description", description = "the description of the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "albumType", description = "a custom field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumType", required = false) @Nullable String albumType,
        @Parameter(name = "albumTypeId", description = "a custom indexed number used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypeId", required = false) @Nullable Long albumTypeId,
        @Parameter(name = "subType", description = "a custom string field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "publicRead", description = "determines whether the album's participants have read permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicRead", required = false) @Nullable Boolean publicRead,
        @Parameter(name = "publicWrite", description = "determines whether the album's participants have write permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicWrite", required = false) @Nullable Boolean publicWrite,
        @Parameter(name = "publicDelete", description = "determines whether the album's participants have delete permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicDelete", required = false) @Nullable Boolean publicDelete,
        @Parameter(name = "publicAdd", description = "determines whether the album's participants have add permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicAdd", required = false) @Nullable Boolean publicAdd,
        @Parameter(name = "latitude", description = "latitude used to update the album's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the album's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "locationDescription", description = "the location description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "visibility", description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "cellPhone", description = "the cell phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "streetAddress", description = "The street address of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "fullAddress", description = "The full address of the location which should include the street address, city, state, and postal code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullAddress", required = false) @Nullable String fullAddress,
        @Parameter(name = "anonymous", description = "determines whether the album is posted anonymously", in = ParameterIn.QUERY) @Valid @RequestParam(value = "anonymous", required = false) @Nullable Boolean anonymous,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "categoryIds", description = "comma separated category ids string associated with the Album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "categoryFilterIds", description = "comma separated filter ids string associated with the Album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryFilterIds", required = false) @Nullable String categoryFilterIds,
        @Parameter(name = "audienceIds", description = "comma separated audience ids string associated with the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "audienceIdsToAdd", description = "comma separated audience ids to add to the album", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove,
        @Parameter(name = "includeAllAppUsersAsMembers", description = "determines whether to include all app users as members (only admins of the app can do this)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAllAppUsersAsMembers", required = false) @Nullable Boolean includeAllAppUsersAsMembers,
        @Parameter(name = "includeAudiencesAsMembers", description = "determines whether to include all users of the audiences as members (only admins of the app can do this)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeAudiencesAsMembers", required = false) @Nullable Boolean includeAudiencesAsMembers,
        @Parameter(name = "audienceOperator", description = "determines whether to use ands or ors when using the audience list to add users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceOperator", required = false) @Nullable String audienceOperator,
        @Parameter(name = "linkedObjectType", description = "sets a linked object so that it can be returned as part of the album response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectType", required = false) @Nullable String linkedObjectType,
        @Parameter(name = "linkedObjectId", description = "sets a linked object id so that it can be returned as part of the album response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkedObjectId", required = false) @Nullable Long linkedObjectId,
        @Parameter(name = "indexNow", description = "determines whether the album should be indexed immediately", in = ParameterIn.QUERY) @Valid @RequestParam(value = "indexNow", required = false) @Nullable Boolean indexNow
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_APPLICATION = "/api/{version}/application/update";
    /**
     * POST /api/{version}/application/update : Update Application
     * Update an application record
     *
     * @param version  (required)
     * @param appKey The application key for updating an existing application (required)
     * @param appName The name of the application (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param about The description of the application (optional)
     * @param bundleId The application bundle identifier (format - com.company.appName) (optional)
     * @param appIconAssetId The application icon asset id (optional)
     * @param appLogoAssetId The application logo asset id (optional)
     * @param facebookAppId The Facebook application id (optional)
     * @param facebookAppSecret The Facebook application secret (optional)
     * @param googleApiKey This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging (optional)
     * @param updateEULADate Determines whether to update the EULA date (optional)
     * @param eulaVersion The EULA version (optional)
     * @param landingPageUrl The landing page URL (optional)
     * @param showInActivities Determines whether to show the application in the activity feed (optional)
     * @param activityDescription The description of the application in the activity feed (optional)
     * @param inviteWelcomeText The text to display on the invite page (optional)
     * @param invitePageUrl The url to the application invite page (optional)
     * @param urlScheme The protocal the app uses to load the app via a browser (optional)
     * @param platforms A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param downloadUrls Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;   (optional)
     * @param categoryIds List of categories to apply (optional)
     * @param scoringType The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT (optional, default to GAME_LEVEL)
     * @param hintCost The cost of hints (optional, default to 11)
     * @param maxScore The maximum score that will be possible (optional, default to 125)
     * @param ticketsPerPoint The point-to-ticket conversion ratio (optional, default to 0.037)
     * @param hasGameData Determines whether the application uses services to save custom game objects (optional, default to true)
     * @param publicNotifications Public Notifications (optional)
     * @param useMatchingAlgorithm Use Matching Algorithm (optional)
     * @param globalTickets Determines whether earned tickets are applied across all applications (optional, default to false)
     * @param buildVersion The current build version of the application (optional, default to 1)
     * @param apiVersion The current API version the application uses (optional)
     * @param placementName The name of the placement (optional)
     * @param placementDescription The description of the placement (optional)
     * @param placementSize The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created) (optional)
     * @param placementHeight The height of a custom ad size (optional)
     * @param placementWidth The width of a custom ad size (optional)
     * @param placementRefreshInterval The refresh interval in seconds (optional)
     * @param createObjectStore Generate a custom object store to use (optional, default to true)
     * @param publicContentApproval Determine whether or not public content requires admin approval before it becomes public (optional, default to false)
     * @param productionMode Determines whether the application uses production or sandbox services (optional, default to false)
     * @param minimumSessionLength Minimum Session Length (optional)
     * @param sessionGapLength Session Gap Length (optional)
     * @param localAdsEnabled Local Ads Enabled (optional, default to false)
     * @param sqootApiKey Sqoot Api Key (optional)
     * @param trilatProcessingType Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT (optional, default to FINGERPRINT)
     * @param maxSampleSize Determines what the maximum sample size during trilateration (optional)
     * @param minRSSI Determines what the minimum acceptable RSSI value (optional)
     * @param modules List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL (optional, default to ALL)
     * @param authorizedCount How many servers the license will support (optional, default to 1)
     * @param authorizedServers The list of ip addresses of servers the license will support, leave null for any server (optional)
     * @param defaultTimezone Sets the default timezone for the app (used for leaderboards and other time specific content) (optional)
     * @param smtpPass SMTP Pass (optional)
     * @param metaData The application meta data. Defined by the client (optional)
     * @param placementMetaData The ad placement meta data. Defined by the client (optional)
     * @param ipsFloor Create floor tables for Ips (optional, default to false)
     * @param enableAPNSBadge Enables setting the APNS badge value in the payload (optional, default to true)
     * @param includeInReport Enables using the application in session reports (optional, default to true)
     * @param defaultAppFilterId Sets the default filter to use (if none is passed in) for certain search APIs including Album Search. (optional)
     * @param enableWelcomeEmail Enables whether the default welcome email will be sent for new app users (optional)
     * @param appleAppId The Apple Application ID (optional)
     * @param appleTeamId The Apple Team ID (optional)
     * @param appleAuthKeyId The Apple Auth Key ID (optional)
     * @param appleAuthKey The Apple Auth Signin Key (p8) File (optional)
     * @param appleIssuerId The Apple Issuer ID (optional)
     * @param appStoreKeyId The Apple App Store Key ID (optional)
     * @param appStoreKey The Apple App Store Key (p8) File (optional)
     * @param googlePrivateKeyFile This is the private key file for your Google service account. (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @param emailSender Email Sender (optional)
     * @param smtpUser SMTP User (optional)
     * @param smtpHost SMTP Host (optional)
     * @param vatomBusinessId Vatom Business Id (optional)
     * @param vatomRestClientId Vatom REST Client Id (optional)
     * @param vatomRestSecretKey Vatom Secret Key (optional)
     * @param twilioAccountSID Twilio Account SID (optional)
     * @param twilioAuthToken Twilio Auth Token (optional)
     * @param twilioSenderPhoneNumber Twilio Sender Phone Number (optional)
     * @param openAISecretKey OpenAI Secret API Key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateApplication",
        summary = "Update Application",
        description = "Update an application record",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationResponse> updateApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "appName", description = "The name of the application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appName", required = true) String appName,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "about", description = "The description of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "about", required = false) @Nullable String about,
        @Parameter(name = "bundleId", description = "The application bundle identifier (format - com.company.appName)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bundleId", required = false) @Nullable String bundleId,
        @Parameter(name = "appIconAssetId", description = "The application icon asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appIconAssetId", required = false) @Nullable Long appIconAssetId,
        @Parameter(name = "appLogoAssetId", description = "The application logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appLogoAssetId", required = false) @Nullable Long appLogoAssetId,
        @Parameter(name = "facebookAppId", description = "The Facebook application id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookAppId", required = false) @Nullable String facebookAppId,
        @Parameter(name = "facebookAppSecret", description = "The Facebook application secret", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookAppSecret", required = false) @Nullable String facebookAppSecret,
        @Parameter(name = "googleApiKey", description = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googleApiKey", required = false) @Nullable String googleApiKey,
        @Parameter(name = "updateEULADate", description = "Determines whether to update the EULA date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateEULADate", required = false) @Nullable Boolean updateEULADate,
        @Parameter(name = "eulaVersion", description = "The EULA version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eulaVersion", required = false) @Nullable String eulaVersion,
        @Parameter(name = "landingPageUrl", description = "The landing page URL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "landingPageUrl", required = false) @Nullable String landingPageUrl,
        @Parameter(name = "showInActivities", description = "Determines whether to show the application in the activity feed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showInActivities", required = false) @Nullable Boolean showInActivities,
        @Parameter(name = "activityDescription", description = "The description of the application in the activity feed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activityDescription", required = false) @Nullable String activityDescription,
        @Parameter(name = "inviteWelcomeText", description = "The text to display on the invite page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inviteWelcomeText", required = false) @Nullable String inviteWelcomeText,
        @Parameter(name = "invitePageUrl", description = "The url to the application invite page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "invitePageUrl", required = false) @Nullable String invitePageUrl,
        @Parameter(name = "urlScheme", description = "The protocal the app uses to load the app via a browser", in = ParameterIn.QUERY) @Valid @RequestParam(value = "urlScheme", required = false) @Nullable String urlScheme,
        @Parameter(name = "platforms", description = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "platforms", required = false) @Nullable String platforms,
        @Parameter(name = "downloadUrls", description = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "downloadUrls", required = false) @Nullable String downloadUrls,
        @Parameter(name = "categoryIds", description = "List of categories to apply", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "scoringType", description = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scoringType", required = false, defaultValue = "GAME_LEVEL") String scoringType,
        @Parameter(name = "hintCost", description = "The cost of hints", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hintCost", required = false, defaultValue = "11") Integer hintCost,
        @Parameter(name = "maxScore", description = "The maximum score that will be possible", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxScore", required = false, defaultValue = "125") Integer maxScore,
        @Parameter(name = "ticketsPerPoint", description = "The point-to-ticket conversion ratio", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsPerPoint", required = false, defaultValue = "0.037") Float ticketsPerPoint,
        @Parameter(name = "hasGameData", description = "Determines whether the application uses services to save custom game objects", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hasGameData", required = false, defaultValue = "true") Boolean hasGameData,
        @Parameter(name = "publicNotifications", description = "Public Notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicNotifications", required = false) @Nullable Boolean publicNotifications,
        @Parameter(name = "useMatchingAlgorithm", description = "Use Matching Algorithm", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useMatchingAlgorithm", required = false) @Nullable Boolean useMatchingAlgorithm,
        @Parameter(name = "globalTickets", description = "Determines whether earned tickets are applied across all applications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalTickets", required = false, defaultValue = "false") Boolean globalTickets,
        @Parameter(name = "buildVersion", description = "The current build version of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "buildVersion", required = false, defaultValue = "1") Float buildVersion,
        @Parameter(name = "apiVersion", description = "The current API version the application uses", in = ParameterIn.QUERY) @Valid @RequestParam(value = "apiVersion", required = false) @Nullable Float apiVersion,
        @Parameter(name = "placementName", description = "The name of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementName", required = false) @Nullable String placementName,
        @Parameter(name = "placementDescription", description = "The description of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementDescription", required = false) @Nullable String placementDescription,
        @Parameter(name = "placementSize", description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementSize", required = false) @Nullable String placementSize,
        @Parameter(name = "placementHeight", description = "The height of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementHeight", required = false) @Nullable Integer placementHeight,
        @Parameter(name = "placementWidth", description = "The width of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementWidth", required = false) @Nullable Integer placementWidth,
        @Parameter(name = "placementRefreshInterval", description = "The refresh interval in seconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementRefreshInterval", required = false) @Nullable Integer placementRefreshInterval,
        @Parameter(name = "createObjectStore", description = "Generate a custom object store to use", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createObjectStore", required = false, defaultValue = "true") Boolean createObjectStore,
        @Parameter(name = "publicContentApproval", description = "Determine whether or not public content requires admin approval before it becomes public", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicContentApproval", required = false, defaultValue = "false") Boolean publicContentApproval,
        @Parameter(name = "productionMode", description = "Determines whether the application uses production or sandbox services", in = ParameterIn.QUERY) @Valid @RequestParam(value = "productionMode", required = false, defaultValue = "false") Boolean productionMode,
        @Parameter(name = "minimumSessionLength", description = "Minimum Session Length", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumSessionLength", required = false) @Nullable Integer minimumSessionLength,
        @Parameter(name = "sessionGapLength", description = "Session Gap Length", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sessionGapLength", required = false) @Nullable Integer sessionGapLength,
        @Parameter(name = "localAdsEnabled", description = "Local Ads Enabled", in = ParameterIn.QUERY) @Valid @RequestParam(value = "localAdsEnabled", required = false, defaultValue = "false") Boolean localAdsEnabled,
        @Parameter(name = "sqootApiKey", description = "Sqoot Api Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sqootApiKey", required = false) @Nullable String sqootApiKey,
        @Parameter(name = "trilatProcessingType", description = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilatProcessingType", required = false, defaultValue = "FINGERPRINT") String trilatProcessingType,
        @Parameter(name = "maxSampleSize", description = "Determines what the maximum sample size during trilateration", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxSampleSize", required = false) @Nullable Integer maxSampleSize,
        @Parameter(name = "minRSSI", description = "Determines what the minimum acceptable RSSI value", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minRSSI", required = false) @Nullable Double minRSSI,
        @Parameter(name = "modules", description = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "modules", required = false, defaultValue = "ALL") String modules,
        @Parameter(name = "authorizedCount", description = "How many servers the license will support", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizedCount", required = false, defaultValue = "1") Integer authorizedCount,
        @Parameter(name = "authorizedServers", description = "The list of ip addresses of servers the license will support, leave null for any server", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizedServers", required = false) @Nullable String authorizedServers,
        @Parameter(name = "defaultTimezone", description = "Sets the default timezone for the app (used for leaderboards and other time specific content)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultTimezone", required = false) @Nullable String defaultTimezone,
        @Parameter(name = "smtpPass", description = "SMTP Pass", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpPass", required = false) @Nullable String smtpPass,
        @Parameter(name = "metaData", description = "The application meta data. Defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "placementMetaData", description = "The ad placement meta data. Defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementMetaData", required = false) @Nullable String placementMetaData,
        @Parameter(name = "ipsFloor", description = "Create floor tables for Ips", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ipsFloor", required = false, defaultValue = "false") Boolean ipsFloor,
        @Parameter(name = "enableAPNSBadge", description = "Enables setting the APNS badge value in the payload", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableAPNSBadge", required = false, defaultValue = "true") Boolean enableAPNSBadge,
        @Parameter(name = "includeInReport", description = "Enables using the application in session reports", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInReport", required = false, defaultValue = "true") Boolean includeInReport,
        @Parameter(name = "defaultAppFilterId", description = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultAppFilterId", required = false) @Nullable Long defaultAppFilterId,
        @Parameter(name = "enableWelcomeEmail", description = "Enables whether the default welcome email will be sent for new app users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableWelcomeEmail", required = false) @Nullable Boolean enableWelcomeEmail,
        @Parameter(name = "appleAppId", description = "The Apple Application ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAppId", required = false) @Nullable String appleAppId,
        @Parameter(name = "appleTeamId", description = "The Apple Team ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleTeamId", required = false) @Nullable String appleTeamId,
        @Parameter(name = "appleAuthKeyId", description = "The Apple Auth Key ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAuthKeyId", required = false) @Nullable String appleAuthKeyId,
        @Parameter(name = "appleAuthKey", description = "The Apple Auth Signin Key (p8) File", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleAuthKey", required = false) @Nullable org.springframework.core.io.Resource appleAuthKey,
        @Parameter(name = "appleIssuerId", description = "The Apple Issuer ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appleIssuerId", required = false) @Nullable String appleIssuerId,
        @Parameter(name = "appStoreKeyId", description = "The Apple App Store Key ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appStoreKeyId", required = false) @Nullable String appStoreKeyId,
        @Parameter(name = "appStoreKey", description = "The Apple App Store Key (p8) File", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appStoreKey", required = false) @Nullable org.springframework.core.io.Resource appStoreKey,
        @Parameter(name = "googlePrivateKeyFile", description = "This is the private key file for your Google service account.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googlePrivateKeyFile", required = false) @Nullable org.springframework.core.io.Resource googlePrivateKeyFile,
        @Parameter(name = "authorizeNetApiKey", description = "Authorize Net Api Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetApiKey", required = false) @Nullable String authorizeNetApiKey,
        @Parameter(name = "authorizeNetTransactionKey", description = "Authorize Net Transaction Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) @Nullable String authorizeNetTransactionKey,
        @Parameter(name = "emailSender", description = "Email Sender", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailSender", required = false) @Nullable String emailSender,
        @Parameter(name = "smtpUser", description = "SMTP User", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpUser", required = false) @Nullable String smtpUser,
        @Parameter(name = "smtpHost", description = "SMTP Host", in = ParameterIn.QUERY) @Valid @RequestParam(value = "smtpHost", required = false) @Nullable String smtpHost,
        @Parameter(name = "vatomBusinessId", description = "Vatom Business Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomBusinessId", required = false) @Nullable String vatomBusinessId,
        @Parameter(name = "vatomRestClientId", description = "Vatom REST Client Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomRestClientId", required = false) @Nullable String vatomRestClientId,
        @Parameter(name = "vatomRestSecretKey", description = "Vatom Secret Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomRestSecretKey", required = false) @Nullable String vatomRestSecretKey,
        @Parameter(name = "twilioAccountSID", description = "Twilio Account SID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioAccountSID", required = false) @Nullable String twilioAccountSID,
        @Parameter(name = "twilioAuthToken", description = "Twilio Auth Token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioAuthToken", required = false) @Nullable String twilioAuthToken,
        @Parameter(name = "twilioSenderPhoneNumber", description = "Twilio Sender Phone Number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twilioSenderPhoneNumber", required = false) @Nullable String twilioSenderPhoneNumber,
        @Parameter(name = "openAISecretKey", description = "OpenAI Secret API Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "openAISecretKey", required = false) @Nullable String openAISecretKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_APPLICATION_ACTIVE = "/api/{version}/application/active";
    /**
     * POST /api/{version}/application/active : Change Appliation Status
     * Set the application&#39;s active flag to true/false. This effectively activates or deactivates the application.
     *
     * @param version  (required)
     * @param accountId The account used to perform the delete, must have rights to edit the application. (required)
     * @param appKey The key of the application to be deleted (required)
     * @param active If true then set to active, false otherwise (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateApplicationActive",
        summary = "Change Appliation Status",
        description = "Set the application's active flag to true/false. This effectively activates or deactivates the application.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_APPLICATION_ACTIVE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateApplicationActive(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the application.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The key of the application to be deleted", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "active", description = "If true then set to active, false otherwise", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_APPLICATION_CONFIG = "/api/{version}/appconfig/update";
    /**
     * POST /api/{version}/appconfig/update : Update AppConfig
     * pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won&#39;t be updated.
     *
     * @param version  (required)
     * @param accountId The account ID of the user (required)
     * @param configId The config ID of the application configuration to update (required)
     * @param appKey The application key that the updated applicationConfig will be associated to (optional)
     * @param configVersion The application configuration, has to be unique within the application (optional)
     * @param assetId The json assetId that stores the configuration detail. (optional)
     * @param retailerId The retailer id for retailer specific configurations (optional)
     * @param retailerLocationId The retailer location id for retailer location specific configurations (optional)
     * @param udid The device udid for device specific configurations (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateApplicationConfig",
        summary = "Update AppConfig",
        description = "pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.",
        tags = { "Application Config" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationConfigResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_APPLICATION_CONFIG,
        produces = { "*/*" }
    )
    default ResponseEntity<ApplicationConfigResponse> updateApplicationConfig(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "configId", description = "The config ID of the application configuration to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "configId", required = true) Long configId,
        @Parameter(name = "appKey", description = "The application key that the updated applicationConfig will be associated to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "configVersion", description = "The application configuration, has to be unique within the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "configVersion", required = false) @Nullable String configVersion,
        @Parameter(name = "assetId", description = "The json assetId that stores the configuration detail.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "retailerId", description = "The retailer id for retailer specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = false) @Nullable Long retailerId,
        @Parameter(name = "retailerLocationId", description = "The retailer location id for retailer location specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "udid", description = "The device udid for device specific configurations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_APPLICATION_PLACEMENT = "/api/{version}/application/placement/update";
    /**
     * POST /api/{version}/application/placement/update : Update Ad Placement
     * Updates an ad placement for an application.
     *
     * @param version  (required)
     * @param placementId The id of the placement to update, the user must have rights to the application the ad placement is for (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the placement (optional)
     * @param description The description of the placement (optional)
     * @param size The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (optional)
     * @param height The height of a custom ad size (optional)
     * @param width The width of a custom ad size (optional)
     * @param refreshInterval The refresh interval in seconds (optional)
     * @param defaultImageId Default Image Id (optional)
     * @param active Active (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateApplicationPlacement",
        summary = "Update Ad Placement",
        description = "Updates an ad placement for an application.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PlacementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_APPLICATION_PLACEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<PlacementResponse> updateApplicationPlacement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "placementId", description = "The id of the placement to update, the user must have rights to the application the ad placement is for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "placementId", required = true) Long placementId,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the placement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "size", description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "size", required = false) @Nullable String size,
        @Parameter(name = "height", description = "The height of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable Integer height,
        @Parameter(name = "width", description = "The width of a custom ad size", in = ParameterIn.QUERY) @Valid @RequestParam(value = "width", required = false) @Nullable Integer width,
        @Parameter(name = "refreshInterval", description = "The refresh interval in seconds", in = ParameterIn.QUERY) @Valid @RequestParam(value = "refreshInterval", required = false) @Nullable Integer refreshInterval,
        @Parameter(name = "defaultImageId", description = "Default Image Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "defaultImageId", required = false) @Nullable Long defaultImageId,
        @Parameter(name = "active", description = "Active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ASSET = "/api/{version}/asset/update";
    /**
     * POST /api/{version}/asset/update : Update Asset
     * Updates an asset&#39;s meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.
     *
     * @param version  (required)
     * @param assetId the ID of the asset to update (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the ID of the album to check user permissions (optional)
     * @param attachedAssetId the ID of the attached asset (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional)
     * @param searchTags search tags (optional)
     * @param appKey the application key (optional)
     * @param latitude latitude used to update the asset&#39;s location (optional)
     * @param longitude longitude used to update the asset&#39;s location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAsset",
        summary = "Update Asset",
        description = "Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.",
        tags = { "Asset" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ASSET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateAsset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "assetId", description = "the ID of the asset to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = true) Long assetId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumId", description = "the ID of the album to check user permissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = false) @Nullable Long albumId,
        @Parameter(name = "attachedAssetId", description = "the ID of the attached asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedAssetId", required = false) @Nullable Long attachedAssetId,
        @Parameter(name = "versionCode", description = "the version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "versionName", description = "the version name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionName", required = false) @Nullable String versionName,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "caption", description = "the caption", in = ParameterIn.QUERY) @Valid @RequestParam(value = "caption", required = false) @Nullable String caption,
        @Parameter(name = "assetType", description = "the asset type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetType", required = false) @Nullable String assetType,
        @Parameter(name = "approvalStatus", description = "approval status for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "approvalStatus", required = false) @Nullable String approvalStatus,
        @Parameter(name = "assignedAccountId", description = "account id assigned to the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignedAccountId", required = false) @Nullable Long assignedAccountId,
        @Parameter(name = "media", description = "a MultipartFile containing the mimetype, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "media", required = false) @Nullable org.springframework.core.io.Resource media,
        @Parameter(name = "mediaUrl", description = "this can be used if the \"media\" is a link (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaUrl", required = false) @Nullable String mediaUrl,
        @Parameter(name = "mediaString", description = "the media content as a string (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaString", required = false) @Nullable String mediaString,
        @Parameter(name = "mediaStringFileName", description = "file name for mediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaStringFileName", required = false) @Nullable String mediaStringFileName,
        @Parameter(name = "mediaStringContentType", description = "content type for mediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaStringContentType", required = false) @Nullable String mediaStringContentType,
        @Parameter(name = "mediaHeight", description = "the media height (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaHeight", required = false) @Nullable Integer mediaHeight,
        @Parameter(name = "mediaWidth", description = "the media width (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaWidth", required = false) @Nullable Integer mediaWidth,
        @Parameter(name = "attachedMedia", description = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMedia", required = false) @Nullable org.springframework.core.io.Resource attachedMedia,
        @Parameter(name = "attachedMediaUrl", description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaUrl", required = false) @Nullable String attachedMediaUrl,
        @Parameter(name = "attachedMediaString", description = "attached media content as a string (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaString", required = false) @Nullable String attachedMediaString,
        @Parameter(name = "attachedMediaStringFileName", description = "file name for attachedMediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaStringFileName", required = false) @Nullable String attachedMediaStringFileName,
        @Parameter(name = "attachedMediaStringContentType", description = "content type for attachedMediaString (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaStringContentType", required = false) @Nullable String attachedMediaStringContentType,
        @Parameter(name = "attachedMediaHeight", description = "the attached media height (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaHeight", required = false) @Nullable Integer attachedMediaHeight,
        @Parameter(name = "attachedMediaWidth", description = "the attached media width (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "attachedMediaWidth", required = false) @Nullable Integer attachedMediaWidth,
        @Parameter(name = "locationDescription", description = "the location description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "searchTags", description = "search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "latitude used to update the asset's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the asset's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_AUDIENCE = "/api/{version}/audience/update";
    /**
     * POST /api/{version}/audience/update : Update Audience
     * Update a user defined audience.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to update. (required)
     * @param name The name of the audience (optional)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param active if audience is active (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param associateDescription the associate description (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAudience",
        summary = "Update Audience",
        description = "Update a user defined audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> updateAudience(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId,
        @Parameter(name = "name", description = "The name of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "gender", description = "The gender; possible values are: MALE, FEMALE, ANY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroups", description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroups", required = false) @Nullable String ageGroups,
        @Parameter(name = "categoryIds", description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "applicationIds", description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "gameExperienceLevel", description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "devices", description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius,
        @Parameter(name = "active", description = "if audience is active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "sendSuggestion", description = "If true, then notify matching users when they are inside the radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false) @Nullable Boolean sendSuggestion,
        @Parameter(name = "startTimeOffset", description = "Seconds from the start time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startTimeOffset", required = false) @Nullable Integer startTimeOffset,
        @Parameter(name = "endTimeOffset", description = "Seconds from the end time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endTimeOffset", required = false) @Nullable Integer endTimeOffset,
        @Parameter(name = "associateDescription", description = "the associate description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateDescription", required = false) @Nullable String associateDescription,
        @Parameter(name = "associateType", description = "The type of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateType", required = false) @Nullable String associateType,
        @Parameter(name = "associateId", description = "The ID of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateId", required = false) @Nullable Long associateId,
        @Parameter(name = "groupingId", description = "Optional grouping id for the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "visibility", description = "Visibility of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "audienceType", description = "Type of audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "useOrder", description = "Use order for cohort", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useOrder", required = false) @Nullable Boolean useOrder,
        @Parameter(name = "cohortRegionsData", description = "Cohort data for \"cohort\" audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cohortRegionsData", required = false) @Nullable String cohortRegionsData,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "trilaterationTypes", description = "Trilateration types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilaterationTypes", required = false) @Nullable String trilaterationTypes,
        @Parameter(name = "uniqueName", description = "If true, makes sure the audience name is unique", in = ParameterIn.QUERY) @Valid @RequestParam(value = "uniqueName", required = false) @Nullable Boolean uniqueName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_BID = "/api/{version}/bid/update";
    /**
     * POST /api/{version}/bid/update : Update Bid
     * Updates a bid on a biddable object
     *
     * @param version  (required)
     * @param bidId The bid id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param amountPerView The bid amount for views. For ads, this is the amount that will be taken for each impression. (optional)
     * @param amountPerAction The bid amount for actions. For ads, this is the amount that will be taken for each click. (optional)
     * @param budgetAmount The allocated budget amount that will be used (optional)
     * @param budgetSchedule The schedule for when the allocated budget amount is reset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateBid",
        summary = "Update Bid",
        description = "Updates a bid on a biddable object",
        tags = { "Bid" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BidResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_BID,
        produces = { "*/*" }
    )
    default ResponseEntity<BidResponse> updateBid(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "bidId", description = "The bid id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "bidId", required = true) Long bidId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "amountPerView", description = "The bid amount for views. For ads, this is the amount that will be taken for each impression.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "amountPerView", required = false) @Nullable Double amountPerView,
        @Parameter(name = "amountPerAction", description = "The bid amount for actions. For ads, this is the amount that will be taken for each click.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "amountPerAction", required = false) @Nullable Double amountPerAction,
        @Parameter(name = "budgetAmount", description = "The allocated budget amount that will be used", in = ParameterIn.QUERY) @Valid @RequestParam(value = "budgetAmount", required = false) @Nullable Double budgetAmount,
        @Parameter(name = "budgetSchedule", description = "The schedule for when the allocated budget amount is reset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "budgetSchedule", required = false) @Nullable String budgetSchedule
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_BILLABLE_ENTITY = "/api/{version}/billable/update";
    /**
     * POST /api/{version}/billable/update : Update Billable
     * Updates the billable record for an account
     *
     * @param version  (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity. (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension of the billable entity (optional)
     * @param authorizeNetApiKey Authorize Net Api Key of the billable entity (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key of the billable entity (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateBillableEntity",
        summary = "Update Billable",
        description = "Updates the billable record for an account",
        tags = { "Billable Entity" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BillableEntityResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_BILLABLE_ENTITY,
        produces = { "*/*" }
    )
    default ResponseEntity<BillableEntityResponse> updateBillableEntity(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the entity responsible for billing ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "streetAddress", description = "The street address of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box) ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "businessPhone", description = "The business phone of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "authorizeNetApiKey", description = "Authorize Net Api Key of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetApiKey", required = false) @Nullable String authorizeNetApiKey,
        @Parameter(name = "authorizeNetTransactionKey", description = "Authorize Net Transaction Key of the billable entity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) @Nullable String authorizeNetTransactionKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_BUSINESS_COINS = "/api/{version}/vatom/b/coins/update";
    /**
     * POST /api/{version}/vatom/b/coins/update : Fund coins for a Business
     * Fund/update coins for a Businesss.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateBusinessCoins",
        summary = "Fund coins for a Business",
        description = "Fund/update coins for a Businesss.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_BUSINESS_COINS
    )
    default ResponseEntity<Void> updateBusinessCoins(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_CARGO_TYPE = "/api/{version}/cargo/type/{cargoTypeId}";
    /**
     * PUT /api/{version}/cargo/type/{cargoTypeId} : Update Cargo Type
     * Update an existing cargo type
     *
     * @param version  (required)
     * @param cargoTypeId the ID of the cargo type (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateCargoType",
        summary = "Update Cargo Type",
        description = "Update an existing cargo type",
        tags = { "Cargo Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CargoType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_CARGO_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<CargoType> updateCargoType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "cargoTypeId", description = "the ID of the cargo type", required = true, in = ParameterIn.PATH) @PathVariable("cargoTypeId") Long cargoTypeId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable CargoType body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_CATEGORY = "/api/{version}/category/update";
    /**
     * POST /api/{version}/category/update : Update Category
     * Update a category.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param categoryId The ID of the category to edit (required)
     * @param parentCategoryId The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param name The name of the category (optional)
     * @param description The description of the category (optional)
     * @param type The type of the category (optional)
     * @param assetId The ID of the image asset previously uploaded using the media service (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param externalCategorySlug external category slug (optional)
     * @param sqootSlug sqoot slug (optional)
     * @param active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @param searchTags user defined strings for searching (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateCategory",
        summary = "Update Category",
        description = "Update a category.",
        tags = { "Category" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CategoryTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_CATEGORY,
        produces = { "*/*" }
    )
    default ResponseEntity<CategoryTreeResponse> updateCategory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "categoryId", description = "The ID of the category to edit", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = true) Long categoryId,
        @Parameter(name = "parentCategoryId", description = "The ID of the parent category, if not provided then the parent category will be null", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentCategoryId", required = false) @Nullable Long parentCategoryId,
        @Parameter(name = "name", description = "The name of the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "type", description = "The type of the category", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "assetId", description = "The ID of the image asset previously uploaded using the media service", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "externalId", description = "A string identifier used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalType", description = "A string type used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "externalCategorySlug", description = "external category slug", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalCategorySlug", required = false) @Nullable String externalCategorySlug,
        @Parameter(name = "sqootSlug", description = "sqoot slug", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sqootSlug", required = false) @Nullable String sqootSlug,
        @Parameter(name = "active", description = "Sets whether the category is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "searchTags", description = "user defined strings for searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_CREATIVE = "/api/{version}/creative/update";
    /**
     * POST /api/{version}/creative/update : Update Creative
     * Update a creative
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param creativeId the creative Id to upate. (required)
     * @param name The name of the level. (optional)
     * @param description The description of the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param action This parameter is deprecated. deprecated use data field (optional)
     * @param data The creative data, json based format depending on type (optional)
     * @param suffix This parameter is deprecated. deprecated use type field (optional)
     * @param type The type of creative. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. Default is false. (optional)
     * @param referenceId if creative related so some other content provided the id (optional)
     * @param appVersion The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives. (optional)
     * @param missionId Assign the creative to a campaign for timing and audience matching. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateCreative",
        summary = "Update Creative",
        description = "Update a creative",
        tags = { "Creative" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CreativeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_CREATIVE,
        produces = { "*/*" }
    )
    default ResponseEntity<CreativeResponse> updateCreative(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "creativeId", description = "the creative Id to upate.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeId", required = true) Long creativeId,
        @Parameter(name = "name", description = "The name of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "assetImageId", description = "The asset Id of the level image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetImageId", required = false) @Nullable Long assetImageId,
        @Parameter(name = "action", description = "This parameter is deprecated. deprecated use data field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "action", required = false) @Nullable String action,
        @Parameter(name = "data", description = "The creative data, json based format depending on type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = false) @Nullable String data,
        @Parameter(name = "suffix", description = "This parameter is deprecated. deprecated use type field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffix", required = false) @Nullable String suffix,
        @Parameter(name = "type", description = "The type of creative.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "balance", description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "active", description = "If true set the game level as active. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "referenceId", description = "if creative related so some other content provided the id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "referenceId", required = false) @Nullable Long referenceId,
        @Parameter(name = "appVersion", description = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "missionId", description = "Assign the creative to a campaign for timing and audience matching.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_CREDENTIAL = "/api/{version}/thirdparty/credential/update";
    /**
     * POST /api/{version}/thirdparty/credential/update : Update Credential
     * Updates a third-party login for an account.
     *
     * @param version  (required)
     * @param networkUID the access provider to authenticate against (required)
     * @param thirdPartyId the third party user account id (required)
     * @param appKey the application key (required)
     * @param deviceId the unique id of the device making the request (optional)
     * @param thirdPartyName the third party user name (optional)
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token) (optional)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateCredential",
        summary = "Update Credential",
        description = "Updates a third-party login for an account.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ProfileResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_CREDENTIAL,
        produces = { "*/*" }
    )
    default ResponseEntity<ProfileResponse> updateCredential(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "networkUID", description = "the access provider to authenticate against", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @NotNull @Parameter(name = "thirdPartyId", description = "the third party user account id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyId", required = true) String thirdPartyId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "thirdPartyName", description = "the third party user name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyName", required = false) @Nullable String thirdPartyName,
        @Parameter(name = "thirdPartyToken", description = "the access token to authenticate with (ex: username or fb token)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyToken", required = false) @Nullable String thirdPartyToken,
        @Parameter(name = "responseFilters", description = "this determines how much of the profile should be returned, see ProfileFilters", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFilters", required = false) @Nullable String responseFilters,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "thirdPartyRefreshToken", description = "optional refresh token for the third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "thirdPartyRefreshToken", required = false) @Nullable String thirdPartyRefreshToken
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_DATA = "/api/{version}/object/data/{objectName}/{objectId}";
    /**
     * PUT /api/{version}/object/data/{objectName}/{objectId} : Update Data
     * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
     *
     * @param version  (required)
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateData",
        summary = "Update Data",
        description = "Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> updateData(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_DISBURSEMENT = "/api/{version}/disbursement/update";
    /**
     * POST /api/{version}/disbursement/update : Update Disbursement
     * Update Disbursement
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param disbursementId the id of the disbursement being updated (required)
     * @param amount the disbursement dollar amount being updated (optional)
     * @param provider the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.) (optional)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title the title given to the disbursement (optional)
     * @param comment a comment that can be made on a disbursement (optional)
     * @param externalId an external ID that can be used to reference the disbursement (optional)
     * @param retry determines whether to try sending the disbursement again in the case of a previous failure (optional)
     * @param introspectionParams for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateDisbursement",
        summary = "Update Disbursement",
        description = "Update Disbursement",
        tags = { "Disbursement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DisbursementResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_DISBURSEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<DisbursementResponse> updateDisbursement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "disbursementId", description = "the id of the disbursement being updated", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "disbursementId", required = true) Long disbursementId,
        @Parameter(name = "amount", description = "the disbursement dollar amount being updated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "amount", required = false) @Nullable BigDecimal amount,
        @Parameter(name = "provider", description = "the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "provider", required = false) @Nullable String provider,
        @Parameter(name = "scheduledDate", description = "the date that the disbursement is scheduled to go out to the payment provider", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "title", description = "the title given to the disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "comment", description = "a comment that can be made on a disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "comment", required = false) @Nullable String comment,
        @Parameter(name = "externalId", description = "an external ID that can be used to reference the disbursement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "retry", description = "determines whether to try sending the disbursement again in the case of a previous failure", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retry", required = false) @Nullable Boolean retry,
        @Parameter(name = "introspectionParams", description = "for specifying parameters to make an http callback request for validating that the disbursement is valid", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionParams", required = false) @Nullable String introspectionParams
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_EMPLOYEE = "/api/{version}/employee/update";
    /**
     * POST /api/{version}/employee/update : Update Employee
     * Update the account record with the provided information.
     *
     * @param version  (required)
     * @param accountId The account id of the logged in user (required)
     * @param employeeAccountId the id of the employee account (required)
     * @param managerAccountId The account id of the manager to assign under (optional)
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender {MALE, FEMALE, ANY} (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR} (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param active Sets whether the employee is active or inactive (optional)
     * @param password Sets the password for the employee (optional)
     * @param retailerLocationIds Sets which retailer locations the employee is assigned to (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateEmployee",
        summary = "Update Employee",
        description = "Update the account record with the provided information.",
        tags = { "Employee" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = EmployeeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_EMPLOYEE,
        produces = { "*/*" }
    )
    default ResponseEntity<EmployeeResponse> updateEmployee(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "employeeAccountId", description = "the id of the employee account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "employeeAccountId", required = true) Long employeeAccountId,
        @Parameter(name = "managerAccountId", description = "The account id of the manager to assign under", in = ParameterIn.QUERY) @Valid @RequestParam(value = "managerAccountId", required = false) @Nullable Long managerAccountId,
        @Parameter(name = "name", description = "a name field", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "prefixName", description = "The name prefix; Mr, Mrs, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "prefixName", required = false) @Nullable String prefixName,
        @Parameter(name = "firstName", description = "The first name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "firstName", required = false) @Nullable String firstName,
        @Parameter(name = "middleName", description = "The middle name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "middleName", required = false) @Nullable String middleName,
        @Parameter(name = "lastName", description = "The last name", in = ParameterIn.QUERY) @Valid @RequestParam(value = "lastName", required = false) @Nullable String lastName,
        @Parameter(name = "suffixName", description = "The name suffix; Jr, Sr, III, etc", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suffixName", required = false) @Nullable String suffixName,
        @Parameter(name = "title", description = "The title of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "assetId", description = "the asset id to set the user's profile image", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "gender", description = "The gender {MALE, FEMALE, ANY}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "homePhone", description = "The home phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "homePhone", required = false) @Nullable String homePhone,
        @Parameter(name = "cellPhone", description = "The cellular phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhone", required = false) @Nullable String cellPhone,
        @Parameter(name = "cellPhoneCarrier", description = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cellPhoneCarrier", required = false) @Nullable String cellPhoneCarrier,
        @Parameter(name = "businessPhone", description = "The business phone number", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "emailAddress", description = "The user's contact email address (NOT the username)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "emailAddress", required = false) @Nullable String emailAddress,
        @Parameter(name = "streetAddress", description = "The street address of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "zipcode", description = "The zipcode of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zipcode", required = false) @Nullable String zipcode,
        @Parameter(name = "country", description = "The country of the user's contact location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "role", description = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "active", description = "Sets whether the employee is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "password", description = "Sets the password for the employee", in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = false) @Nullable String password,
        @Parameter(name = "retailerLocationIds", description = "Sets which retailer locations the employee is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "settingsAppKey", description = "Determines whether to return the application settings for the employee for a particular application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "settingsAppKey", required = false) @Nullable String settingsAppKey,
        @Parameter(name = "appBlob", description = "external custom client defined data (per Application)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appBlob", required = false) @Nullable String appBlob,
        @Parameter(name = "assignedDeviceId", description = "The device id to assign to the user (used for IPS beacon tracking)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assignedDeviceId", required = false) @Nullable String assignedDeviceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_EVENT = "/api/{version}/event/update";
    /**
     * POST /api/{version}/event/update : Update Event
     * Update a private event to share with associates.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param eventId The id of the event to update (required)
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param title The event title (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateEvent",
        summary = "Update Event",
        description = "Update a private event to share with associates.",
        tags = { "Event" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_EVENT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferResponse> updateEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "eventId", description = "The id of the event to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventId", required = true) Long eventId,
        @Parameter(name = "retailerLocationIds", description = "The retailer location to have the event at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "title", description = "The event title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "subTitle", description = "The event sub title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The event details", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "categoryIds", description = "The categories the associate the event with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "The filters the associate the event with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "active", description = "Is this event active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "imageAssetId", description = "The image to show for the event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "redeemableStart", description = "The event start date/time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The event end date/time", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_EVENT_GUEST_LIST = "/api/{version}/vatom/b/events/guests/update";
    /**
     * POST /api/{version}/vatom/b/events/guests/update : Update Vatom Event Guest List
     * Update the guest list of an event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomEventId Vatom Event Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateEventGuestList",
        summary = "Update Vatom Event Guest List",
        description = "Update the guest list of an event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_EVENT_GUEST_LIST
    )
    default ResponseEntity<Void> updateEventGuestList(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomEventId", description = "Vatom Event Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomEventId", required = true) String vatomEventId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_FILTER = "/api/{version}/filter/update";
    /**
     * POST /api/{version}/filter/update : Update Filter
     * Update a filter.
     *
     * @param version  (required)
     * @param accountId The account id of the user (required)
     * @param filterId The ID of the filter to edit (required)
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param name The name of the filter (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateFilter",
        summary = "Update Filter",
        description = "Update a filter.",
        tags = { "Filter" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = FilterTreeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_FILTER,
        produces = { "*/*" }
    )
    default ResponseEntity<FilterTreeResponse> updateFilter(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "filterId", description = "The ID of the filter to edit", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterId", required = true) Long filterId,
        @Parameter(name = "parentFilterId", description = "The ID of the parent filter, if not provided then the parent filter will be null", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentFilterId", required = false) @Nullable Long parentFilterId,
        @Parameter(name = "name", description = "The name of the filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the filter", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "externalId", description = "A string identifier used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalType", description = "A string type used by client applications to store external information", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalType", required = false) @Nullable String externalType,
        @Parameter(name = "active", description = "Sets whether the filter is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_FLAG_THRESHOLD = "/api/{version}/flag/threshold/update";
    /**
     * POST /api/{version}/flag/threshold/update : Update Flag Threshold
     * Update the flag threshold on an object type for a particular application.
     *
     * @param version  (required)
     * @param itemBeingFlaggedType The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE} (required)
     * @param threshold The threshold value (required)
     * @param appKey The application key (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateFlagThreshold",
        summary = "Update Flag Threshold",
        description = "Update the flag threshold on an object type for a particular application.",
        tags = { "Flag" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CountResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_FLAG_THRESHOLD,
        produces = { "*/*" }
    )
    default ResponseEntity<CountResponse> updateFlagThreshold(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "itemBeingFlaggedType", description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "itemBeingFlaggedType", required = true) String itemBeingFlaggedType,
        @NotNull @Parameter(name = "threshold", description = "The threshold value", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "threshold", required = true) Long threshold,
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_GAME = "/api/{version}/game/update";
    /**
     * POST /api/{version}/game/update : Update a Game
     * Update a Game
     *
     * @param version  (required)
     * @param accountId The logged in user. (optional)
     * @param gameId the updating game&#39;s id (optional)
     * @param appKey The game application key to save the level for. (optional)
     * @param title Title of the Game. (optional)
     * @param description Description of the Game. (optional)
     * @param metaData metaData of the Game. (optional)
     * @param packIds comma separated String of pack Ids that will associate with the game. (optional)
     * @param includeGameData show more details in response. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateGame",
        summary = "Update a Game",
        description = "Update a Game",
        tags = { "Game" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_GAME,
        produces = { "*/*" }
    )
    default ResponseEntity<GameResponse> updateGame(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "gameId", description = "the updating game's id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameId", required = false) @Nullable Long gameId,
        @Parameter(name = "appKey", description = "The game application key to save the level for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "title", description = "Title of the Game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "Description of the Game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "metaData of the Game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "packIds", description = "comma separated String of pack Ids that will associate with the game.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packIds", required = false) @Nullable String packIds,
        @Parameter(name = "includeGameData", description = "show more details in response.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_GAME_LEVEL = "/api/{version}/level/update";
    /**
     * POST /api/{version}/level/update : Update Game Level
     * Update a game level. Currently does NOT support game objects.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param levelId If update then include the level Id. (required)
     * @param appKey The game application key to save the level for. (optional)
     * @param name The name of the level. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the applicatuion required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param gameData The game level data: xml, json, or other texted based format. (optional)
     * @param gameDataSuffix The game level data format type. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutorial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId  (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateGameLevel",
        summary = "Update Game Level",
        description = "Update a game level. Currently does NOT support game objects.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GameLevelResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_GAME_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<GameLevelResponse> updateGameLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "levelId", description = "If update then include the level Id.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @Parameter(name = "appKey", description = "The game application key to save the level for.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "name", description = "The name of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "difficulty", description = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "difficulty", required = false) @Nullable String difficulty,
        @Parameter(name = "appVersion", description = "The version number of the applicatuion required to correctly load/play the level.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "assetImageId", description = "The asset Id of the level image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetImageId", required = false) @Nullable Long assetImageId,
        @Parameter(name = "assetIconId", description = "The asset Id of the level icon.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetIconId", required = false) @Nullable Long assetIconId,
        @Parameter(name = "gameData", description = "The game level data: xml, json, or other texted based format.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameData", required = false) @Nullable String gameData,
        @Parameter(name = "gameDataSuffix", description = "The game level data format type.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameDataSuffix", required = false) @Nullable String gameDataSuffix,
        @Parameter(name = "visibility", description = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "friendGroup", description = "Make the level be readable by all friends.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendGroup", required = false) @Nullable Boolean friendGroup,
        @Parameter(name = "connectionIds", description = "Make the level be readable by connections in this list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionIds", required = false) @Nullable String connectionIds,
        @Parameter(name = "connectionGroupIds", description = "Make the level be readable by connection groups in this list.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "balance", description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "active", description = "If true set the game level as active.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketCount", description = "The number of tickets to reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = false) @Nullable Long ticketCount,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a level", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "tutorialTitle", description = "Title of the tutorial.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialTitle", required = false) @Nullable String tutorialTitle,
        @Parameter(name = "tutorialMessage", description = "Message of the tutorial.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialMessage", required = false) @Nullable String tutorialMessage,
        @Parameter(name = "tutorialAlignment", description = "Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialAlignment", required = false) @Nullable String tutorialAlignment,
        @Parameter(name = "tutorialImageAssetId", description = "Asset id of the tutorial image.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tutorialImageAssetId", required = false) @Nullable Long tutorialImageAssetId,
        @Parameter(name = "offerId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_LEADERBOARD = "/api/{version}/leaderboard/update";
    /**
     * POST /api/{version}/leaderboard/update : Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
     * Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
     *
     * @param version  (required)
     * @param leaderboardId The leaderboard id to update. (required)
     * @param accountId The account id of the user updating the leaderboard. (optional)
     * @param appKey The application key (optional)
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. (optional)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (optional)
     * @param iconMedia a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty) (optional)
     * @param iconAssetId The asset ID to set the leaderboard icon (optional)
     * @param bannerMedia a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty) (optional)
     * @param bannerAssetId The asset ID to set the leaderboard banner (optional)
     * @param limitation limit number of rankings for each leaderboard (optional)
     * @param active Whether the leaderboard is active (optional)
     * @param title leaderboard&#39;s title (optional)
     * @param description leaderboard&#39;s description (optional)
     * @param metaData custom meta data for the leaderboard (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateLeaderboard",
        summary = "Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        description = "Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        tags = { "Leaderboard" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = LeaderboardResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_LEADERBOARD,
        produces = { "*/*" }
    )
    default ResponseEntity<LeaderboardResponse> updateLeaderboard(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "leaderboardId", description = "The leaderboard id to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardId", required = true) Long leaderboardId,
        @Parameter(name = "accountId", description = "The account id of the user updating the leaderboard.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "rankType", description = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = false) @Nullable String rankType,
        @Parameter(name = "leaderboardMode", description = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM", in = ParameterIn.QUERY) @Valid @RequestParam(value = "leaderboardMode", required = false) @Nullable String leaderboardMode,
        @Parameter(name = "sortField", description = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "iconMedia", description = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconMedia", required = false) @Nullable org.springframework.core.io.Resource iconMedia,
        @Parameter(name = "iconAssetId", description = "The asset ID to set the leaderboard icon", in = ParameterIn.QUERY) @Valid @RequestParam(value = "iconAssetId", required = false) @Nullable Long iconAssetId,
        @Parameter(name = "bannerMedia", description = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bannerMedia", required = false) @Nullable org.springframework.core.io.Resource bannerMedia,
        @Parameter(name = "bannerAssetId", description = "The asset ID to set the leaderboard banner", in = ParameterIn.QUERY) @Valid @RequestParam(value = "bannerAssetId", required = false) @Nullable Long bannerAssetId,
        @Parameter(name = "limitation", description = "limit number of rankings for each leaderboard", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limitation", required = false) @Nullable Integer limitation,
        @Parameter(name = "active", description = "Whether the leaderboard is active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "title", description = "leaderboard's title", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "leaderboard's description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "custom meta data for the leaderboard", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_LISTING = "/api/{version}/listing/update";
    /**
     * POST /api/{version}/listing/update : Update Listing
     * Updates a listing.
     *
     * @param version  (required)
     * @param accountId the user&#39;s account ID (required)
     * @param listingId the listing to update (required)
     * @param filterIds comma separated list of filter IDs (optional)
     * @param name the name of the listing (optional)
     * @param description the description of the listing (optional)
     * @param start the start date of the listing (optional)
     * @param end the end date of the listing (optional)
     * @param locationName the name of the location the listing will be held at (optional)
     * @param locationDescription the description of the location the listing will be held at (optional)
     * @param isPrivate determines whether the listing is public or private (optional)
     * @param externalId external identifier used by a third party (optional)
     * @param externalId2 secondary external identifier used by a third party (optional)
     * @param externalGroupId external group identifier used by a third party (optional)
     * @param active Sets the active flag (optional)
     * @param metaData external custom client defined data (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateListing",
        summary = "Update Listing",
        description = "Updates a listing.",
        tags = { "Listing" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListingFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_LISTING,
        produces = { "*/*" }
    )
    default ResponseEntity<ListingFullResponse> updateListing(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the user's account ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "listingId", description = "the listing to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = true) Long listingId,
        @Parameter(name = "filterIds", description = "comma separated list of filter IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "name", description = "the name of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "the description of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "start", description = "the start date of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "end", description = "the end date of the listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "end", required = false) @Nullable Long end,
        @Parameter(name = "locationName", description = "the name of the location the listing will be held at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationName", required = false) @Nullable String locationName,
        @Parameter(name = "locationDescription", description = "the description of the location the listing will be held at", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "isPrivate", description = "determines whether the listing is public or private", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isPrivate", required = false) @Nullable Boolean isPrivate,
        @Parameter(name = "externalId", description = "external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "externalId2", description = "secondary external identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId2", required = false) @Nullable String externalId2,
        @Parameter(name = "externalGroupId", description = "external group identifier used by a third party", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalGroupId", required = false) @Nullable String externalGroupId,
        @Parameter(name = "active", description = "Sets the active flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_LOCATION = "/api/{version}/account/location/update";
    /**
     * POST /api/{version}/account/location/update : Update Location
     * Update the account location
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param clientTime The time of the update (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateLocation",
        summary = "Update Location",
        description = "Update the account location",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_LOCATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateLocation(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "clientTime", description = "The time of the update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "clientTime", required = false) @Nullable Long clientTime
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_LOCATION_V2 = "/api/{version}/location/{id}";
    /**
     * POST /api/{version}/location/{id} : Update an existing location
     * Update an existing location
     *
     * @param version  (required)
     * @param id the id of the location to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateLocationV2",
        summary = "Update an existing location",
        description = "Update an existing location",
        tags = { "LocationApiV2" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_LOCATION_V2,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateLocationV2(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the location to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Location body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_LOCATIONS = "/api/{version}/trip/{id}/locations";
    /**
     * POST /api/{version}/trip/{id}/locations : Update Trip Locations
     *
     * @param version  (required)
     * @param id the id of the trip to update locations for (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateLocations",
        summary = "Update Trip Locations",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> updateLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip to update locations for", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_MEDIA = "/api/{version}/media/update";
    /**
     * POST /api/{version}/media/update : Update Media
     * Update a media offering.
     *
     * @param version  (required)
     * @param accountId The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (required)
     * @param mediaId  (required)
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param title The title (255 char limit) (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (optional)
     * @param availableLimit The limit of how many times the offer can be used by consumers (optional)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (optional)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (optional)
     * @param viewLimit  (optional)
     * @param maxPrints The maximum number of times the offer can be printed (optional)
     * @param ticketPriceType the type of ticket needed to buy the offer (optional)
     * @param ticketPrice The cost of the offer in tickets (optional)
     * @param fullPrice The retail/full price cost of the offer in real currency (optional)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (optional)
     * @param showRemaining The show remaining (optional)
     * @param showRedeemed The show redeemed (optional)
     * @param replaced The replaced (optional)
     * @param featured The featured (optional)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param active Sets the active flag (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param mediaType  (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateMedia",
        summary = "Update Media",
        description = "Update a media offering.",
        tags = { "Media" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MediaOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_MEDIA,
        produces = { "*/*" }
    )
    default ResponseEntity<MediaOfferResponse> updateMedia(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "mediaId", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaId", required = true) Long mediaId,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "offerLocations", description = "A list of json data that has offer location specific values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocations", required = false) @Nullable String offerLocations,
        @Parameter(name = "title", description = "The title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "subTitle", description = "The sub title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The details", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "subDetails", description = "A string for custom details (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subDetails", required = false) @Nullable String subDetails,
        @Parameter(name = "finePrint", description = "The fine print", in = ParameterIn.QUERY) @Valid @RequestParam(value = "finePrint", required = false) @Nullable String finePrint,
        @Parameter(name = "barcodeType", description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = false) @Nullable String barcodeType,
        @Parameter(name = "barcodeEntry", description = "The bar code entry string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "externalRedeemOptions", description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalRedeemOptions", required = false) @Nullable String externalRedeemOptions,
        @Parameter(name = "externalUrl", description = "The clickUrl of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalUrl", required = false) @Nullable String externalUrl,
        @Parameter(name = "ticketsRewardType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsRewardType", required = false) @Nullable String ticketsRewardType,
        @Parameter(name = "ticketsReward", description = "Determines how many tickets are awarded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsReward", required = false) @Nullable Long ticketsReward,
        @Parameter(name = "activated", description = "The date of when the offer will be visible to consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activated", required = false) @Nullable Long activated,
        @Parameter(name = "expires", description = "The date of when the offer expires", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expires", required = false) @Nullable Long expires,
        @Parameter(name = "noExpiration", description = "Overrides the expiration date so that the offer does not expire", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noExpiration", required = false) @Nullable Boolean noExpiration,
        @Parameter(name = "availableLimit", description = "The limit of how many times the offer can be used by consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = false) @Nullable Integer availableLimit,
        @Parameter(name = "availableLimitPerUser", description = "The limit of how many times a user can used the same offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimitPerUser", required = false) @Nullable Integer availableLimitPerUser,
        @Parameter(name = "addedLimit", description = "The limit of how many times the offer can be added to consumer wallets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "addedLimit", required = false) @Nullable Integer addedLimit,
        @Parameter(name = "viewLimit", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "viewLimit", required = false) @Nullable Integer viewLimit,
        @Parameter(name = "maxPrints", description = "The maximum number of times the offer can be printed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxPrints", required = false) @Nullable Integer maxPrints,
        @Parameter(name = "ticketPriceType", description = "the type of ticket needed to buy the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPriceType", required = false) @Nullable String ticketPriceType,
        @Parameter(name = "ticketPrice", description = "The cost of the offer in tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPrice", required = false) @Nullable Long ticketPrice,
        @Parameter(name = "fullPrice", description = "The retail/full price cost of the offer in real currency", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullPrice", required = false) @Nullable Double fullPrice,
        @Parameter(name = "discountPrice", description = "The cost of the offer at a discounted price (what the consumer pays)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "discountPrice", required = false) @Nullable Double discountPrice,
        @Parameter(name = "showRemaining", description = "The show remaining", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRemaining", required = false) @Nullable Boolean showRemaining,
        @Parameter(name = "showRedeemed", description = "The show redeemed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRedeemed", required = false) @Nullable Boolean showRedeemed,
        @Parameter(name = "replaced", description = "The replaced", in = ParameterIn.QUERY) @Valid @RequestParam(value = "replaced", required = false) @Nullable Boolean replaced,
        @Parameter(name = "featured", description = "The featured", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "specialOfferType", description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "offerVisibility", description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerVisibility", required = false) @Nullable String offerVisibility,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "active", description = "Sets the active flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "barcodeAssetId", description = "The id of the barcode asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeAssetId", required = false) @Nullable Long barcodeAssetId,
        @Parameter(name = "imageAssetId", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "imageAssetId1", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId1", required = false) @Nullable Long imageAssetId1,
        @Parameter(name = "imageAssetId2", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId2", required = false) @Nullable Long imageAssetId2,
        @Parameter(name = "imageAssetId3", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId3", required = false) @Nullable Long imageAssetId3,
        @Parameter(name = "imageAssetId4", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId4", required = false) @Nullable Long imageAssetId4,
        @Parameter(name = "imageAssetId5", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId5", required = false) @Nullable Long imageAssetId5,
        @Parameter(name = "publisher", description = "The maker of the item.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publisher", required = false) @Nullable String publisher,
        @Parameter(name = "redeemableStart", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd,
        @Parameter(name = "conditionType", description = "The condition. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionType", required = false) @Nullable String conditionType,
        @Parameter(name = "isbn", description = "The ISBN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "The ASIN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "catalogNumbers", description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "catalogNumbers", required = false) @Nullable String catalogNumbers,
        @Parameter(name = "availabilityDate", description = "The date available. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilityDate", required = false) @Nullable Long availabilityDate,
        @Parameter(name = "parentalRating", description = "The parental control rating. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentalRating", required = false) @Nullable String parentalRating,
        @Parameter(name = "mediaType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaType", required = false) @Nullable String mediaType,
        @Parameter(name = "duration", description = "The total playing time of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Integer duration,
        @Parameter(name = "author", description = "The created/author of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "author", required = false) @Nullable String author,
        @Parameter(name = "releaseDate", description = "The date/time of when the media item was originally released. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "releaseDate", required = false) @Nullable Long releaseDate,
        @Parameter(name = "collectionIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionIds", required = false) @Nullable String collectionIds,
        @Parameter(name = "availability", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availability", required = false) @Nullable String availability,
        @Parameter(name = "availabilitySummary", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilitySummary", required = false) @Nullable String availabilitySummary
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_MISSION = "/api/{version}/mission/update";
    /**
     * POST /api/{version}/mission/update : Update Mission
     * Update a mission.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param missionId The id of the mission to update. (required)
     * @param title The title of the mission (optional)
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param metaData external custom client defined data (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds  (optional)
     * @param audienceIds  (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateMission",
        summary = "Update Mission",
        description = "Update a mission.",
        tags = { "Mission" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_MISSION,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> updateMission(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "The id of the mission to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @Parameter(name = "title", description = "The title of the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "The description of the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "subType", description = "Custom string client apps can use for searching/filtering missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "metaData", description = "external custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "startDate", description = "The date/time to start the mission, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The date/time to end the mission, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "active", description = "Activate/deactivate the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "gameLevelIds", description = "the game level ids to include in the mission, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "creativeIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "creativeIds", required = false) @Nullable String creativeIds,
        @Parameter(name = "audienceIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "offerId", description = "The offerId to give as a reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = false) @Nullable Long offerId,
        @Parameter(name = "balance", description = "Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "balance", required = false) @Nullable Double balance,
        @Parameter(name = "advancedReporting", description = "Flag to mark the mission as eligible for advanced reporting", in = ParameterIn.QUERY) @Valid @RequestParam(value = "advancedReporting", required = false) @Nullable Boolean advancedReporting,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketCount", description = "The number of tickets to reward", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = false) @Nullable Long ticketCount,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "applicationIds", description = "Comma separated list of application ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "devices", description = "Deprecated parameter for device names", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "Comma separated list of device ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "Comma separated list of device version ranges", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "List of lat/long pairs for mission locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "Comma separated list of radii for locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_MISSION_INVITE = "/api/{version}/mission/invite/update";
    /**
     * POST /api/{version}/mission/invite/update : Update Mission Invite
     * Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
     *
     * @param version  (required)
     * @param deviceId the device id (deviceId or accountId required). (optional)
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @param appKey the application key (optional)
     * @param missionId The mission to find the invite for (missionId or missionInviteId requried). (optional)
     * @param missionInviteId The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
     * @param packId the pack id to find the invite for (optional)
     * @param gameLevelId the game level id to find the invite for (optional)
     * @param status The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED} (optional)
     * @param permissionableType This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM} (optional)
     * @param permissionableId The id of the content being submitted. (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateMissionInvite",
        summary = "Update Mission Invite",
        description = "Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.",
        tags = { "Mission Invite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = MissionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_MISSION_INVITE,
        produces = { "*/*" }
    )
    default ResponseEntity<MissionResponse> updateMissionInvite(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "the device id (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "missionId", description = "The mission to find the invite for (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = false) @Nullable Long missionId,
        @Parameter(name = "missionInviteId", description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionInviteId", required = false) @Nullable Long missionInviteId,
        @Parameter(name = "packId", description = "the pack id to find the invite for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = false) @Nullable Long packId,
        @Parameter(name = "gameLevelId", description = "the game level id to find the invite for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelId", required = false) @Nullable Long gameLevelId,
        @Parameter(name = "status", description = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "permissionableType", description = "This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the content being submitted.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "includeGameData", description = "Include the game level data with the mission.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeGameData", required = false) @Nullable Boolean includeGameData
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_NETWORK = "/api/{version}/thirdparty/network/update";
    /**
     * POST /api/{version}/thirdparty/network/update : Update Network
     * Updates a custom third party network. Only the network owners and managers have access to this.
     *
     * @param version  (required)
     * @param accountId The account id making the request (required)
     * @param networkUID The unique identifier for the third party network defined by Sirqul (required)
     * @param name The name of the network (optional)
     * @param description The description of the network (optional)
     * @param enableIntrospection Whether the network uses introspection calls (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateNetwork",
        summary = "Update Network",
        description = "Updates a custom third party network. Only the network owners and managers have access to this.",
        tags = { "ThirdParty Credentials" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ThirdPartyNetworkResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_NETWORK,
        produces = { "*/*" }
    )
    default ResponseEntity<ThirdPartyNetworkResponse> updateNetwork(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account id making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "networkUID", description = "The unique identifier for the third party network defined by Sirqul", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "networkUID", required = true) String networkUID,
        @Parameter(name = "name", description = "The name of the network", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the network", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "enableIntrospection", description = "Whether the network uses introspection calls", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableIntrospection", required = false) @Nullable Boolean enableIntrospection,
        @Parameter(name = "introspectionMethod", description = "HTTP method to use for introspection calls (e.g., GET, POST)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionMethod", required = false) @Nullable String introspectionMethod,
        @Parameter(name = "introspectionURL", description = "The HTTP URL of the introspection call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionURL", required = false) @Nullable String introspectionURL,
        @Parameter(name = "introspectionParams", description = "The parameters of the introspection call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "introspectionParams", required = false) @Nullable String introspectionParams,
        @Parameter(name = "requiredRootField", description = "Required response params", in = ParameterIn.QUERY) @Valid @RequestParam(value = "requiredRootField", required = false) @Nullable String requiredRootField,
        @Parameter(name = "enableMFA", description = "Whether this network uses MFA", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMFA", required = false) @Nullable Boolean enableMFA,
        @Parameter(name = "sizeMFA", description = "Size of the MFA token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sizeMFA", required = false) @Nullable Integer sizeMFA,
        @Parameter(name = "shelfLifeMFA", description = "Shelf life (seconds) of the MFA token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "shelfLifeMFA", required = false) @Nullable Integer shelfLifeMFA,
        @Parameter(name = "oauthTokenURL", description = "OAuth token endpoint URL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthTokenURL", required = false) @Nullable String oauthTokenURL,
        @Parameter(name = "oauthPrivateKey", description = "OAuth private key file (multipart)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthPrivateKey", required = false) @Nullable org.springframework.core.io.Resource oauthPrivateKey,
        @Parameter(name = "oauthPublicKey", description = "OAuth public key file (multipart)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthPublicKey", required = false) @Nullable org.springframework.core.io.Resource oauthPublicKey,
        @Parameter(name = "oauthClientId", description = "OAuth client id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthClientId", required = false) @Nullable String oauthClientId,
        @Parameter(name = "oauthSecretKey", description = "OAuth secret key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "oauthSecretKey", required = false) @Nullable String oauthSecretKey,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_NOTE = "/api/{version}/note/update";
    /**
     * POST /api/{version}/note/update : Update Note
     * Update an existing comment (note). Only the creator of the note have permission to update.
     *
     * @param version  (required)
     * @param noteId The id of the note, used when editing a comment (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param comment The message the user wishes to leave a comment on (optional)
     * @param noteType The custom string defined by the client (used for differentiating on various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData meta data to update with the note (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param active Sets the active flag for the note (optional)
     * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset (optional)
     * @param assetReturnNulls Return null fields for asset response when updating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateNote",
        summary = "Update Note",
        description = "Update an existing comment (note). Only the creator of the note have permission to update.",
        tags = { "Note" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NoteResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_NOTE,
        produces = { "*/*" }
    )
    default ResponseEntity<NoteResponse> updateNote(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "noteId", description = "The id of the note, used when editing a comment", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteId", required = true) Long noteId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "comment", description = "The message the user wishes to leave a comment on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "comment", required = false) @Nullable String comment,
        @Parameter(name = "noteType", description = "The custom string defined by the client (used for differentiating on various note types)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noteType", required = false) @Nullable String noteType,
        @Parameter(name = "assetIds", description = "A comma separated list of asset IDs to add with the note", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetIds", required = false) @Nullable String assetIds,
        @Parameter(name = "tags", description = "search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "permissionableType", description = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableType", required = false) @Nullable String permissionableType,
        @Parameter(name = "permissionableId", description = "The id of the permissionable object (for sending group notifications)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "permissionableId", required = false) @Nullable Long permissionableId,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "locationDescription", description = "The description of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "meta data to update with the note", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "returnFullResponse", description = "whether to return the full response or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false) @Nullable Boolean returnFullResponse,
        @Parameter(name = "active", description = "Sets the active flag for the note", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "updateAsset", description = "main flag for updating asset in note, must set to true if you want to update the note's asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateAsset", required = false) @Nullable Boolean updateAsset,
        @Parameter(name = "assetReturnNulls", description = "Return null fields for asset response when updating an asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetReturnNulls", required = false) @Nullable Boolean assetReturnNulls,
        @Parameter(name = "assetAlbumId", description = "the album the asset will be added to (optional)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAlbumId", required = false) @Nullable Long assetAlbumId,
        @Parameter(name = "assetCollectionId", description = "the collection ID that the asset is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetCollectionId", required = false) @Nullable Long assetCollectionId,
        @Parameter(name = "assetAddToDefaultAlbum", description = "the default album to add the asset to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAddToDefaultAlbum", required = false) @Nullable String assetAddToDefaultAlbum,
        @Parameter(name = "assetAddToMediaLibrary", description = "the media library to add the asset to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAddToMediaLibrary", required = false) @Nullable Boolean assetAddToMediaLibrary,
        @Parameter(name = "assetVersionCode", description = "the version code of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetVersionCode", required = false) @Nullable Integer assetVersionCode,
        @Parameter(name = "assetVersionName", description = "the version name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetVersionName", required = false) @Nullable String assetVersionName,
        @Parameter(name = "assetMetaData", description = "the meta data of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMetaData", required = false) @Nullable String assetMetaData,
        @Parameter(name = "assetCaption", description = "the caption of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetCaption", required = false) @Nullable String assetCaption,
        @Parameter(name = "assetMedia", description = "the media of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMedia", required = false) @Nullable org.springframework.core.io.Resource assetMedia,
        @Parameter(name = "assetMediaUrl", description = "the media URL of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaUrl", required = false) @Nullable String assetMediaUrl,
        @Parameter(name = "assetMediaString", description = "the media string of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaString", required = false) @Nullable String assetMediaString,
        @Parameter(name = "assetMediaStringFileName", description = "the media string file name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaStringFileName", required = false) @Nullable String assetMediaStringFileName,
        @Parameter(name = "assetMediaStringContentType", description = "the media string content type of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetMediaStringContentType", required = false) @Nullable String assetMediaStringContentType,
        @Parameter(name = "assetAttachedMedia", description = "the attached media of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMedia", required = false) @Nullable org.springframework.core.io.Resource assetAttachedMedia,
        @Parameter(name = "assetAttachedMediaUrl", description = "the attached media URL of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaUrl", required = false) @Nullable String assetAttachedMediaUrl,
        @Parameter(name = "assetAttachedMediaString", description = "the attached media string of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaString", required = false) @Nullable String assetAttachedMediaString,
        @Parameter(name = "assetAttachedMediaStringFileName", description = "the attached media string file name of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaStringFileName", required = false) @Nullable String assetAttachedMediaStringFileName,
        @Parameter(name = "assetAttachedMediaStringContentType", description = "the attached media string content type of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetAttachedMediaStringContentType", required = false) @Nullable String assetAttachedMediaStringContentType,
        @Parameter(name = "assetLocationDescription", description = "the location description for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLocationDescription", required = false) @Nullable String assetLocationDescription,
        @Parameter(name = "assetApp", description = "the application for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetApp", required = false) @Nullable String assetApp,
        @Parameter(name = "assetSearchTags", description = "the search tags used for the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetSearchTags", required = false) @Nullable String assetSearchTags,
        @Parameter(name = "assetLatitude", description = "the latitude of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLatitude", required = false) @Nullable Double assetLatitude,
        @Parameter(name = "assetLongitude", description = "the longitude of the asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetLongitude", required = false) @Nullable Double assetLongitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_NOTIFICATION_TEMPLATE = "/api/{version}/notification/template/update";
    /**
     * POST /api/{version}/notification/template/update : Update Notification Template
     * Update a notification template. Developers will only be able to update notification templates for their own applications.
     *
     * @param version  (required)
     * @param accountId The account ID of the user. (required)
     * @param notificationTemplateId The notification template ID to update. (required)
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
     * @param body The body of the message. (optional)
     * @param tags The search tags on the template used during search queries. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateNotificationTemplate",
        summary = "Update Notification Template",
        description = "Update a notification template. Developers will only be able to update notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> updateNotificationTemplate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "The notification template ID to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId,
        @Parameter(name = "title", description = "The title of the message (this would become the subject title for emails). There is a 191 character limit.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "body", description = "The body of the message.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "body", required = false) @Nullable String body,
        @Parameter(name = "tags", description = "The search tags on the template used during search queries.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_OFFER = "/api/{version}/retailer/offer/update";
    /**
     * POST /api/{version}/retailer/offer/update : Update Offer
     * Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.
     *
     * @param version  (required)
     * @param offerId The offer to update (required)
     * @param includeOfferLocations If true return all the offer locations associated with the offer (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (optional)
     * @param parentOfferId  (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param title The title (255 char limit) (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param externalId  (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (optional)
     * @param availableLimit The limit of how many times the offer can be used by consumers (optional)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (optional)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (optional)
     * @param viewLimit  (optional)
     * @param maxPrints The maximum number of times the offer can be printed (optional)
     * @param ticketPriceType the type of ticket needed to buy the offer (optional)
     * @param ticketPrice The cost of the offer in tickets (optional)
     * @param fullPrice The retail/full price cost of the offer in real currency (optional)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (optional)
     * @param showRemaining show remaining offers available (optional)
     * @param showRedeemed show how many offers have been redeemed (optional)
     * @param replaced  (optional)
     * @param featured whether the offer is featured or not (optional)
     * @param offerType The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT} (optional)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param active Sets the active flag (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param brand The brand. OfferType PRODUCT only. (optional)
     * @param productType The product type. OfferType PRODUCT only. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param department The department name. The OfferType PRODUCT only. (optional)
     * @param features The list of features, comma seperated. OfferType PRODUCT only. (optional)
     * @param minimumPrice The MAP price. OfferType PRODUCT only. (optional)
     * @param width The width of the item. OfferType PRODUCT only. (optional)
     * @param height The height of the item. OfferType PRODUCT only. (optional)
     * @param depth The depth of the item. OfferType PRODUCT only. (optional)
     * @param weight The weight of the item. OfferType PRODUCT only. (optional)
     * @param unit The unit of measurement. OfferType PRODUCT only. (optional)
     * @param studio The studio name. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param publishDate The date published. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param sizeId The size Id. OfferType PRODUCT only. (optional)
     * @param listingId The ID of the event listing (optional)
     * @param mediaType  (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param rebootTimeHour The reboot hour time ranging from 0 to 23 (optional)
     * @param rebootTimeMinute The reboot minute time ranging from 0 to 59 (optional)
     * @param idleTimeoutInSecond If the device is idle for idleTimeoutInSecond then the device should timeout (optional)
     * @param serialNumber The serial number on the device (optional)
     * @param udid The unique device id for the device (optional)
     * @param deviceType The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;. (optional)
     * @param devicePower RSSI reading at 1 meter from device (-10 to -140) (optional)
     * @param deviceInterference  (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateOffer",
        summary = "Update Offer",
        description = "Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerOfferResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_OFFER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerOfferResponse> updateOffer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerId", description = "The offer to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerId", required = true) Long offerId,
        @NotNull @Parameter(name = "includeOfferLocations", description = "If true return all the offer locations associated with the offer", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeOfferLocations", required = true) Boolean includeOfferLocations,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "parentOfferId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentOfferId", required = false) @Nullable Long parentOfferId,
        @Parameter(name = "retailerLocationIds", description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationIds", required = false) @Nullable String retailerLocationIds,
        @Parameter(name = "offerLocations", description = "A list of json data that has offer location specific values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocations", required = false) @Nullable String offerLocations,
        @Parameter(name = "tags", description = "Custom string field for doing full-text searches", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "title", description = "The title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "subTitle", description = "The sub title (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subTitle", required = false) @Nullable String subTitle,
        @Parameter(name = "details", description = "The details", in = ParameterIn.QUERY) @Valid @RequestParam(value = "details", required = false) @Nullable String details,
        @Parameter(name = "subDetails", description = "A string for custom details (255 char limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subDetails", required = false) @Nullable String subDetails,
        @Parameter(name = "finePrint", description = "The fine print", in = ParameterIn.QUERY) @Valid @RequestParam(value = "finePrint", required = false) @Nullable String finePrint,
        @Parameter(name = "barcodeType", description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeType", required = false) @Nullable String barcodeType,
        @Parameter(name = "barcodeEntry", description = "The bar code entry string", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeEntry", required = false) @Nullable String barcodeEntry,
        @Parameter(name = "externalRedeemOptions", description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalRedeemOptions", required = false) @Nullable String externalRedeemOptions,
        @Parameter(name = "externalUrl", description = "The clickUrl of the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalUrl", required = false) @Nullable String externalUrl,
        @Parameter(name = "externalId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalId", required = false) @Nullable String externalId,
        @Parameter(name = "ticketsRewardType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsRewardType", required = false) @Nullable String ticketsRewardType,
        @Parameter(name = "ticketsReward", description = "Determines how many tickets are awarded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketsReward", required = false) @Nullable Long ticketsReward,
        @Parameter(name = "activated", description = "The date of when the offer will be visible to consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activated", required = false) @Nullable Long activated,
        @Parameter(name = "expires", description = "The date of when the offer expires", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expires", required = false) @Nullable Long expires,
        @Parameter(name = "noExpiration", description = "Overrides the expiration date so that the offer does not expire", in = ParameterIn.QUERY) @Valid @RequestParam(value = "noExpiration", required = false) @Nullable Boolean noExpiration,
        @Parameter(name = "availableLimit", description = "The limit of how many times the offer can be used by consumers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = false) @Nullable Integer availableLimit,
        @Parameter(name = "availableLimitPerUser", description = "The limit of how many times a user can used the same offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimitPerUser", required = false) @Nullable Integer availableLimitPerUser,
        @Parameter(name = "addedLimit", description = "The limit of how many times the offer can be added to consumer wallets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "addedLimit", required = false) @Nullable Integer addedLimit,
        @Parameter(name = "viewLimit", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "viewLimit", required = false) @Nullable Integer viewLimit,
        @Parameter(name = "maxPrints", description = "The maximum number of times the offer can be printed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maxPrints", required = false) @Nullable Integer maxPrints,
        @Parameter(name = "ticketPriceType", description = "the type of ticket needed to buy the offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPriceType", required = false) @Nullable String ticketPriceType,
        @Parameter(name = "ticketPrice", description = "The cost of the offer in tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketPrice", required = false) @Nullable Long ticketPrice,
        @Parameter(name = "fullPrice", description = "The retail/full price cost of the offer in real currency", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullPrice", required = false) @Nullable Double fullPrice,
        @Parameter(name = "discountPrice", description = "The cost of the offer at a discounted price (what the consumer pays)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "discountPrice", required = false) @Nullable Double discountPrice,
        @Parameter(name = "showRemaining", description = "show remaining offers available", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRemaining", required = false) @Nullable Boolean showRemaining,
        @Parameter(name = "showRedeemed", description = "show how many offers have been redeemed", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showRedeemed", required = false) @Nullable Boolean showRedeemed,
        @Parameter(name = "replaced", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "replaced", required = false) @Nullable Boolean replaced,
        @Parameter(name = "featured", description = "whether the offer is featured or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "offerType", description = "The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerType", required = false) @Nullable String offerType,
        @Parameter(name = "specialOfferType", description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "specialOfferType", required = false) @Nullable String specialOfferType,
        @Parameter(name = "offerVisibility", description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerVisibility", required = false) @Nullable String offerVisibility,
        @Parameter(name = "categoryIds", description = "Comma separated list of category ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter ids", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "active", description = "Sets the active flag", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "barcodeAssetId", description = "The id of the barcode asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "barcodeAssetId", required = false) @Nullable Long barcodeAssetId,
        @Parameter(name = "imageAssetId", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "imageAssetId1", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId1", required = false) @Nullable Long imageAssetId1,
        @Parameter(name = "imageAssetId2", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId2", required = false) @Nullable Long imageAssetId2,
        @Parameter(name = "imageAssetId3", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId3", required = false) @Nullable Long imageAssetId3,
        @Parameter(name = "imageAssetId4", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId4", required = false) @Nullable Long imageAssetId4,
        @Parameter(name = "imageAssetId5", description = "The id of the an offer asset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId5", required = false) @Nullable Long imageAssetId5,
        @Parameter(name = "publisher", description = "The maker of the item.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publisher", required = false) @Nullable String publisher,
        @Parameter(name = "redeemableStart", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableStart", required = false) @Nullable Long redeemableStart,
        @Parameter(name = "redeemableEnd", description = "The redeemable start date/time of the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "redeemableEnd", required = false) @Nullable Long redeemableEnd,
        @Parameter(name = "brand", description = "The brand. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "brand", required = false) @Nullable String brand,
        @Parameter(name = "productType", description = "The product type. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "productType", required = false) @Nullable String productType,
        @Parameter(name = "conditionType", description = "The condition. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionType", required = false) @Nullable String conditionType,
        @Parameter(name = "isbn", description = "The ISBN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "isbn", required = false) @Nullable String isbn,
        @Parameter(name = "asin", description = "The ASIN id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "asin", required = false) @Nullable String asin,
        @Parameter(name = "catalogNumbers", description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "catalogNumbers", required = false) @Nullable String catalogNumbers,
        @Parameter(name = "department", description = "The department name. The OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "department", required = false) @Nullable String department,
        @Parameter(name = "features", description = "The list of features, comma seperated. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "features", required = false) @Nullable String features,
        @Parameter(name = "minimumPrice", description = "The MAP price. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumPrice", required = false) @Nullable Double minimumPrice,
        @Parameter(name = "width", description = "The width of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "width", required = false) @Nullable Double width,
        @Parameter(name = "height", description = "The height of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "height", required = false) @Nullable Double height,
        @Parameter(name = "depth", description = "The depth of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "depth", required = false) @Nullable Double depth,
        @Parameter(name = "weight", description = "The weight of the item. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "weight", required = false) @Nullable Double weight,
        @Parameter(name = "unit", description = "The unit of measurement. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "unit", required = false) @Nullable String unit,
        @Parameter(name = "studio", description = "The studio name. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "studio", required = false) @Nullable String studio,
        @Parameter(name = "parentalRating", description = "The parental control rating. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentalRating", required = false) @Nullable String parentalRating,
        @Parameter(name = "publishDate", description = "The date published. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publishDate", required = false) @Nullable Long publishDate,
        @Parameter(name = "availabilityDate", description = "The date available. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilityDate", required = false) @Nullable Long availabilityDate,
        @Parameter(name = "sizeId", description = "The size Id. OfferType PRODUCT only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sizeId", required = false) @Nullable Long sizeId,
        @Parameter(name = "listingId", description = "The ID of the event listing", in = ParameterIn.QUERY) @Valid @RequestParam(value = "listingId", required = false) @Nullable Long listingId,
        @Parameter(name = "mediaType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "mediaType", required = false) @Nullable String mediaType,
        @Parameter(name = "duration", description = "The total playing time of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "duration", required = false) @Nullable Integer duration,
        @Parameter(name = "author", description = "The created/author of the media item. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "author", required = false) @Nullable String author,
        @Parameter(name = "releaseDate", description = "The date/time of when the media item was originally released. OfferType MEDIA only.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "releaseDate", required = false) @Nullable Long releaseDate,
        @Parameter(name = "collectionIds", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "collectionIds", required = false) @Nullable String collectionIds,
        @Parameter(name = "rebootTimeHour", description = "The reboot hour time ranging from 0 to 23", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rebootTimeHour", required = false) @Nullable Integer rebootTimeHour,
        @Parameter(name = "rebootTimeMinute", description = "The reboot minute time ranging from 0 to 59", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rebootTimeMinute", required = false) @Nullable Integer rebootTimeMinute,
        @Parameter(name = "idleTimeoutInSecond", description = "If the device is idle for idleTimeoutInSecond then the device should timeout", in = ParameterIn.QUERY) @Valid @RequestParam(value = "idleTimeoutInSecond", required = false) @Nullable Integer idleTimeoutInSecond,
        @Parameter(name = "serialNumber", description = "The serial number on the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "serialNumber", required = false) @Nullable String serialNumber,
        @Parameter(name = "udid", description = "The unique device id for the device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "udid", required = false) @Nullable String udid,
        @Parameter(name = "deviceType", description = "The type of the device, for example: \"Kiosk\", \"Beacon\".", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "devicePower", description = "RSSI reading at 1 meter from device (-10 to -140)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devicePower", required = false) @Nullable Double devicePower,
        @Parameter(name = "deviceInterference", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceInterference", required = false) @Nullable Double deviceInterference,
        @Parameter(name = "availability", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availability", required = false) @Nullable String availability,
        @Parameter(name = "availabilitySummary", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availabilitySummary", required = false) @Nullable String availabilitySummary
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_OFFER_STATUS = "/api/{version}/retailer/offer/status";
    /**
     * POST /api/{version}/retailer/offer/status : Activate Offer
     * Sets the activated date on offers. This will make offers visible for consumers.
     *
     * @param version  (required)
     * @param offerIds Comma separated list of offer ids (required)
     * @param active Determines whether to make the offer active as well (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the activation, must have rights to edit the offer. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateOfferStatus",
        summary = "Activate Offer",
        description = "Sets the activated date on offers. This will make offers visible for consumers.",
        tags = { "Offer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_OFFER_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateOfferStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "offerIds", description = "Comma separated list of offer ids", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerIds", required = true) String offerIds,
        @NotNull @Parameter(name = "active", description = "Determines whether to make the offer active as well", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = true) Boolean active,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the activation, must have rights to edit the offer.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_OFFER_TRANSACTION = "/api/{version}/wallet/update";
    /**
     * POST /api/{version}/wallet/update : Update Wallet Offer
     * Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
     *
     * @param version  (required)
     * @param transactionId The offer transaction id to remove (required)
     * @param status The status value to change to (0 or 1) (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerLocationId Offer Location Id (optional)
     * @param currencyType Currency Type (optional, default to CASH)
     * @param usePoints Use Points (optional)
     * @param appKey App Key (optional)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateOfferTransaction",
        summary = "Update Wallet Offer",
        description = "Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.",
        tags = { "Wallet" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferTransactionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_OFFER_TRANSACTION,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferTransactionResponse> updateOfferTransaction(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "transactionId", description = "The offer transaction id to remove", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "transactionId", required = true) Long transactionId,
        @NotNull @Parameter(name = "status", description = "The status value to change to (0 or 1)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = true) Integer status,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "offerLocationId", description = "Offer Location Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId,
        @Parameter(name = "currencyType", description = "Currency Type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "usePoints", deprecated = true, description = "Use Points", in = ParameterIn.QUERY) @Valid @RequestParam(value = "usePoints", required = false) @Deprecated @Nullable Boolean usePoints,
        @Parameter(name = "appKey", description = "App Key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "latitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The latitude location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "returnFullResponse", description = "Determines whether to return a detailed version of the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "false") Boolean returnFullResponse,
        @Parameter(name = "exceptionMembershipOfferIds", description = "Exception Offers, transaction audiences of these offers won't be removed out of the account when up", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exceptionMembershipOfferIds", required = false) @Nullable String exceptionMembershipOfferIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_OFFER_TRANSACTION_STATUS = "/api/{version}/offer/status/update";
    /**
     * POST /api/{version}/offer/status/update : Update Offer Status
     * Update an offer status record
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param statusId The id of the record to update  (optional)
     * @param name The name of th status (optional)
     * @param description The description of the status (optional)
     * @param code The status code, must be unique  (optional)
     * @param role The actor that uses the status (optional)
     * @param active The active status (optional)
     * @param applicationIds The applications to associate the status with, if null then for all. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateOfferTransactionStatus",
        summary = "Update Offer Status",
        description = "Update an offer status record",
        tags = { "Offer Status" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferTransactionStatusResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_OFFER_TRANSACTION_STATUS,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferTransactionStatusResponse> updateOfferTransactionStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "statusId", description = "The id of the record to update ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statusId", required = false) @Nullable Long statusId,
        @Parameter(name = "name", description = "The name of th status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "code", description = "The status code, must be unique ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "code", required = false) @Nullable Integer code,
        @Parameter(name = "role", description = "The actor that uses the status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "role", required = false) @Nullable String role,
        @Parameter(name = "active", description = "The active status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "applicationIds", description = "The applications to associate the status with, if null then for all.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ORDER = "/api/{version}/order/update";
    /**
     * POST /api/{version}/order/update : Update Order
     * Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
     *
     * @param version  (required)
     * @param orderId The order to add the purchase to, leave null for new order. (required)
     * @param appKey The application requesting the purchase (required)
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param paymentTransactionId The payment transaction to apply the refund to (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param externalDate External Date (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateOrder",
        summary = "Update Order",
        description = "Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.",
        tags = { "Purchase Order" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OrderResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_ORDER,
        produces = { "*/*" }
    )
    default ResponseEntity<OrderResponse> updateOrder(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "orderId", description = "The order to add the purchase to, leave null for new order.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "orderId", required = true) Long orderId,
        @NotNull @Parameter(name = "appKey", description = "The application requesting the purchase", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "cart", description = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "cart", required = true) String cart,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "paymentTransactionId", description = "The payment transaction to apply the refund to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentTransactionId", required = false) @Nullable Long paymentTransactionId,
        @Parameter(name = "description", description = "A description of the purchase", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "currencyType", description = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") String currencyType,
        @Parameter(name = "paymentMethodId", description = "Use a specific payment method (CASH), if not provided use default", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentMethodId", required = false) @Nullable Long paymentMethodId,
        @Parameter(name = "externalPaymentId", description = "Store identifier from external system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalPaymentId", required = false) @Nullable String externalPaymentId,
        @Parameter(name = "externalDate", description = "External Date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "externalDate", required = false) @Nullable Long externalDate
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_PACK = "/api/{version}/pack/update";
    /**
     * POST /api/{version}/pack/update : Update Pack
     * Update a pack.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param packId The id of the pack to update. (required)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed packs (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param title The title of the pack (optional)
     * @param description The description of the pack (optional)
     * @param searchTags The tags for searching the pack, comma separated (optional)
     * @param active Activate/deactivate the pack (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param packType The type of the pack (optional)
     * @param packOrder The order of the pack (optional)
     * @param sequenceType The type of game sequence of the pack (optional)
     * @param backgroundId The background asset id of the pack (optional)
     * @param imageId The image asset id of the pack (optional)
     * @param startDate The date/time to start the pack, send 0 to unset (optional)
     * @param endDate The date/time to end the pack, send 0 to unset (optional)
     * @param authorOverride  (optional)
     * @param price The price in tickets to purchase this pack (optional)
     * @param priceType the type of ticket required to purchase this pack (optional)
     * @param gameLevelIds the game level ids to include in the pack, comma separated (optional)
     * @param inGame  (optional)
     * @param highest The scoring is highest is best (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a pack (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updatePack",
        summary = "Update Pack",
        description = "Update a pack.",
        tags = { "Pack" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PackResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_PACK,
        produces = { "*/*" }
    )
    default ResponseEntity<PackResponse> updatePack(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "packId", description = "The id of the pack to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "packId", required = true) Long packId,
        @NotNull @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed packs", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = true) Boolean allocateTickets,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true) Long ticketCount,
        @Parameter(name = "title", description = "The title of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "description", description = "The description of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The tags for searching the pack, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "active", description = "Activate/deactivate the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "appKey", description = "The application key used to identify the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "packType", description = "The type of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packType", required = false) @Nullable String packType,
        @Parameter(name = "packOrder", description = "The order of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "packOrder", required = false) @Nullable Long packOrder,
        @Parameter(name = "sequenceType", description = "The type of game sequence of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sequenceType", required = false) @Nullable String sequenceType,
        @Parameter(name = "backgroundId", description = "The background asset id of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "backgroundId", required = false) @Nullable Long backgroundId,
        @Parameter(name = "imageId", description = "The image asset id of the pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageId", required = false) @Nullable Long imageId,
        @Parameter(name = "startDate", description = "The date/time to start the pack, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The date/time to end the pack, send 0 to unset", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "authorOverride", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "authorOverride", required = false) @Nullable String authorOverride,
        @Parameter(name = "price", description = "The price in tickets to purchase this pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "price", required = false) @Nullable Integer price,
        @Parameter(name = "priceType", description = "the type of ticket required to purchase this pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "priceType", required = false) @Nullable String priceType,
        @Parameter(name = "gameLevelIds", description = "the game level ids to include in the pack, comma separated", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameLevelIds", required = false) @Nullable String gameLevelIds,
        @Parameter(name = "inGame", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "inGame", required = false) @Nullable Boolean inGame,
        @Parameter(name = "highest", description = "The scoring is highest is best", in = ParameterIn.QUERY) @Valid @RequestParam(value = "highest", required = false) @Nullable Boolean highest,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a pack", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_PERSONA = "/api/{version}/persona/update";
    /**
     * POST /api/{version}/persona/update : Update Persona
     * Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.
     *
     * @param version  (required)
     * @param accountId the account ID of the user (required)
     * @param personaId the persona ID of the persona to update (required)
     * @param title the title of the persona (optional)
     * @param previewAccounts the accounts that are able to preview from this persona (optional)
     * @param active the status of the persona, there can only be one active persona per account (optional)
     * @param date the sepcified date that this persona is viewing the app (optional)
     * @param age the specified age of this persona (optional)
     * @param gender the specified gender of this persona (optional)
     * @param gameExperienceLevel the specified experience level of the persona (optional)
     * @param latitude the specified latitude of the persona (optional)
     * @param longitude the specified longitude of the persona (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updatePersona",
        summary = "Update Persona",
        description = "Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.",
        tags = { "Preview Persona" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PreviewPersonaResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_PERSONA,
        produces = { "*/*" }
    )
    default ResponseEntity<PreviewPersonaResponse> updatePersona(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account ID of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "personaId", description = "the persona ID of the persona to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "personaId", required = true) Long personaId,
        @Parameter(name = "title", description = "the title of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "previewAccounts", description = "the accounts that are able to preview from this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "previewAccounts", required = false) @Nullable String previewAccounts,
        @Parameter(name = "active", description = "the status of the persona, there can only be one active persona per account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "date", description = "the sepcified date that this persona is viewing the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "date", required = false) @Nullable Long date,
        @Parameter(name = "age", description = "the specified age of this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "gender", description = "the specified gender of this persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "gameExperienceLevel", description = "the specified experience level of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "latitude", description = "the specified latitude of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the specified longitude of the persona", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_POSTAL_CODE = "/api/{version}/postalCode/update";
    /**
     * POST /api/{version}/postalCode/update : Update Postal Code
     * Update a Postal Code
     *
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param postalCodeId the id of the postal code to update (required)
     * @param code the postal code to update (optional)
     * @param latitude the latitude of the postal code (optional)
     * @param longitude the longitude of the postal code (optional)
     * @param stateCode the state code (e.g. WA, WI, WY) where the postal code is located (optional)
     * @param city the city where the postal code is located (optional)
     * @param active whether the postal code is active or inactive (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updatePostalCode",
        summary = "Update Postal Code",
        description = "Update a Postal Code",
        tags = { "Postal Code" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PostalCodeResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_POSTAL_CODE,
        produces = { "*/*" }
    )
    default ResponseEntity<PostalCodeResponse> updatePostalCode(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "postalCodeId", description = "the id of the postal code to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCodeId", required = true) Long postalCodeId,
        @Parameter(name = "code", description = "the postal code to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "code", required = false) @Nullable String code,
        @Parameter(name = "latitude", description = "the latitude of the postal code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the postal code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "stateCode", description = "the state code (e.g. WA, WI, WY) where the postal code is located", in = ParameterIn.QUERY) @Valid @RequestParam(value = "stateCode", required = false) @Nullable String stateCode,
        @Parameter(name = "city", description = "the city where the postal code is located", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "active", description = "whether the postal code is active or inactive", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_PURCHASE_ITEM = "/api/{version}/purchase/update";
    /**
     * POST /api/{version}/purchase/update : Update Purchase
     * Updates a purchase item for in app purchases
     *
     * @param version  (required)
     * @param purchaseItemId The purchase item id (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the purchase item (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param active Sets whether the purchase item is active or inactive (hidden from consumers) (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updatePurchaseItem",
        summary = "Update Purchase",
        description = "Updates a purchase item for in app purchases",
        tags = { "Purchase Item" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PurchaseItemFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_PURCHASE_ITEM,
        produces = { "*/*" }
    )
    default ResponseEntity<PurchaseItemFullResponse> updatePurchaseItem(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "purchaseItemId", description = "The purchase item id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseItemId", required = true) Long purchaseItemId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "tickets", description = "How much the purchase item is worth in tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tickets", required = false) @Nullable Integer tickets,
        @Parameter(name = "price", description = "How much the purchase item will cost in real money", in = ParameterIn.QUERY) @Valid @RequestParam(value = "price", required = false) @Nullable Float price,
        @Parameter(name = "purchaseType", description = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseType", required = false) @Nullable String purchaseType,
        @Parameter(name = "purchaseCode", description = "The unique identifier used by purchase providers to identify in-app-purchases", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseCode", required = false) @Nullable String purchaseCode,
        @Parameter(name = "secretKey", description = "A secret key from purchase providers that would be used for validation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secretKey", required = false) @Nullable String secretKey,
        @Parameter(name = "purchaseLimit", description = "How many times a user acquire the same purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "purchaseLimit", required = false) @Nullable Integer purchaseLimit,
        @Parameter(name = "serviceAction", description = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", in = ParameterIn.QUERY) @Valid @RequestParam(value = "serviceAction", required = false) @Nullable String serviceAction,
        @Parameter(name = "coverAssetId", description = "The cover image of the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "coverAssetId", required = false) @Nullable Long coverAssetId,
        @Parameter(name = "promoAssetId", description = "An application specific asset that can be used to store/provide additional data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoAssetId", required = false) @Nullable Long promoAssetId,
        @Parameter(name = "giftable", description = "Determines whether the purchase item can be gifted to other users", in = ParameterIn.QUERY) @Valid @RequestParam(value = "giftable", required = false) @Nullable Boolean giftable,
        @Parameter(name = "assetable", description = "Determines whether users can attach their own media/asset to the purchase item", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetable", required = false) @Nullable Boolean assetable,
        @Parameter(name = "active", description = "Sets whether the purchase item is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false, defaultValue = "false") Boolean allocateTickets,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points,
        @Parameter(name = "offerLocationId", description = "The offer location that will get added to the user's wallet after purchase.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerLocationId", required = false) @Nullable Long offerLocationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_QUESTION = "/api/{version}/game/question/update";
    /**
     * POST /api/{version}/game/question/update : Update Question
     * Update a question and related answers.
     *
     * @param version  (required)
     * @param questionId The id of the question to update. (required)
     * @param accountId The logged in user. (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param question The text of the question. (optional)
     * @param answers The json representations of answers for the question. (optional)
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param active If true set the question to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateQuestion",
        summary = "Update Question",
        description = "Update a question and related answers.",
        tags = { "Question" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = QuestionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_QUESTION,
        produces = { "*/*" }
    )
    default ResponseEntity<QuestionResponse> updateQuestion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "questionId", description = "The id of the question to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "questionId", required = true) Long questionId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true) Long ticketCount,
        @Parameter(name = "question", description = "The text of the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "question", required = false) @Nullable String question,
        @Parameter(name = "answers", description = "The json representations of answers for the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "answers", required = false) @Nullable String answers,
        @Parameter(name = "tags", description = "The tags of the question for search.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags,
        @Parameter(name = "videoURL", description = "The video link for the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "videoURL", required = false) @Nullable String videoURL,
        @Parameter(name = "assetId", description = "The asset id of the question.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "active", description = "If true set the question to active.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_QUESTIONS_IN_LEVEL = "/api/{version}/level/questions/update";
    /**
     * POST /api/{version}/level/questions/update : Update Level Questions
     * Updates a level with question game objects.
     *
     * @param version  (required)
     * @param levelId the id of the level to update questions on (required)
     * @param accountId the id of the logged in user (required)
     * @param questionIds the IDs of the questions to update (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateQuestionsInLevel",
        summary = "Update Level Questions",
        description = "Updates a level with question game objects.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_QUESTIONS_IN_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateQuestionsInLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "levelId", description = "the id of the level to update questions on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "questionIds", description = "the IDs of the questions to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "questionIds", required = true) String questionIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RANKINGS = "/api/{version}/ranking/update";
    /**
     * POST /api/{version}/ranking/update : Update Ranking
     * Update the rank value 
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param appKey the application key for filtering results by application (required)
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (required)
     * @param increment the value to increment (optional, default to 1)
     * @param timeIncrement the time value to increment (optional)
     * @param tag the analytic tag for this achievement (used to validate scores) (optional)
     * @param startDate custom date you can save along with the score for the user (optional)
     * @param endDate custom date you can save along with the score for the user (optional)
     * @param updateGlobal update the global rankings if true, default is false (optional)
     * @param createLeaderboard create the leaderboard if it does not exist (default false) (optional, default to false)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRankings",
        summary = "Update Ranking",
        description = "Update the rank value ",
        tags = { "Ranking" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RANKINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateRankings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key for filtering results by application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "rankType", description = "a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "rankType", required = true) String rankType,
        @Parameter(name = "increment", description = "the value to increment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "increment", required = false, defaultValue = "1") Long increment,
        @Parameter(name = "timeIncrement", description = "the time value to increment", in = ParameterIn.QUERY) @Valid @RequestParam(value = "timeIncrement", required = false) @Nullable Long timeIncrement,
        @Parameter(name = "tag", description = "the analytic tag for this achievement (used to validate scores)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tag", required = false) @Nullable String tag,
        @Parameter(name = "startDate", description = "custom date you can save along with the score for the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "custom date you can save along with the score for the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "updateGlobal", description = "update the global rankings if true, default is false", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateGlobal", required = false) @Nullable Boolean updateGlobal,
        @Parameter(name = "createLeaderboard", description = "create the leaderboard if it does not exist (default false)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "createLeaderboard", required = false, defaultValue = "false") Boolean createLeaderboard
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RATING = "/api/{version}/rating/update";
    /**
     * POST /api/{version}/rating/update : Update Rating
     * Update an existing rating. Only the creator of the rating have permission to update.
     *
     * @param version  (required)
     * @param ratingId The id of the rating (Note: this is not the ratable object id) (required)
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param ratingValue The rating value to update (optional)
     * @param categoryId  (optional)
     * @param display A subject title for the user rating (limited to 255 characters) (optional)
     * @param description The description of the rating (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRating",
        summary = "Update Rating",
        description = "Update an existing rating. Only the creator of the rating have permission to update.",
        tags = { "Rating" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RatingResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RATING,
        produces = { "*/*" }
    )
    default ResponseEntity<RatingResponse> updateRating(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "ratingId", description = "The id of the rating (Note: this is not the ratable object id)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratingId", required = true) Long ratingId,
        @Parameter(name = "deviceId", description = "The unique device identifier that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The unique accountId that made the request (either deviceId or accountId must be used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "ratingValue", description = "The rating value to update", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ratingValue", required = false) @Nullable Integer ratingValue,
        @Parameter(name = "categoryId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryId", required = false) @Nullable Long categoryId,
        @Parameter(name = "display", description = "A subject title for the user rating (limited to 255 characters)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "display", required = false) @Nullable String display,
        @Parameter(name = "description", description = "The description of the rating", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "locationDescription", description = "The description of the location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "latitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current location of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RECURRENCE_LOCATIONS = "/api/{version}/trip/{id}/locations/recurrence";
    /**
     * POST /api/{version}/trip/{id}/locations/recurrence : Update Recurrence Locations
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRecurrenceLocations",
        summary = "Update Recurrence Locations",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RECURRENCE_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> updateRecurrenceLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RECURRENCE_SHIPMENTS = "/api/{version}/trip/{id}/shipments/recurrence";
    /**
     * POST /api/{version}/trip/{id}/shipments/recurrence : Update Recurrence Shipments
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRecurrenceShipments",
        summary = "Update Recurrence Shipments",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = Trip.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RECURRENCE_SHIPMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<Trip>> updateRecurrenceShipments(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_REGION = "/api/{version}/region/update";
    /**
     * POST /api/{version}/region/update : Update Region
     * Update a region.
     *
     * @param version  (required)
     * @param accountId The id of the account sending the request (required)
     * @param regionId The id of the region to be updated (required)
     * @param regionClass RegionClass of this region (optional)
     * @param shortName Short name of the region. This is optimized for search (optional)
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the retailer location ID that the region is associated with (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon of the region (optional)
     * @param metaData the meta data of the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @param clearLists If true clear the children and postal code lists before add new ones, otherwise just append. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRegion",
        summary = "Update Region",
        description = "Update a region.",
        tags = { "Region" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RegionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_REGION,
        produces = { "*/*" }
    )
    default ResponseEntity<RegionResponse> updateRegion(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The id of the account sending the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "regionId", description = "The id of the region to be updated", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionId", required = true) Long regionId,
        @Parameter(name = "regionClass", description = "RegionClass of this region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "regionClass", required = false) @Nullable String regionClass,
        @Parameter(name = "shortName", description = "Short name of the region. This is optimized for search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "shortName", required = false) @Nullable String shortName,
        @Parameter(name = "fullName", description = "Full name of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fullName", required = false) @Nullable String fullName,
        @Parameter(name = "parentIds", description = "Comma separated region ids that are parents of this region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "childrenIds", description = "Comma separated region ids that are children of this region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "childrenIds", required = false) @Nullable String childrenIds,
        @Parameter(name = "postalCodeIds", description = "Comma separated postal code ids the region will include", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCodeIds", required = false) @Nullable String postalCodeIds,
        @Parameter(name = "locations", description = "Sets of name,lat,long used to create new postal codes assigned to the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "retailerLocationId", description = "the retailer location ID that the region is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = false) @Nullable Long retailerLocationId,
        @Parameter(name = "visibility", description = "The Visibility of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "categoryIds", description = "the categories that the region is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "the filters that the region is assigned to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "start", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Long start,
        @Parameter(name = "end", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "end", required = false) @Nullable Long end,
        @Parameter(name = "polygon", description = "the polygon of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "polygon", required = false) @Nullable String polygon,
        @Parameter(name = "metaData", description = "the meta data of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "latitude", description = "the latitude of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "versionCode", description = "the version code", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versionCode", required = false) @Nullable Integer versionCode,
        @Parameter(name = "root", description = "If this is a root region or not. If true means this region has no parent regions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "root", required = false) @Nullable Boolean root,
        @Parameter(name = "active", description = "Active or inactive status of the region", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "clearLists", description = "If true clear the children and postal code lists before add new ones, otherwise just append.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "clearLists", required = false) @Nullable Boolean clearLists
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RETAILER = "/api/{version}/retailer/update";
    /**
     * POST /api/{version}/retailer/update : Update Retailer
     * Update a retailer record. Only the owner and the employees of the retailer have access to update its information.
     *
     * @param version  (required)
     * @param retailerId The ID of the retailer to update (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRetailer",
        summary = "Update Retailer",
        description = "Update a retailer record. Only the owner and the employees of the retailer have access to update its information.",
        tags = { "Retailer" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RETAILER,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerFullResponse> updateRetailer(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerId", description = "The ID of the retailer to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerId", required = true) Long retailerId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "streetAddress", description = "The street address of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "the country of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "businessPhone", description = "The business phone of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "website", description = "The website of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "website", required = false) @Nullable String website,
        @Parameter(name = "email", description = "The email of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = false) @Nullable String email,
        @Parameter(name = "facebookUrl", description = "The facebook URL of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "facebookUrl", required = false) @Nullable String facebookUrl,
        @Parameter(name = "twitterUrl", description = "The twitter URL of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "twitterUrl", required = false) @Nullable String twitterUrl,
        @Parameter(name = "logo", description = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logo", required = false) @Nullable org.springframework.core.io.Resource logo,
        @Parameter(name = "logoAssetId", description = "The retailer logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logoAssetId", required = false) @Nullable Long logoAssetId,
        @Parameter(name = "picture1", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1", required = false) @Nullable org.springframework.core.io.Resource picture1,
        @Parameter(name = "picture1AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1AssetId", required = false) @Nullable Long picture1AssetId,
        @Parameter(name = "picture2", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2", required = false) @Nullable org.springframework.core.io.Resource picture2,
        @Parameter(name = "picture2AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2AssetId", required = false) @Nullable Long picture2AssetId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category IDs used to filter retailers by categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter IDs used to filter retailers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "latitude", description = "the latitude of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "searchTags", description = "External custom search keywords", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "retailerType", description = "External custom type identifier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerType", required = false) @Nullable String retailerType,
        @Parameter(name = "visibility", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the retailer is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "responseFormat", description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_RETAILER_LOCATIONS = "/api/{version}/retailer/location/update";
    /**
     * POST /api/{version}/retailer/location/update : Update Retailer Location
     * Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     *
     * @param version  (required)
     * @param retailerLocationId The ID of the retailer location (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer location (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension of the retailer location (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latituede of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the Google Place ID that the retailer location is associated with (optional)
     * @param yelpId the Yelp ID that the retailer location is associated with (optional)
     * @param metaData External custom client defined data (optional)
     * @param paymentProvider Specifies which payment provider Sirqul will use when making payments (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRetailerLocations",
        summary = "Update Retailer Location",
        description = "Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.",
        tags = { "Retailer Location" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RetailerLocationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_RETAILER_LOCATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<RetailerLocationResponse> updateRetailerLocations(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "retailerLocationId", description = "The ID of the retailer location", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "retailerLocationId", required = true) Long retailerLocationId,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "name", description = "The name of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "streetAddress", description = "The street address of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress", required = false) @Nullable String streetAddress,
        @Parameter(name = "streetAddress2", description = "Additional address information (such as a suite number, floor number, building name, or PO Box)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "streetAddress2", required = false) @Nullable String streetAddress2,
        @Parameter(name = "city", description = "The city of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The state of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "postalCode", description = "The postal code of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "postalCode", required = false) @Nullable String postalCode,
        @Parameter(name = "country", description = "the country of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "businessPhone", description = "The business phone number of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhone", required = false) @Nullable String businessPhone,
        @Parameter(name = "businessPhoneExt", description = "The business phone extension of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "businessPhoneExt", required = false) @Nullable String businessPhoneExt,
        @Parameter(name = "website", description = "The website of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "website", required = false) @Nullable String website,
        @Parameter(name = "email", description = "The email of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "email", required = false) @Nullable String email,
        @Parameter(name = "internalId", description = "An internal identifier used by the retailer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "internalId", required = false) @Nullable String internalId,
        @Parameter(name = "detailsHeader", description = "A brief description about the retailer location (255 character limit)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsHeader", required = false) @Nullable String detailsHeader,
        @Parameter(name = "detailsBody", description = "A detailed description about the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "detailsBody", required = false) @Nullable String detailsBody,
        @Parameter(name = "hours", description = "The hours of operation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "hours", required = false) @Nullable String hours,
        @Parameter(name = "logo", description = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logo", required = false) @Nullable org.springframework.core.io.Resource logo,
        @Parameter(name = "logoAssetId", description = "The retailer location logo asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "logoAssetId", required = false) @Nullable Long logoAssetId,
        @Parameter(name = "picture1", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1", required = false) @Nullable org.springframework.core.io.Resource picture1,
        @Parameter(name = "picture1AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture1AssetId", required = false) @Nullable Long picture1AssetId,
        @Parameter(name = "picture2", description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2", required = false) @Nullable org.springframework.core.io.Resource picture2,
        @Parameter(name = "picture2AssetId", description = "An asset id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "picture2AssetId", required = false) @Nullable Long picture2AssetId,
        @Parameter(name = "categoryIds", description = "Comma separated list of category IDs used to filter retailer locations by categories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "filterIds", description = "Comma separated list of filter IDs used to filter retailer locations", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filterIds", required = false) @Nullable String filterIds,
        @Parameter(name = "latitude", description = "the latituede of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "the longitude of the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "building", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "building", required = false) @Nullable String building,
        @Parameter(name = "googlePlaceId", description = "the Google Place ID that the retailer location is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "googlePlaceId", required = false) @Nullable String googlePlaceId,
        @Parameter(name = "yelpId", description = "the Yelp ID that the retailer location is associated with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "yelpId", required = false) @Nullable String yelpId,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "paymentProvider", description = "Specifies which payment provider Sirqul will use when making payments", in = ParameterIn.QUERY) @Valid @RequestParam(value = "paymentProvider", required = false) @Nullable String paymentProvider,
        @Parameter(name = "active", description = "Sets whether the retailer is active or inactive (hidden from consumers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "publicLocation", description = "Sets whether the location is public or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "publicLocation", required = false) @Nullable Boolean publicLocation,
        @Parameter(name = "locationType", description = "External custom type identifier", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationType", required = false) @Nullable String locationType,
        @Parameter(name = "audienceIds", description = "Comma separated list of audience IDs used to assign audiences to the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "audienceIdsToAdd", description = "Comma separated list of audience IDs to add to the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToAdd", required = false) @Nullable String audienceIdsToAdd,
        @Parameter(name = "audienceIdsToRemove", description = "Comma separated list of audience IDs to remove from the retailer location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIdsToRemove", required = false) @Nullable String audienceIdsToRemove,
        @Parameter(name = "responseFormat", description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "responseFormat", required = false) @Nullable String responseFormat,
        @Parameter(name = "tags", description = "Custom string field for doing full-text searches", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ROUTE = "/api/{version}/route/{routeId}";
    /**
     * PUT /api/{version}/route/{routeId} : Update Route
     * Update an existing route
     *
     * @param version  (required)
     * @param routeId the id of the route (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRoute",
        summary = "Update Route",
        description = "Update an existing route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Route.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_ROUTE,
        produces = { "*/*" }
    )
    default ResponseEntity<Route> updateRoute(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Route body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ROUTE_SETTINGS = "/api/{version}/route/setting/{routeSettingsId}";
    /**
     * PUT /api/{version}/route/setting/{routeSettingsId} : Update Route Setting
     * Update an existing route setting
     *
     * @param version  (required)
     * @param routeSettingsId the id of the route settings to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRouteSettings",
        summary = "Update Route Setting",
        description = "Update an existing route setting",
        tags = { "Route Setting" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = RouteSettings.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_ROUTE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<RouteSettings> updateRouteSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeSettingsId", description = "the id of the route settings to update", required = true, in = ParameterIn.PATH) @PathVariable("routeSettingsId") Long routeSettingsId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable RouteSettings body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_ROUTE_STOP = "/api/{version}/route/{routeId}/stop/{stopId}";
    /**
     * PUT /api/{version}/route/{routeId}/stop/{stopId} : Update Route Stop
     * Update a stop on a specified route
     *
     * @param version  (required)
     * @param routeId the id of the route to update stops for (required)
     * @param stopId the id of the specific stop to update on the route (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateRouteStop",
        summary = "Update Route Stop",
        description = "Update a stop on a specified route",
        tags = { "Route" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_ROUTE_STOP
    )
    default ResponseEntity<Void> updateRouteStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "routeId", description = "the id of the route to update stops for", required = true, in = ParameterIn.PATH) @PathVariable("routeId") Long routeId,
        @NotNull @Parameter(name = "stopId", description = "the id of the specific stop to update on the route", required = true, in = ParameterIn.PATH) @PathVariable("stopId") Long stopId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Stop body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SCHEDULED_NOTIFICATION = "/api/{version}/notification/schedule/update";
    /**
     * POST /api/{version}/notification/schedule/update : Update Scheduled Notification
     * This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     *
     * @param version  (required)
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateScheduledNotification",
        summary = "Update Scheduled Notification",
        description = "This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> updateScheduledNotification(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "scheduledNotificationId", description = "The id of scheduled notification to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "name", description = "The name of the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "type", description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "message", description = "The message to send", in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = false) @Nullable String message,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "contentId", description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "appKey", description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "connectionGroupIds", description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "connectionAccountIds", description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. The audience used to generate the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "albumIds", description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "reportId", description = "The report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportId", required = false) @Nullable Long reportId,
        @Parameter(name = "reportParams", description = "The parameters to supply to the report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "scheduledDate", description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "cronType", description = "The cron expression type: UNIX, CRON4J, QUARTZ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronType", required = false) @Nullable String cronType,
        @Parameter(name = "metaData", description = "Additional metadata for the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "templateType", description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateType", required = false) @Nullable String templateType,
        @Parameter(name = "visibility", description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "errorMessage", description = "the error message associated with the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "errorMessage", required = false) @Nullable String errorMessage,
        @Parameter(name = "status", description = "the status of the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "updateByGroupingId", description = "also updates ScheduledNotifications with the same groupingId and account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateByGroupingId", required = false) @Nullable Boolean updateByGroupingId,
        @Parameter(name = "sendNow", description = "whether to send the scheduled notification now or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendNow", required = false) @Nullable Boolean sendNow,
        @Parameter(name = "eventType", description = "Sets the event type for the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") String eventType,
        @Parameter(name = "deepLinkURI", description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deepLinkURI", required = false) @Nullable String deepLinkURI,
        @Parameter(name = "sendToAll", description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendToAll", required = false) @Nullable Boolean sendToAll
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SECURE_APPLICATION = "/api/{version}/secure/application/update";
    /**
     * POST /api/{version}/secure/application/update : Update Secure Application
     * Update a secure application record.
     *
     * @param version  (required)
     * @param accountId The unique id of the user making the request (required)
     * @param appKey The application to secure (required)
     * @param active  (optional)
     * @param keyCert  (optional)
     * @param trustStore  (optional)
     * @param username  (optional)
     * @param password  (optional)
     * @param biometricType The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL (optional)
     * @param biometricPosition The position for the biometric file uploaded (optional)
     * @param biometricPosition2 The position for each the biometric2 file uploaded (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateSecureApplication",
        summary = "Update Secure Application",
        description = "Update a secure application record.",
        tags = { "SecureApp" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SECURE_APPLICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateSecureApplication(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The unique id of the user making the request", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to secure", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "active", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "keyCert", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyCert", required = false) @Nullable org.springframework.core.io.Resource keyCert,
        @Parameter(name = "trustStore", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trustStore", required = false) @Nullable org.springframework.core.io.Resource trustStore,
        @Parameter(name = "username", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "username", required = false) @Nullable String username,
        @Parameter(name = "password", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "password", required = false) @Nullable String password,
        @Parameter(name = "biometricType", description = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricType", required = false) @Nullable String biometricType,
        @Parameter(name = "biometricPosition", description = "The position for the biometric file uploaded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricPosition", required = false) @Nullable String biometricPosition,
        @Parameter(name = "biometricPosition2", description = "The position for each the biometric2 file uploaded", in = ParameterIn.QUERY) @Valid @RequestParam(value = "biometricPosition2", required = false) @Nullable String biometricPosition2
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SETTINGS = "/api/{version}/account/settings/update";
    /**
     * POST /api/{version}/account/settings/update : Update Account Settings
     * Update the account settings for a user
     *
     * @param version  (required)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockedNotifications The notifications to be blocked (optional)
     * @param suggestionMethod How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS) (optional)
     * @param suggestionCount How many suggestions to receive per time frame (optional)
     * @param suggestionTimeFrame The time frame in seconds, 3600 would be a 1 hour time frame (optional)
     * @param showOthersExactLocation Show Others Exact Location (optional)
     * @param showAsZipcode Show As Zipcode (optional)
     * @param showExactLocation Show Exact Location (optional)
     * @param favoriteVisibility Show favorites (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateSettings",
        summary = "Update Account Settings",
        description = "Update the account settings for a user",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = UserSettingsResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SETTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<UserSettingsResponse> updateSettings(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @Parameter(name = "deviceId", description = "The device id (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "blockedNotifications", description = "The notifications to be blocked", in = ParameterIn.QUERY) @Valid @RequestParam(value = "blockedNotifications", required = false) @Nullable String blockedNotifications,
        @Parameter(name = "suggestionMethod", description = "How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionMethod", required = false) @Nullable String suggestionMethod,
        @Parameter(name = "suggestionCount", description = "How many suggestions to receive per time frame", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionCount", required = false) @Nullable Integer suggestionCount,
        @Parameter(name = "suggestionTimeFrame", description = "The time frame in seconds, 3600 would be a 1 hour time frame", in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionTimeFrame", required = false) @Nullable Integer suggestionTimeFrame,
        @Parameter(name = "showOthersExactLocation", description = "Show Others Exact Location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showOthersExactLocation", required = false) @Nullable Boolean showOthersExactLocation,
        @Parameter(name = "showAsZipcode", description = "Show As Zipcode", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showAsZipcode", required = false) @Nullable Boolean showAsZipcode,
        @Parameter(name = "showExactLocation", description = "Show Exact Location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "showExactLocation", required = false) @Nullable Boolean showExactLocation,
        @Parameter(name = "favoriteVisibility", description = "Show favorites", in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoriteVisibility", required = false) @Nullable String favoriteVisibility,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SHIPMENT = "/api/{version}/shipment/{id}";
    /**
     * PUT /api/{version}/shipment/{id} : Update Shipment
     * Update an existing shipment
     *
     * @param version  (required)
     * @param id the id of the shipment to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateShipment",
        summary = "Update Shipment",
        description = "Update an existing shipment",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Shipment.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_SHIPMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<Shipment> updateShipment(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the shipment to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Shipment body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SHIPMENT_STATUS = "/api/{version}/shipment/{id}/status";
    /**
     * POST /api/{version}/shipment/{id}/status : Uupdate Shipment Status
     * Update status of an existing shipment
     *
     * @param version  (required)
     * @param id the id of the shipment to update status (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateShipmentStatus",
        summary = "Uupdate Shipment Status",
        description = "Update status of an existing shipment",
        tags = { "Shipment" },
        responses = {
            @ApiResponse(responseCode = "default", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SHIPMENT_STATUS
    )
    default ResponseEntity<Void> updateShipmentStatus(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the shipment to update status", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Map<String, Boolean> body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SHIPMENTS = "/api/{version}/trip/{id}/shipments";
    /**
     * POST /api/{version}/trip/{id}/shipments : Update Trip Shipments
     *
     * @param version  (required)
     * @param id the id of the trip shipments to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateShipments",
        summary = "Update Trip Shipments",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SHIPMENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> updateShipments(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip shipments to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SPACE = "/api/{version}/vatom/b/spaces/update";
    /**
     * POST /api/{version}/vatom/b/spaces/update : Update Vatom Space
     * Update a Vatom space.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomSpaceId Vatom Space Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateSpace",
        summary = "Update Vatom Space",
        description = "Update a Vatom space.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SPACE
    )
    default ResponseEntity<Void> updateSpace(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomSpaceId", description = "Vatom Space Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomSpaceId", required = true) String vatomSpaceId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_STOP = "/api/{version}/stop/{id}";
    /**
     * PUT /api/{version}/stop/{id} : Update Stop
     * Update an existing stop
     *
     * @param version  (required)
     * @param id the id of the stop to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateStop",
        summary = "Update Stop",
        description = "Update an existing stop",
        tags = { "Stop" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Stop.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_STOP,
        produces = { "*/*" }
    )
    default ResponseEntity<Stop> updateStop(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the stop to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Stop body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SUBSCRIPTION = "/api/{version}/subscription/update";
    /**
     * POST /api/{version}/subscription/update : Update Subscription
     * Updates the subscription for the billable entity for an account
     *
     * @param version  (required)
     * @param accountId The account used to perform the update, must be the responsible manager (required)
     * @param planId The plan to subscribe to (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @param active Set active status (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateSubscription",
        summary = "Update Subscription",
        description = "Updates the subscription for the billable entity for an account",
        tags = { "Subscription" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SubscriptionResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_SUBSCRIPTION,
        produces = { "*/*" }
    )
    default ResponseEntity<SubscriptionResponse> updateSubscription(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The account used to perform the update, must be the responsible manager", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "planId", description = "The plan to subscribe to", in = ParameterIn.QUERY) @Valid @RequestParam(value = "planId", required = false) @Nullable Long planId,
        @Parameter(name = "promoCode", description = "Set a promo code for a discount.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "promoCode", required = false) @Nullable String promoCode,
        @Parameter(name = "active", description = "Set active status", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TASK = "/api/{version}/task/update";
    /**
     * POST /api/{version}/task/update : Update Task
     * Update a Task
     *
     * @param version  (required)
     * @param taskId Task Id (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the task (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTask",
        summary = "Update Task",
        description = "Update a Task",
        tags = { "Task" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TaskResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_TASK,
        produces = { "*/*" }
    )
    default ResponseEntity<TaskResponse> updateTask(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "taskId", description = "Task Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "taskId", required = true) Long taskId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "name", description = "The name of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "appKey", description = "The application to target", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping tasks", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The date and time of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The starting date of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The ending date of the task", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the task's schedule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "visibility", description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Task is active or not (inactive Tasks are not processed)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TERRITORY = "/api/{version}/territory/update";
    /**
     * POST /api/{version}/territory/update : Update Territory
     * Updates a territory.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param territoryId the id of the territory to update (required)
     * @param name The name of the territory (optional)
     * @param active If true set the game level as active. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTerritory",
        summary = "Update Territory",
        description = "Updates a territory.",
        tags = { "Territory" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TerritoryResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_TERRITORY,
        produces = { "*/*" }
    )
    default ResponseEntity<TerritoryResponse> updateTerritory(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "territoryId", description = "the id of the territory to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "territoryId", required = true) Long territoryId,
        @Parameter(name = "name", description = "The name of the territory", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "active", description = "If true set the game level as active.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TOURNAMENT = "/api/{version}/tournament/update";
    /**
     * POST /api/{version}/tournament/update : Update Tournament
     * Update a tournament.
     *
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param missionId The mission/tournament to update (required)
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTournament",
        summary = "Update Tournament",
        description = "Update a tournament.",
        tags = { "Tournament" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TournamentResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_TOURNAMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<TournamentResponse> updateTournament(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "missionId", description = "The mission/tournament to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "missionId", required = true) Long missionId,
        @Parameter(name = "title", description = "The title of the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "subType", description = "Custom string client apps can use for searching/filtering missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subType", required = false) @Nullable String subType,
        @Parameter(name = "imageAssetId", description = "The asset ID to attach to the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "imageAssetId", required = false) @Nullable Long imageAssetId,
        @Parameter(name = "secondsBetweenLevels", description = "The number of seconds in between the start of each tournament game", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsBetweenLevels", required = false) @Nullable Integer secondsBetweenLevels,
        @Parameter(name = "secondsForTieBreaker", description = "The number of seconds to extend the round end time in the case of a tie breaker", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsForTieBreaker", required = false) @Nullable Integer secondsForTieBreaker,
        @Parameter(name = "secondsBetweenPacks", description = "The number of seconds in between the start of each tournament round", in = ParameterIn.QUERY) @Valid @RequestParam(value = "secondsBetweenPacks", required = false) @Nullable Integer secondsBetweenPacks,
        @Parameter(name = "maximumLevelLength", description = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity", in = ParameterIn.QUERY) @Valid @RequestParam(value = "maximumLevelLength", required = false) @Nullable Integer maximumLevelLength,
        @Parameter(name = "costToPlay", description = "The number of tickets required to pay to enter the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "costToPlay", required = false) @Nullable Integer costToPlay,
        @Parameter(name = "costToPlayType", description = "The type of ticket required to pay", in = ParameterIn.QUERY) @Valid @RequestParam(value = "costToPlayType", required = false) @Nullable String costToPlayType,
        @Parameter(name = "minimumToPlay", description = "The minimum number of players required to sign up for the tournament to be played", in = ParameterIn.QUERY) @Valid @RequestParam(value = "minimumToPlay", required = false) @Nullable Integer minimumToPlay,
        @Parameter(name = "startingLimit", description = "The starting number of players for a tournament (filled with AI's)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startingLimit", required = false) @Nullable Integer startingLimit,
        @Parameter(name = "availableLimit", description = "The maximum number of players for a tournament (currently 128 but not enforced)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "availableLimit", required = false) @Nullable Integer availableLimit,
        @Parameter(name = "description", description = "The description of the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "startDate", description = "The date/time to start the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "audienceIds", description = "The audiences associated with the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "active", description = "Activate/deactivate the mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "enableBuyBack", description = "Determines whether to allow players to buy back into a tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableBuyBack", required = false) @Nullable Boolean enableBuyBack,
        @Parameter(name = "offerIds", description = "The list of offers to give as a reward beyond the tickets", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerIds", required = false) @Nullable String offerIds,
        @Parameter(name = "offerAssetId", description = "The artwork ID to attach to the reward offer", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offerAssetId", required = false) @Nullable Long offerAssetId,
        @Parameter(name = "fixedReward", description = "If set then do not update the ticket reward, auto set to true if offerIds provided", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fixedReward", required = false) @Nullable Boolean fixedReward,
        @Parameter(name = "splitReward", description = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", in = ParameterIn.QUERY) @Valid @RequestParam(value = "splitReward", required = false) @Nullable String splitReward,
        @Parameter(name = "allocateTickets", description = "Flag to indicate owner should receive tickets for completed missions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "tournamentData", description = "A text based string that will be passed into each tournament setup to populate the content", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tournamentData", required = false) @Nullable String tournamentData,
        @Parameter(name = "visibility", description = "Sets the visibility flag for the tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "preliminaryGroups", description = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preliminaryGroups", required = false) @Nullable Integer preliminaryGroups,
        @Parameter(name = "preliminaryGroupAdvancements", description = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "preliminaryGroupAdvancements", required = false) @Nullable String preliminaryGroupAdvancements,
        @Parameter(name = "enableMultipleEntries", description = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMultipleEntries", required = false) @Nullable Boolean enableMultipleEntries,
        @Parameter(name = "enableMultipleVotes", description = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament", in = ParameterIn.QUERY) @Valid @RequestParam(value = "enableMultipleVotes", required = false) @Nullable Boolean enableMultipleVotes,
        @Parameter(name = "featured", description = "This determines whether the tournament is \"featured\" or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "featured", required = false) @Nullable Boolean featured,
        @Parameter(name = "winnerTag", description = "This sets what analytic tag is used when a winner is determined", in = ParameterIn.QUERY) @Valid @RequestParam(value = "winnerTag", required = false) @Nullable String winnerTag,
        @Parameter(name = "tieTag", description = "This sets what analytic tag is used when a winner is determined", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tieTag", required = false) @Nullable String tieTag
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TRIGGER = "/api/{version}/trigger/update";
    /**
     * POST /api/{version}/trigger/update : Update Trigger
     * Update a trigger
     *
     * @param version  (required)
     * @param triggerId The trigger to update (required)
     * @param accountId The logged in user (required)
     * @param name The name of the trigger (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTrigger",
        summary = "Update Trigger",
        description = "Update a trigger",
        tags = { "Trigger" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = TriggerResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_TRIGGER,
        produces = { "*/*" }
    )
    default ResponseEntity<TriggerResponse> updateTrigger(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "triggerId", description = "The trigger to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "triggerId", required = true) Long triggerId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "name", description = "The name of the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "appKey", description = "The application to target", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping triggers", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The date and time of the next trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The starting date of the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The ending date of the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the trigger's schedule", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the trigger", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "visibility", description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Trigger is active or not (inactive Triggers are not processed)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TRIP = "/api/{version}/trip/{id}";
    /**
     * PUT /api/{version}/trip/{id} : Update Trip
     * Update an existing trip. Does not support recurring trip update.
     *
     * @param version  (required)
     * @param id the id of the trip to update (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTrip",
        summary = "Update Trip",
        description = "Update an existing trip. Does not support recurring trip update.",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_TRIP,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> updateTrip(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Trip body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_TRIP_NOTIFICATIONS = "/api/{version}/trip/notifications";
    /**
     * POST /api/{version}/trip/notifications : Trip Notifications
     * Update the trip notifications
     *
     * @param version  (required)
     * @param id the id of the trip (required)
     * @param notifications the notifications to update on the trip (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateTripNotifications",
        summary = "Trip Notifications",
        description = "Update the trip notifications",
        tags = { "Trip" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Trip.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_TRIP_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<Trip> updateTripNotifications(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "the id of the trip", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "id", required = true) Long id,
        @Parameter(name = "notifications", description = "the notifications to update on the trip", in = ParameterIn.QUERY) @Valid @RequestParam(value = "notifications", required = false) @Nullable String notifications
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_USER_ACHIEVEMENT = "/api/{version}/achievement/progress/update";
    /**
     * POST /api/{version}/achievement/progress/update : Update Achievement Progress
     * Update user achievement progress.
     *
     * @param version  (required)
     * @param accountId the account id of the user (required)
     * @param achievementId the achievement id (achievementId or tag required) (optional)
     * @param tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param customId a custom identifier used for validation (optional)
     * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param startDate a custom start date that the client can set (not yet used in server logic) (optional)
     * @param endDate a custom end date that the client can set (not yet used in server logic) (optional)
     * @param returnProgress determines whether to return the achievement progress response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateUserAchievement",
        summary = "Update Achievement Progress",
        description = "Update user achievement progress.",
        tags = { "Achievement" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_USER_ACHIEVEMENT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateUserAchievement(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "achievementId", description = "the achievement id (achievementId or tag required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementId", required = false) @Nullable Long achievementId,
        @Parameter(name = "tag", description = "the analytic tag to identify an achievement (achievementId or tag required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tag", required = false) @Nullable String tag,
        @Parameter(name = "customId", description = "a custom identifier used for validation", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customId", required = false) @Nullable Long customId,
        @Parameter(name = "increment", description = "the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "increment", required = false) @Nullable Long increment,
        @Parameter(name = "startDate", description = "a custom start date that the client can set (not yet used in server logic)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "a custom end date that the client can set (not yet used in server logic)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "returnProgress", description = "determines whether to return the achievement progress response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnProgress", required = false) @Nullable Boolean returnProgress
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_USER_COINS_AS_BUSINESS = "/api/{version}/vatom/b/users/coins/update";
    /**
     * POST /api/{version}/vatom/b/users/coins/update : Update the coins for a user (as a Business)
     * Update the coins for a user (as a Business).
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomUserId Vatom User Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateUserCoinsAsBusiness",
        summary = "Update the coins for a user (as a Business)",
        description = "Update the coins for a user (as a Business).",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_USER_COINS_AS_BUSINESS
    )
    default ResponseEntity<Void> updateUserCoinsAsBusiness(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomUserId", description = "Vatom User Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomUserId", required = true) String vatomUserId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_USER_PROFILE = "/api/{version}/vatom/me/update";
    /**
     * POST /api/{version}/vatom/me/update : Update Vatom User Profile
     * Gets the logged in user&#39;s profile in Vatom.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateUserProfile",
        summary = "Update Vatom User Profile",
        description = "Gets the logged in user's profile in Vatom.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_USER_PROFILE
    )
    default ResponseEntity<Void> updateUserProfile(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_VATOM_EVENT = "/api/{version}/vatom/b/events/update";
    /**
     * POST /api/{version}/vatom/b/events/update : Update Vatom Event
     * Update a Vatom event.
     *
     * @param version  (required)
     * @param accountId Sirqul Account Id (required)
     * @param appKey Sirqul Application Key (required)
     * @param vatomEventId Vatom Event Id (required)
     * @param vatomParameters Vatom Parameters (required)
     * @param returnRawResponse Return raw response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateVatomEvent",
        summary = "Update Vatom Event",
        description = "Update a Vatom event.",
        tags = { "Vatom" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_VATOM_EVENT
    )
    default ResponseEntity<Void> updateVatomEvent(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "Sirqul Account Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "Sirqul Application Key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "vatomEventId", description = "Vatom Event Id", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomEventId", required = true) String vatomEventId,
        @NotNull @Parameter(name = "vatomParameters", description = "Vatom Parameters", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vatomParameters", required = true) String vatomParameters,
        @Parameter(name = "returnRawResponse", description = "Return raw response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnRawResponse", required = false) @Nullable Boolean returnRawResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_VEHICLE = "/api/{version}/vehicle/{id}";
    /**
     * PUT /api/{version}/vehicle/{id} : Update Vehicle
     * Update an existing vehicle
     *
     * @param version  (required)
     * @param id The id of the vehicle to update (required)
     * @param vehicle A JSON representation of cargo type, for example: &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Truck\&quot;,   \&quot;vehicleType\&quot;: { \&quot;id\&quot;: 1 },   \&quot;hub\&quot;: { \&quot;id\&quot;: 1 } } &#x60;&#x60;&#x60;  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateVehicle",
        summary = "Update Vehicle",
        description = "Update an existing vehicle",
        tags = { "Vehicle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Vehicle.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_VEHICLE,
        produces = { "*/*" }
    )
    default ResponseEntity<Vehicle> updateVehicle(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "id", description = "The id of the vehicle to update", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @NotNull @Parameter(name = "vehicle", description = "A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vehicle", required = true) String vehicle,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable Vehicle body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_VEHICLE_TYPE = "/api/{version}/vehicle/type/{vehicleTypeId}";
    /**
     * PUT /api/{version}/vehicle/type/{vehicleTypeId} : Update Vehicle Type
     * Update a vehicle type
     *
     * @param version  (required)
     * @param vehicleTypeId The id of the vehicle type to update (required)
     * @param vehicleType The new data for the vehicle type to update to. A JSON representation of cargo type, for example: &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Truck\&quot;,   \&quot;width\&quot;: 100,   \&quot;height\&quot;: 200,   \&quot;depth\&quot;: 200,   \&quot;maxWeight\&quot;: 5000,   \&quot;hub\&quot;: { \&quot;id\&quot;: 1 } } &#x60;&#x60;&#x60;  (required)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateVehicleType",
        summary = "Update Vehicle Type",
        description = "Update a vehicle type",
        tags = { "Vehicle Type" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = VehicleType.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ApiApi.PATH_UPDATE_VEHICLE_TYPE,
        produces = { "*/*" }
    )
    default ResponseEntity<VehicleType> updateVehicleType(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "vehicleTypeId", description = "The id of the vehicle type to update", required = true, in = ParameterIn.PATH) @PathVariable("vehicleTypeId") Long vehicleTypeId,
        @NotNull @Parameter(name = "vehicleType", description = "The new data for the vehicle type to update to. A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "vehicleType", required = true) String vehicleType,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable VehicleType body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_WORD = "/api/{version}/game/word/update";
    /**
     * POST /api/{version}/game/word/update : Update Word
     * Update a word by the given params.
     *
     * @param version  (required)
     * @param wordId The id of the word to update. (required)
     * @param accountId The logged in user. (required)
     * @param ticketCount The number of tickets to reward (required)
     * @param wordText The text for the word (optional)
     * @param definition The definition of the word. (optional)
     * @param assetId The asset id of the word. (optional)
     * @param active If true set the word to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateWord",
        summary = "Update Word",
        description = "Update a word by the given params.",
        tags = { "Word" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = WordzWordResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_WORD,
        produces = { "*/*" }
    )
    default ResponseEntity<WordzWordResponse> updateWord(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "wordId", description = "The id of the word to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "wordId", required = true) Long wordId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "ticketCount", description = "The number of tickets to reward", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketCount", required = true, defaultValue = "0") Long ticketCount,
        @Parameter(name = "wordText", description = "The text for the word", in = ParameterIn.QUERY) @Valid @RequestParam(value = "wordText", required = false) @Nullable String wordText,
        @Parameter(name = "definition", description = "The definition of the word.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "definition", required = false) @Nullable String definition,
        @Parameter(name = "assetId", description = "The asset id of the word.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "assetId", required = false) @Nullable Long assetId,
        @Parameter(name = "active", description = "If true set the word to active.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "allocateTickets", description = "If true then scoring will give tickets.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "allocateTickets", required = false) @Nullable Boolean allocateTickets,
        @Parameter(name = "ticketType", description = "The type of ticket to reward, null means default type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ticketType", required = false) @Nullable String ticketType,
        @Parameter(name = "points", description = "The number of points to award for completing a mission", in = ParameterIn.QUERY) @Valid @RequestParam(value = "points", required = false) @Nullable Long points
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_WORDS_IN_LEVEL = "/api/{version}/level/words/update";
    /**
     * POST /api/{version}/level/words/update : Update Level Words
     * Updates a level with word game objects.
     *
     * @param version  (required)
     * @param levelId the id of the level to update words for (required)
     * @param accountId the id of the logged in user (required)
     * @param wordIds the ids of the words to update for the level (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateWordsInLevel",
        summary = "Update Level Words",
        description = "Updates a level with word game objects.",
        tags = { "Game Level" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPDATE_WORDS_IN_LEVEL,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> updateWordsInLevel(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "levelId", description = "the id of the level to update words for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "levelId", required = true) Long levelId,
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "wordIds", description = "the ids of the words to update for the level", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "wordIds", required = true) String wordIds
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPLOAD_APPLICATION_CERTIFICATE = "/api/{version}/application/certificate/create";
    /**
     * POST /api/{version}/application/certificate/create : Create Application Certificate
     * Uploads a certificate for an application that the user has access to.
     *
     * @param version  (required)
     * @param appKey The key of the application (required)
     * @param deviceId Device Id (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the application. (optional)
     * @param certificate Certificate (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "uploadApplicationCertificate",
        summary = "Create Application Certificate",
        description = "Uploads a certificate for an application that the user has access to.",
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPLOAD_APPLICATION_CERTIFICATE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> uploadApplicationCertificate(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The key of the application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "deviceId", description = "Device Id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account used to perform the delete, must have rights to edit the application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "certificate", description = "Certificate", in = ParameterIn.QUERY) @Valid @RequestParam(value = "certificate", required = false) @Nullable org.springframework.core.io.Resource certificate
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPLOAD_CSV = "/api/{version}/csvimport/upload";
    /**
     * POST /api/{version}/csvimport/upload : Upload CSV
     * Uploads a CSV import file.
     *
     * @param version  (required)
     * @param accountId the id of the account (required)
     * @param uploadType the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS (required)
     * @param importFile the import file to reference (required)
     * @param fileFormat the format of the file (required)
     * @param appKey the application key (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "uploadCSV",
        summary = "Upload CSV",
        description = "Uploads a CSV import file.",
        tags = { "CSV Import" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = CsvImportResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_UPLOAD_CSV,
        produces = { "*/*" }
    )
    default ResponseEntity<CsvImportResponse> uploadCSV(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "uploadType", description = "the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "uploadType", required = true) String uploadType,
        @NotNull @Parameter(name = "importFile", description = "the import file to reference", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "importFile", required = true) org.springframework.core.io.Resource importFile,
        @NotNull @Parameter(name = "fileFormat", description = "the format of the file", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fileFormat", required = true) String fileFormat,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_USAGE = "/api/{version}/analytics/usage";
    /**
     * POST /api/{version}/analytics/usage : Create Usage Record
     * Record an analytic record for a known state within the application.
     *
     * @param version  (required)
     * @param tag The tag to apply: the name of the action or thing being logged. (required)
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param applicationId This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param appVersion The current build version of the application (optional)
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param latitude The current position of the user (optional)
     * @param longitude The current position of the user (optional)
     * @param customId A customId used to associate the usage record with some other record in the system (optional)
     * @param customType The type of record the customId is recorded for (optional)
     * @param achievementIncrement This parameter is deprecated. This is deprecated, use \&quot;customValue\&quot;. Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement (optional)
     * @param city The current city of the user (optional)
     * @param state The current state of the user (optional)
     * @param country The current country of the user (optional)
     * @param zip The current zip of the user (optional)
     * @param locationDescription The general description of the user&#39;s location (optional)
     * @param clientTime Timestamp sent from device (optional)
     * @param errorMessage This parameter is deprecated. (optional)
     * @param ip the ip address of the client device (optional)
     * @param userAgent this is a description of the client (might contain the device&#39;s OS, browser version etc - its a common term) (optional)
     * @param backgroundEvent This is deprecated. (optional)
     * @param customMessage a custom message for the usage record (optional)
     * @param customMessage2 a custom message for the usage record (optional)
     * @param customValue a custom value for the usage record (optional)
     * @param customValue2 a custom value for the usage record (optional)
     * @param customLong a custom long value for the usage record (optional)
     * @param customLong2 a custom long value for the usage record (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "usage",
        summary = "Create Usage Record",
        description = "Record an analytic record for a known state within the application.",
        tags = { "Analytics" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_USAGE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> usage(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "tag", description = "The tag to apply: the name of the action or thing being logged.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "tag", required = true) String tag,
        @Parameter(name = "deviceId", description = "The client deviceID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The logged in user ID", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "applicationId", description = "This parameter is deprecated. This is deprecated, use appKey.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationId", required = false) @Nullable Long applicationId,
        @Parameter(name = "appKey", description = "The application key unique to each application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "appVersion", description = "The current build version of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "device", description = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = false) @Nullable String device,
        @Parameter(name = "deviceType", description = "The type of device (Handheld or Desktop)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "deviceOS", description = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceOS", required = false) @Nullable String deviceOS,
        @Parameter(name = "model", description = "The model of the device (iPhone5,1 , Nexus One, etc.)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "model", required = false) @Nullable String model,
        @Parameter(name = "latitude", description = "The current position of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current position of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "customId", description = "A customId used to associate the usage record with some other record in the system", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customId", required = false) @Nullable Long customId,
        @Parameter(name = "customType", description = "The type of record the customId is recorded for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customType", required = false) @Nullable String customType,
        @Parameter(name = "achievementIncrement", description = "This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement", in = ParameterIn.QUERY) @Valid @RequestParam(value = "achievementIncrement", required = false) @Nullable Long achievementIncrement,
        @Parameter(name = "city", description = "The current city of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "city", required = false) @Nullable String city,
        @Parameter(name = "state", description = "The current state of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) @Nullable String state,
        @Parameter(name = "country", description = "The current country of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "country", required = false) @Nullable String country,
        @Parameter(name = "zip", description = "The current zip of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "zip", required = false) @Nullable String zip,
        @Parameter(name = "locationDescription", description = "The general description of the user's location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locationDescription", required = false) @Nullable String locationDescription,
        @Parameter(name = "clientTime", description = "Timestamp sent from device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "clientTime", required = false) @Nullable Long clientTime,
        @Parameter(name = "errorMessage", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "errorMessage", required = false) @Nullable String errorMessage,
        @Parameter(name = "ip", description = "the ip address of the client device", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ip", required = false) @Nullable String ip,
        @Parameter(name = "userAgent", description = "this is a description of the client (might contain the device's OS, browser version etc - its a common term)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "userAgent", required = false) @Nullable String userAgent,
        @Parameter(name = "backgroundEvent", description = "This is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "backgroundEvent", required = false) @Nullable Boolean backgroundEvent,
        @Parameter(name = "customMessage", description = "a custom message for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = false) @Nullable String customMessage,
        @Parameter(name = "customMessage2", description = "a custom message for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage2", required = false) @Nullable String customMessage2,
        @Parameter(name = "customValue", description = "a custom value for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customValue", required = false) @Nullable Double customValue,
        @Parameter(name = "customValue2", description = "a custom value for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customValue2", required = false) @Nullable Double customValue2,
        @Parameter(name = "customLong", description = "a custom long value for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customLong", required = false) @Nullable Long customLong,
        @Parameter(name = "customLong2", description = "a custom long value for the usage record", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customLong2", required = false) @Nullable Long customLong2
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_USAGE_BATCH = "/api/{version}/analytics/usage/batch";
    /**
     * POST /api/{version}/analytics/usage/batch : Create Multiple Usage Records
     * Sends multiple analytics. Can be used to send in the user&#39;s stored usage when they did not have internet access. Should not include more than 100 items per batch.
     *
     * @param version  (required)
     * @param appKey The application key unique to each application. (required)
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (required)
     * @param data The analytic data AnalyticListResponse (required)
     * @param deviceId The unique id of the device making the request (optional)
     * @param accountId The account ID of the logged in user making the request (optional)
     * @param appVersion The current build version of the application (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param updateRanking Will create a leaderboard if one does not exist for the \&quot;tag\&quot; yet (optional)
     * @param returnSummaryResponse Returns a summary response of the achievements that have been completed due to the analytics (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "usageBatch",
        summary = "Create Multiple Usage Records",
        description = "Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.",
        tags = { "Analytics" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_USAGE_BATCH,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> usageBatch(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "appKey", description = "The application key unique to each application.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "device", description = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "device", required = true) String device,
        @NotNull @Parameter(name = "data", description = "The analytic data AnalyticListResponse", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the logged in user making the request", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appVersion", description = "The current build version of the application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appVersion", required = false) @Nullable String appVersion,
        @Parameter(name = "deviceType", description = "The type of device (Handheld or Desktop)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceType", required = false) @Nullable String deviceType,
        @Parameter(name = "deviceOS", description = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceOS", required = false) @Nullable String deviceOS,
        @Parameter(name = "model", description = "The model of the device (iPhone5,1 , Nexus One, etc.)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "model", required = false) @Nullable String model,
        @Parameter(name = "updateRanking", description = "Will create a leaderboard if one does not exist for the \"tag\" yet", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateRanking", required = false) @Nullable Boolean updateRanking,
        @Parameter(name = "returnSummaryResponse", description = "Returns a summary response of the achievements that have been completed due to the analytics", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnSummaryResponse", required = false) @Nullable Boolean returnSummaryResponse
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_VALIDATE_ACCOUNT_SIGNUP = "/api/{version}/account/validateAccountSignup";
    /**
     * POST /api/{version}/account/validateAccountSignup : Save Validation Status
     * Validate the account&#39;s email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
     *
     * @param version  (required)
     * @param token The token associated with the account to update, good for 24 hours (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "validateAccountSignup",
        summary = "Save Validation Status",
        description = "Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AccountLoginResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_VALIDATE_ACCOUNT_SIGNUP,
        produces = { "*/*" }
    )
    default ResponseEntity<AccountLoginResponse> validateAccountSignup(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "token", description = "The token associated with the account to update, good for 24 hours", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_VALIDATE_PASSWORD_RESET = "/api/{version}/account/validatepasswordreset";
    /**
     * POST /api/{version}/account/validatepasswordreset : Validate Password Reset Token
     * Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
     *
     * @param version  (required)
     * @param token The token associated with the account to update, good for 24 hours (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "validatePasswordReset",
        summary = "Validate Password Reset Token",
        description = "Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.",
        tags = { "Account" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_VALIDATE_PASSWORD_RESET,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> validatePasswordReset(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "token", description = "The token associated with the account to update, good for 24 hours", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_VOTE_ON_ALBUM_CONTEST = "/api/{version}/consumer/album/contest/vote";
    /**
     * POST /api/{version}/consumer/album/contest/vote : Vote on Contest
     * Vote on a collection in a contest.
     *
     * @param version  (required)
     * @param albumContestId the album contest ID (required)
     * @param albumId the ID of the album to vote on (required)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param contestType a custom field used for aggregation and searching (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "voteOnAlbumContest",
        summary = "Vote on Contest",
        description = "Vote on a collection in a contest.",
        tags = { "Contest" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AlbumContestResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ApiApi.PATH_VOTE_ON_ALBUM_CONTEST,
        produces = { "*/*" }
    )
    default ResponseEntity<AlbumContestResponse> voteOnAlbumContest(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "albumContestId", description = "the album contest ID", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumContestId", required = true) Long albumContestId,
        @NotNull @Parameter(name = "albumId", description = "the ID of the album to vote on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumId", required = true) Long albumId,
        @Parameter(name = "deviceId", description = "a unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "contestType", description = "a custom field used for aggregation and searching", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contestType", required = false) @Nullable String contestType,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_WHO_HAS_FAVORITED = "/api/{version}/favorite/whois";
    /**
     * GET /api/{version}/favorite/whois : Who has Favorited
     * Searches for everyone that has favorited an item
     *
     * @param version  (required)
     * @param favoritableId The ID of the favoritableType to search on (required)
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (required)
     * @param start The start index for pagination (required)
     * @param limit The limit for pagination (required)
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param keyword The keyword to limit that account list (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "whoHasFavorited",
        summary = "Who has Favorited",
        description = "Searches for everyone that has favorited an item",
        tags = { "Favorite" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AccountResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ApiApi.PATH_WHO_HAS_FAVORITED,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AccountResponse>> whoHasFavorited(
        @NotNull @Parameter(name = "version", description = "", required = true, in = ParameterIn.PATH) @PathVariable("version") BigDecimal version,
        @NotNull @Parameter(name = "favoritableId", description = "The ID of the favoritableType to search on", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableId", required = true) Long favoritableId,
        @NotNull @Parameter(name = "favoritableType", description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "favoritableType", required = true) String favoritableType,
        @NotNull @Parameter(name = "start", description = "The start index for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit for pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "deviceId", description = "The unique ID given by the device (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account ID of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "latitude", description = "The current latitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "The current longitude of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "keyword", description = "The keyword to limit that account list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
