// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * API version: 3.16
 * Contact: info@sirqul.com
 */

package openapi

import (
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// TrackingAPIController binds http requests to an api service and writes the service results to the http response
type TrackingAPIController struct {
	service TrackingAPIServicer
	errorHandler ErrorHandler
}

// TrackingAPIOption for how the controller is set up.
type TrackingAPIOption func(*TrackingAPIController)

// WithTrackingAPIErrorHandler inject ErrorHandler into controller
func WithTrackingAPIErrorHandler(h ErrorHandler) TrackingAPIOption {
	return func(c *TrackingAPIController) {
		c.errorHandler = h
	}
}

// NewTrackingAPIController creates a default api controller
func NewTrackingAPIController(s TrackingAPIServicer, opts ...TrackingAPIOption) *TrackingAPIController {
	controller := &TrackingAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the TrackingAPIController
func (c *TrackingAPIController) Routes() Routes {
	return Routes{
		"BatchSaveTracking": Route{
			"BatchSaveTracking",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/batch/create",
			c.BatchSaveTracking,
		},
		"SaveTrackingLeg": Route{
			"SaveTrackingLeg",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/leg/create",
			c.SaveTrackingLeg,
		},
		"SearchAccountsWithTrackingLegs": Route{
			"SearchAccountsWithTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/list",
			c.SearchAccountsWithTrackingLegs,
		},
		"GetPredictedPath": Route{
			"GetPredictedPath",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/path/get",
			c.GetPredictedPath,
		},
		"GetPredictedLocations": Route{
			"GetPredictedLocations",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/predicted/get",
			c.GetPredictedLocations,
		},
		"GetPreferredLocations": Route{
			"GetPreferredLocations",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/preferred/search",
			c.GetPreferredLocations,
		},
		"GetTrackingLegs": Route{
			"GetTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/search",
			c.GetTrackingLegs,
		},
		"SaveTrackingStep": Route{
			"SaveTrackingStep",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/step/create",
			c.SaveTrackingStep,
		},
		"SearchTrackingLegs": Route{
			"SearchTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/searchByBillable",
			c.SearchTrackingLegs,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the TrackingAPIController
func (c *TrackingAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"BatchSaveTracking",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/batch/create",
			c.BatchSaveTracking,
		},
		Route{
			"SaveTrackingLeg",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/leg/create",
			c.SaveTrackingLeg,
		},
		Route{
			"SearchAccountsWithTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/list",
			c.SearchAccountsWithTrackingLegs,
		},
		Route{
			"GetPredictedPath",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/path/get",
			c.GetPredictedPath,
		},
		Route{
			"GetPredictedLocations",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/predicted/get",
			c.GetPredictedLocations,
		},
		Route{
			"GetPreferredLocations",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/preferred/search",
			c.GetPreferredLocations,
		},
		Route{
			"GetTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/search",
			c.GetTrackingLegs,
		},
		Route{
			"SaveTrackingStep",
			strings.ToUpper("Post"),
			"/api/{version}/tracking/step/create",
			c.SaveTrackingStep,
		},
		Route{
			"SearchTrackingLegs",
			strings.ToUpper("Get"),
			"/api/{version}/tracking/searchByBillable",
			c.SearchTrackingLegs,
		},
	}
}



// BatchSaveTracking - Create Batch Tracking
func (c *TrackingAPIController) BatchSaveTracking(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var dataParam string
	if query.Has("data") {
		param := query.Get("data")

		dataParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "data"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var generateAccountsParam bool
	if query.Has("generateAccounts") {
		param, err := parseBoolParameter(
			query.Get("generateAccounts"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "generateAccounts", Err: err}, nil)
			return
		}

		generateAccountsParam = param
	} else {
	}
	var updateAccountLocationsParam bool
	if query.Has("updateAccountLocations") {
		param, err := parseBoolParameter(
			query.Get("updateAccountLocations"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "updateAccountLocations", Err: err}, nil)
			return
		}

		updateAccountLocationsParam = param
	} else {
	}
	var defaultTagParam string
	if query.Has("defaultTag") {
		param := query.Get("defaultTag")

		defaultTagParam = param
	} else {
		param := "PASSIVE"
		defaultTagParam = param
	}
	var slaveUIDParam string
	if query.Has("slaveUID") {
		param := query.Get("slaveUID")

		slaveUIDParam = param
	} else {
	}
	result, err := c.service.BatchSaveTracking(r.Context(), versionParam, dataParam, deviceIdParam, accountIdParam, generateAccountsParam, updateAccountLocationsParam, defaultTagParam, slaveUIDParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SaveTrackingLeg - Create Tracking Leg
func (c *TrackingAPIController) SaveTrackingLeg(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var startLatParam float64
	if query.Has("startLat") {
		param, err := parseNumericParameter[float64](
			query.Get("startLat"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startLat", Err: err}, nil)
			return
		}

		startLatParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startLat"}, nil)
		return
	}
	var startLngParam float64
	if query.Has("startLng") {
		param, err := parseNumericParameter[float64](
			query.Get("startLng"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startLng", Err: err}, nil)
			return
		}

		startLngParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startLng"}, nil)
		return
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startDate"}, nil)
		return
	}
	var endLatParam float64
	if query.Has("endLat") {
		param, err := parseNumericParameter[float64](
			query.Get("endLat"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endLat", Err: err}, nil)
			return
		}

		endLatParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endLat"}, nil)
		return
	}
	var endLngParam float64
	if query.Has("endLng") {
		param, err := parseNumericParameter[float64](
			query.Get("endLng"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endLng", Err: err}, nil)
			return
		}

		endLngParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endLng"}, nil)
		return
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endDate"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var distanceParam float64
	if query.Has("distance") {
		param, err := parseNumericParameter[float64](
			query.Get("distance"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "distance", Err: err}, nil)
			return
		}

		distanceParam = param
	} else {
	}
	var durationParam int64
	if query.Has("duration") {
		param, err := parseNumericParameter[int64](
			query.Get("duration"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "duration", Err: err}, nil)
			return
		}

		durationParam = param
	} else {
	}
	var stepsParam string
	if query.Has("steps") {
		param := query.Get("steps")

		stepsParam = param
	} else {
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
	}
	result, err := c.service.SaveTrackingLeg(r.Context(), versionParam, startLatParam, startLngParam, startDateParam, endLatParam, endLngParam, endDateParam, deviceIdParam, accountIdParam, distanceParam, durationParam, stepsParam, tagsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SearchAccountsWithTrackingLegs - List Tracking
func (c *TrackingAPIController) SearchAccountsWithTrackingLegs(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var keywordParam string
	if query.Has("keyword") {
		param := query.Get("keyword")

		keywordParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
	}
	var audienceIdsParam string
	if query.Has("audienceIds") {
		param := query.Get("audienceIds")

		audienceIdsParam = param
	} else {
	}
	var latitudeParam float64
	if query.Has("latitude") {
		param, err := parseNumericParameter[float64](
			query.Get("latitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "latitude", Err: err}, nil)
			return
		}

		latitudeParam = param
	} else {
	}
	var longitudeParam float64
	if query.Has("longitude") {
		param, err := parseNumericParameter[float64](
			query.Get("longitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "longitude", Err: err}, nil)
			return
		}

		longitudeParam = param
	} else {
	}
	var range_Param float64
	if query.Has("range") {
		param, err := parseNumericParameter[float64](
			query.Get("range"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "range", Err: err}, nil)
			return
		}

		range_Param = param
	} else {
		var param float64 = 5
		range_Param = param
	}
	var sortFieldParam string
	if query.Has("sortField") {
		param := query.Get("sortField")

		sortFieldParam = param
	} else {
		param := "LEG_START_DATE"
		sortFieldParam = param
	}
	var descendingParam bool
	if query.Has("descending") {
		param, err := parseBoolParameter(
			query.Get("descending"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "descending", Err: err}, nil)
			return
		}

		descendingParam = param
	} else {
		var param bool = true
		descendingParam = param
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
		var param int32 = 0
		startParam = param
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var activeOnlyParam bool
	if query.Has("activeOnly") {
		param, err := parseBoolParameter(
			query.Get("activeOnly"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "activeOnly", Err: err}, nil)
			return
		}

		activeOnlyParam = param
	} else {
		var param bool = false
		activeOnlyParam = param
	}
	result, err := c.service.SearchAccountsWithTrackingLegs(r.Context(), versionParam, accountIdParam, keywordParam, startDateParam, endDateParam, tagsParam, audienceIdsParam, latitudeParam, longitudeParam, range_Param, sortFieldParam, descendingParam, startParam, limitParam, activeOnlyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPredictedPath - Get Tracking Path
func (c *TrackingAPIController) GetPredictedPath(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var startStepIdParam int64
	if query.Has("startStepId") {
		param, err := parseNumericParameter[int64](
			query.Get("startStepId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startStepId", Err: err}, nil)
			return
		}

		startStepIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startStepId"}, nil)
		return
	}
	var endStepIdParam int64
	if query.Has("endStepId") {
		param, err := parseNumericParameter[int64](
			query.Get("endStepId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endStepId", Err: err}, nil)
			return
		}

		endStepIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endStepId"}, nil)
		return
	}
	result, err := c.service.GetPredictedPath(r.Context(), versionParam, accountIdParam, startStepIdParam, endStepIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPredictedLocations - Get Predicted Locations
func (c *TrackingAPIController) GetPredictedLocations(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var latitudeParam float64
	if query.Has("latitude") {
		param, err := parseNumericParameter[float64](
			query.Get("latitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "latitude", Err: err}, nil)
			return
		}

		latitudeParam = param
	} else {
	}
	var longitudeParam float64
	if query.Has("longitude") {
		param, err := parseNumericParameter[float64](
			query.Get("longitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "longitude", Err: err}, nil)
			return
		}

		longitudeParam = param
	} else {
	}
	var dateCheckParam int64
	if query.Has("dateCheck") {
		param, err := parseNumericParameter[int64](
			query.Get("dateCheck"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "dateCheck", Err: err}, nil)
			return
		}

		dateCheckParam = param
	} else {
	}
	var hourCheckParam string
	if query.Has("hourCheck") {
		param := query.Get("hourCheck")

		hourCheckParam = param
	} else {
	}
	var thresholdParam int64
	if query.Has("threshold") {
		param, err := parseNumericParameter[int64](
			query.Get("threshold"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "threshold", Err: err}, nil)
			return
		}

		thresholdParam = param
	} else {
		var param int64 = 1
		thresholdParam = param
	}
	var distanceUnitParam string
	if query.Has("distanceUnit") {
		param := query.Get("distanceUnit")

		distanceUnitParam = param
	} else {
		param := "MILES"
		distanceUnitParam = param
	}
	var searchRangeParam float64
	if query.Has("searchRange") {
		param, err := parseNumericParameter[float64](
			query.Get("searchRange"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "searchRange", Err: err}, nil)
			return
		}

		searchRangeParam = param
	} else {
		var param float64 = 0
		searchRangeParam = param
	}
	var sortOrderParam string
	if query.Has("sortOrder") {
		param := query.Get("sortOrder")

		sortOrderParam = param
	} else {
		param := "MATCHES"
		sortOrderParam = param
	}
	result, err := c.service.GetPredictedLocations(r.Context(), versionParam, accountIdParam, latitudeParam, longitudeParam, dateCheckParam, hourCheckParam, thresholdParam, distanceUnitParam, searchRangeParam, sortOrderParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPreferredLocations - Search Preferred Locations
func (c *TrackingAPIController) GetPreferredLocations(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var latitudeParam float64
	if query.Has("latitude") {
		param, err := parseNumericParameter[float64](
			query.Get("latitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "latitude", Err: err}, nil)
			return
		}

		latitudeParam = param
	} else {
	}
	var longitudeParam float64
	if query.Has("longitude") {
		param, err := parseNumericParameter[float64](
			query.Get("longitude"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "longitude", Err: err}, nil)
			return
		}

		longitudeParam = param
	} else {
	}
	var dateCheckParam int64
	if query.Has("dateCheck") {
		param, err := parseNumericParameter[int64](
			query.Get("dateCheck"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "dateCheck", Err: err}, nil)
			return
		}

		dateCheckParam = param
	} else {
	}
	var hourCheckParam string
	if query.Has("hourCheck") {
		param := query.Get("hourCheck")

		hourCheckParam = param
	} else {
	}
	var sortFieldParam string
	if query.Has("sortField") {
		param := query.Get("sortField")

		sortFieldParam = param
	} else {
		param := "PREFERRED_DATE"
		sortFieldParam = param
	}
	var descendingParam bool
	if query.Has("descending") {
		param, err := parseBoolParameter(
			query.Get("descending"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "descending", Err: err}, nil)
			return
		}

		descendingParam = param
	} else {
		var param bool = true
		descendingParam = param
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
		var param int32 = 0
		startParam = param
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var searchRangeParam float64
	if query.Has("searchRange") {
		param, err := parseNumericParameter[float64](
			query.Get("searchRange"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "searchRange", Err: err}, nil)
			return
		}

		searchRangeParam = param
	} else {
		var param float64 = 0
		searchRangeParam = param
	}
	var distanceUnitParam string
	if query.Has("distanceUnit") {
		param := query.Get("distanceUnit")

		distanceUnitParam = param
	} else {
		param := "MILES"
		distanceUnitParam = param
	}
	result, err := c.service.GetPreferredLocations(r.Context(), versionParam, accountIdParam, latitudeParam, longitudeParam, dateCheckParam, hourCheckParam, sortFieldParam, descendingParam, startParam, limitParam, searchRangeParam, distanceUnitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetTrackingLegs - Search Tracking
func (c *TrackingAPIController) GetTrackingLegs(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var ownerIdParam int64
	if query.Has("ownerId") {
		param, err := parseNumericParameter[int64](
			query.Get("ownerId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "ownerId", Err: err}, nil)
			return
		}

		ownerIdParam = param
	} else {
	}
	var trackingDeviceIdParam string
	if query.Has("trackingDeviceId") {
		param := query.Get("trackingDeviceId")

		trackingDeviceIdParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
	}
	var getLastPointParam bool
	if query.Has("getLastPoint") {
		param, err := parseBoolParameter(
			query.Get("getLastPoint"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "getLastPoint", Err: err}, nil)
			return
		}

		getLastPointParam = param
	} else {
		var param bool = false
		getLastPointParam = param
	}
	result, err := c.service.GetTrackingLegs(r.Context(), versionParam, deviceIdParam, accountIdParam, ownerIdParam, trackingDeviceIdParam, startDateParam, endDateParam, tagsParam, getLastPointParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SaveTrackingStep - Create Tracking Step
func (c *TrackingAPIController) SaveTrackingStep(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var legIdParam int64
	if query.Has("legId") {
		param, err := parseNumericParameter[int64](
			query.Get("legId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "legId", Err: err}, nil)
			return
		}

		legIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "legId"}, nil)
		return
	}
	var startLatParam float64
	if query.Has("startLat") {
		param, err := parseNumericParameter[float64](
			query.Get("startLat"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startLat", Err: err}, nil)
			return
		}

		startLatParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startLat"}, nil)
		return
	}
	var startLngParam float64
	if query.Has("startLng") {
		param, err := parseNumericParameter[float64](
			query.Get("startLng"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startLng", Err: err}, nil)
			return
		}

		startLngParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startLng"}, nil)
		return
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "startDate"}, nil)
		return
	}
	var endLatParam float64
	if query.Has("endLat") {
		param, err := parseNumericParameter[float64](
			query.Get("endLat"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endLat", Err: err}, nil)
			return
		}

		endLatParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endLat"}, nil)
		return
	}
	var endLngParam float64
	if query.Has("endLng") {
		param, err := parseNumericParameter[float64](
			query.Get("endLng"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endLng", Err: err}, nil)
			return
		}

		endLngParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endLng"}, nil)
		return
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "endDate"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var distanceParam float64
	if query.Has("distance") {
		param, err := parseNumericParameter[float64](
			query.Get("distance"),
			WithParse[float64](parseFloat64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "distance", Err: err}, nil)
			return
		}

		distanceParam = param
	} else {
	}
	var durationParam int64
	if query.Has("duration") {
		param, err := parseNumericParameter[int64](
			query.Get("duration"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "duration", Err: err}, nil)
			return
		}

		durationParam = param
	} else {
	}
	result, err := c.service.SaveTrackingStep(r.Context(), versionParam, legIdParam, startLatParam, startLngParam, startDateParam, endLatParam, endLngParam, endDateParam, deviceIdParam, accountIdParam, distanceParam, durationParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SearchTrackingLegs - Search Tracking (Billable)
func (c *TrackingAPIController) SearchTrackingLegs(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "appKey"}, nil)
		return
	}
	var trackingDeviceIdParam string
	if query.Has("trackingDeviceId") {
		param := query.Get("trackingDeviceId")

		trackingDeviceIdParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
		var param int32 = 0
		startParam = param
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 100
		limitParam = param
	}
	result, err := c.service.SearchTrackingLegs(r.Context(), versionParam, accountIdParam, appKeyParam, trackingDeviceIdParam, startDateParam, endDateParam, tagsParam, startParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
