// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * API version: 3.16
 * Contact: info@sirqul.com
 */

package openapi

import (
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// PackAPIController binds http requests to an api service and writes the service results to the http response
type PackAPIController struct {
	service PackAPIServicer
	errorHandler ErrorHandler
}

// PackAPIOption for how the controller is set up.
type PackAPIOption func(*PackAPIController)

// WithPackAPIErrorHandler inject ErrorHandler into controller
func WithPackAPIErrorHandler(h ErrorHandler) PackAPIOption {
	return func(c *PackAPIController) {
		c.errorHandler = h
	}
}

// NewPackAPIController creates a default api controller
func NewPackAPIController(s PackAPIServicer, opts ...PackAPIOption) *PackAPIController {
	controller := &PackAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the PackAPIController
func (c *PackAPIController) Routes() Routes {
	return Routes{
		"CreatePack": Route{
			"CreatePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/create",
			c.CreatePack,
		},
		"DeletePack": Route{
			"DeletePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/delete",
			c.DeletePack,
		},
		"GetPack": Route{
			"GetPack",
			strings.ToUpper("Get"),
			"/api/{version}/pack/get",
			c.GetPack,
		},
		"SearchPacks": Route{
			"SearchPacks",
			strings.ToUpper("Get"),
			"/api/{version}/pack/search",
			c.SearchPacks,
		},
		"UpdatePack": Route{
			"UpdatePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/update",
			c.UpdatePack,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the PackAPIController
func (c *PackAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"CreatePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/create",
			c.CreatePack,
		},
		Route{
			"DeletePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/delete",
			c.DeletePack,
		},
		Route{
			"GetPack",
			strings.ToUpper("Get"),
			"/api/{version}/pack/get",
			c.GetPack,
		},
		Route{
			"SearchPacks",
			strings.ToUpper("Get"),
			"/api/{version}/pack/search",
			c.SearchPacks,
		},
		Route{
			"UpdatePack",
			strings.ToUpper("Post"),
			"/api/{version}/pack/update",
			c.UpdatePack,
		},
	}
}



// CreatePack - Create Pack
func (c *PackAPIController) CreatePack(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var titleParam string
	if query.Has("title") {
		param := query.Get("title")

		titleParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "title"}, nil)
		return
	}
	var packOrderParam int64
	if query.Has("packOrder") {
		param, err := parseNumericParameter[int64](
			query.Get("packOrder"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "packOrder", Err: err}, nil)
			return
		}

		packOrderParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "packOrder"}, nil)
		return
	}
	var priceParam int32
	if query.Has("price") {
		param, err := parseNumericParameter[int32](
			query.Get("price"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "price", Err: err}, nil)
			return
		}

		priceParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "price"}, nil)
		return
	}
	var highestParam bool
	if query.Has("highest") {
		param, err := parseBoolParameter(
			query.Get("highest"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "highest", Err: err}, nil)
			return
		}

		highestParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "highest"}, nil)
		return
	}
	var allocateTicketsParam bool
	if query.Has("allocateTickets") {
		param, err := parseBoolParameter(
			query.Get("allocateTickets"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "allocateTickets", Err: err}, nil)
			return
		}

		allocateTicketsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "allocateTickets"}, nil)
		return
	}
	var ticketCountParam int64
	if query.Has("ticketCount") {
		param, err := parseNumericParameter[int64](
			query.Get("ticketCount"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "ticketCount", Err: err}, nil)
			return
		}

		ticketCountParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "ticketCount"}, nil)
		return
	}
	var descriptionParam string
	if query.Has("description") {
		param := query.Get("description")

		descriptionParam = param
	} else {
	}
	var searchTagsParam string
	if query.Has("searchTags") {
		param := query.Get("searchTags")

		searchTagsParam = param
	} else {
	}
	var activeParam bool
	if query.Has("active") {
		param, err := parseBoolParameter(
			query.Get("active"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "active", Err: err}, nil)
			return
		}

		activeParam = param
	} else {
	}
	var gameTypeParam string
	if query.Has("gameType") {
		param := query.Get("gameType")

		gameTypeParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var packTypeParam string
	if query.Has("packType") {
		param := query.Get("packType")

		packTypeParam = param
	} else {
	}
	var sequenceTypeParam string
	if query.Has("sequenceType") {
		param := query.Get("sequenceType")

		sequenceTypeParam = param
	} else {
	}
	var backgroundIdParam int64
	if query.Has("backgroundId") {
		param, err := parseNumericParameter[int64](
			query.Get("backgroundId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "backgroundId", Err: err}, nil)
			return
		}

		backgroundIdParam = param
	} else {
	}
	var imageIdParam int64
	if query.Has("imageId") {
		param, err := parseNumericParameter[int64](
			query.Get("imageId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "imageId", Err: err}, nil)
			return
		}

		imageIdParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var authorOverrideParam string
	if query.Has("authorOverride") {
		param := query.Get("authorOverride")

		authorOverrideParam = param
	} else {
	}
	var priceTypeParam string
	if query.Has("priceType") {
		param := query.Get("priceType")

		priceTypeParam = param
	} else {
	}
	var gameLevelIdsParam string
	if query.Has("gameLevelIds") {
		param := query.Get("gameLevelIds")

		gameLevelIdsParam = param
	} else {
	}
	var inGameParam bool
	if query.Has("inGame") {
		param, err := parseBoolParameter(
			query.Get("inGame"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "inGame", Err: err}, nil)
			return
		}

		inGameParam = param
	} else {
	}
	var ticketTypeParam string
	if query.Has("ticketType") {
		param := query.Get("ticketType")

		ticketTypeParam = param
	} else {
	}
	var pointsParam int64
	if query.Has("points") {
		param, err := parseNumericParameter[int64](
			query.Get("points"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "points", Err: err}, nil)
			return
		}

		pointsParam = param
	} else {
	}
	result, err := c.service.CreatePack(r.Context(), versionParam, accountIdParam, titleParam, packOrderParam, priceParam, highestParam, allocateTicketsParam, ticketCountParam, descriptionParam, searchTagsParam, activeParam, gameTypeParam, appKeyParam, packTypeParam, sequenceTypeParam, backgroundIdParam, imageIdParam, startDateParam, endDateParam, authorOverrideParam, priceTypeParam, gameLevelIdsParam, inGameParam, ticketTypeParam, pointsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeletePack - Delete Pack
func (c *PackAPIController) DeletePack(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var packIdParam int64
	if query.Has("packId") {
		param, err := parseNumericParameter[int64](
			query.Get("packId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "packId", Err: err}, nil)
			return
		}

		packIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "packId"}, nil)
		return
	}
	result, err := c.service.DeletePack(r.Context(), versionParam, accountIdParam, packIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPack - Get Pack
func (c *PackAPIController) GetPack(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var packIdParam int64
	if query.Has("packId") {
		param, err := parseNumericParameter[int64](
			query.Get("packId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "packId", Err: err}, nil)
			return
		}

		packIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "packId"}, nil)
		return
	}
	var includeGameDataParam bool
	if query.Has("includeGameData") {
		param, err := parseBoolParameter(
			query.Get("includeGameData"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "includeGameData", Err: err}, nil)
			return
		}

		includeGameDataParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "includeGameData"}, nil)
		return
	}
	result, err := c.service.GetPack(r.Context(), versionParam, accountIdParam, packIdParam, includeGameDataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SearchPacks - Search Packs
func (c *PackAPIController) SearchPacks(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var sortFieldParam string
	if query.Has("sortField") {
		param := query.Get("sortField")

		sortFieldParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "sortField"}, nil)
		return
	}
	var descendingParam bool
	if query.Has("descending") {
		param, err := parseBoolParameter(
			query.Get("descending"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "descending", Err: err}, nil)
			return
		}

		descendingParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "descending"}, nil)
		return
	}
	var keywordParam string
	if query.Has("keyword") {
		param := query.Get("keyword")

		keywordParam = param
	} else {
	}
	var packTypeParam string
	if query.Has("packType") {
		param := query.Get("packType")

		packTypeParam = param
	} else {
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var includeGameDataParam bool
	if query.Has("includeGameData") {
		param, err := parseBoolParameter(
			query.Get("includeGameData"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "includeGameData", Err: err}, nil)
			return
		}

		includeGameDataParam = param
	} else {
	}
	var includeInactiveParam bool
	if query.Has("includeInactive") {
		param, err := parseBoolParameter(
			query.Get("includeInactive"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "includeInactive", Err: err}, nil)
			return
		}

		includeInactiveParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	result, err := c.service.SearchPacks(r.Context(), versionParam, accountIdParam, sortFieldParam, descendingParam, keywordParam, packTypeParam, startParam, limitParam, includeGameDataParam, includeInactiveParam, appKeyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UpdatePack - Update Pack
func (c *PackAPIController) UpdatePack(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var packIdParam int64
	if query.Has("packId") {
		param, err := parseNumericParameter[int64](
			query.Get("packId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "packId", Err: err}, nil)
			return
		}

		packIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "packId"}, nil)
		return
	}
	var allocateTicketsParam bool
	if query.Has("allocateTickets") {
		param, err := parseBoolParameter(
			query.Get("allocateTickets"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "allocateTickets", Err: err}, nil)
			return
		}

		allocateTicketsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "allocateTickets"}, nil)
		return
	}
	var ticketCountParam int64
	if query.Has("ticketCount") {
		param, err := parseNumericParameter[int64](
			query.Get("ticketCount"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "ticketCount", Err: err}, nil)
			return
		}

		ticketCountParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "ticketCount"}, nil)
		return
	}
	var titleParam string
	if query.Has("title") {
		param := query.Get("title")

		titleParam = param
	} else {
	}
	var descriptionParam string
	if query.Has("description") {
		param := query.Get("description")

		descriptionParam = param
	} else {
	}
	var searchTagsParam string
	if query.Has("searchTags") {
		param := query.Get("searchTags")

		searchTagsParam = param
	} else {
	}
	var activeParam bool
	if query.Has("active") {
		param, err := parseBoolParameter(
			query.Get("active"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "active", Err: err}, nil)
			return
		}

		activeParam = param
	} else {
	}
	var gameTypeParam string
	if query.Has("gameType") {
		param := query.Get("gameType")

		gameTypeParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var packTypeParam string
	if query.Has("packType") {
		param := query.Get("packType")

		packTypeParam = param
	} else {
	}
	var packOrderParam int64
	if query.Has("packOrder") {
		param, err := parseNumericParameter[int64](
			query.Get("packOrder"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "packOrder", Err: err}, nil)
			return
		}

		packOrderParam = param
	} else {
	}
	var sequenceTypeParam string
	if query.Has("sequenceType") {
		param := query.Get("sequenceType")

		sequenceTypeParam = param
	} else {
	}
	var backgroundIdParam int64
	if query.Has("backgroundId") {
		param, err := parseNumericParameter[int64](
			query.Get("backgroundId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "backgroundId", Err: err}, nil)
			return
		}

		backgroundIdParam = param
	} else {
	}
	var imageIdParam int64
	if query.Has("imageId") {
		param, err := parseNumericParameter[int64](
			query.Get("imageId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "imageId", Err: err}, nil)
			return
		}

		imageIdParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var authorOverrideParam string
	if query.Has("authorOverride") {
		param := query.Get("authorOverride")

		authorOverrideParam = param
	} else {
	}
	var priceParam int32
	if query.Has("price") {
		param, err := parseNumericParameter[int32](
			query.Get("price"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "price", Err: err}, nil)
			return
		}

		priceParam = param
	} else {
	}
	var priceTypeParam string
	if query.Has("priceType") {
		param := query.Get("priceType")

		priceTypeParam = param
	} else {
	}
	var gameLevelIdsParam string
	if query.Has("gameLevelIds") {
		param := query.Get("gameLevelIds")

		gameLevelIdsParam = param
	} else {
	}
	var inGameParam bool
	if query.Has("inGame") {
		param, err := parseBoolParameter(
			query.Get("inGame"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "inGame", Err: err}, nil)
			return
		}

		inGameParam = param
	} else {
	}
	var highestParam bool
	if query.Has("highest") {
		param, err := parseBoolParameter(
			query.Get("highest"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "highest", Err: err}, nil)
			return
		}

		highestParam = param
	} else {
	}
	var ticketTypeParam string
	if query.Has("ticketType") {
		param := query.Get("ticketType")

		ticketTypeParam = param
	} else {
	}
	var pointsParam int64
	if query.Has("points") {
		param, err := parseNumericParameter[int64](
			query.Get("points"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "points", Err: err}, nil)
			return
		}

		pointsParam = param
	} else {
	}
	result, err := c.service.UpdatePack(r.Context(), versionParam, accountIdParam, packIdParam, allocateTicketsParam, ticketCountParam, titleParam, descriptionParam, searchTagsParam, activeParam, gameTypeParam, appKeyParam, packTypeParam, packOrderParam, sequenceTypeParam, backgroundIdParam, imageIdParam, startDateParam, endDateParam, authorOverrideParam, priceParam, priceTypeParam, gameLevelIdsParam, inGameParam, highestParam, ticketTypeParam, pointsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
