// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * API version: 3.16
 * Contact: info@sirqul.com
 */

package openapi

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// ReportingAPIController binds http requests to an api service and writes the service results to the http response
type ReportingAPIController struct {
	service ReportingAPIServicer
	errorHandler ErrorHandler
}

// ReportingAPIOption for how the controller is set up.
type ReportingAPIOption func(*ReportingAPIController)

// WithReportingAPIErrorHandler inject ErrorHandler into controller
func WithReportingAPIErrorHandler(h ErrorHandler) ReportingAPIOption {
	return func(c *ReportingAPIController) {
		c.errorHandler = h
	}
}

// NewReportingAPIController creates a default api controller
func NewReportingAPIController(s ReportingAPIServicer, opts ...ReportingAPIOption) *ReportingAPIController {
	controller := &ReportingAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the ReportingAPIController
func (c *ReportingAPIController) Routes() Routes {
	return Routes{
		"CreateBatch": Route{
			"CreateBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/batch/create",
			c.CreateBatch,
		},
		"DeleteBatch": Route{
			"DeleteBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/batch/delete",
			c.DeleteBatch,
		},
		"GetReportBatch": Route{
			"GetReportBatch",
			strings.ToUpper("Get"),
			"/api/{version}/report/batch/get",
			c.GetReportBatch,
		},
		"SearchBatch": Route{
			"SearchBatch",
			strings.ToUpper("Get"),
			"/api/{version}/report/batch/search",
			c.SearchBatch,
		},
		"CreateRegionLegSummaryBatch": Route{
			"CreateRegionLegSummaryBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/region/summary/batch",
			c.CreateRegionLegSummaryBatch,
		},
		"RunReport": Route{
			"RunReport",
			strings.ToUpper("Post"),
			"/api/{version}/report/run",
			c.RunReport,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the ReportingAPIController
func (c *ReportingAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"CreateBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/batch/create",
			c.CreateBatch,
		},
		Route{
			"DeleteBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/batch/delete",
			c.DeleteBatch,
		},
		Route{
			"GetReportBatch",
			strings.ToUpper("Get"),
			"/api/{version}/report/batch/get",
			c.GetReportBatch,
		},
		Route{
			"SearchBatch",
			strings.ToUpper("Get"),
			"/api/{version}/report/batch/search",
			c.SearchBatch,
		},
		Route{
			"CreateRegionLegSummaryBatch",
			strings.ToUpper("Post"),
			"/api/{version}/report/region/summary/batch",
			c.CreateRegionLegSummaryBatch,
		},
		Route{
			"RunReport",
			strings.ToUpper("Post"),
			"/api/{version}/report/run",
			c.RunReport,
		},
	}
}



// CreateBatch - Create Offline Report
func (c *ReportingAPIController) CreateBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var statusParam string
	if query.Has("status") {
		param := query.Get("status")

		statusParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "status"}, nil)
		return
	}
	var previewLimitParam int32
	if query.Has("previewLimit") {
		param, err := parseNumericParameter[int32](
			query.Get("previewLimit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "previewLimit", Err: err}, nil)
			return
		}

		previewLimitParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "previewLimit"}, nil)
		return
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var endpointParam string
	if query.Has("endpoint") {
		param := query.Get("endpoint")

		endpointParam = param
	} else {
	}
	var parametersParam string
	if query.Has("parameters") {
		param := query.Get("parameters")

		parametersParam = param
	} else {
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	var descriptionParam string
	if query.Has("description") {
		param := query.Get("description")

		descriptionParam = param
	} else {
	}
	var pageUrlParam string
	if query.Has("pageUrl") {
		param := query.Get("pageUrl")

		pageUrlParam = param
	} else {
	}
	result, err := c.service.CreateBatch(r.Context(), versionParam, accountIdParam, statusParam, previewLimitParam, appKeyParam, endpointParam, parametersParam, nameParam, startDateParam, endDateParam, descriptionParam, pageUrlParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteBatch - Delete Offline Report
func (c *ReportingAPIController) DeleteBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var batchIdParam int64
	if query.Has("batchId") {
		param, err := parseNumericParameter[int64](
			query.Get("batchId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "batchId", Err: err}, nil)
			return
		}

		batchIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "batchId"}, nil)
		return
	}
	result, err := c.service.DeleteBatch(r.Context(), versionParam, accountIdParam, batchIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetReportBatch - Get Offline Report
func (c *ReportingAPIController) GetReportBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var batchIdParam int64
	if query.Has("batchId") {
		param, err := parseNumericParameter[int64](
			query.Get("batchId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "batchId", Err: err}, nil)
			return
		}

		batchIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "batchId"}, nil)
		return
	}
	var allResultsParam bool
	if query.Has("allResults") {
		param, err := parseBoolParameter(
			query.Get("allResults"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "allResults", Err: err}, nil)
			return
		}

		allResultsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "allResults"}, nil)
		return
	}
	result, err := c.service.GetReportBatch(r.Context(), versionParam, accountIdParam, batchIdParam, allResultsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SearchBatch - Search Offline Reports
func (c *ReportingAPIController) SearchBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "limit"}, nil)
		return
	}
	var namesParam string
	if query.Has("names") {
		param := query.Get("names")

		namesParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var statusParam string
	if query.Has("status") {
		param := query.Get("status")

		statusParam = param
	} else {
	}
	var globalAppSearchParam bool
	if query.Has("globalAppSearch") {
		param, err := parseBoolParameter(
			query.Get("globalAppSearch"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "globalAppSearch", Err: err}, nil)
			return
		}

		globalAppSearchParam = param
	} else {
	}
	var startDateParam int64
	if query.Has("startDate") {
		param, err := parseNumericParameter[int64](
			query.Get("startDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "startDate", Err: err}, nil)
			return
		}

		startDateParam = param
	} else {
	}
	var endDateParam int64
	if query.Has("endDate") {
		param, err := parseNumericParameter[int64](
			query.Get("endDate"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "endDate", Err: err}, nil)
			return
		}

		endDateParam = param
	} else {
	}
	result, err := c.service.SearchBatch(r.Context(), versionParam, accountIdParam, startParam, limitParam, namesParam, appKeyParam, statusParam, globalAppSearchParam, startDateParam, endDateParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateRegionLegSummaryBatch - Create Offline Report
func (c *ReportingAPIController) CreateRegionLegSummaryBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var bodyParam []RegionLegSummary
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range bodyParam {
		if err := AssertRegionLegSummaryRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	result, err := c.service.CreateRegionLegSummaryBatch(r.Context(), versionParam, bodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// RunReport - Run Report
func (c *ReportingAPIController) RunReport(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var descParam bool
	if query.Has("desc") {
		param, err := parseBoolParameter(
			query.Get("desc"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "desc", Err: err}, nil)
			return
		}

		descParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "desc"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var queryParam string
	if query.Has("query") {
		param := query.Get("query")

		queryParam = param
	} else {
	}
	var parametersParam string
	if query.Has("parameters") {
		param := query.Get("parameters")

		parametersParam = param
	} else {
	}
	var orderParam string
	if query.Has("order") {
		param := query.Get("order")

		orderParam = param
	} else {
	}
	var startParam int64
	if query.Has("start") {
		param, err := parseNumericParameter[int64](
			query.Get("start"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
	}
	var limitParam int64
	if query.Has("limit") {
		param, err := parseNumericParameter[int64](
			query.Get("limit"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var responseFormatParam string
	if query.Has("responseFormat") {
		param := query.Get("responseFormat")

		responseFormatParam = param
	} else {
	}
	result, err := c.service.RunReport(r.Context(), versionParam, descParam, accountIdParam, queryParam, parametersParam, orderParam, startParam, limitParam, responseFormatParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
