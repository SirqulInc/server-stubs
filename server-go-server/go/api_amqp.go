// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * API version: 3.16
 * Contact: info@sirqul.com
 */

package openapi

import (
	"net/http"
	"strings"
)

// AMQPAPIController binds http requests to an api service and writes the service results to the http response
type AMQPAPIController struct {
	service AMQPAPIServicer
	errorHandler ErrorHandler
}

// AMQPAPIOption for how the controller is set up.
type AMQPAPIOption func(*AMQPAPIController)

// WithAMQPAPIErrorHandler inject ErrorHandler into controller
func WithAMQPAPIErrorHandler(h ErrorHandler) AMQPAPIOption {
	return func(c *AMQPAPIController) {
		c.errorHandler = h
	}
}

// NewAMQPAPIController creates a default api controller
func NewAMQPAPIController(s AMQPAPIServicer, opts ...AMQPAPIOption) *AMQPAPIController {
	controller := &AMQPAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the AMQPAPIController
func (c *AMQPAPIController) Routes() Routes {
	return Routes{
		"ConsumerCreate": Route{
			"ConsumerCreate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/consumer/create",
			c.ConsumerCreate,
		},
		"ConsumerUpdate": Route{
			"ConsumerUpdate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/consumer/update",
			c.ConsumerUpdate,
		},
		"QueueCreate": Route{
			"QueueCreate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/create",
			c.QueueCreate,
		},
		"QueueDelete": Route{
			"QueueDelete",
			strings.ToUpper("Post"),
			"/api/3.18/queue/delete",
			c.QueueDelete,
		},
		"QueueGet": Route{
			"QueueGet",
			strings.ToUpper("Get"),
			"/api/3.18/queue/get",
			c.QueueGet,
		},
		"QueuePublish": Route{
			"QueuePublish",
			strings.ToUpper("Post"),
			"/api/3.18/queue/publish",
			c.QueuePublish,
		},
		"QueueSearch": Route{
			"QueueSearch",
			strings.ToUpper("Get"),
			"/api/3.18/queue/search",
			c.QueueSearch,
		},
		"QueueUpdate": Route{
			"QueueUpdate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/update",
			c.QueueUpdate,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the AMQPAPIController
func (c *AMQPAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"ConsumerCreate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/consumer/create",
			c.ConsumerCreate,
		},
		Route{
			"ConsumerUpdate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/consumer/update",
			c.ConsumerUpdate,
		},
		Route{
			"QueueCreate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/create",
			c.QueueCreate,
		},
		Route{
			"QueueDelete",
			strings.ToUpper("Post"),
			"/api/3.18/queue/delete",
			c.QueueDelete,
		},
		Route{
			"QueueGet",
			strings.ToUpper("Get"),
			"/api/3.18/queue/get",
			c.QueueGet,
		},
		Route{
			"QueuePublish",
			strings.ToUpper("Post"),
			"/api/3.18/queue/publish",
			c.QueuePublish,
		},
		Route{
			"QueueSearch",
			strings.ToUpper("Get"),
			"/api/3.18/queue/search",
			c.QueueSearch,
		},
		Route{
			"QueueUpdate",
			strings.ToUpper("Post"),
			"/api/3.18/queue/update",
			c.QueueUpdate,
		},
	}
}



// ConsumerCreate - Create Consumer
func (c *AMQPAPIController) ConsumerCreate(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "appKey"}, nil)
		return
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "name"}, nil)
		return
	}
	var hostnameParam string
	if query.Has("hostname") {
		param := query.Get("hostname")

		hostnameParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "hostname"}, nil)
		return
	}
	var usernameParam string
	if query.Has("username") {
		param := query.Get("username")

		usernameParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		return
	}
	var passwordParam string
	if query.Has("password") {
		param := query.Get("password")

		passwordParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "password"}, nil)
		return
	}
	var dataMappingParam string
	if query.Has("dataMapping") {
		param := query.Get("dataMapping")

		dataMappingParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "dataMapping"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var portParam int32
	if query.Has("port") {
		param, err := parseNumericParameter[int32](
			query.Get("port"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "port", Err: err}, nil)
			return
		}

		portParam = param
	} else {
		var param int32 = 5672
		portParam = param
	}
	var virtualHostParam string
	if query.Has("virtualHost") {
		param := query.Get("virtualHost")

		virtualHostParam = param
	} else {
	}
	var exchangerParam string
	if query.Has("exchanger") {
		param := query.Get("exchanger")

		exchangerParam = param
	} else {
	}
	var exchangerTypeParam string
	if query.Has("exchangerType") {
		param := query.Get("exchangerType")

		exchangerTypeParam = param
	} else {
	}
	var workersParam int32
	if query.Has("workers") {
		param, err := parseNumericParameter[int32](
			query.Get("workers"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "workers", Err: err}, nil)
			return
		}

		workersParam = param
	} else {
		var param int32 = 1
		workersParam = param
	}
	var useSSLParam bool
	if query.Has("useSSL") {
		param, err := parseBoolParameter(
			query.Get("useSSL"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "useSSL", Err: err}, nil)
			return
		}

		useSSLParam = param
	} else {
	}
	result, err := c.service.ConsumerCreate(r.Context(), appKeyParam, nameParam, hostnameParam, usernameParam, passwordParam, dataMappingParam, deviceIdParam, accountIdParam, portParam, virtualHostParam, exchangerParam, exchangerTypeParam, workersParam, useSSLParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// ConsumerUpdate - Update Consumer
func (c *AMQPAPIController) ConsumerUpdate(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "appKey"}, nil)
		return
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "queueId"}, nil)
		return
	}
	var dataMappingParam string
	if query.Has("dataMapping") {
		param := query.Get("dataMapping")

		dataMappingParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "dataMapping"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var useSSLParam bool
	if query.Has("useSSL") {
		param, err := parseBoolParameter(
			query.Get("useSSL"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "useSSL", Err: err}, nil)
			return
		}

		useSSLParam = param
	} else {
	}
	result, err := c.service.ConsumerUpdate(r.Context(), appKeyParam, queueIdParam, dataMappingParam, deviceIdParam, accountIdParam, useSSLParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueueCreate - Create Queue
func (c *AMQPAPIController) QueueCreate(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "appKey"}, nil)
		return
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "name"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var workersParam int32
	if query.Has("workers") {
		param, err := parseNumericParameter[int32](
			query.Get("workers"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "workers", Err: err}, nil)
			return
		}

		workersParam = param
	} else {
		var param int32 = 1
		workersParam = param
	}
	var analyticTagsParam string
	if query.Has("analyticTags") {
		param := query.Get("analyticTags")

		analyticTagsParam = param
	} else {
	}
	var hostnameParam string
	if query.Has("hostname") {
		param := query.Get("hostname")

		hostnameParam = param
	} else {
	}
	var portParam int32
	if query.Has("port") {
		param, err := parseNumericParameter[int32](
			query.Get("port"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "port", Err: err}, nil)
			return
		}

		portParam = param
	} else {
	}
	var usernameParam string
	if query.Has("username") {
		param := query.Get("username")

		usernameParam = param
	} else {
	}
	var passwordParam string
	if query.Has("password") {
		param := query.Get("password")

		passwordParam = param
	} else {
	}
	var virtualHostParam string
	if query.Has("virtualHost") {
		param := query.Get("virtualHost")

		virtualHostParam = param
	} else {
	}
	var useSSLParam bool
	if query.Has("useSSL") {
		param, err := parseBoolParameter(
			query.Get("useSSL"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "useSSL", Err: err}, nil)
			return
		}

		useSSLParam = param
	} else {
	}
	result, err := c.service.QueueCreate(r.Context(), appKeyParam, nameParam, deviceIdParam, accountIdParam, workersParam, analyticTagsParam, hostnameParam, portParam, usernameParam, passwordParam, virtualHostParam, useSSLParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueueDelete - Delete Queue
func (c *AMQPAPIController) QueueDelete(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "queueId"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	result, err := c.service.QueueDelete(r.Context(), queueIdParam, deviceIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueueGet - Get Queue
func (c *AMQPAPIController) QueueGet(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
	}
	var hostnameParam string
	if query.Has("hostname") {
		param := query.Get("hostname")

		hostnameParam = param
	} else {
	}
	var virtualHostParam string
	if query.Has("virtualHost") {
		param := query.Get("virtualHost")

		virtualHostParam = param
	} else {
	}
	result, err := c.service.QueueGet(r.Context(), deviceIdParam, accountIdParam, queueIdParam, appKeyParam, nameParam, hostnameParam, virtualHostParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueuePublish - Publish Queue
func (c *AMQPAPIController) QueuePublish(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var messageParam string
	if query.Has("message") {
		param := query.Get("message")

		messageParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "message"}, nil)
		return
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
	}
	var hostnameParam string
	if query.Has("hostname") {
		param := query.Get("hostname")

		hostnameParam = param
	} else {
	}
	var virtualHostParam string
	if query.Has("virtualHost") {
		param := query.Get("virtualHost")

		virtualHostParam = param
	} else {
	}
	result, err := c.service.QueuePublish(r.Context(), messageParam, queueIdParam, appKeyParam, nameParam, hostnameParam, virtualHostParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueueSearch - Search Queue
func (c *AMQPAPIController) QueueSearch(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var nameParam string
	if query.Has("name") {
		param := query.Get("name")

		nameParam = param
	} else {
	}
	var startParam int32
	if query.Has("start") {
		param, err := parseNumericParameter[int32](
			query.Get("start"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start", Err: err}, nil)
			return
		}

		startParam = param
	} else {
		var param int32 = 0
		startParam = param
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 10
		limitParam = param
	}
	result, err := c.service.QueueSearch(r.Context(), queueIdParam, deviceIdParam, accountIdParam, nameParam, startParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// QueueUpdate - Update Queue
func (c *AMQPAPIController) QueueUpdate(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var queueIdParam int64
	if query.Has("queueId") {
		param, err := parseNumericParameter[int64](
			query.Get("queueId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "queueId", Err: err}, nil)
			return
		}

		queueIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "queueId"}, nil)
		return
	}
	var deviceIdParam string
	if query.Has("deviceId") {
		param := query.Get("deviceId")

		deviceIdParam = param
	} else {
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
	}
	var appKeyParam string
	if query.Has("appKey") {
		param := query.Get("appKey")

		appKeyParam = param
	} else {
	}
	var workersParam int32
	if query.Has("workers") {
		param, err := parseNumericParameter[int32](
			query.Get("workers"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "workers", Err: err}, nil)
			return
		}

		workersParam = param
	} else {
	}
	var analyticTagsParam string
	if query.Has("analyticTags") {
		param := query.Get("analyticTags")

		analyticTagsParam = param
	} else {
	}
	var hostnameParam string
	if query.Has("hostname") {
		param := query.Get("hostname")

		hostnameParam = param
	} else {
	}
	var portParam int32
	if query.Has("port") {
		param, err := parseNumericParameter[int32](
			query.Get("port"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "port", Err: err}, nil)
			return
		}

		portParam = param
	} else {
	}
	var usernameParam string
	if query.Has("username") {
		param := query.Get("username")

		usernameParam = param
	} else {
	}
	var passwordParam string
	if query.Has("password") {
		param := query.Get("password")

		passwordParam = param
	} else {
	}
	var virtualHostParam string
	if query.Has("virtualHost") {
		param := query.Get("virtualHost")

		virtualHostParam = param
	} else {
	}
	var useSSLParam bool
	if query.Has("useSSL") {
		param, err := parseBoolParameter(
			query.Get("useSSL"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "useSSL", Err: err}, nil)
			return
		}

		useSSLParam = param
	} else {
	}
	result, err := c.service.QueueUpdate(r.Context(), queueIdParam, deviceIdParam, accountIdParam, appKeyParam, workersParam, analyticTagsParam, hostnameParam, portParam, usernameParam, passwordParam, virtualHostParam, useSSLParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
