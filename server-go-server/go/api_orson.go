// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * API version: 3.16
 * Contact: info@sirqul.com
 */

package openapi

import (
	"net/http"
	"strings"
	"os"

	"github.com/gorilla/mux"
)

// OrsonAPIController binds http requests to an api service and writes the service results to the http response
type OrsonAPIController struct {
	service OrsonAPIServicer
	errorHandler ErrorHandler
}

// OrsonAPIOption for how the controller is set up.
type OrsonAPIOption func(*OrsonAPIController)

// WithOrsonAPIErrorHandler inject ErrorHandler into controller
func WithOrsonAPIErrorHandler(h ErrorHandler) OrsonAPIOption {
	return func(c *OrsonAPIController) {
		c.errorHandler = h
	}
}

// NewOrsonAPIController creates a default api controller
func NewOrsonAPIController(s OrsonAPIServicer, opts ...OrsonAPIOption) *OrsonAPIController {
	controller := &OrsonAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the OrsonAPIController
func (c *OrsonAPIController) Routes() Routes {
	return Routes{
		"CreateInstantEpisode": Route{
			"CreateInstantEpisode",
			strings.ToUpper("Post"),
			"/api/{version}/orson/stories/episodes/instant",
			c.CreateInstantEpisode,
		},
		"GetEpisodeStatus": Route{
			"GetEpisodeStatus",
			strings.ToUpper("Get"),
			"/api/{version}/orson/stories/episodes/{episodeId}/status",
			c.GetEpisodeStatus,
		},
		"StartVideoRender": Route{
			"StartVideoRender",
			strings.ToUpper("Post"),
			"/api/{version}/orson/stories/renders",
			c.StartVideoRender,
		},
		"GetRenderStatus": Route{
			"GetRenderStatus",
			strings.ToUpper("Get"),
			"/api/{version}/orson/stories/renders/{renderId}/status",
			c.GetRenderStatus,
		},
		"CreateVoiceCanvas": Route{
			"CreateVoiceCanvas",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/voiceCanvas",
			c.CreateVoiceCanvas,
		},
		"GetVoiceCanvas": Route{
			"GetVoiceCanvas",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/voiceCanvas/{requestId}",
			c.GetVoiceCanvas,
		},
		"SummarizeTopics": Route{
			"SummarizeTopics",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/topics",
			c.SummarizeTopics,
		},
		"GetTopics": Route{
			"GetTopics",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/topics/{requestId}",
			c.GetTopics,
		},
		"AddMovie": Route{
			"AddMovie",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/addMovie",
			c.AddMovie,
		},
		"GetAddMovieResult": Route{
			"GetAddMovieResult",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/addMovie/{requestId}",
			c.GetAddMovieResult,
		},
		"Stt": Route{
			"Stt",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/stt",
			c.Stt,
		},
		"GetSTT": Route{
			"GetSTT",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/stt/{requestId}",
			c.GetSTT,
		},
		"Tts": Route{
			"Tts",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/tts",
			c.Tts,
		},
		"GetTTS": Route{
			"GetTTS",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/tts/{requestId}",
			c.GetTTS,
		},
		"TechTune": Route{
			"TechTune",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/techTune",
			c.TechTune,
		},
		"GetTechTune": Route{
			"GetTechTune",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/techTune/{requestId}",
			c.GetTechTune,
		},
		"Emotion": Route{
			"Emotion",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/emotion",
			c.Emotion,
		},
		"GetEmotion": Route{
			"GetEmotion",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/emotion/{requestId}",
			c.GetEmotion,
		},
		"Batch": Route{
			"Batch",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/batch",
			c.Batch,
		},
		"GetBatch": Route{
			"GetBatch",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/batch/{requestId}",
			c.GetBatch,
		},
		"AiFindImages": Route{
			"AiFindImages",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/img",
			c.AiFindImages,
		},
		"AiDocs": Route{
			"AiDocs",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/docs",
			c.AiDocs,
		},
		"AiTags": Route{
			"AiTags",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/tags",
			c.AiTags,
		},
		"AiText": Route{
			"AiText",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/text",
			c.AiText,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the OrsonAPIController
func (c *OrsonAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"CreateInstantEpisode",
			strings.ToUpper("Post"),
			"/api/{version}/orson/stories/episodes/instant",
			c.CreateInstantEpisode,
		},
		Route{
			"GetEpisodeStatus",
			strings.ToUpper("Get"),
			"/api/{version}/orson/stories/episodes/{episodeId}/status",
			c.GetEpisodeStatus,
		},
		Route{
			"StartVideoRender",
			strings.ToUpper("Post"),
			"/api/{version}/orson/stories/renders",
			c.StartVideoRender,
		},
		Route{
			"GetRenderStatus",
			strings.ToUpper("Get"),
			"/api/{version}/orson/stories/renders/{renderId}/status",
			c.GetRenderStatus,
		},
		Route{
			"CreateVoiceCanvas",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/voiceCanvas",
			c.CreateVoiceCanvas,
		},
		Route{
			"GetVoiceCanvas",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/voiceCanvas/{requestId}",
			c.GetVoiceCanvas,
		},
		Route{
			"SummarizeTopics",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/topics",
			c.SummarizeTopics,
		},
		Route{
			"GetTopics",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/topics/{requestId}",
			c.GetTopics,
		},
		Route{
			"AddMovie",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/addMovie",
			c.AddMovie,
		},
		Route{
			"GetAddMovieResult",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/addMovie/{requestId}",
			c.GetAddMovieResult,
		},
		Route{
			"Stt",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/stt",
			c.Stt,
		},
		Route{
			"GetSTT",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/stt/{requestId}",
			c.GetSTT,
		},
		Route{
			"Tts",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/tts",
			c.Tts,
		},
		Route{
			"GetTTS",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/tts/{requestId}",
			c.GetTTS,
		},
		Route{
			"TechTune",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/techTune",
			c.TechTune,
		},
		Route{
			"GetTechTune",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/techTune/{requestId}",
			c.GetTechTune,
		},
		Route{
			"Emotion",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/emotion",
			c.Emotion,
		},
		Route{
			"GetEmotion",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/emotion/{requestId}",
			c.GetEmotion,
		},
		Route{
			"Batch",
			strings.ToUpper("Post"),
			"/api/{version}/orson/ai/batch",
			c.Batch,
		},
		Route{
			"GetBatch",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/batch/{requestId}",
			c.GetBatch,
		},
		Route{
			"AiFindImages",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/img",
			c.AiFindImages,
		},
		Route{
			"AiDocs",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/docs",
			c.AiDocs,
		},
		Route{
			"AiTags",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/tags",
			c.AiTags,
		},
		Route{
			"AiText",
			strings.ToUpper("Get"),
			"/api/{version}/orson/ai/text",
			c.AiText,
		},
	}
}



// CreateInstantEpisode - Creates an instant episode
func (c *OrsonAPIController) CreateInstantEpisode(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var dataParam string
	if query.Has("data") {
		param := query.Get("data")

		dataParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "data"}, nil)
		return
	}
	result, err := c.service.CreateInstantEpisode(r.Context(), versionParam, accountIdParam, dataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetEpisodeStatus - Check episode status
func (c *OrsonAPIController) GetEpisodeStatus(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	episodeIdParam, err := parseNumericParameter[int64](
		params["episodeId"],
		WithRequire[int64](parseInt64),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "episodeId", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetEpisodeStatus(r.Context(), versionParam, episodeIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// StartVideoRender - Starts a StoryStitch video render
func (c *OrsonAPIController) StartVideoRender(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var dataParam string
	if query.Has("data") {
		param := query.Get("data")

		dataParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "data"}, nil)
		return
	}
	result, err := c.service.StartVideoRender(r.Context(), versionParam, accountIdParam, dataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetRenderStatus - Check episode status
func (c *OrsonAPIController) GetRenderStatus(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	renderIdParam := params["renderId"]
	if renderIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"renderId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetRenderStatus(r.Context(), versionParam, renderIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateVoiceCanvas - Create VoiceCanvas images
func (c *OrsonAPIController) CreateVoiceCanvas(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var dimensionsParam string
	if query.Has("dimensions") {
		param := query.Get("dimensions")

		dimensionsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "dimensions"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var textParam string
	if query.Has("text") {
		param := query.Get("text")

		textParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var parseFlagParam bool
	if query.Has("parseFlag") {
		param, err := parseBoolParameter(
			query.Get("parseFlag"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "parseFlag", Err: err}, nil)
			return
		}

		parseFlagParam = param
	} else {
	}
	var fetchFlagParam bool
	if query.Has("fetchFlag") {
		param, err := parseBoolParameter(
			query.Get("fetchFlag"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "fetchFlag", Err: err}, nil)
			return
		}

		fetchFlagParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.CreateVoiceCanvas(r.Context(), versionParam, accountIdParam, dimensionsParam, thirdPartyAccountIdParam, textParam, fileParam, urlParam, parseFlagParam, fetchFlagParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetVoiceCanvas - Get VoiceCanvas images
func (c *OrsonAPIController) GetVoiceCanvas(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetVoiceCanvas(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// SummarizeTopics - Summarize Topics
func (c *OrsonAPIController) SummarizeTopics(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var docParam string
	if query.Has("doc") {
		param := query.Get("doc")

		docParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.SummarizeTopics(r.Context(), versionParam, accountIdParam, thirdPartyAccountIdParam, docParam, fileParam, urlParam, limitParam, offsetParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetTopics - Get Topics
func (c *OrsonAPIController) GetTopics(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetTopics(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// AddMovie - Add Movie
func (c *OrsonAPIController) AddMovie(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var movieNameParam string
	if query.Has("movieName") {
		param := query.Get("movieName")

		movieNameParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "movieName"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.AddMovie(r.Context(), versionParam, accountIdParam, movieNameParam, thirdPartyAccountIdParam, tagsParam, fileParam, urlParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAddMovieResult - Get Add Movie Result
func (c *OrsonAPIController) GetAddMovieResult(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetAddMovieResult(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// Stt - Speach to Text
func (c *OrsonAPIController) Stt(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var sourceLanguageParam string
	if query.Has("sourceLanguage") {
		param := query.Get("sourceLanguage")

		sourceLanguageParam = param
	} else {
	}
	var targetLanguageParam string
	if query.Has("targetLanguage") {
		param := query.Get("targetLanguage")

		targetLanguageParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.Stt(r.Context(), versionParam, accountIdParam, thirdPartyAccountIdParam, sourceLanguageParam, targetLanguageParam, fileParam, urlParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSTT - Get Speach to Text Result
func (c *OrsonAPIController) GetSTT(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetSTT(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// Tts - Text to Speach
func (c *OrsonAPIController) Tts(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var textParam string
	if query.Has("text") {
		param := query.Get("text")

		textParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "text"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var languageParam string
	if query.Has("language") {
		param := query.Get("language")

		languageParam = param
	} else {
	}
	var voiceParam string
	if query.Has("voice") {
		param := query.Get("voice")

		voiceParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.Tts(r.Context(), versionParam, accountIdParam, textParam, thirdPartyAccountIdParam, languageParam, voiceParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetTTS - Get Text to Speach Result
func (c *OrsonAPIController) GetTTS(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetTTS(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// TechTune - Detect Technical Issues
func (c *OrsonAPIController) TechTune(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var numFacesExpectedParam int32
	if query.Has("numFacesExpected") {
		param, err := parseNumericParameter[int32](
			query.Get("numFacesExpected"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "numFacesExpected", Err: err}, nil)
			return
		}

		numFacesExpectedParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "numFacesExpected"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.TechTune(r.Context(), versionParam, accountIdParam, numFacesExpectedParam, thirdPartyAccountIdParam, fileParam, urlParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetTechTune - Get TechTune Results
func (c *OrsonAPIController) GetTechTune(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetTechTune(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// Emotion - Detect emotions
func (c *OrsonAPIController) Emotion(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.Emotion(r.Context(), versionParam, accountIdParam, thirdPartyAccountIdParam, fileParam, urlParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetEmotion - Get Emotion Results
func (c *OrsonAPIController) GetEmotion(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetEmotion(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// Batch - Batch Analysis
func (c *OrsonAPIController) Batch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var thirdPartyAccountIdParam string
	if query.Has("thirdPartyAccountId") {
		param := query.Get("thirdPartyAccountId")

		thirdPartyAccountIdParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var operationsParam string
	if query.Has("operations") {
		param := query.Get("operations")

		operationsParam = param
	} else {
	}
	var fileParam *os.File
	if query.Has("file") {
		param := *os.File(query.Get("file"))

		fileParam = param
	} else {
	}
	var urlParam string
	if query.Has("url") {
		param := query.Get("url")

		urlParam = param
	} else {
	}
	var callbackParam string
	if query.Has("callback") {
		param := query.Get("callback")

		callbackParam = param
	} else {
	}
	result, err := c.service.Batch(r.Context(), versionParam, accountIdParam, thirdPartyAccountIdParam, limitParam, operationsParam, fileParam, urlParam, callbackParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetBatch - Get Batch Analysis Results
func (c *OrsonAPIController) GetBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	requestIdParam := params["requestId"]
	if requestIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"requestId"}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	result, err := c.service.GetBatch(r.Context(), versionParam, requestIdParam, accountIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// AiFindImages - Find images
func (c *OrsonAPIController) AiFindImages(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var textParam string
	if query.Has("text") {
		param := query.Get("text")

		textParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "text"}, nil)
		return
	}
	var parseFlagParam string
	if query.Has("parse_flag") {
		param := query.Get("parse_flag")

		parseFlagParam = param
	} else {
	}
	var fetchFlagParam string
	if query.Has("fetch_flag") {
		param := query.Get("fetch_flag")

		fetchFlagParam = param
	} else {
	}
	var sizeParam string
	if query.Has("size") {
		param := query.Get("size")

		sizeParam = param
	} else {
	}
	result, err := c.service.AiFindImages(r.Context(), versionParam, accountIdParam, textParam, parseFlagParam, fetchFlagParam, sizeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// AiDocs - Search Docs
func (c *OrsonAPIController) AiDocs(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var docParam string
	if query.Has("doc") {
		param := query.Get("doc")

		docParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "doc"}, nil)
		return
	}
	var returnTopicsParam bool
	if query.Has("return_topics") {
		param, err := parseBoolParameter(
			query.Get("return_topics"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "return_topics", Err: err}, nil)
			return
		}

		returnTopicsParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	result, err := c.service.AiDocs(r.Context(), versionParam, accountIdParam, docParam, returnTopicsParam, limitParam, offsetParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// AiTags - Search Tags
func (c *OrsonAPIController) AiTags(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var tagsParam string
	if query.Has("tags") {
		param := query.Get("tags")

		tagsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "tags"}, nil)
		return
	}
	var conditionalParam string
	if query.Has("conditional") {
		param := query.Get("conditional")

		conditionalParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	result, err := c.service.AiTags(r.Context(), versionParam, accountIdParam, tagsParam, conditionalParam, limitParam, offsetParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// AiText - Search Text
func (c *OrsonAPIController) AiText(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	versionParam, err := parseNumericParameter[float32](
		params["version"],
		WithRequire[float32](parseFloat32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		return
	}
	var accountIdParam int64
	if query.Has("accountId") {
		param, err := parseNumericParameter[int64](
			query.Get("accountId"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "accountId", Err: err}, nil)
			return
		}

		accountIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "accountId"}, nil)
		return
	}
	var termsParam string
	if query.Has("terms") {
		param := query.Get("terms")

		termsParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "terms"}, nil)
		return
	}
	var conditionalParam string
	if query.Has("conditional") {
		param := query.Get("conditional")

		conditionalParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	result, err := c.service.AiText(r.Context(), versionParam, accountIdParam, termsParam, conditionalParam, limitParam, offsetParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
