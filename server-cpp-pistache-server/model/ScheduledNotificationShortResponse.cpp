/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "ScheduledNotificationShortResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

ScheduledNotificationShortResponse::ScheduledNotificationShortResponse()
{
    m_ScheduledNotificationId = 0L;
    m_ScheduledNotificationIdIsSet = false;
    m_Active = false;
    m_ActiveIsSet = false;
    m_Status = "";
    m_StatusIsSet = false;
    m_Type = "";
    m_TypeIsSet = false;
    m_Name = "";
    m_NameIsSet = false;
    m_Message = "";
    m_MessageIsSet = false;
    m_GroupingId = "";
    m_GroupingIdIsSet = false;
    m_ScheduledDate = 0L;
    m_ScheduledDateIsSet = false;
    m_StartDate = 0L;
    m_StartDateIsSet = false;
    m_EndDate = 0L;
    m_EndDateIsSet = false;
    
}

void ScheduledNotificationShortResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool ScheduledNotificationShortResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool ScheduledNotificationShortResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "ScheduledNotificationShortResponse" : pathPrefix;

                                            
    return success;
}

bool ScheduledNotificationShortResponse::operator==(const ScheduledNotificationShortResponse& rhs) const
{
    return
    
    
    
    ((!scheduledNotificationIdIsSet() && !rhs.scheduledNotificationIdIsSet()) || (scheduledNotificationIdIsSet() && rhs.scheduledNotificationIdIsSet() && getScheduledNotificationId() == rhs.getScheduledNotificationId())) &&
    
    
    ((!activeIsSet() && !rhs.activeIsSet()) || (activeIsSet() && rhs.activeIsSet() && isActive() == rhs.isActive())) &&
    
    
    ((!statusIsSet() && !rhs.statusIsSet()) || (statusIsSet() && rhs.statusIsSet() && getStatus() == rhs.getStatus())) &&
    
    
    ((!typeIsSet() && !rhs.typeIsSet()) || (typeIsSet() && rhs.typeIsSet() && getType() == rhs.getType())) &&
    
    
    ((!nameIsSet() && !rhs.nameIsSet()) || (nameIsSet() && rhs.nameIsSet() && getName() == rhs.getName())) &&
    
    
    ((!messageIsSet() && !rhs.messageIsSet()) || (messageIsSet() && rhs.messageIsSet() && getMessage() == rhs.getMessage())) &&
    
    
    ((!groupingIdIsSet() && !rhs.groupingIdIsSet()) || (groupingIdIsSet() && rhs.groupingIdIsSet() && getGroupingId() == rhs.getGroupingId())) &&
    
    
    ((!scheduledDateIsSet() && !rhs.scheduledDateIsSet()) || (scheduledDateIsSet() && rhs.scheduledDateIsSet() && getScheduledDate() == rhs.getScheduledDate())) &&
    
    
    ((!startDateIsSet() && !rhs.startDateIsSet()) || (startDateIsSet() && rhs.startDateIsSet() && getStartDate() == rhs.getStartDate())) &&
    
    
    ((!endDateIsSet() && !rhs.endDateIsSet()) || (endDateIsSet() && rhs.endDateIsSet() && getEndDate() == rhs.getEndDate()))
    
    ;
}

bool ScheduledNotificationShortResponse::operator!=(const ScheduledNotificationShortResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const ScheduledNotificationShortResponse& o)
{
    j = nlohmann::json::object();
    if(o.scheduledNotificationIdIsSet())
        j["scheduledNotificationId"] = o.m_ScheduledNotificationId;
    if(o.activeIsSet())
        j["active"] = o.m_Active;
    if(o.statusIsSet())
        j["status"] = o.m_Status;
    if(o.typeIsSet())
        j["type"] = o.m_Type;
    if(o.nameIsSet())
        j["name"] = o.m_Name;
    if(o.messageIsSet())
        j["message"] = o.m_Message;
    if(o.groupingIdIsSet())
        j["groupingId"] = o.m_GroupingId;
    if(o.scheduledDateIsSet())
        j["scheduledDate"] = o.m_ScheduledDate;
    if(o.startDateIsSet())
        j["startDate"] = o.m_StartDate;
    if(o.endDateIsSet())
        j["endDate"] = o.m_EndDate;
    
}

void from_json(const nlohmann::json& j, ScheduledNotificationShortResponse& o)
{
    if(j.find("scheduledNotificationId") != j.end())
    {
        j.at("scheduledNotificationId").get_to(o.m_ScheduledNotificationId);
        o.m_ScheduledNotificationIdIsSet = true;
    } 
    if(j.find("active") != j.end())
    {
        j.at("active").get_to(o.m_Active);
        o.m_ActiveIsSet = true;
    } 
    if(j.find("status") != j.end())
    {
        j.at("status").get_to(o.m_Status);
        o.m_StatusIsSet = true;
    } 
    if(j.find("type") != j.end())
    {
        j.at("type").get_to(o.m_Type);
        o.m_TypeIsSet = true;
    } 
    if(j.find("name") != j.end())
    {
        j.at("name").get_to(o.m_Name);
        o.m_NameIsSet = true;
    } 
    if(j.find("message") != j.end())
    {
        j.at("message").get_to(o.m_Message);
        o.m_MessageIsSet = true;
    } 
    if(j.find("groupingId") != j.end())
    {
        j.at("groupingId").get_to(o.m_GroupingId);
        o.m_GroupingIdIsSet = true;
    } 
    if(j.find("scheduledDate") != j.end())
    {
        j.at("scheduledDate").get_to(o.m_ScheduledDate);
        o.m_ScheduledDateIsSet = true;
    } 
    if(j.find("startDate") != j.end())
    {
        j.at("startDate").get_to(o.m_StartDate);
        o.m_StartDateIsSet = true;
    } 
    if(j.find("endDate") != j.end())
    {
        j.at("endDate").get_to(o.m_EndDate);
        o.m_EndDateIsSet = true;
    } 
    
}

int64_t ScheduledNotificationShortResponse::getScheduledNotificationId() const
{
    return m_ScheduledNotificationId;
}
void ScheduledNotificationShortResponse::setScheduledNotificationId(int64_t const value)
{
    m_ScheduledNotificationId = value;
    m_ScheduledNotificationIdIsSet = true;
}
bool ScheduledNotificationShortResponse::scheduledNotificationIdIsSet() const
{
    return m_ScheduledNotificationIdIsSet;
}
void ScheduledNotificationShortResponse::unsetScheduledNotificationId()
{
    m_ScheduledNotificationIdIsSet = false;
}
bool ScheduledNotificationShortResponse::isActive() const
{
    return m_Active;
}
void ScheduledNotificationShortResponse::setActive(bool const value)
{
    m_Active = value;
    m_ActiveIsSet = true;
}
bool ScheduledNotificationShortResponse::activeIsSet() const
{
    return m_ActiveIsSet;
}
void ScheduledNotificationShortResponse::unsetActive()
{
    m_ActiveIsSet = false;
}
std::string ScheduledNotificationShortResponse::getStatus() const
{
    return m_Status;
}
void ScheduledNotificationShortResponse::setStatus(std::string const& value)
{
    m_Status = value;
    m_StatusIsSet = true;
}
bool ScheduledNotificationShortResponse::statusIsSet() const
{
    return m_StatusIsSet;
}
void ScheduledNotificationShortResponse::unsetStatus()
{
    m_StatusIsSet = false;
}
std::string ScheduledNotificationShortResponse::getType() const
{
    return m_Type;
}
void ScheduledNotificationShortResponse::setType(std::string const& value)
{
    m_Type = value;
    m_TypeIsSet = true;
}
bool ScheduledNotificationShortResponse::typeIsSet() const
{
    return m_TypeIsSet;
}
void ScheduledNotificationShortResponse::unsetType()
{
    m_TypeIsSet = false;
}
std::string ScheduledNotificationShortResponse::getName() const
{
    return m_Name;
}
void ScheduledNotificationShortResponse::setName(std::string const& value)
{
    m_Name = value;
    m_NameIsSet = true;
}
bool ScheduledNotificationShortResponse::nameIsSet() const
{
    return m_NameIsSet;
}
void ScheduledNotificationShortResponse::unsetName()
{
    m_NameIsSet = false;
}
std::string ScheduledNotificationShortResponse::getMessage() const
{
    return m_Message;
}
void ScheduledNotificationShortResponse::setMessage(std::string const& value)
{
    m_Message = value;
    m_MessageIsSet = true;
}
bool ScheduledNotificationShortResponse::messageIsSet() const
{
    return m_MessageIsSet;
}
void ScheduledNotificationShortResponse::unsetMessage()
{
    m_MessageIsSet = false;
}
std::string ScheduledNotificationShortResponse::getGroupingId() const
{
    return m_GroupingId;
}
void ScheduledNotificationShortResponse::setGroupingId(std::string const& value)
{
    m_GroupingId = value;
    m_GroupingIdIsSet = true;
}
bool ScheduledNotificationShortResponse::groupingIdIsSet() const
{
    return m_GroupingIdIsSet;
}
void ScheduledNotificationShortResponse::unsetGroupingId()
{
    m_GroupingIdIsSet = false;
}
int64_t ScheduledNotificationShortResponse::getScheduledDate() const
{
    return m_ScheduledDate;
}
void ScheduledNotificationShortResponse::setScheduledDate(int64_t const value)
{
    m_ScheduledDate = value;
    m_ScheduledDateIsSet = true;
}
bool ScheduledNotificationShortResponse::scheduledDateIsSet() const
{
    return m_ScheduledDateIsSet;
}
void ScheduledNotificationShortResponse::unsetScheduledDate()
{
    m_ScheduledDateIsSet = false;
}
int64_t ScheduledNotificationShortResponse::getStartDate() const
{
    return m_StartDate;
}
void ScheduledNotificationShortResponse::setStartDate(int64_t const value)
{
    m_StartDate = value;
    m_StartDateIsSet = true;
}
bool ScheduledNotificationShortResponse::startDateIsSet() const
{
    return m_StartDateIsSet;
}
void ScheduledNotificationShortResponse::unsetStartDate()
{
    m_StartDateIsSet = false;
}
int64_t ScheduledNotificationShortResponse::getEndDate() const
{
    return m_EndDate;
}
void ScheduledNotificationShortResponse::setEndDate(int64_t const value)
{
    m_EndDate = value;
    m_EndDateIsSet = true;
}
bool ScheduledNotificationShortResponse::endDateIsSet() const
{
    return m_EndDateIsSet;
}
void ScheduledNotificationShortResponse::unsetEndDate()
{
    m_EndDateIsSet = false;
}


} // namespace org::openapitools::server::model

