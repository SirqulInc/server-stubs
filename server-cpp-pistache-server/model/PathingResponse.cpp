/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "PathingResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

PathingResponse::PathingResponse()
{
    m_StartIsSet = false;
    m_EndIsSet = false;
    m_WaypointsIsSet = false;
    m_ExclusionsIsSet = false;
    m_Width = 0;
    m_WidthIsSet = false;
    m_Height = 0;
    m_HeightIsSet = false;
    m_SouthwestIsSet = false;
    m_NortheastIsSet = false;
    m_MetersPerX = 0.0;
    m_MetersPerXIsSet = false;
    m_MetersPerY = 0.0;
    m_MetersPerYIsSet = false;
    m_PathIsSet = false;
    m_PathCount = 0;
    m_PathCountIsSet = false;
    m_DirectionsIsSet = false;
    m_DirectionCount = 0;
    m_DirectionCountIsSet = false;
    m_SwcalibrationIsSet = false;
    m_CalibrationBearings = 0.0;
    m_CalibrationBearingsIsSet = false;
    m_NecalibrationIsSet = false;
    
}

void PathingResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool PathingResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool PathingResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "PathingResponse" : pathPrefix;

                 
    if (waypointsIsSet())
    {
        const std::vector<org::openapitools::server::model::NodeRequest>& value = m_Waypoints;
        const std::string currentValuePath = _pathPrefix + ".waypoints";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::NodeRequest& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".waypoints") && success;
 
                i++;
            }
        }

    }
         
    if (exclusionsIsSet())
    {
        const std::vector<org::openapitools::server::model::NodeRequest>& value = m_Exclusions;
        const std::string currentValuePath = _pathPrefix + ".exclusions";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::NodeRequest& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".exclusions") && success;
 
                i++;
            }
        }

    }
                                 
    if (pathIsSet())
    {
        const std::vector<org::openapitools::server::model::NodeRequest>& value = m_Path;
        const std::string currentValuePath = _pathPrefix + ".path";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::NodeRequest& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".path") && success;
 
                i++;
            }
        }

    }
             
    if (directionsIsSet())
    {
        const std::vector<org::openapitools::server::model::DirectionResponse>& value = m_Directions;
        const std::string currentValuePath = _pathPrefix + ".directions";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::DirectionResponse& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".directions") && success;
 
                i++;
            }
        }

    }
                    
    return success;
}

bool PathingResponse::operator==(const PathingResponse& rhs) const
{
    return
    
    
    
    ((!startIsSet() && !rhs.startIsSet()) || (startIsSet() && rhs.startIsSet() && getStart() == rhs.getStart())) &&
    
    
    ((!endIsSet() && !rhs.endIsSet()) || (endIsSet() && rhs.endIsSet() && getEnd() == rhs.getEnd())) &&
    
    
    ((!waypointsIsSet() && !rhs.waypointsIsSet()) || (waypointsIsSet() && rhs.waypointsIsSet() && getWaypoints() == rhs.getWaypoints())) &&
    
    
    ((!exclusionsIsSet() && !rhs.exclusionsIsSet()) || (exclusionsIsSet() && rhs.exclusionsIsSet() && getExclusions() == rhs.getExclusions())) &&
    
    
    ((!widthIsSet() && !rhs.widthIsSet()) || (widthIsSet() && rhs.widthIsSet() && getWidth() == rhs.getWidth())) &&
    
    
    ((!heightIsSet() && !rhs.heightIsSet()) || (heightIsSet() && rhs.heightIsSet() && getHeight() == rhs.getHeight())) &&
    
    
    ((!southwestIsSet() && !rhs.southwestIsSet()) || (southwestIsSet() && rhs.southwestIsSet() && getSouthwest() == rhs.getSouthwest())) &&
    
    
    ((!northeastIsSet() && !rhs.northeastIsSet()) || (northeastIsSet() && rhs.northeastIsSet() && getNortheast() == rhs.getNortheast())) &&
    
    
    ((!metersPerXIsSet() && !rhs.metersPerXIsSet()) || (metersPerXIsSet() && rhs.metersPerXIsSet() && getMetersPerX() == rhs.getMetersPerX())) &&
    
    
    ((!metersPerYIsSet() && !rhs.metersPerYIsSet()) || (metersPerYIsSet() && rhs.metersPerYIsSet() && getMetersPerY() == rhs.getMetersPerY())) &&
    
    
    ((!pathIsSet() && !rhs.pathIsSet()) || (pathIsSet() && rhs.pathIsSet() && getPath() == rhs.getPath())) &&
    
    
    ((!pathCountIsSet() && !rhs.pathCountIsSet()) || (pathCountIsSet() && rhs.pathCountIsSet() && getPathCount() == rhs.getPathCount())) &&
    
    
    ((!directionsIsSet() && !rhs.directionsIsSet()) || (directionsIsSet() && rhs.directionsIsSet() && getDirections() == rhs.getDirections())) &&
    
    
    ((!directionCountIsSet() && !rhs.directionCountIsSet()) || (directionCountIsSet() && rhs.directionCountIsSet() && getDirectionCount() == rhs.getDirectionCount())) &&
    
    
    ((!swcalibrationIsSet() && !rhs.swcalibrationIsSet()) || (swcalibrationIsSet() && rhs.swcalibrationIsSet() && getSwcalibration() == rhs.getSwcalibration())) &&
    
    
    ((!calibrationBearingsIsSet() && !rhs.calibrationBearingsIsSet()) || (calibrationBearingsIsSet() && rhs.calibrationBearingsIsSet() && getCalibrationBearings() == rhs.getCalibrationBearings())) &&
    
    
    ((!necalibrationIsSet() && !rhs.necalibrationIsSet()) || (necalibrationIsSet() && rhs.necalibrationIsSet() && getNecalibration() == rhs.getNecalibration()))
    
    ;
}

bool PathingResponse::operator!=(const PathingResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const PathingResponse& o)
{
    j = nlohmann::json::object();
    if(o.startIsSet())
        j["start"] = o.m_Start;
    if(o.endIsSet())
        j["end"] = o.m_End;
    if(o.waypointsIsSet() || !o.m_Waypoints.empty())
        j["waypoints"] = o.m_Waypoints;
    if(o.exclusionsIsSet() || !o.m_Exclusions.empty())
        j["exclusions"] = o.m_Exclusions;
    if(o.widthIsSet())
        j["width"] = o.m_Width;
    if(o.heightIsSet())
        j["height"] = o.m_Height;
    if(o.southwestIsSet())
        j["southwest"] = o.m_Southwest;
    if(o.northeastIsSet())
        j["northeast"] = o.m_Northeast;
    if(o.metersPerXIsSet())
        j["metersPerX"] = o.m_MetersPerX;
    if(o.metersPerYIsSet())
        j["metersPerY"] = o.m_MetersPerY;
    if(o.pathIsSet() || !o.m_Path.empty())
        j["path"] = o.m_Path;
    if(o.pathCountIsSet())
        j["pathCount"] = o.m_PathCount;
    if(o.directionsIsSet() || !o.m_Directions.empty())
        j["directions"] = o.m_Directions;
    if(o.directionCountIsSet())
        j["directionCount"] = o.m_DirectionCount;
    if(o.swcalibrationIsSet())
        j["swcalibration"] = o.m_Swcalibration;
    if(o.calibrationBearingsIsSet())
        j["calibrationBearings"] = o.m_CalibrationBearings;
    if(o.necalibrationIsSet())
        j["necalibration"] = o.m_Necalibration;
    
}

void from_json(const nlohmann::json& j, PathingResponse& o)
{
    if(j.find("start") != j.end())
    {
        j.at("start").get_to(o.m_Start);
        o.m_StartIsSet = true;
    } 
    if(j.find("end") != j.end())
    {
        j.at("end").get_to(o.m_End);
        o.m_EndIsSet = true;
    } 
    if(j.find("waypoints") != j.end())
    {
        j.at("waypoints").get_to(o.m_Waypoints);
        o.m_WaypointsIsSet = true;
    } 
    if(j.find("exclusions") != j.end())
    {
        j.at("exclusions").get_to(o.m_Exclusions);
        o.m_ExclusionsIsSet = true;
    } 
    if(j.find("width") != j.end())
    {
        j.at("width").get_to(o.m_Width);
        o.m_WidthIsSet = true;
    } 
    if(j.find("height") != j.end())
    {
        j.at("height").get_to(o.m_Height);
        o.m_HeightIsSet = true;
    } 
    if(j.find("southwest") != j.end())
    {
        j.at("southwest").get_to(o.m_Southwest);
        o.m_SouthwestIsSet = true;
    } 
    if(j.find("northeast") != j.end())
    {
        j.at("northeast").get_to(o.m_Northeast);
        o.m_NortheastIsSet = true;
    } 
    if(j.find("metersPerX") != j.end())
    {
        j.at("metersPerX").get_to(o.m_MetersPerX);
        o.m_MetersPerXIsSet = true;
    } 
    if(j.find("metersPerY") != j.end())
    {
        j.at("metersPerY").get_to(o.m_MetersPerY);
        o.m_MetersPerYIsSet = true;
    } 
    if(j.find("path") != j.end())
    {
        j.at("path").get_to(o.m_Path);
        o.m_PathIsSet = true;
    } 
    if(j.find("pathCount") != j.end())
    {
        j.at("pathCount").get_to(o.m_PathCount);
        o.m_PathCountIsSet = true;
    } 
    if(j.find("directions") != j.end())
    {
        j.at("directions").get_to(o.m_Directions);
        o.m_DirectionsIsSet = true;
    } 
    if(j.find("directionCount") != j.end())
    {
        j.at("directionCount").get_to(o.m_DirectionCount);
        o.m_DirectionCountIsSet = true;
    } 
    if(j.find("swcalibration") != j.end())
    {
        j.at("swcalibration").get_to(o.m_Swcalibration);
        o.m_SwcalibrationIsSet = true;
    } 
    if(j.find("calibrationBearings") != j.end())
    {
        j.at("calibrationBearings").get_to(o.m_CalibrationBearings);
        o.m_CalibrationBearingsIsSet = true;
    } 
    if(j.find("necalibration") != j.end())
    {
        j.at("necalibration").get_to(o.m_Necalibration);
        o.m_NecalibrationIsSet = true;
    } 
    
}

org::openapitools::server::model::NodeRequest PathingResponse::getStart() const
{
    return m_Start;
}
void PathingResponse::setStart(org::openapitools::server::model::NodeRequest const& value)
{
    m_Start = value;
    m_StartIsSet = true;
}
bool PathingResponse::startIsSet() const
{
    return m_StartIsSet;
}
void PathingResponse::unsetStart()
{
    m_StartIsSet = false;
}
org::openapitools::server::model::NodeRequest PathingResponse::getEnd() const
{
    return m_End;
}
void PathingResponse::setEnd(org::openapitools::server::model::NodeRequest const& value)
{
    m_End = value;
    m_EndIsSet = true;
}
bool PathingResponse::endIsSet() const
{
    return m_EndIsSet;
}
void PathingResponse::unsetEnd()
{
    m_EndIsSet = false;
}
std::vector<org::openapitools::server::model::NodeRequest> PathingResponse::getWaypoints() const
{
    return m_Waypoints;
}
void PathingResponse::setWaypoints(std::vector<org::openapitools::server::model::NodeRequest> const& value)
{
    m_Waypoints = value;
    m_WaypointsIsSet = true;
}
bool PathingResponse::waypointsIsSet() const
{
    return m_WaypointsIsSet;
}
void PathingResponse::unsetWaypoints()
{
    m_WaypointsIsSet = false;
}
std::vector<org::openapitools::server::model::NodeRequest> PathingResponse::getExclusions() const
{
    return m_Exclusions;
}
void PathingResponse::setExclusions(std::vector<org::openapitools::server::model::NodeRequest> const& value)
{
    m_Exclusions = value;
    m_ExclusionsIsSet = true;
}
bool PathingResponse::exclusionsIsSet() const
{
    return m_ExclusionsIsSet;
}
void PathingResponse::unsetExclusions()
{
    m_ExclusionsIsSet = false;
}
int32_t PathingResponse::getWidth() const
{
    return m_Width;
}
void PathingResponse::setWidth(int32_t const value)
{
    m_Width = value;
    m_WidthIsSet = true;
}
bool PathingResponse::widthIsSet() const
{
    return m_WidthIsSet;
}
void PathingResponse::unsetWidth()
{
    m_WidthIsSet = false;
}
int32_t PathingResponse::getHeight() const
{
    return m_Height;
}
void PathingResponse::setHeight(int32_t const value)
{
    m_Height = value;
    m_HeightIsSet = true;
}
bool PathingResponse::heightIsSet() const
{
    return m_HeightIsSet;
}
void PathingResponse::unsetHeight()
{
    m_HeightIsSet = false;
}
org::openapitools::server::model::NodeRequest PathingResponse::getSouthwest() const
{
    return m_Southwest;
}
void PathingResponse::setSouthwest(org::openapitools::server::model::NodeRequest const& value)
{
    m_Southwest = value;
    m_SouthwestIsSet = true;
}
bool PathingResponse::southwestIsSet() const
{
    return m_SouthwestIsSet;
}
void PathingResponse::unsetSouthwest()
{
    m_SouthwestIsSet = false;
}
org::openapitools::server::model::NodeRequest PathingResponse::getNortheast() const
{
    return m_Northeast;
}
void PathingResponse::setNortheast(org::openapitools::server::model::NodeRequest const& value)
{
    m_Northeast = value;
    m_NortheastIsSet = true;
}
bool PathingResponse::northeastIsSet() const
{
    return m_NortheastIsSet;
}
void PathingResponse::unsetNortheast()
{
    m_NortheastIsSet = false;
}
double PathingResponse::getMetersPerX() const
{
    return m_MetersPerX;
}
void PathingResponse::setMetersPerX(double const value)
{
    m_MetersPerX = value;
    m_MetersPerXIsSet = true;
}
bool PathingResponse::metersPerXIsSet() const
{
    return m_MetersPerXIsSet;
}
void PathingResponse::unsetMetersPerX()
{
    m_MetersPerXIsSet = false;
}
double PathingResponse::getMetersPerY() const
{
    return m_MetersPerY;
}
void PathingResponse::setMetersPerY(double const value)
{
    m_MetersPerY = value;
    m_MetersPerYIsSet = true;
}
bool PathingResponse::metersPerYIsSet() const
{
    return m_MetersPerYIsSet;
}
void PathingResponse::unsetMetersPerY()
{
    m_MetersPerYIsSet = false;
}
std::vector<org::openapitools::server::model::NodeRequest> PathingResponse::getPath() const
{
    return m_Path;
}
void PathingResponse::setPath(std::vector<org::openapitools::server::model::NodeRequest> const& value)
{
    m_Path = value;
    m_PathIsSet = true;
}
bool PathingResponse::pathIsSet() const
{
    return m_PathIsSet;
}
void PathingResponse::unsetPath()
{
    m_PathIsSet = false;
}
int32_t PathingResponse::getPathCount() const
{
    return m_PathCount;
}
void PathingResponse::setPathCount(int32_t const value)
{
    m_PathCount = value;
    m_PathCountIsSet = true;
}
bool PathingResponse::pathCountIsSet() const
{
    return m_PathCountIsSet;
}
void PathingResponse::unsetPathCount()
{
    m_PathCountIsSet = false;
}
std::vector<org::openapitools::server::model::DirectionResponse> PathingResponse::getDirections() const
{
    return m_Directions;
}
void PathingResponse::setDirections(std::vector<org::openapitools::server::model::DirectionResponse> const& value)
{
    m_Directions = value;
    m_DirectionsIsSet = true;
}
bool PathingResponse::directionsIsSet() const
{
    return m_DirectionsIsSet;
}
void PathingResponse::unsetDirections()
{
    m_DirectionsIsSet = false;
}
int32_t PathingResponse::getDirectionCount() const
{
    return m_DirectionCount;
}
void PathingResponse::setDirectionCount(int32_t const value)
{
    m_DirectionCount = value;
    m_DirectionCountIsSet = true;
}
bool PathingResponse::directionCountIsSet() const
{
    return m_DirectionCountIsSet;
}
void PathingResponse::unsetDirectionCount()
{
    m_DirectionCountIsSet = false;
}
org::openapitools::server::model::NodeRequest PathingResponse::getSwcalibration() const
{
    return m_Swcalibration;
}
void PathingResponse::setSwcalibration(org::openapitools::server::model::NodeRequest const& value)
{
    m_Swcalibration = value;
    m_SwcalibrationIsSet = true;
}
bool PathingResponse::swcalibrationIsSet() const
{
    return m_SwcalibrationIsSet;
}
void PathingResponse::unsetSwcalibration()
{
    m_SwcalibrationIsSet = false;
}
double PathingResponse::getCalibrationBearings() const
{
    return m_CalibrationBearings;
}
void PathingResponse::setCalibrationBearings(double const value)
{
    m_CalibrationBearings = value;
    m_CalibrationBearingsIsSet = true;
}
bool PathingResponse::calibrationBearingsIsSet() const
{
    return m_CalibrationBearingsIsSet;
}
void PathingResponse::unsetCalibrationBearings()
{
    m_CalibrationBearingsIsSet = false;
}
org::openapitools::server::model::NodeRequest PathingResponse::getNecalibration() const
{
    return m_Necalibration;
}
void PathingResponse::setNecalibration(org::openapitools::server::model::NodeRequest const& value)
{
    m_Necalibration = value;
    m_NecalibrationIsSet = true;
}
bool PathingResponse::necalibrationIsSet() const
{
    return m_NecalibrationIsSet;
}
void PathingResponse::unsetNecalibration()
{
    m_NecalibrationIsSet = false;
}


} // namespace org::openapitools::server::model

