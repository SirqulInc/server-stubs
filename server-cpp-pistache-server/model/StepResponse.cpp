/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "StepResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

StepResponse::StepResponse()
{
    m_LegIsSet = false;
    m_Distance = 0.0;
    m_DistanceIsSet = false;
    m_Duration = 0L;
    m_DurationIsSet = false;
    m_StartLat = 0.0;
    m_StartLatIsSet = false;
    m_StartLng = 0.0;
    m_StartLngIsSet = false;
    m_StartAlt = 0.0;
    m_StartAltIsSet = false;
    m_StartDate = 0L;
    m_StartDateIsSet = false;
    m_EndLat = 0.0;
    m_EndLatIsSet = false;
    m_EndLng = 0.0;
    m_EndLngIsSet = false;
    m_EndAlt = 0.0;
    m_EndAltIsSet = false;
    m_EndDate = 0L;
    m_EndDateIsSet = false;
    m_Accuracy = 0;
    m_AccuracyIsSet = false;
    
}

void StepResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool StepResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool StepResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "StepResponse" : pathPrefix;

                                                    
    return success;
}

bool StepResponse::operator==(const StepResponse& rhs) const
{
    return
    
    
    
    ((!legIsSet() && !rhs.legIsSet()) || (legIsSet() && rhs.legIsSet() && getLeg() == rhs.getLeg())) &&
    
    
    ((!distanceIsSet() && !rhs.distanceIsSet()) || (distanceIsSet() && rhs.distanceIsSet() && getDistance() == rhs.getDistance())) &&
    
    
    ((!durationIsSet() && !rhs.durationIsSet()) || (durationIsSet() && rhs.durationIsSet() && getDuration() == rhs.getDuration())) &&
    
    
    ((!startLatIsSet() && !rhs.startLatIsSet()) || (startLatIsSet() && rhs.startLatIsSet() && getStartLat() == rhs.getStartLat())) &&
    
    
    ((!startLngIsSet() && !rhs.startLngIsSet()) || (startLngIsSet() && rhs.startLngIsSet() && getStartLng() == rhs.getStartLng())) &&
    
    
    ((!startAltIsSet() && !rhs.startAltIsSet()) || (startAltIsSet() && rhs.startAltIsSet() && getStartAlt() == rhs.getStartAlt())) &&
    
    
    ((!startDateIsSet() && !rhs.startDateIsSet()) || (startDateIsSet() && rhs.startDateIsSet() && getStartDate() == rhs.getStartDate())) &&
    
    
    ((!endLatIsSet() && !rhs.endLatIsSet()) || (endLatIsSet() && rhs.endLatIsSet() && getEndLat() == rhs.getEndLat())) &&
    
    
    ((!endLngIsSet() && !rhs.endLngIsSet()) || (endLngIsSet() && rhs.endLngIsSet() && getEndLng() == rhs.getEndLng())) &&
    
    
    ((!endAltIsSet() && !rhs.endAltIsSet()) || (endAltIsSet() && rhs.endAltIsSet() && getEndAlt() == rhs.getEndAlt())) &&
    
    
    ((!endDateIsSet() && !rhs.endDateIsSet()) || (endDateIsSet() && rhs.endDateIsSet() && getEndDate() == rhs.getEndDate())) &&
    
    
    ((!accuracyIsSet() && !rhs.accuracyIsSet()) || (accuracyIsSet() && rhs.accuracyIsSet() && getAccuracy() == rhs.getAccuracy()))
    
    ;
}

bool StepResponse::operator!=(const StepResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const StepResponse& o)
{
    j = nlohmann::json::object();
    if(o.legIsSet())
        j["leg"] = o.m_Leg;
    if(o.distanceIsSet())
        j["distance"] = o.m_Distance;
    if(o.durationIsSet())
        j["duration"] = o.m_Duration;
    if(o.startLatIsSet())
        j["startLat"] = o.m_StartLat;
    if(o.startLngIsSet())
        j["startLng"] = o.m_StartLng;
    if(o.startAltIsSet())
        j["startAlt"] = o.m_StartAlt;
    if(o.startDateIsSet())
        j["startDate"] = o.m_StartDate;
    if(o.endLatIsSet())
        j["endLat"] = o.m_EndLat;
    if(o.endLngIsSet())
        j["endLng"] = o.m_EndLng;
    if(o.endAltIsSet())
        j["endAlt"] = o.m_EndAlt;
    if(o.endDateIsSet())
        j["endDate"] = o.m_EndDate;
    if(o.accuracyIsSet())
        j["accuracy"] = o.m_Accuracy;
    
}

void from_json(const nlohmann::json& j, StepResponse& o)
{
    if(j.find("leg") != j.end())
    {
        j.at("leg").get_to(o.m_Leg);
        o.m_LegIsSet = true;
    } 
    if(j.find("distance") != j.end())
    {
        j.at("distance").get_to(o.m_Distance);
        o.m_DistanceIsSet = true;
    } 
    if(j.find("duration") != j.end())
    {
        j.at("duration").get_to(o.m_Duration);
        o.m_DurationIsSet = true;
    } 
    if(j.find("startLat") != j.end())
    {
        j.at("startLat").get_to(o.m_StartLat);
        o.m_StartLatIsSet = true;
    } 
    if(j.find("startLng") != j.end())
    {
        j.at("startLng").get_to(o.m_StartLng);
        o.m_StartLngIsSet = true;
    } 
    if(j.find("startAlt") != j.end())
    {
        j.at("startAlt").get_to(o.m_StartAlt);
        o.m_StartAltIsSet = true;
    } 
    if(j.find("startDate") != j.end())
    {
        j.at("startDate").get_to(o.m_StartDate);
        o.m_StartDateIsSet = true;
    } 
    if(j.find("endLat") != j.end())
    {
        j.at("endLat").get_to(o.m_EndLat);
        o.m_EndLatIsSet = true;
    } 
    if(j.find("endLng") != j.end())
    {
        j.at("endLng").get_to(o.m_EndLng);
        o.m_EndLngIsSet = true;
    } 
    if(j.find("endAlt") != j.end())
    {
        j.at("endAlt").get_to(o.m_EndAlt);
        o.m_EndAltIsSet = true;
    } 
    if(j.find("endDate") != j.end())
    {
        j.at("endDate").get_to(o.m_EndDate);
        o.m_EndDateIsSet = true;
    } 
    if(j.find("accuracy") != j.end())
    {
        j.at("accuracy").get_to(o.m_Accuracy);
        o.m_AccuracyIsSet = true;
    } 
    
}

org::openapitools::server::model::LegResponse StepResponse::getLeg() const
{
    return m_Leg;
}
void StepResponse::setLeg(org::openapitools::server::model::LegResponse const& value)
{
    m_Leg = value;
    m_LegIsSet = true;
}
bool StepResponse::legIsSet() const
{
    return m_LegIsSet;
}
void StepResponse::unsetLeg()
{
    m_LegIsSet = false;
}
double StepResponse::getDistance() const
{
    return m_Distance;
}
void StepResponse::setDistance(double const value)
{
    m_Distance = value;
    m_DistanceIsSet = true;
}
bool StepResponse::distanceIsSet() const
{
    return m_DistanceIsSet;
}
void StepResponse::unsetDistance()
{
    m_DistanceIsSet = false;
}
int64_t StepResponse::getDuration() const
{
    return m_Duration;
}
void StepResponse::setDuration(int64_t const value)
{
    m_Duration = value;
    m_DurationIsSet = true;
}
bool StepResponse::durationIsSet() const
{
    return m_DurationIsSet;
}
void StepResponse::unsetDuration()
{
    m_DurationIsSet = false;
}
double StepResponse::getStartLat() const
{
    return m_StartLat;
}
void StepResponse::setStartLat(double const value)
{
    m_StartLat = value;
    m_StartLatIsSet = true;
}
bool StepResponse::startLatIsSet() const
{
    return m_StartLatIsSet;
}
void StepResponse::unsetStartLat()
{
    m_StartLatIsSet = false;
}
double StepResponse::getStartLng() const
{
    return m_StartLng;
}
void StepResponse::setStartLng(double const value)
{
    m_StartLng = value;
    m_StartLngIsSet = true;
}
bool StepResponse::startLngIsSet() const
{
    return m_StartLngIsSet;
}
void StepResponse::unsetStartLng()
{
    m_StartLngIsSet = false;
}
double StepResponse::getStartAlt() const
{
    return m_StartAlt;
}
void StepResponse::setStartAlt(double const value)
{
    m_StartAlt = value;
    m_StartAltIsSet = true;
}
bool StepResponse::startAltIsSet() const
{
    return m_StartAltIsSet;
}
void StepResponse::unsetStartAlt()
{
    m_StartAltIsSet = false;
}
int64_t StepResponse::getStartDate() const
{
    return m_StartDate;
}
void StepResponse::setStartDate(int64_t const value)
{
    m_StartDate = value;
    m_StartDateIsSet = true;
}
bool StepResponse::startDateIsSet() const
{
    return m_StartDateIsSet;
}
void StepResponse::unsetStartDate()
{
    m_StartDateIsSet = false;
}
double StepResponse::getEndLat() const
{
    return m_EndLat;
}
void StepResponse::setEndLat(double const value)
{
    m_EndLat = value;
    m_EndLatIsSet = true;
}
bool StepResponse::endLatIsSet() const
{
    return m_EndLatIsSet;
}
void StepResponse::unsetEndLat()
{
    m_EndLatIsSet = false;
}
double StepResponse::getEndLng() const
{
    return m_EndLng;
}
void StepResponse::setEndLng(double const value)
{
    m_EndLng = value;
    m_EndLngIsSet = true;
}
bool StepResponse::endLngIsSet() const
{
    return m_EndLngIsSet;
}
void StepResponse::unsetEndLng()
{
    m_EndLngIsSet = false;
}
double StepResponse::getEndAlt() const
{
    return m_EndAlt;
}
void StepResponse::setEndAlt(double const value)
{
    m_EndAlt = value;
    m_EndAltIsSet = true;
}
bool StepResponse::endAltIsSet() const
{
    return m_EndAltIsSet;
}
void StepResponse::unsetEndAlt()
{
    m_EndAltIsSet = false;
}
int64_t StepResponse::getEndDate() const
{
    return m_EndDate;
}
void StepResponse::setEndDate(int64_t const value)
{
    m_EndDate = value;
    m_EndDateIsSet = true;
}
bool StepResponse::endDateIsSet() const
{
    return m_EndDateIsSet;
}
void StepResponse::unsetEndDate()
{
    m_EndDateIsSet = false;
}
int32_t StepResponse::getAccuracy() const
{
    return m_Accuracy;
}
void StepResponse::setAccuracy(int32_t const value)
{
    m_Accuracy = value;
    m_AccuracyIsSet = true;
}
bool StepResponse::accuracyIsSet() const
{
    return m_AccuracyIsSet;
}
void StepResponse::unsetAccuracy()
{
    m_AccuracyIsSet = false;
}


} // namespace org::openapitools::server::model

