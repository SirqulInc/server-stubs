/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "RankResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

RankResponse::RankResponse()
{
    m_OwnerIsSet = false;
    m_Rank = "";
    m_RankIsSet = false;
    m_ScoreValue = 0L;
    m_ScoreValueIsSet = false;
    m_TimeValue = 0L;
    m_TimeValueIsSet = false;
    m_CountValue = 0L;
    m_CountValueIsSet = false;
    m_Updated = 0L;
    m_UpdatedIsSet = false;
    
}

void RankResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool RankResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool RankResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "RankResponse" : pathPrefix;

                            
    return success;
}

bool RankResponse::operator==(const RankResponse& rhs) const
{
    return
    
    
    
    ((!ownerIsSet() && !rhs.ownerIsSet()) || (ownerIsSet() && rhs.ownerIsSet() && getOwner() == rhs.getOwner())) &&
    
    
    ((!rankIsSet() && !rhs.rankIsSet()) || (rankIsSet() && rhs.rankIsSet() && getRank() == rhs.getRank())) &&
    
    
    ((!scoreValueIsSet() && !rhs.scoreValueIsSet()) || (scoreValueIsSet() && rhs.scoreValueIsSet() && getScoreValue() == rhs.getScoreValue())) &&
    
    
    ((!timeValueIsSet() && !rhs.timeValueIsSet()) || (timeValueIsSet() && rhs.timeValueIsSet() && getTimeValue() == rhs.getTimeValue())) &&
    
    
    ((!countValueIsSet() && !rhs.countValueIsSet()) || (countValueIsSet() && rhs.countValueIsSet() && getCountValue() == rhs.getCountValue())) &&
    
    
    ((!updatedIsSet() && !rhs.updatedIsSet()) || (updatedIsSet() && rhs.updatedIsSet() && getUpdated() == rhs.getUpdated()))
    
    ;
}

bool RankResponse::operator!=(const RankResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const RankResponse& o)
{
    j = nlohmann::json::object();
    if(o.ownerIsSet())
        j["owner"] = o.m_Owner;
    if(o.rankIsSet())
        j["rank"] = o.m_Rank;
    if(o.scoreValueIsSet())
        j["scoreValue"] = o.m_ScoreValue;
    if(o.timeValueIsSet())
        j["timeValue"] = o.m_TimeValue;
    if(o.countValueIsSet())
        j["countValue"] = o.m_CountValue;
    if(o.updatedIsSet())
        j["updated"] = o.m_Updated;
    
}

void from_json(const nlohmann::json& j, RankResponse& o)
{
    if(j.find("owner") != j.end())
    {
        j.at("owner").get_to(o.m_Owner);
        o.m_OwnerIsSet = true;
    } 
    if(j.find("rank") != j.end())
    {
        j.at("rank").get_to(o.m_Rank);
        o.m_RankIsSet = true;
    } 
    if(j.find("scoreValue") != j.end())
    {
        j.at("scoreValue").get_to(o.m_ScoreValue);
        o.m_ScoreValueIsSet = true;
    } 
    if(j.find("timeValue") != j.end())
    {
        j.at("timeValue").get_to(o.m_TimeValue);
        o.m_TimeValueIsSet = true;
    } 
    if(j.find("countValue") != j.end())
    {
        j.at("countValue").get_to(o.m_CountValue);
        o.m_CountValueIsSet = true;
    } 
    if(j.find("updated") != j.end())
    {
        j.at("updated").get_to(o.m_Updated);
        o.m_UpdatedIsSet = true;
    } 
    
}

org::openapitools::server::model::AccountShortResponse RankResponse::getOwner() const
{
    return m_Owner;
}
void RankResponse::setOwner(org::openapitools::server::model::AccountShortResponse const& value)
{
    m_Owner = value;
    m_OwnerIsSet = true;
}
bool RankResponse::ownerIsSet() const
{
    return m_OwnerIsSet;
}
void RankResponse::unsetOwner()
{
    m_OwnerIsSet = false;
}
std::string RankResponse::getRank() const
{
    return m_Rank;
}
void RankResponse::setRank(std::string const& value)
{
    m_Rank = value;
    m_RankIsSet = true;
}
bool RankResponse::rankIsSet() const
{
    return m_RankIsSet;
}
void RankResponse::unsetRank()
{
    m_RankIsSet = false;
}
int64_t RankResponse::getScoreValue() const
{
    return m_ScoreValue;
}
void RankResponse::setScoreValue(int64_t const value)
{
    m_ScoreValue = value;
    m_ScoreValueIsSet = true;
}
bool RankResponse::scoreValueIsSet() const
{
    return m_ScoreValueIsSet;
}
void RankResponse::unsetScoreValue()
{
    m_ScoreValueIsSet = false;
}
int64_t RankResponse::getTimeValue() const
{
    return m_TimeValue;
}
void RankResponse::setTimeValue(int64_t const value)
{
    m_TimeValue = value;
    m_TimeValueIsSet = true;
}
bool RankResponse::timeValueIsSet() const
{
    return m_TimeValueIsSet;
}
void RankResponse::unsetTimeValue()
{
    m_TimeValueIsSet = false;
}
int64_t RankResponse::getCountValue() const
{
    return m_CountValue;
}
void RankResponse::setCountValue(int64_t const value)
{
    m_CountValue = value;
    m_CountValueIsSet = true;
}
bool RankResponse::countValueIsSet() const
{
    return m_CountValueIsSet;
}
void RankResponse::unsetCountValue()
{
    m_CountValueIsSet = false;
}
int64_t RankResponse::getUpdated() const
{
    return m_Updated;
}
void RankResponse::setUpdated(int64_t const value)
{
    m_Updated = value;
    m_UpdatedIsSet = true;
}
bool RankResponse::updatedIsSet() const
{
    return m_UpdatedIsSet;
}
void RankResponse::unsetUpdated()
{
    m_UpdatedIsSet = false;
}


} // namespace org::openapitools::server::model

