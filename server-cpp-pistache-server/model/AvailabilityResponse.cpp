/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "AvailabilityResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

AvailabilityResponse::AvailabilityResponse()
{
    m_AvailabilityId = 0L;
    m_AvailabilityIdIsSet = false;
    m_StartDate = 0L;
    m_StartDateIsSet = false;
    m_EndDate = 0L;
    m_EndDateIsSet = false;
    m_DayOfWeek = 0;
    m_DayOfWeekIsSet = false;
    m_StartTime = 0L;
    m_StartTimeIsSet = false;
    m_EndTime = 0L;
    m_EndTimeIsSet = false;
    m_TimeZone = "";
    m_TimeZoneIsSet = false;
    m_Deleted = false;
    m_DeletedIsSet = false;
    
}

void AvailabilityResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool AvailabilityResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool AvailabilityResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "AvailabilityResponse" : pathPrefix;

                                    
    return success;
}

bool AvailabilityResponse::operator==(const AvailabilityResponse& rhs) const
{
    return
    
    
    
    ((!availabilityIdIsSet() && !rhs.availabilityIdIsSet()) || (availabilityIdIsSet() && rhs.availabilityIdIsSet() && getAvailabilityId() == rhs.getAvailabilityId())) &&
    
    
    ((!startDateIsSet() && !rhs.startDateIsSet()) || (startDateIsSet() && rhs.startDateIsSet() && getStartDate() == rhs.getStartDate())) &&
    
    
    ((!endDateIsSet() && !rhs.endDateIsSet()) || (endDateIsSet() && rhs.endDateIsSet() && getEndDate() == rhs.getEndDate())) &&
    
    
    ((!dayOfWeekIsSet() && !rhs.dayOfWeekIsSet()) || (dayOfWeekIsSet() && rhs.dayOfWeekIsSet() && getDayOfWeek() == rhs.getDayOfWeek())) &&
    
    
    ((!startTimeIsSet() && !rhs.startTimeIsSet()) || (startTimeIsSet() && rhs.startTimeIsSet() && getStartTime() == rhs.getStartTime())) &&
    
    
    ((!endTimeIsSet() && !rhs.endTimeIsSet()) || (endTimeIsSet() && rhs.endTimeIsSet() && getEndTime() == rhs.getEndTime())) &&
    
    
    ((!timeZoneIsSet() && !rhs.timeZoneIsSet()) || (timeZoneIsSet() && rhs.timeZoneIsSet() && getTimeZone() == rhs.getTimeZone())) &&
    
    
    ((!deletedIsSet() && !rhs.deletedIsSet()) || (deletedIsSet() && rhs.deletedIsSet() && isDeleted() == rhs.isDeleted()))
    
    ;
}

bool AvailabilityResponse::operator!=(const AvailabilityResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const AvailabilityResponse& o)
{
    j = nlohmann::json::object();
    if(o.availabilityIdIsSet())
        j["availabilityId"] = o.m_AvailabilityId;
    if(o.startDateIsSet())
        j["startDate"] = o.m_StartDate;
    if(o.endDateIsSet())
        j["endDate"] = o.m_EndDate;
    if(o.dayOfWeekIsSet())
        j["dayOfWeek"] = o.m_DayOfWeek;
    if(o.startTimeIsSet())
        j["startTime"] = o.m_StartTime;
    if(o.endTimeIsSet())
        j["endTime"] = o.m_EndTime;
    if(o.timeZoneIsSet())
        j["timeZone"] = o.m_TimeZone;
    if(o.deletedIsSet())
        j["deleted"] = o.m_Deleted;
    
}

void from_json(const nlohmann::json& j, AvailabilityResponse& o)
{
    if(j.find("availabilityId") != j.end())
    {
        j.at("availabilityId").get_to(o.m_AvailabilityId);
        o.m_AvailabilityIdIsSet = true;
    } 
    if(j.find("startDate") != j.end())
    {
        j.at("startDate").get_to(o.m_StartDate);
        o.m_StartDateIsSet = true;
    } 
    if(j.find("endDate") != j.end())
    {
        j.at("endDate").get_to(o.m_EndDate);
        o.m_EndDateIsSet = true;
    } 
    if(j.find("dayOfWeek") != j.end())
    {
        j.at("dayOfWeek").get_to(o.m_DayOfWeek);
        o.m_DayOfWeekIsSet = true;
    } 
    if(j.find("startTime") != j.end())
    {
        j.at("startTime").get_to(o.m_StartTime);
        o.m_StartTimeIsSet = true;
    } 
    if(j.find("endTime") != j.end())
    {
        j.at("endTime").get_to(o.m_EndTime);
        o.m_EndTimeIsSet = true;
    } 
    if(j.find("timeZone") != j.end())
    {
        j.at("timeZone").get_to(o.m_TimeZone);
        o.m_TimeZoneIsSet = true;
    } 
    if(j.find("deleted") != j.end())
    {
        j.at("deleted").get_to(o.m_Deleted);
        o.m_DeletedIsSet = true;
    } 
    
}

int64_t AvailabilityResponse::getAvailabilityId() const
{
    return m_AvailabilityId;
}
void AvailabilityResponse::setAvailabilityId(int64_t const value)
{
    m_AvailabilityId = value;
    m_AvailabilityIdIsSet = true;
}
bool AvailabilityResponse::availabilityIdIsSet() const
{
    return m_AvailabilityIdIsSet;
}
void AvailabilityResponse::unsetAvailabilityId()
{
    m_AvailabilityIdIsSet = false;
}
int64_t AvailabilityResponse::getStartDate() const
{
    return m_StartDate;
}
void AvailabilityResponse::setStartDate(int64_t const value)
{
    m_StartDate = value;
    m_StartDateIsSet = true;
}
bool AvailabilityResponse::startDateIsSet() const
{
    return m_StartDateIsSet;
}
void AvailabilityResponse::unsetStartDate()
{
    m_StartDateIsSet = false;
}
int64_t AvailabilityResponse::getEndDate() const
{
    return m_EndDate;
}
void AvailabilityResponse::setEndDate(int64_t const value)
{
    m_EndDate = value;
    m_EndDateIsSet = true;
}
bool AvailabilityResponse::endDateIsSet() const
{
    return m_EndDateIsSet;
}
void AvailabilityResponse::unsetEndDate()
{
    m_EndDateIsSet = false;
}
int32_t AvailabilityResponse::getDayOfWeek() const
{
    return m_DayOfWeek;
}
void AvailabilityResponse::setDayOfWeek(int32_t const value)
{
    m_DayOfWeek = value;
    m_DayOfWeekIsSet = true;
}
bool AvailabilityResponse::dayOfWeekIsSet() const
{
    return m_DayOfWeekIsSet;
}
void AvailabilityResponse::unsetDayOfWeek()
{
    m_DayOfWeekIsSet = false;
}
int64_t AvailabilityResponse::getStartTime() const
{
    return m_StartTime;
}
void AvailabilityResponse::setStartTime(int64_t const value)
{
    m_StartTime = value;
    m_StartTimeIsSet = true;
}
bool AvailabilityResponse::startTimeIsSet() const
{
    return m_StartTimeIsSet;
}
void AvailabilityResponse::unsetStartTime()
{
    m_StartTimeIsSet = false;
}
int64_t AvailabilityResponse::getEndTime() const
{
    return m_EndTime;
}
void AvailabilityResponse::setEndTime(int64_t const value)
{
    m_EndTime = value;
    m_EndTimeIsSet = true;
}
bool AvailabilityResponse::endTimeIsSet() const
{
    return m_EndTimeIsSet;
}
void AvailabilityResponse::unsetEndTime()
{
    m_EndTimeIsSet = false;
}
std::string AvailabilityResponse::getTimeZone() const
{
    return m_TimeZone;
}
void AvailabilityResponse::setTimeZone(std::string const& value)
{
    m_TimeZone = value;
    m_TimeZoneIsSet = true;
}
bool AvailabilityResponse::timeZoneIsSet() const
{
    return m_TimeZoneIsSet;
}
void AvailabilityResponse::unsetTimeZone()
{
    m_TimeZoneIsSet = false;
}
bool AvailabilityResponse::isDeleted() const
{
    return m_Deleted;
}
void AvailabilityResponse::setDeleted(bool const value)
{
    m_Deleted = value;
    m_DeletedIsSet = true;
}
bool AvailabilityResponse::deletedIsSet() const
{
    return m_DeletedIsSet;
}
void AvailabilityResponse::unsetDeleted()
{
    m_DeletedIsSet = false;
}


} // namespace org::openapitools::server::model

