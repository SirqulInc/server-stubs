/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "TimeSlotResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

TimeSlotResponse::TimeSlotResponse()
{
    m_ScheduledDate = 0L;
    m_ScheduledDateIsSet = false;
    m_StartTime = 0L;
    m_StartTimeIsSet = false;
    m_EndTime = 0L;
    m_EndTimeIsSet = false;
    m_DayOfWeek = 0;
    m_DayOfWeekIsSet = false;
    m_TimeZone = "";
    m_TimeZoneIsSet = false;
    m_ReservationCount = 0;
    m_ReservationCountIsSet = false;
    m_ReservationsIsSet = false;
    
}

void TimeSlotResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool TimeSlotResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool TimeSlotResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "TimeSlotResponse" : pathPrefix;

                                 
    if (reservationsIsSet())
    {
        const std::vector<org::openapitools::server::model::AccountShortResponse>& value = m_Reservations;
        const std::string currentValuePath = _pathPrefix + ".reservations";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::AccountShortResponse& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".reservations") && success;
 
                i++;
            }
        }

    }
    
    return success;
}

bool TimeSlotResponse::operator==(const TimeSlotResponse& rhs) const
{
    return
    
    
    
    ((!scheduledDateIsSet() && !rhs.scheduledDateIsSet()) || (scheduledDateIsSet() && rhs.scheduledDateIsSet() && getScheduledDate() == rhs.getScheduledDate())) &&
    
    
    ((!startTimeIsSet() && !rhs.startTimeIsSet()) || (startTimeIsSet() && rhs.startTimeIsSet() && getStartTime() == rhs.getStartTime())) &&
    
    
    ((!endTimeIsSet() && !rhs.endTimeIsSet()) || (endTimeIsSet() && rhs.endTimeIsSet() && getEndTime() == rhs.getEndTime())) &&
    
    
    ((!dayOfWeekIsSet() && !rhs.dayOfWeekIsSet()) || (dayOfWeekIsSet() && rhs.dayOfWeekIsSet() && getDayOfWeek() == rhs.getDayOfWeek())) &&
    
    
    ((!timeZoneIsSet() && !rhs.timeZoneIsSet()) || (timeZoneIsSet() && rhs.timeZoneIsSet() && getTimeZone() == rhs.getTimeZone())) &&
    
    
    ((!reservationCountIsSet() && !rhs.reservationCountIsSet()) || (reservationCountIsSet() && rhs.reservationCountIsSet() && getReservationCount() == rhs.getReservationCount())) &&
    
    
    ((!reservationsIsSet() && !rhs.reservationsIsSet()) || (reservationsIsSet() && rhs.reservationsIsSet() && getReservations() == rhs.getReservations()))
    
    ;
}

bool TimeSlotResponse::operator!=(const TimeSlotResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const TimeSlotResponse& o)
{
    j = nlohmann::json::object();
    if(o.scheduledDateIsSet())
        j["scheduledDate"] = o.m_ScheduledDate;
    if(o.startTimeIsSet())
        j["startTime"] = o.m_StartTime;
    if(o.endTimeIsSet())
        j["endTime"] = o.m_EndTime;
    if(o.dayOfWeekIsSet())
        j["dayOfWeek"] = o.m_DayOfWeek;
    if(o.timeZoneIsSet())
        j["timeZone"] = o.m_TimeZone;
    if(o.reservationCountIsSet())
        j["reservationCount"] = o.m_ReservationCount;
    if(o.reservationsIsSet() || !o.m_Reservations.empty())
        j["reservations"] = o.m_Reservations;
    
}

void from_json(const nlohmann::json& j, TimeSlotResponse& o)
{
    if(j.find("scheduledDate") != j.end())
    {
        j.at("scheduledDate").get_to(o.m_ScheduledDate);
        o.m_ScheduledDateIsSet = true;
    } 
    if(j.find("startTime") != j.end())
    {
        j.at("startTime").get_to(o.m_StartTime);
        o.m_StartTimeIsSet = true;
    } 
    if(j.find("endTime") != j.end())
    {
        j.at("endTime").get_to(o.m_EndTime);
        o.m_EndTimeIsSet = true;
    } 
    if(j.find("dayOfWeek") != j.end())
    {
        j.at("dayOfWeek").get_to(o.m_DayOfWeek);
        o.m_DayOfWeekIsSet = true;
    } 
    if(j.find("timeZone") != j.end())
    {
        j.at("timeZone").get_to(o.m_TimeZone);
        o.m_TimeZoneIsSet = true;
    } 
    if(j.find("reservationCount") != j.end())
    {
        j.at("reservationCount").get_to(o.m_ReservationCount);
        o.m_ReservationCountIsSet = true;
    } 
    if(j.find("reservations") != j.end())
    {
        j.at("reservations").get_to(o.m_Reservations);
        o.m_ReservationsIsSet = true;
    } 
    
}

int64_t TimeSlotResponse::getScheduledDate() const
{
    return m_ScheduledDate;
}
void TimeSlotResponse::setScheduledDate(int64_t const value)
{
    m_ScheduledDate = value;
    m_ScheduledDateIsSet = true;
}
bool TimeSlotResponse::scheduledDateIsSet() const
{
    return m_ScheduledDateIsSet;
}
void TimeSlotResponse::unsetScheduledDate()
{
    m_ScheduledDateIsSet = false;
}
int64_t TimeSlotResponse::getStartTime() const
{
    return m_StartTime;
}
void TimeSlotResponse::setStartTime(int64_t const value)
{
    m_StartTime = value;
    m_StartTimeIsSet = true;
}
bool TimeSlotResponse::startTimeIsSet() const
{
    return m_StartTimeIsSet;
}
void TimeSlotResponse::unsetStartTime()
{
    m_StartTimeIsSet = false;
}
int64_t TimeSlotResponse::getEndTime() const
{
    return m_EndTime;
}
void TimeSlotResponse::setEndTime(int64_t const value)
{
    m_EndTime = value;
    m_EndTimeIsSet = true;
}
bool TimeSlotResponse::endTimeIsSet() const
{
    return m_EndTimeIsSet;
}
void TimeSlotResponse::unsetEndTime()
{
    m_EndTimeIsSet = false;
}
int32_t TimeSlotResponse::getDayOfWeek() const
{
    return m_DayOfWeek;
}
void TimeSlotResponse::setDayOfWeek(int32_t const value)
{
    m_DayOfWeek = value;
    m_DayOfWeekIsSet = true;
}
bool TimeSlotResponse::dayOfWeekIsSet() const
{
    return m_DayOfWeekIsSet;
}
void TimeSlotResponse::unsetDayOfWeek()
{
    m_DayOfWeekIsSet = false;
}
std::string TimeSlotResponse::getTimeZone() const
{
    return m_TimeZone;
}
void TimeSlotResponse::setTimeZone(std::string const& value)
{
    m_TimeZone = value;
    m_TimeZoneIsSet = true;
}
bool TimeSlotResponse::timeZoneIsSet() const
{
    return m_TimeZoneIsSet;
}
void TimeSlotResponse::unsetTimeZone()
{
    m_TimeZoneIsSet = false;
}
int32_t TimeSlotResponse::getReservationCount() const
{
    return m_ReservationCount;
}
void TimeSlotResponse::setReservationCount(int32_t const value)
{
    m_ReservationCount = value;
    m_ReservationCountIsSet = true;
}
bool TimeSlotResponse::reservationCountIsSet() const
{
    return m_ReservationCountIsSet;
}
void TimeSlotResponse::unsetReservationCount()
{
    m_ReservationCountIsSet = false;
}
std::vector<org::openapitools::server::model::AccountShortResponse> TimeSlotResponse::getReservations() const
{
    return m_Reservations;
}
void TimeSlotResponse::setReservations(std::vector<org::openapitools::server::model::AccountShortResponse> const& value)
{
    m_Reservations = value;
    m_ReservationsIsSet = true;
}
bool TimeSlotResponse::reservationsIsSet() const
{
    return m_ReservationsIsSet;
}
void TimeSlotResponse::unsetReservations()
{
    m_ReservationsIsSet = false;
}


} // namespace org::openapitools::server::model

