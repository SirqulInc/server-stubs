/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "QuestionResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

QuestionResponse::QuestionResponse()
{
    m_Id = 0L;
    m_IdIsSet = false;
    m_Question = "";
    m_QuestionIsSet = false;
    m_ImageIsSet = false;
    m_VideoURL = "";
    m_VideoURLIsSet = false;
    m_Active = false;
    m_ActiveIsSet = false;
    m_AnswersIsSet = false;
    m_ScoresIsSet = false;
    m_TicketsIsSet = false;
    m_OwnerIsSet = false;
    m_IconIsSet = false;
    m_AuthorOverride = "";
    m_AuthorOverrideIsSet = false;
    m_UpdatedDate = 0L;
    m_UpdatedDateIsSet = false;
    m_StartDate = 0L;
    m_StartDateIsSet = false;
    m_EndDate = 0L;
    m_EndDateIsSet = false;
    m_CreatedDate = 0L;
    m_CreatedDateIsSet = false;
    m_Tags = "";
    m_TagsIsSet = false;
    m_AllocateTickets = false;
    m_AllocateTicketsIsSet = false;
    m_TicketType = "";
    m_TicketTypeIsSet = false;
    m_TicketCount = 0L;
    m_TicketCountIsSet = false;
    m_Points = 0L;
    m_PointsIsSet = false;
    
}

void QuestionResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool QuestionResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool QuestionResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "QuestionResponse" : pathPrefix;

                             
    if (answersIsSet())
    {
        const std::vector<org::openapitools::server::model::AnswerResponse>& value = m_Answers;
        const std::string currentValuePath = _pathPrefix + ".answers";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::AnswerResponse& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".answers") && success;
 
                i++;
            }
        }

    }
                                                            
    return success;
}

bool QuestionResponse::operator==(const QuestionResponse& rhs) const
{
    return
    
    
    
    ((!idIsSet() && !rhs.idIsSet()) || (idIsSet() && rhs.idIsSet() && getId() == rhs.getId())) &&
    
    
    ((!questionIsSet() && !rhs.questionIsSet()) || (questionIsSet() && rhs.questionIsSet() && getQuestion() == rhs.getQuestion())) &&
    
    
    ((!imageIsSet() && !rhs.imageIsSet()) || (imageIsSet() && rhs.imageIsSet() && getImage() == rhs.getImage())) &&
    
    
    ((!videoURLIsSet() && !rhs.videoURLIsSet()) || (videoURLIsSet() && rhs.videoURLIsSet() && getVideoURL() == rhs.getVideoURL())) &&
    
    
    ((!activeIsSet() && !rhs.activeIsSet()) || (activeIsSet() && rhs.activeIsSet() && isActive() == rhs.isActive())) &&
    
    
    ((!answersIsSet() && !rhs.answersIsSet()) || (answersIsSet() && rhs.answersIsSet() && getAnswers() == rhs.getAnswers())) &&
    
    
    ((!scoresIsSet() && !rhs.scoresIsSet()) || (scoresIsSet() && rhs.scoresIsSet() && getScores() == rhs.getScores())) &&
    
    
    ((!ticketsIsSet() && !rhs.ticketsIsSet()) || (ticketsIsSet() && rhs.ticketsIsSet() && getTickets() == rhs.getTickets())) &&
    
    
    ((!ownerIsSet() && !rhs.ownerIsSet()) || (ownerIsSet() && rhs.ownerIsSet() && getOwner() == rhs.getOwner())) &&
    
    
    ((!iconIsSet() && !rhs.iconIsSet()) || (iconIsSet() && rhs.iconIsSet() && getIcon() == rhs.getIcon())) &&
    
    
    ((!authorOverrideIsSet() && !rhs.authorOverrideIsSet()) || (authorOverrideIsSet() && rhs.authorOverrideIsSet() && getAuthorOverride() == rhs.getAuthorOverride())) &&
    
    
    ((!updatedDateIsSet() && !rhs.updatedDateIsSet()) || (updatedDateIsSet() && rhs.updatedDateIsSet() && getUpdatedDate() == rhs.getUpdatedDate())) &&
    
    
    ((!startDateIsSet() && !rhs.startDateIsSet()) || (startDateIsSet() && rhs.startDateIsSet() && getStartDate() == rhs.getStartDate())) &&
    
    
    ((!endDateIsSet() && !rhs.endDateIsSet()) || (endDateIsSet() && rhs.endDateIsSet() && getEndDate() == rhs.getEndDate())) &&
    
    
    ((!createdDateIsSet() && !rhs.createdDateIsSet()) || (createdDateIsSet() && rhs.createdDateIsSet() && getCreatedDate() == rhs.getCreatedDate())) &&
    
    
    ((!tagsIsSet() && !rhs.tagsIsSet()) || (tagsIsSet() && rhs.tagsIsSet() && getTags() == rhs.getTags())) &&
    
    
    ((!allocateTicketsIsSet() && !rhs.allocateTicketsIsSet()) || (allocateTicketsIsSet() && rhs.allocateTicketsIsSet() && isAllocateTickets() == rhs.isAllocateTickets())) &&
    
    
    ((!ticketTypeIsSet() && !rhs.ticketTypeIsSet()) || (ticketTypeIsSet() && rhs.ticketTypeIsSet() && getTicketType() == rhs.getTicketType())) &&
    
    
    ((!ticketCountIsSet() && !rhs.ticketCountIsSet()) || (ticketCountIsSet() && rhs.ticketCountIsSet() && getTicketCount() == rhs.getTicketCount())) &&
    
    
    ((!pointsIsSet() && !rhs.pointsIsSet()) || (pointsIsSet() && rhs.pointsIsSet() && getPoints() == rhs.getPoints()))
    
    ;
}

bool QuestionResponse::operator!=(const QuestionResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const QuestionResponse& o)
{
    j = nlohmann::json::object();
    if(o.idIsSet())
        j["id"] = o.m_Id;
    if(o.questionIsSet())
        j["question"] = o.m_Question;
    if(o.imageIsSet())
        j["image"] = o.m_Image;
    if(o.videoURLIsSet())
        j["videoURL"] = o.m_VideoURL;
    if(o.activeIsSet())
        j["active"] = o.m_Active;
    if(o.answersIsSet() || !o.m_Answers.empty())
        j["answers"] = o.m_Answers;
    if(o.scoresIsSet())
        j["scores"] = o.m_Scores;
    if(o.ticketsIsSet())
        j["tickets"] = o.m_Tickets;
    if(o.ownerIsSet())
        j["owner"] = o.m_Owner;
    if(o.iconIsSet())
        j["icon"] = o.m_Icon;
    if(o.authorOverrideIsSet())
        j["authorOverride"] = o.m_AuthorOverride;
    if(o.updatedDateIsSet())
        j["updatedDate"] = o.m_UpdatedDate;
    if(o.startDateIsSet())
        j["startDate"] = o.m_StartDate;
    if(o.endDateIsSet())
        j["endDate"] = o.m_EndDate;
    if(o.createdDateIsSet())
        j["createdDate"] = o.m_CreatedDate;
    if(o.tagsIsSet())
        j["tags"] = o.m_Tags;
    if(o.allocateTicketsIsSet())
        j["allocateTickets"] = o.m_AllocateTickets;
    if(o.ticketTypeIsSet())
        j["ticketType"] = o.m_TicketType;
    if(o.ticketCountIsSet())
        j["ticketCount"] = o.m_TicketCount;
    if(o.pointsIsSet())
        j["points"] = o.m_Points;
    
}

void from_json(const nlohmann::json& j, QuestionResponse& o)
{
    if(j.find("id") != j.end())
    {
        j.at("id").get_to(o.m_Id);
        o.m_IdIsSet = true;
    } 
    if(j.find("question") != j.end())
    {
        j.at("question").get_to(o.m_Question);
        o.m_QuestionIsSet = true;
    } 
    if(j.find("image") != j.end())
    {
        j.at("image").get_to(o.m_Image);
        o.m_ImageIsSet = true;
    } 
    if(j.find("videoURL") != j.end())
    {
        j.at("videoURL").get_to(o.m_VideoURL);
        o.m_VideoURLIsSet = true;
    } 
    if(j.find("active") != j.end())
    {
        j.at("active").get_to(o.m_Active);
        o.m_ActiveIsSet = true;
    } 
    if(j.find("answers") != j.end())
    {
        j.at("answers").get_to(o.m_Answers);
        o.m_AnswersIsSet = true;
    } 
    if(j.find("scores") != j.end())
    {
        j.at("scores").get_to(o.m_Scores);
        o.m_ScoresIsSet = true;
    } 
    if(j.find("tickets") != j.end())
    {
        j.at("tickets").get_to(o.m_Tickets);
        o.m_TicketsIsSet = true;
    } 
    if(j.find("owner") != j.end())
    {
        j.at("owner").get_to(o.m_Owner);
        o.m_OwnerIsSet = true;
    } 
    if(j.find("icon") != j.end())
    {
        j.at("icon").get_to(o.m_Icon);
        o.m_IconIsSet = true;
    } 
    if(j.find("authorOverride") != j.end())
    {
        j.at("authorOverride").get_to(o.m_AuthorOverride);
        o.m_AuthorOverrideIsSet = true;
    } 
    if(j.find("updatedDate") != j.end())
    {
        j.at("updatedDate").get_to(o.m_UpdatedDate);
        o.m_UpdatedDateIsSet = true;
    } 
    if(j.find("startDate") != j.end())
    {
        j.at("startDate").get_to(o.m_StartDate);
        o.m_StartDateIsSet = true;
    } 
    if(j.find("endDate") != j.end())
    {
        j.at("endDate").get_to(o.m_EndDate);
        o.m_EndDateIsSet = true;
    } 
    if(j.find("createdDate") != j.end())
    {
        j.at("createdDate").get_to(o.m_CreatedDate);
        o.m_CreatedDateIsSet = true;
    } 
    if(j.find("tags") != j.end())
    {
        j.at("tags").get_to(o.m_Tags);
        o.m_TagsIsSet = true;
    } 
    if(j.find("allocateTickets") != j.end())
    {
        j.at("allocateTickets").get_to(o.m_AllocateTickets);
        o.m_AllocateTicketsIsSet = true;
    } 
    if(j.find("ticketType") != j.end())
    {
        j.at("ticketType").get_to(o.m_TicketType);
        o.m_TicketTypeIsSet = true;
    } 
    if(j.find("ticketCount") != j.end())
    {
        j.at("ticketCount").get_to(o.m_TicketCount);
        o.m_TicketCountIsSet = true;
    } 
    if(j.find("points") != j.end())
    {
        j.at("points").get_to(o.m_Points);
        o.m_PointsIsSet = true;
    } 
    
}

int64_t QuestionResponse::getId() const
{
    return m_Id;
}
void QuestionResponse::setId(int64_t const value)
{
    m_Id = value;
    m_IdIsSet = true;
}
bool QuestionResponse::idIsSet() const
{
    return m_IdIsSet;
}
void QuestionResponse::unsetId()
{
    m_IdIsSet = false;
}
std::string QuestionResponse::getQuestion() const
{
    return m_Question;
}
void QuestionResponse::setQuestion(std::string const& value)
{
    m_Question = value;
    m_QuestionIsSet = true;
}
bool QuestionResponse::questionIsSet() const
{
    return m_QuestionIsSet;
}
void QuestionResponse::unsetQuestion()
{
    m_QuestionIsSet = false;
}
org::openapitools::server::model::AssetShortResponse QuestionResponse::getImage() const
{
    return m_Image;
}
void QuestionResponse::setImage(org::openapitools::server::model::AssetShortResponse const& value)
{
    m_Image = value;
    m_ImageIsSet = true;
}
bool QuestionResponse::imageIsSet() const
{
    return m_ImageIsSet;
}
void QuestionResponse::unsetImage()
{
    m_ImageIsSet = false;
}
std::string QuestionResponse::getVideoURL() const
{
    return m_VideoURL;
}
void QuestionResponse::setVideoURL(std::string const& value)
{
    m_VideoURL = value;
    m_VideoURLIsSet = true;
}
bool QuestionResponse::videoURLIsSet() const
{
    return m_VideoURLIsSet;
}
void QuestionResponse::unsetVideoURL()
{
    m_VideoURLIsSet = false;
}
bool QuestionResponse::isActive() const
{
    return m_Active;
}
void QuestionResponse::setActive(bool const value)
{
    m_Active = value;
    m_ActiveIsSet = true;
}
bool QuestionResponse::activeIsSet() const
{
    return m_ActiveIsSet;
}
void QuestionResponse::unsetActive()
{
    m_ActiveIsSet = false;
}
std::vector<org::openapitools::server::model::AnswerResponse> QuestionResponse::getAnswers() const
{
    return m_Answers;
}
void QuestionResponse::setAnswers(std::vector<org::openapitools::server::model::AnswerResponse> const& value)
{
    m_Answers = value;
    m_AnswersIsSet = true;
}
bool QuestionResponse::answersIsSet() const
{
    return m_AnswersIsSet;
}
void QuestionResponse::unsetAnswers()
{
    m_AnswersIsSet = false;
}
org::openapitools::server::model::ScoreListResponse QuestionResponse::getScores() const
{
    return m_Scores;
}
void QuestionResponse::setScores(org::openapitools::server::model::ScoreListResponse const& value)
{
    m_Scores = value;
    m_ScoresIsSet = true;
}
bool QuestionResponse::scoresIsSet() const
{
    return m_ScoresIsSet;
}
void QuestionResponse::unsetScores()
{
    m_ScoresIsSet = false;
}
org::openapitools::server::model::TicketListResponse QuestionResponse::getTickets() const
{
    return m_Tickets;
}
void QuestionResponse::setTickets(org::openapitools::server::model::TicketListResponse const& value)
{
    m_Tickets = value;
    m_TicketsIsSet = true;
}
bool QuestionResponse::ticketsIsSet() const
{
    return m_TicketsIsSet;
}
void QuestionResponse::unsetTickets()
{
    m_TicketsIsSet = false;
}
org::openapitools::server::model::AccountShortResponse QuestionResponse::getOwner() const
{
    return m_Owner;
}
void QuestionResponse::setOwner(org::openapitools::server::model::AccountShortResponse const& value)
{
    m_Owner = value;
    m_OwnerIsSet = true;
}
bool QuestionResponse::ownerIsSet() const
{
    return m_OwnerIsSet;
}
void QuestionResponse::unsetOwner()
{
    m_OwnerIsSet = false;
}
org::openapitools::server::model::AssetShortResponse QuestionResponse::getIcon() const
{
    return m_Icon;
}
void QuestionResponse::setIcon(org::openapitools::server::model::AssetShortResponse const& value)
{
    m_Icon = value;
    m_IconIsSet = true;
}
bool QuestionResponse::iconIsSet() const
{
    return m_IconIsSet;
}
void QuestionResponse::unsetIcon()
{
    m_IconIsSet = false;
}
std::string QuestionResponse::getAuthorOverride() const
{
    return m_AuthorOverride;
}
void QuestionResponse::setAuthorOverride(std::string const& value)
{
    m_AuthorOverride = value;
    m_AuthorOverrideIsSet = true;
}
bool QuestionResponse::authorOverrideIsSet() const
{
    return m_AuthorOverrideIsSet;
}
void QuestionResponse::unsetAuthorOverride()
{
    m_AuthorOverrideIsSet = false;
}
int64_t QuestionResponse::getUpdatedDate() const
{
    return m_UpdatedDate;
}
void QuestionResponse::setUpdatedDate(int64_t const value)
{
    m_UpdatedDate = value;
    m_UpdatedDateIsSet = true;
}
bool QuestionResponse::updatedDateIsSet() const
{
    return m_UpdatedDateIsSet;
}
void QuestionResponse::unsetUpdatedDate()
{
    m_UpdatedDateIsSet = false;
}
int64_t QuestionResponse::getStartDate() const
{
    return m_StartDate;
}
void QuestionResponse::setStartDate(int64_t const value)
{
    m_StartDate = value;
    m_StartDateIsSet = true;
}
bool QuestionResponse::startDateIsSet() const
{
    return m_StartDateIsSet;
}
void QuestionResponse::unsetStartDate()
{
    m_StartDateIsSet = false;
}
int64_t QuestionResponse::getEndDate() const
{
    return m_EndDate;
}
void QuestionResponse::setEndDate(int64_t const value)
{
    m_EndDate = value;
    m_EndDateIsSet = true;
}
bool QuestionResponse::endDateIsSet() const
{
    return m_EndDateIsSet;
}
void QuestionResponse::unsetEndDate()
{
    m_EndDateIsSet = false;
}
int64_t QuestionResponse::getCreatedDate() const
{
    return m_CreatedDate;
}
void QuestionResponse::setCreatedDate(int64_t const value)
{
    m_CreatedDate = value;
    m_CreatedDateIsSet = true;
}
bool QuestionResponse::createdDateIsSet() const
{
    return m_CreatedDateIsSet;
}
void QuestionResponse::unsetCreatedDate()
{
    m_CreatedDateIsSet = false;
}
std::string QuestionResponse::getTags() const
{
    return m_Tags;
}
void QuestionResponse::setTags(std::string const& value)
{
    m_Tags = value;
    m_TagsIsSet = true;
}
bool QuestionResponse::tagsIsSet() const
{
    return m_TagsIsSet;
}
void QuestionResponse::unsetTags()
{
    m_TagsIsSet = false;
}
bool QuestionResponse::isAllocateTickets() const
{
    return m_AllocateTickets;
}
void QuestionResponse::setAllocateTickets(bool const value)
{
    m_AllocateTickets = value;
    m_AllocateTicketsIsSet = true;
}
bool QuestionResponse::allocateTicketsIsSet() const
{
    return m_AllocateTicketsIsSet;
}
void QuestionResponse::unsetAllocateTickets()
{
    m_AllocateTicketsIsSet = false;
}
std::string QuestionResponse::getTicketType() const
{
    return m_TicketType;
}
void QuestionResponse::setTicketType(std::string const& value)
{
    m_TicketType = value;
    m_TicketTypeIsSet = true;
}
bool QuestionResponse::ticketTypeIsSet() const
{
    return m_TicketTypeIsSet;
}
void QuestionResponse::unsetTicketType()
{
    m_TicketTypeIsSet = false;
}
int64_t QuestionResponse::getTicketCount() const
{
    return m_TicketCount;
}
void QuestionResponse::setTicketCount(int64_t const value)
{
    m_TicketCount = value;
    m_TicketCountIsSet = true;
}
bool QuestionResponse::ticketCountIsSet() const
{
    return m_TicketCountIsSet;
}
void QuestionResponse::unsetTicketCount()
{
    m_TicketCountIsSet = false;
}
int64_t QuestionResponse::getPoints() const
{
    return m_Points;
}
void QuestionResponse::setPoints(int64_t const value)
{
    m_Points = value;
    m_PointsIsSet = true;
}
bool QuestionResponse::pointsIsSet() const
{
    return m_PointsIsSet;
}
void QuestionResponse::unsetPoints()
{
    m_PointsIsSet = false;
}


} // namespace org::openapitools::server::model

