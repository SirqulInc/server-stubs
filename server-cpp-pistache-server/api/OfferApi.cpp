/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "OfferApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string OfferApi::base = "";

OfferApi::OfferApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void OfferApi::init() {
    setupRoutes();
}

void OfferApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/retailer/offer/location/batchUpdate", Routes::bind(&OfferApi::batch_update_offer_locations_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/create", Routes::bind(&OfferApi::create_offer_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/delete", Routes::bind(&OfferApi::delete_offer_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/location/delete", Routes::bind(&OfferApi::delete_offer_location_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/offer/get", Routes::bind(&OfferApi::get_offer_handler, this));
    Routes::Get(*router, base + "/api/:version/offer/get", Routes::bind(&OfferApi::get_offer_details_handler, this));
    Routes::Get(*router, base + "/api/:version/offer/lists/count", Routes::bind(&OfferApi::get_offer_list_counts_handler, this));
    Routes::Get(*router, base + "/api/:version/offer/location/get", Routes::bind(&OfferApi::get_offer_location_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/offer/location/search", Routes::bind(&OfferApi::get_offer_locations_for_retailers_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/offer/search", Routes::bind(&OfferApi::get_offers_for_retailers_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/transaction/update", Routes::bind(&OfferApi::redeem_offer_transaction_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/offer/transaction/search", Routes::bind(&OfferApi::search_offer_transactions_for_retailers_handler, this));
    Routes::Get(*router, base + "/api/:version/offer/lists", Routes::bind(&OfferApi::search_offers_for_consumer_handler, this));
    Routes::Get(*router, base + "/api/:version/offer/top", Routes::bind(&OfferApi::top_offer_transactions_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/update", Routes::bind(&OfferApi::update_offer_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/offer/status", Routes::bind(&OfferApi::update_offer_status_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&OfferApi::offer_api_default_handler, this));
}

void OfferApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OfferApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void OfferApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OfferApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void OfferApi::batch_update_offer_locations_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
    


        try {





            this->batch_update_offer_locations(version, data, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::create_offer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto parentOfferIdQuery = request.query().get("parentOfferId");
        std::optional<int64_t> parentOfferId;
        if (parentOfferIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentOfferIdQuery.value(), valueQuery_instance)) {
                parentOfferId = valueQuery_instance;
            }
        }
        auto includeOfferLocationsQuery = request.query().get("includeOfferLocations");
        std::optional<bool> includeOfferLocations;
        if (includeOfferLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeOfferLocationsQuery.value(), valueQuery_instance)) {
                includeOfferLocations = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto offerLocationsQuery = request.query().get("offerLocations");
        std::optional<std::string> offerLocations;
        if (offerLocationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerLocationsQuery.value(), valueQuery_instance)) {
                offerLocations = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTitleQuery = request.query().get("subTitle");
        std::optional<std::string> subTitle;
        if (subTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTitleQuery.value(), valueQuery_instance)) {
                subTitle = valueQuery_instance;
            }
        }
        auto detailsQuery = request.query().get("details");
        std::optional<std::string> details;
        if (detailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsQuery.value(), valueQuery_instance)) {
                details = valueQuery_instance;
            }
        }
        auto subDetailsQuery = request.query().get("subDetails");
        std::optional<std::string> subDetails;
        if (subDetailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subDetailsQuery.value(), valueQuery_instance)) {
                subDetails = valueQuery_instance;
            }
        }
        auto finePrintQuery = request.query().get("finePrint");
        std::optional<std::string> finePrint;
        if (finePrintQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(finePrintQuery.value(), valueQuery_instance)) {
                finePrint = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto externalRedeemOptionsQuery = request.query().get("externalRedeemOptions");
        std::optional<std::string> externalRedeemOptions;
        if (externalRedeemOptionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalRedeemOptionsQuery.value(), valueQuery_instance)) {
                externalRedeemOptions = valueQuery_instance;
            }
        }
        auto externalUrlQuery = request.query().get("externalUrl");
        std::optional<std::string> externalUrl;
        if (externalUrlQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalUrlQuery.value(), valueQuery_instance)) {
                externalUrl = valueQuery_instance;
            }
        }
        auto externalIdQuery = request.query().get("externalId");
        std::optional<std::string> externalId;
        if (externalIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalIdQuery.value(), valueQuery_instance)) {
                externalId = valueQuery_instance;
            }
        }
        auto ticketsRewardTypeQuery = request.query().get("ticketsRewardType");
        std::optional<std::string> ticketsRewardType;
        if (ticketsRewardTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketsRewardTypeQuery.value(), valueQuery_instance)) {
                ticketsRewardType = valueQuery_instance;
            }
        }
        auto ticketsRewardQuery = request.query().get("ticketsReward");
        std::optional<int64_t> ticketsReward;
        if (ticketsRewardQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketsRewardQuery.value(), valueQuery_instance)) {
                ticketsReward = valueQuery_instance;
            }
        }
        auto activatedQuery = request.query().get("activated");
        std::optional<int64_t> activated;
        if (activatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(activatedQuery.value(), valueQuery_instance)) {
                activated = valueQuery_instance;
            }
        }
        auto expiresQuery = request.query().get("expires");
        std::optional<int64_t> expires;
        if (expiresQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(expiresQuery.value(), valueQuery_instance)) {
                expires = valueQuery_instance;
            }
        }
        auto noExpirationQuery = request.query().get("noExpiration");
        std::optional<bool> noExpiration;
        if (noExpirationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(noExpirationQuery.value(), valueQuery_instance)) {
                noExpiration = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto availableLimitPerUserQuery = request.query().get("availableLimitPerUser");
        std::optional<int32_t> availableLimitPerUser;
        if (availableLimitPerUserQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitPerUserQuery.value(), valueQuery_instance)) {
                availableLimitPerUser = valueQuery_instance;
            }
        }
        auto addedLimitQuery = request.query().get("addedLimit");
        std::optional<int32_t> addedLimit;
        if (addedLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(addedLimitQuery.value(), valueQuery_instance)) {
                addedLimit = valueQuery_instance;
            }
        }
        auto viewLimitQuery = request.query().get("viewLimit");
        std::optional<int32_t> viewLimit;
        if (viewLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(viewLimitQuery.value(), valueQuery_instance)) {
                viewLimit = valueQuery_instance;
            }
        }
        auto maxPrintsQuery = request.query().get("maxPrints");
        std::optional<int32_t> maxPrints;
        if (maxPrintsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxPrintsQuery.value(), valueQuery_instance)) {
                maxPrints = valueQuery_instance;
            }
        }
        auto ticketPriceTypeQuery = request.query().get("ticketPriceType");
        std::optional<std::string> ticketPriceType;
        if (ticketPriceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketPriceTypeQuery.value(), valueQuery_instance)) {
                ticketPriceType = valueQuery_instance;
            }
        }
        auto ticketPriceQuery = request.query().get("ticketPrice");
        std::optional<int64_t> ticketPrice;
        if (ticketPriceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketPriceQuery.value(), valueQuery_instance)) {
                ticketPrice = valueQuery_instance;
            }
        }
        auto fullPriceQuery = request.query().get("fullPrice");
        std::optional<double> fullPrice;
        if (fullPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(fullPriceQuery.value(), valueQuery_instance)) {
                fullPrice = valueQuery_instance;
            }
        }
        auto discountPriceQuery = request.query().get("discountPrice");
        std::optional<double> discountPrice;
        if (discountPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(discountPriceQuery.value(), valueQuery_instance)) {
                discountPrice = valueQuery_instance;
            }
        }
        auto showRemainingQuery = request.query().get("showRemaining");
        std::optional<bool> showRemaining;
        if (showRemainingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRemainingQuery.value(), valueQuery_instance)) {
                showRemaining = valueQuery_instance;
            }
        }
        auto showRedeemedQuery = request.query().get("showRedeemed");
        std::optional<bool> showRedeemed;
        if (showRedeemedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRedeemedQuery.value(), valueQuery_instance)) {
                showRedeemed = valueQuery_instance;
            }
        }
        auto replacedQuery = request.query().get("replaced");
        std::optional<bool> replaced;
        if (replacedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(replacedQuery.value(), valueQuery_instance)) {
                replaced = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto offerTypeQuery = request.query().get("offerType");
        std::optional<std::string> offerType;
        if (offerTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypeQuery.value(), valueQuery_instance)) {
                offerType = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto offerVisibilityQuery = request.query().get("offerVisibility");
        std::optional<std::string> offerVisibility;
        if (offerVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerVisibilityQuery.value(), valueQuery_instance)) {
                offerVisibility = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto barcodeAssetIdQuery = request.query().get("barcodeAssetId");
        std::optional<int64_t> barcodeAssetId;
        if (barcodeAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(barcodeAssetIdQuery.value(), valueQuery_instance)) {
                barcodeAssetId = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto imageAssetId1Query = request.query().get("imageAssetId1");
        std::optional<int64_t> imageAssetId1;
        if (imageAssetId1Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId1Query.value(), valueQuery_instance)) {
                imageAssetId1 = valueQuery_instance;
            }
        }
        auto imageAssetId2Query = request.query().get("imageAssetId2");
        std::optional<int64_t> imageAssetId2;
        if (imageAssetId2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId2Query.value(), valueQuery_instance)) {
                imageAssetId2 = valueQuery_instance;
            }
        }
        auto imageAssetId3Query = request.query().get("imageAssetId3");
        std::optional<int64_t> imageAssetId3;
        if (imageAssetId3Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId3Query.value(), valueQuery_instance)) {
                imageAssetId3 = valueQuery_instance;
            }
        }
        auto imageAssetId4Query = request.query().get("imageAssetId4");
        std::optional<int64_t> imageAssetId4;
        if (imageAssetId4Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId4Query.value(), valueQuery_instance)) {
                imageAssetId4 = valueQuery_instance;
            }
        }
        auto imageAssetId5Query = request.query().get("imageAssetId5");
        std::optional<int64_t> imageAssetId5;
        if (imageAssetId5Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId5Query.value(), valueQuery_instance)) {
                imageAssetId5 = valueQuery_instance;
            }
        }
        auto publisherQuery = request.query().get("publisher");
        std::optional<std::string> publisher;
        if (publisherQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(publisherQuery.value(), valueQuery_instance)) {
                publisher = valueQuery_instance;
            }
        }
        auto redeemableStartQuery = request.query().get("redeemableStart");
        std::optional<int64_t> redeemableStart;
        if (redeemableStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableStartQuery.value(), valueQuery_instance)) {
                redeemableStart = valueQuery_instance;
            }
        }
        auto redeemableEndQuery = request.query().get("redeemableEnd");
        std::optional<int64_t> redeemableEnd;
        if (redeemableEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableEndQuery.value(), valueQuery_instance)) {
                redeemableEnd = valueQuery_instance;
            }
        }
        auto brandQuery = request.query().get("brand");
        std::optional<std::string> brand;
        if (brandQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(brandQuery.value(), valueQuery_instance)) {
                brand = valueQuery_instance;
            }
        }
        auto productTypeQuery = request.query().get("productType");
        std::optional<std::string> productType;
        if (productTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(productTypeQuery.value(), valueQuery_instance)) {
                productType = valueQuery_instance;
            }
        }
        auto conditionTypeQuery = request.query().get("conditionType");
        std::optional<std::string> conditionType;
        if (conditionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionTypeQuery.value(), valueQuery_instance)) {
                conditionType = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto catalogNumbersQuery = request.query().get("catalogNumbers");
        std::optional<std::string> catalogNumbers;
        if (catalogNumbersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(catalogNumbersQuery.value(), valueQuery_instance)) {
                catalogNumbers = valueQuery_instance;
            }
        }
        auto departmentQuery = request.query().get("department");
        std::optional<std::string> department;
        if (departmentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(departmentQuery.value(), valueQuery_instance)) {
                department = valueQuery_instance;
            }
        }
        auto featuresQuery = request.query().get("features");
        std::optional<std::string> features;
        if (featuresQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(featuresQuery.value(), valueQuery_instance)) {
                features = valueQuery_instance;
            }
        }
        auto minimumPriceQuery = request.query().get("minimumPrice");
        std::optional<double> minimumPrice;
        if (minimumPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(minimumPriceQuery.value(), valueQuery_instance)) {
                minimumPrice = valueQuery_instance;
            }
        }
        auto widthQuery = request.query().get("width");
        std::optional<double> width;
        if (widthQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(widthQuery.value(), valueQuery_instance)) {
                width = valueQuery_instance;
            }
        }
        auto heightQuery = request.query().get("height");
        std::optional<double> height;
        if (heightQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(heightQuery.value(), valueQuery_instance)) {
                height = valueQuery_instance;
            }
        }
        auto depthQuery = request.query().get("depth");
        std::optional<double> depth;
        if (depthQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(depthQuery.value(), valueQuery_instance)) {
                depth = valueQuery_instance;
            }
        }
        auto weightQuery = request.query().get("weight");
        std::optional<double> weight;
        if (weightQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(weightQuery.value(), valueQuery_instance)) {
                weight = valueQuery_instance;
            }
        }
        auto unitQuery = request.query().get("unit");
        std::optional<std::string> unit;
        if (unitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(unitQuery.value(), valueQuery_instance)) {
                unit = valueQuery_instance;
            }
        }
        auto studioQuery = request.query().get("studio");
        std::optional<std::string> studio;
        if (studioQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(studioQuery.value(), valueQuery_instance)) {
                studio = valueQuery_instance;
            }
        }
        auto parentalRatingQuery = request.query().get("parentalRating");
        std::optional<std::string> parentalRating;
        if (parentalRatingQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentalRatingQuery.value(), valueQuery_instance)) {
                parentalRating = valueQuery_instance;
            }
        }
        auto publishDateQuery = request.query().get("publishDate");
        std::optional<int64_t> publishDate;
        if (publishDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(publishDateQuery.value(), valueQuery_instance)) {
                publishDate = valueQuery_instance;
            }
        }
        auto availabilityDateQuery = request.query().get("availabilityDate");
        std::optional<int64_t> availabilityDate;
        if (availabilityDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(availabilityDateQuery.value(), valueQuery_instance)) {
                availabilityDate = valueQuery_instance;
            }
        }
        auto sizeIdQuery = request.query().get("sizeId");
        std::optional<int64_t> sizeId;
        if (sizeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(sizeIdQuery.value(), valueQuery_instance)) {
                sizeId = valueQuery_instance;
            }
        }
        auto listingIdQuery = request.query().get("listingId");
        std::optional<int64_t> listingId;
        if (listingIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(listingIdQuery.value(), valueQuery_instance)) {
                listingId = valueQuery_instance;
            }
        }
        auto mediaTypeQuery = request.query().get("mediaType");
        std::optional<std::string> mediaType;
        if (mediaTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mediaTypeQuery.value(), valueQuery_instance)) {
                mediaType = valueQuery_instance;
            }
        }
        auto durationQuery = request.query().get("duration");
        std::optional<int32_t> duration;
        if (durationQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(durationQuery.value(), valueQuery_instance)) {
                duration = valueQuery_instance;
            }
        }
        auto authorQuery = request.query().get("author");
        std::optional<std::string> author;
        if (authorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(authorQuery.value(), valueQuery_instance)) {
                author = valueQuery_instance;
            }
        }
        auto releaseDateQuery = request.query().get("releaseDate");
        std::optional<int64_t> releaseDate;
        if (releaseDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(releaseDateQuery.value(), valueQuery_instance)) {
                releaseDate = valueQuery_instance;
            }
        }
        auto collectionIdsQuery = request.query().get("collectionIds");
        std::optional<std::string> collectionIds;
        if (collectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(collectionIdsQuery.value(), valueQuery_instance)) {
                collectionIds = valueQuery_instance;
            }
        }
        auto rebootTimeHourQuery = request.query().get("rebootTimeHour");
        std::optional<int32_t> rebootTimeHour;
        if (rebootTimeHourQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rebootTimeHourQuery.value(), valueQuery_instance)) {
                rebootTimeHour = valueQuery_instance;
            }
        }
        auto rebootTimeMinuteQuery = request.query().get("rebootTimeMinute");
        std::optional<int32_t> rebootTimeMinute;
        if (rebootTimeMinuteQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rebootTimeMinuteQuery.value(), valueQuery_instance)) {
                rebootTimeMinute = valueQuery_instance;
            }
        }
        auto idleTimeoutInSecondQuery = request.query().get("idleTimeoutInSecond");
        std::optional<int32_t> idleTimeoutInSecond;
        if (idleTimeoutInSecondQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(idleTimeoutInSecondQuery.value(), valueQuery_instance)) {
                idleTimeoutInSecond = valueQuery_instance;
            }
        }
        auto serialNumberQuery = request.query().get("serialNumber");
        std::optional<std::string> serialNumber;
        if (serialNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(serialNumberQuery.value(), valueQuery_instance)) {
                serialNumber = valueQuery_instance;
            }
        }
        auto udidQuery = request.query().get("udid");
        std::optional<std::string> udid;
        if (udidQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(udidQuery.value(), valueQuery_instance)) {
                udid = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto devicePowerQuery = request.query().get("devicePower");
        std::optional<double> devicePower;
        if (devicePowerQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(devicePowerQuery.value(), valueQuery_instance)) {
                devicePower = valueQuery_instance;
            }
        }
        auto deviceInterferenceQuery = request.query().get("deviceInterference");
        std::optional<double> deviceInterference;
        if (deviceInterferenceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(deviceInterferenceQuery.value(), valueQuery_instance)) {
                deviceInterference = valueQuery_instance;
            }
        }
        auto availabilityQuery = request.query().get("availability");
        std::optional<std::string> availability;
        if (availabilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilityQuery.value(), valueQuery_instance)) {
                availability = valueQuery_instance;
            }
        }
        auto availabilitySummaryQuery = request.query().get("availabilitySummary");
        std::optional<std::string> availabilitySummary;
        if (availabilitySummaryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilitySummaryQuery.value(), valueQuery_instance)) {
                availabilitySummary = valueQuery_instance;
            }
        }
    


        try {





            this->create_offer(version, includeOfferLocations, title, barcodeType, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPrice, fullPrice, discountPrice, offerType, specialOfferType, offerVisibility, active, deviceId, accountId, tags, parentOfferId, retailerLocationIds, offerLocations, subTitle, details, subDetails, finePrint, barcodeEntry, externalRedeemOptions, externalUrl, externalId, ticketsRewardType, ticketsReward, activated, expires, ticketPriceType, showRemaining, showRedeemed, replaced, featured, categoryIds, filterIds, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, brand, productType, conditionType, isbn, asin, catalogNumbers, department, features, minimumPrice, width, height, depth, weight, unit, studio, parentalRating, publishDate, availabilityDate, sizeId, listingId, mediaType, duration, author, releaseDate, collectionIds, rebootTimeHour, rebootTimeMinute, idleTimeoutInSecond, serialNumber, udid, deviceType, devicePower, deviceInterference, availability, availabilitySummary, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::delete_offer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_offer(version, offerId, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::delete_offer_location_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerLocationIdQuery = request.query().get("offerLocationId");
        std::optional<int64_t> offerLocationId;
        if (offerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerLocationIdQuery.value(), valueQuery_instance)) {
                offerLocationId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_offer_location(version, offerLocationId, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto includeOfferLocationsQuery = request.query().get("includeOfferLocations");
        std::optional<bool> includeOfferLocations;
        if (includeOfferLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeOfferLocationsQuery.value(), valueQuery_instance)) {
                includeOfferLocations = valueQuery_instance;
            }
        }
    


        try {





            this->get_offer(version, offerId, includeOfferLocations, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offer_details_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto offerLocationIdQuery = request.query().get("offerLocationId");
        std::optional<int64_t> offerLocationId;
        if (offerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerLocationIdQuery.value(), valueQuery_instance)) {
                offerLocationId = valueQuery_instance;
            }
        }
        auto distanceQuery = request.query().get("distance");
        std::optional<double> distance;
        if (distanceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(distanceQuery.value(), valueQuery_instance)) {
                distance = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto includeOfferLocationsQuery = request.query().get("includeOfferLocations");
        std::optional<bool> includeOfferLocations;
        if (includeOfferLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeOfferLocationsQuery.value(), valueQuery_instance)) {
                includeOfferLocations = valueQuery_instance;
            }
        }
        auto includeRetailerLocationsQuery = request.query().get("includeRetailerLocations");
        std::optional<bool> includeRetailerLocations;
        if (includeRetailerLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRetailerLocationsQuery.value(), valueQuery_instance)) {
                includeRetailerLocations = valueQuery_instance;
            }
        }
        auto includeChildOffersQuery = request.query().get("includeChildOffers");
        std::optional<bool> includeChildOffers;
        if (includeChildOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeChildOffersQuery.value(), valueQuery_instance)) {
                includeChildOffers = valueQuery_instance;
            }
        }
    


        try {





            this->get_offer_details(version, deviceId, accountId, offerId, offerLocationId, distance, latitude, longitude, includeOfferLocations, includeRetailerLocations, includeChildOffers, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offer_list_counts_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto searchRangeQuery = request.query().get("searchRange");
        std::optional<double> searchRange;
        if (searchRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(searchRangeQuery.value(), valueQuery_instance)) {
                searchRange = valueQuery_instance;
            }
        }
        auto distanceUnitQuery = request.query().get("distanceUnit");
        std::optional<std::string> distanceUnit;
        if (distanceUnitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(distanceUnitQuery.value(), valueQuery_instance)) {
                distanceUnit = valueQuery_instance;
            }
        }
    


        try {





            this->get_offer_list_counts(version, latitude, longitude, searchRange, distanceUnit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offer_location_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto offerLocationIdQuery = request.query().get("offerLocationId");
        std::optional<int64_t> offerLocationId;
        if (offerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerLocationIdQuery.value(), valueQuery_instance)) {
                offerLocationId = valueQuery_instance;
            }
        }
        auto udidQuery = request.query().get("udid");
        std::optional<std::string> udid;
        if (udidQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(udidQuery.value(), valueQuery_instance)) {
                udid = valueQuery_instance;
            }
        }
    


        try {





            this->get_offer_location(version, offerLocationId, udid, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offer_locations_for_retailers_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto retailerIdQuery = request.query().get("retailerId");
        std::optional<int64_t> retailerId;
        if (retailerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerIdQuery.value(), valueQuery_instance)) {
                retailerId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto offerTypeQuery = request.query().get("offerType");
        std::optional<std::string> offerType;
        if (offerTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypeQuery.value(), valueQuery_instance)) {
                offerType = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto includeRetailerLocationQuery = request.query().get("includeRetailerLocation");
        std::optional<bool> includeRetailerLocation;
        if (includeRetailerLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRetailerLocationQuery.value(), valueQuery_instance)) {
                includeRetailerLocation = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto deviceStatusQuery = request.query().get("deviceStatus");
        std::optional<std::string> deviceStatus;
        if (deviceStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceStatusQuery.value(), valueQuery_instance)) {
                deviceStatus = valueQuery_instance;
            }
        }
        auto needsNotificationSentQuery = request.query().get("needsNotificationSent");
        std::optional<bool> needsNotificationSent;
        if (needsNotificationSentQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(needsNotificationSentQuery.value(), valueQuery_instance)) {
                needsNotificationSent = valueQuery_instance;
            }
        }
        auto lastNotificationSentQuery = request.query().get("lastNotificationSent");
        std::optional<int64_t> lastNotificationSent;
        if (lastNotificationSentQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(lastNotificationSentQuery.value(), valueQuery_instance)) {
                lastNotificationSent = valueQuery_instance;
            }
        }
    


        try {





            this->get_offer_locations_for_retailers(version, sortField, descending, start, limit, activeOnly, includeRetailerLocation, deviceId, accountId, keyword, retailerId, retailerLocationId, offerType, specialOfferType, barcodeType, barcodeEntry, isbn, asin, deviceStatus, needsNotificationSent, lastNotificationSent, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::get_offers_for_retailers_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto retailerIdQuery = request.query().get("retailerId");
        std::optional<int64_t> retailerId;
        if (retailerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerIdQuery.value(), valueQuery_instance)) {
                retailerId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto couponTypeQuery = request.query().get("couponType");
        std::optional<std::string> couponType;
        if (couponTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(couponTypeQuery.value(), valueQuery_instance)) {
                couponType = valueQuery_instance;
            }
        }
        auto offerTypeQuery = request.query().get("offerType");
        std::optional<std::string> offerType;
        if (offerTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypeQuery.value(), valueQuery_instance)) {
                offerType = valueQuery_instance;
            }
        }
        auto offerTypesQuery = request.query().get("offerTypes");
        std::optional<std::string> offerTypes;
        if (offerTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypesQuery.value(), valueQuery_instance)) {
                offerTypes = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto offerVisibilityQuery = request.query().get("offerVisibility");
        std::optional<std::string> offerVisibility;
        if (offerVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerVisibilityQuery.value(), valueQuery_instance)) {
                offerVisibility = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto availableOnlyQuery = request.query().get("availableOnly");
        std::optional<bool> availableOnly;
        if (availableOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(availableOnlyQuery.value(), valueQuery_instance)) {
                availableOnly = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto includeCategoriesQuery = request.query().get("includeCategories");
        std::optional<bool> includeCategories;
        if (includeCategoriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeCategoriesQuery.value(), valueQuery_instance)) {
                includeCategories = valueQuery_instance;
            }
        }
        auto includeFiltersQuery = request.query().get("includeFilters");
        std::optional<bool> includeFilters;
        if (includeFiltersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFiltersQuery.value(), valueQuery_instance)) {
                includeFilters = valueQuery_instance;
            }
        }
        auto includeOfferLocationsQuery = request.query().get("includeOfferLocations");
        std::optional<bool> includeOfferLocations;
        if (includeOfferLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeOfferLocationsQuery.value(), valueQuery_instance)) {
                includeOfferLocations = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto deviceStatusQuery = request.query().get("deviceStatus");
        std::optional<std::string> deviceStatus;
        if (deviceStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceStatusQuery.value(), valueQuery_instance)) {
                deviceStatus = valueQuery_instance;
            }
        }
        auto needsNotificationSentQuery = request.query().get("needsNotificationSent");
        std::optional<bool> needsNotificationSent;
        if (needsNotificationSentQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(needsNotificationSentQuery.value(), valueQuery_instance)) {
                needsNotificationSent = valueQuery_instance;
            }
        }
        auto lastNotificationSentQuery = request.query().get("lastNotificationSent");
        std::optional<int64_t> lastNotificationSent;
        if (lastNotificationSentQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(lastNotificationSentQuery.value(), valueQuery_instance)) {
                lastNotificationSent = valueQuery_instance;
            }
        }
    


        try {





            this->get_offers_for_retailers(version, offerVisibility, sortField, descending, start, limit, availableOnly, activeOnly, includeCategories, includeFilters, includeOfferLocations, deviceId, accountId, categoryIds, filterIds, q, keyword, retailerId, retailerLocationId, couponType, offerType, offerTypes, specialOfferType, i, l, barcodeType, barcodeEntry, isbn, asin, deviceStatus, needsNotificationSent, lastNotificationSent, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::redeem_offer_transaction_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerTransactionIdQuery = request.query().get("offerTransactionId");
        std::optional<int64_t> offerTransactionId;
        if (offerTransactionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerTransactionIdQuery.value(), valueQuery_instance)) {
                offerTransactionId = valueQuery_instance;
            }
        }
        auto offerLocationIdQuery = request.query().get("offerLocationId");
        std::optional<int64_t> offerLocationId;
        if (offerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerLocationIdQuery.value(), valueQuery_instance)) {
                offerLocationId = valueQuery_instance;
            }
        }
        auto statusQuery = request.query().get("status");
        std::optional<int32_t> status;
        if (statusQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(statusQuery.value(), valueQuery_instance)) {
                status = valueQuery_instance;
            }
        }
    


        try {





            this->redeem_offer_transaction(version, offerTransactionId, status, deviceId, accountId, offerLocationId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::search_offer_transactions_for_retailers_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto retailerIdQuery = request.query().get("retailerId");
        std::optional<int64_t> retailerId;
        if (retailerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerIdQuery.value(), valueQuery_instance)) {
                retailerId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto offerLocationIdQuery = request.query().get("offerLocationId");
        std::optional<int64_t> offerLocationId;
        if (offerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerLocationIdQuery.value(), valueQuery_instance)) {
                offerLocationId = valueQuery_instance;
            }
        }
        auto redeemedQuery = request.query().get("redeemed");
        std::optional<bool> redeemed;
        if (redeemedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(redeemedQuery.value(), valueQuery_instance)) {
                redeemed = valueQuery_instance;
            }
        }
        auto reservationsOnlyQuery = request.query().get("reservationsOnly");
        std::optional<bool> reservationsOnly;
        if (reservationsOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(reservationsOnlyQuery.value(), valueQuery_instance)) {
                reservationsOnly = valueQuery_instance;
            }
        }
        auto couponTypeQuery = request.query().get("couponType");
        std::optional<std::string> couponType;
        if (couponTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(couponTypeQuery.value(), valueQuery_instance)) {
                couponType = valueQuery_instance;
            }
        }
        auto offerTypeQuery = request.query().get("offerType");
        std::optional<std::string> offerType;
        if (offerTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypeQuery.value(), valueQuery_instance)) {
                offerType = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto customerAccountIdsQuery = request.query().get("customerAccountIds");
        std::optional<std::string> customerAccountIds;
        if (customerAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customerAccountIdsQuery.value(), valueQuery_instance)) {
                customerAccountIds = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto redeemableStartDateQuery = request.query().get("redeemableStartDate");
        std::optional<int64_t> redeemableStartDate;
        if (redeemableStartDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableStartDateQuery.value(), valueQuery_instance)) {
                redeemableStartDate = valueQuery_instance;
            }
        }
        auto redeemableEndDateQuery = request.query().get("redeemableEndDate");
        std::optional<int64_t> redeemableEndDate;
        if (redeemableEndDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableEndDateQuery.value(), valueQuery_instance)) {
                redeemableEndDate = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
    


        try {





            this->search_offer_transactions_for_retailers(version, sortField, descending, start, limit, activeOnly, deviceId, accountId, q, keyword, retailerId, retailerLocationId, offerId, offerLocationId, redeemed, reservationsOnly, couponType, offerType, specialOfferType, customerAccountIds, categoryIds, redeemableStartDate, redeemableEndDate, i, l, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::search_offers_for_consumer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto searchRangeQuery = request.query().get("searchRange");
        std::optional<double> searchRange;
        if (searchRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(searchRangeQuery.value(), valueQuery_instance)) {
                searchRange = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto supportedPostalCodesQuery = request.query().get("supportedPostalCodes");
        std::optional<std::string> supportedPostalCodes;
        if (supportedPostalCodesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(supportedPostalCodesQuery.value(), valueQuery_instance)) {
                supportedPostalCodes = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto categoriesQuery = request.query().get("categories");
        std::optional<std::string> categories;
        if (categoriesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoriesQuery.value(), valueQuery_instance)) {
                categories = valueQuery_instance;
            }
        }
        auto filtersQuery = request.query().get("filters");
        std::optional<std::string> filters;
        if (filtersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filtersQuery.value(), valueQuery_instance)) {
                filters = valueQuery_instance;
            }
        }
        auto offerTypesQuery = request.query().get("offerTypes");
        std::optional<std::string> offerTypes;
        if (offerTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypesQuery.value(), valueQuery_instance)) {
                offerTypes = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto recommendOfferIdsQuery = request.query().get("recommendOfferIds");
        std::optional<std::string> recommendOfferIds;
        if (recommendOfferIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(recommendOfferIdsQuery.value(), valueQuery_instance)) {
                recommendOfferIds = valueQuery_instance;
            }
        }
        auto recommendationTypeQuery = request.query().get("recommendationType");
        std::optional<std::string> recommendationType;
        if (recommendationTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(recommendationTypeQuery.value(), valueQuery_instance)) {
                recommendationType = valueQuery_instance;
            }
        }
        auto locationIdQuery = request.query().get("locationId");
        std::optional<int64_t> locationId;
        if (locationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(locationIdQuery.value(), valueQuery_instance)) {
                locationId = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto includeMissionQuery = request.query().get("includeMission");
        std::optional<bool> includeMission;
        if (includeMissionQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeMissionQuery.value(), valueQuery_instance)) {
                includeMission = valueQuery_instance;
            }
        }
        auto includeCategoriesQuery = request.query().get("includeCategories");
        std::optional<bool> includeCategories;
        if (includeCategoriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeCategoriesQuery.value(), valueQuery_instance)) {
                includeCategories = valueQuery_instance;
            }
        }
        auto includeFiltersQuery = request.query().get("includeFilters");
        std::optional<bool> includeFilters;
        if (includeFiltersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFiltersQuery.value(), valueQuery_instance)) {
                includeFilters = valueQuery_instance;
            }
        }
        auto includeExpiredQuery = request.query().get("includeExpired");
        std::optional<bool> includeExpired;
        if (includeExpiredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeExpiredQuery.value(), valueQuery_instance)) {
                includeExpired = valueQuery_instance;
            }
        }
        auto includeFavoriteQuery = request.query().get("includeFavorite");
        std::optional<bool> includeFavorite;
        if (includeFavoriteQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFavoriteQuery.value(), valueQuery_instance)) {
                includeFavorite = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto maxRecommendationsQuery = request.query().get("maxRecommendations");
        std::optional<int32_t> maxRecommendations;
        if (maxRecommendationsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxRecommendationsQuery.value(), valueQuery_instance)) {
                maxRecommendations = valueQuery_instance;
            }
        }
        auto distanceUnitQuery = request.query().get("distanceUnit");
        std::optional<std::string> distanceUnit;
        if (distanceUnitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(distanceUnitQuery.value(), valueQuery_instance)) {
                distanceUnit = valueQuery_instance;
            }
        }
        auto closestOfferOnlyQuery = request.query().get("closestOfferOnly");
        std::optional<bool> closestOfferOnly;
        if (closestOfferOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(closestOfferOnlyQuery.value(), valueQuery_instance)) {
                closestOfferOnly = valueQuery_instance;
            }
        }
        auto searchExpressionQuery = request.query().get("searchExpression");
        std::optional<std::string> searchExpression;
        if (searchExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchExpressionQuery.value(), valueQuery_instance)) {
                searchExpression = valueQuery_instance;
            }
        }
        auto groupByQuery = request.query().get("groupBy");
        std::optional<std::string> groupBy;
        if (groupByQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupByQuery.value(), valueQuery_instance)) {
                groupBy = valueQuery_instance;
            }
        }
    


        try {





            this->search_offers_for_consumer(version, latitude, longitude, recommendationType, locationId, start, limit, maxRecommendations, distanceUnit, appKey, deviceId, accountId, searchRange, tags, supportedPostalCodes, keyword, categories, filters, offerTypes, type, sortField, recommendOfferIds, retailerLocationIds, offerId, includeMission, includeCategories, includeFilters, includeExpired, includeFavorite, closestOfferOnly, searchExpression, groupBy, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::top_offer_transactions_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->top_offer_transactions(version, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::update_offer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto parentOfferIdQuery = request.query().get("parentOfferId");
        std::optional<int64_t> parentOfferId;
        if (parentOfferIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentOfferIdQuery.value(), valueQuery_instance)) {
                parentOfferId = valueQuery_instance;
            }
        }
        auto includeOfferLocationsQuery = request.query().get("includeOfferLocations");
        std::optional<bool> includeOfferLocations;
        if (includeOfferLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeOfferLocationsQuery.value(), valueQuery_instance)) {
                includeOfferLocations = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto offerLocationsQuery = request.query().get("offerLocations");
        std::optional<std::string> offerLocations;
        if (offerLocationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerLocationsQuery.value(), valueQuery_instance)) {
                offerLocations = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTitleQuery = request.query().get("subTitle");
        std::optional<std::string> subTitle;
        if (subTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTitleQuery.value(), valueQuery_instance)) {
                subTitle = valueQuery_instance;
            }
        }
        auto detailsQuery = request.query().get("details");
        std::optional<std::string> details;
        if (detailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsQuery.value(), valueQuery_instance)) {
                details = valueQuery_instance;
            }
        }
        auto subDetailsQuery = request.query().get("subDetails");
        std::optional<std::string> subDetails;
        if (subDetailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subDetailsQuery.value(), valueQuery_instance)) {
                subDetails = valueQuery_instance;
            }
        }
        auto finePrintQuery = request.query().get("finePrint");
        std::optional<std::string> finePrint;
        if (finePrintQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(finePrintQuery.value(), valueQuery_instance)) {
                finePrint = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto externalRedeemOptionsQuery = request.query().get("externalRedeemOptions");
        std::optional<std::string> externalRedeemOptions;
        if (externalRedeemOptionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalRedeemOptionsQuery.value(), valueQuery_instance)) {
                externalRedeemOptions = valueQuery_instance;
            }
        }
        auto externalUrlQuery = request.query().get("externalUrl");
        std::optional<std::string> externalUrl;
        if (externalUrlQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalUrlQuery.value(), valueQuery_instance)) {
                externalUrl = valueQuery_instance;
            }
        }
        auto externalIdQuery = request.query().get("externalId");
        std::optional<std::string> externalId;
        if (externalIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalIdQuery.value(), valueQuery_instance)) {
                externalId = valueQuery_instance;
            }
        }
        auto ticketsRewardTypeQuery = request.query().get("ticketsRewardType");
        std::optional<std::string> ticketsRewardType;
        if (ticketsRewardTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketsRewardTypeQuery.value(), valueQuery_instance)) {
                ticketsRewardType = valueQuery_instance;
            }
        }
        auto ticketsRewardQuery = request.query().get("ticketsReward");
        std::optional<int64_t> ticketsReward;
        if (ticketsRewardQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketsRewardQuery.value(), valueQuery_instance)) {
                ticketsReward = valueQuery_instance;
            }
        }
        auto activatedQuery = request.query().get("activated");
        std::optional<int64_t> activated;
        if (activatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(activatedQuery.value(), valueQuery_instance)) {
                activated = valueQuery_instance;
            }
        }
        auto expiresQuery = request.query().get("expires");
        std::optional<int64_t> expires;
        if (expiresQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(expiresQuery.value(), valueQuery_instance)) {
                expires = valueQuery_instance;
            }
        }
        auto noExpirationQuery = request.query().get("noExpiration");
        std::optional<bool> noExpiration;
        if (noExpirationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(noExpirationQuery.value(), valueQuery_instance)) {
                noExpiration = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto availableLimitPerUserQuery = request.query().get("availableLimitPerUser");
        std::optional<int32_t> availableLimitPerUser;
        if (availableLimitPerUserQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitPerUserQuery.value(), valueQuery_instance)) {
                availableLimitPerUser = valueQuery_instance;
            }
        }
        auto addedLimitQuery = request.query().get("addedLimit");
        std::optional<int32_t> addedLimit;
        if (addedLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(addedLimitQuery.value(), valueQuery_instance)) {
                addedLimit = valueQuery_instance;
            }
        }
        auto viewLimitQuery = request.query().get("viewLimit");
        std::optional<int32_t> viewLimit;
        if (viewLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(viewLimitQuery.value(), valueQuery_instance)) {
                viewLimit = valueQuery_instance;
            }
        }
        auto maxPrintsQuery = request.query().get("maxPrints");
        std::optional<int32_t> maxPrints;
        if (maxPrintsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxPrintsQuery.value(), valueQuery_instance)) {
                maxPrints = valueQuery_instance;
            }
        }
        auto ticketPriceTypeQuery = request.query().get("ticketPriceType");
        std::optional<std::string> ticketPriceType;
        if (ticketPriceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketPriceTypeQuery.value(), valueQuery_instance)) {
                ticketPriceType = valueQuery_instance;
            }
        }
        auto ticketPriceQuery = request.query().get("ticketPrice");
        std::optional<int64_t> ticketPrice;
        if (ticketPriceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketPriceQuery.value(), valueQuery_instance)) {
                ticketPrice = valueQuery_instance;
            }
        }
        auto fullPriceQuery = request.query().get("fullPrice");
        std::optional<double> fullPrice;
        if (fullPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(fullPriceQuery.value(), valueQuery_instance)) {
                fullPrice = valueQuery_instance;
            }
        }
        auto discountPriceQuery = request.query().get("discountPrice");
        std::optional<double> discountPrice;
        if (discountPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(discountPriceQuery.value(), valueQuery_instance)) {
                discountPrice = valueQuery_instance;
            }
        }
        auto showRemainingQuery = request.query().get("showRemaining");
        std::optional<bool> showRemaining;
        if (showRemainingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRemainingQuery.value(), valueQuery_instance)) {
                showRemaining = valueQuery_instance;
            }
        }
        auto showRedeemedQuery = request.query().get("showRedeemed");
        std::optional<bool> showRedeemed;
        if (showRedeemedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRedeemedQuery.value(), valueQuery_instance)) {
                showRedeemed = valueQuery_instance;
            }
        }
        auto replacedQuery = request.query().get("replaced");
        std::optional<bool> replaced;
        if (replacedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(replacedQuery.value(), valueQuery_instance)) {
                replaced = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto offerTypeQuery = request.query().get("offerType");
        std::optional<std::string> offerType;
        if (offerTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerTypeQuery.value(), valueQuery_instance)) {
                offerType = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto offerVisibilityQuery = request.query().get("offerVisibility");
        std::optional<std::string> offerVisibility;
        if (offerVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerVisibilityQuery.value(), valueQuery_instance)) {
                offerVisibility = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto barcodeAssetIdQuery = request.query().get("barcodeAssetId");
        std::optional<int64_t> barcodeAssetId;
        if (barcodeAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(barcodeAssetIdQuery.value(), valueQuery_instance)) {
                barcodeAssetId = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto imageAssetId1Query = request.query().get("imageAssetId1");
        std::optional<int64_t> imageAssetId1;
        if (imageAssetId1Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId1Query.value(), valueQuery_instance)) {
                imageAssetId1 = valueQuery_instance;
            }
        }
        auto imageAssetId2Query = request.query().get("imageAssetId2");
        std::optional<int64_t> imageAssetId2;
        if (imageAssetId2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId2Query.value(), valueQuery_instance)) {
                imageAssetId2 = valueQuery_instance;
            }
        }
        auto imageAssetId3Query = request.query().get("imageAssetId3");
        std::optional<int64_t> imageAssetId3;
        if (imageAssetId3Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId3Query.value(), valueQuery_instance)) {
                imageAssetId3 = valueQuery_instance;
            }
        }
        auto imageAssetId4Query = request.query().get("imageAssetId4");
        std::optional<int64_t> imageAssetId4;
        if (imageAssetId4Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId4Query.value(), valueQuery_instance)) {
                imageAssetId4 = valueQuery_instance;
            }
        }
        auto imageAssetId5Query = request.query().get("imageAssetId5");
        std::optional<int64_t> imageAssetId5;
        if (imageAssetId5Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId5Query.value(), valueQuery_instance)) {
                imageAssetId5 = valueQuery_instance;
            }
        }
        auto publisherQuery = request.query().get("publisher");
        std::optional<std::string> publisher;
        if (publisherQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(publisherQuery.value(), valueQuery_instance)) {
                publisher = valueQuery_instance;
            }
        }
        auto redeemableStartQuery = request.query().get("redeemableStart");
        std::optional<int64_t> redeemableStart;
        if (redeemableStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableStartQuery.value(), valueQuery_instance)) {
                redeemableStart = valueQuery_instance;
            }
        }
        auto redeemableEndQuery = request.query().get("redeemableEnd");
        std::optional<int64_t> redeemableEnd;
        if (redeemableEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableEndQuery.value(), valueQuery_instance)) {
                redeemableEnd = valueQuery_instance;
            }
        }
        auto brandQuery = request.query().get("brand");
        std::optional<std::string> brand;
        if (brandQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(brandQuery.value(), valueQuery_instance)) {
                brand = valueQuery_instance;
            }
        }
        auto productTypeQuery = request.query().get("productType");
        std::optional<std::string> productType;
        if (productTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(productTypeQuery.value(), valueQuery_instance)) {
                productType = valueQuery_instance;
            }
        }
        auto conditionTypeQuery = request.query().get("conditionType");
        std::optional<std::string> conditionType;
        if (conditionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionTypeQuery.value(), valueQuery_instance)) {
                conditionType = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto catalogNumbersQuery = request.query().get("catalogNumbers");
        std::optional<std::string> catalogNumbers;
        if (catalogNumbersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(catalogNumbersQuery.value(), valueQuery_instance)) {
                catalogNumbers = valueQuery_instance;
            }
        }
        auto departmentQuery = request.query().get("department");
        std::optional<std::string> department;
        if (departmentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(departmentQuery.value(), valueQuery_instance)) {
                department = valueQuery_instance;
            }
        }
        auto featuresQuery = request.query().get("features");
        std::optional<std::string> features;
        if (featuresQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(featuresQuery.value(), valueQuery_instance)) {
                features = valueQuery_instance;
            }
        }
        auto minimumPriceQuery = request.query().get("minimumPrice");
        std::optional<double> minimumPrice;
        if (minimumPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(minimumPriceQuery.value(), valueQuery_instance)) {
                minimumPrice = valueQuery_instance;
            }
        }
        auto widthQuery = request.query().get("width");
        std::optional<double> width;
        if (widthQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(widthQuery.value(), valueQuery_instance)) {
                width = valueQuery_instance;
            }
        }
        auto heightQuery = request.query().get("height");
        std::optional<double> height;
        if (heightQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(heightQuery.value(), valueQuery_instance)) {
                height = valueQuery_instance;
            }
        }
        auto depthQuery = request.query().get("depth");
        std::optional<double> depth;
        if (depthQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(depthQuery.value(), valueQuery_instance)) {
                depth = valueQuery_instance;
            }
        }
        auto weightQuery = request.query().get("weight");
        std::optional<double> weight;
        if (weightQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(weightQuery.value(), valueQuery_instance)) {
                weight = valueQuery_instance;
            }
        }
        auto unitQuery = request.query().get("unit");
        std::optional<std::string> unit;
        if (unitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(unitQuery.value(), valueQuery_instance)) {
                unit = valueQuery_instance;
            }
        }
        auto studioQuery = request.query().get("studio");
        std::optional<std::string> studio;
        if (studioQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(studioQuery.value(), valueQuery_instance)) {
                studio = valueQuery_instance;
            }
        }
        auto parentalRatingQuery = request.query().get("parentalRating");
        std::optional<std::string> parentalRating;
        if (parentalRatingQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentalRatingQuery.value(), valueQuery_instance)) {
                parentalRating = valueQuery_instance;
            }
        }
        auto publishDateQuery = request.query().get("publishDate");
        std::optional<int64_t> publishDate;
        if (publishDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(publishDateQuery.value(), valueQuery_instance)) {
                publishDate = valueQuery_instance;
            }
        }
        auto availabilityDateQuery = request.query().get("availabilityDate");
        std::optional<int64_t> availabilityDate;
        if (availabilityDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(availabilityDateQuery.value(), valueQuery_instance)) {
                availabilityDate = valueQuery_instance;
            }
        }
        auto sizeIdQuery = request.query().get("sizeId");
        std::optional<int64_t> sizeId;
        if (sizeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(sizeIdQuery.value(), valueQuery_instance)) {
                sizeId = valueQuery_instance;
            }
        }
        auto listingIdQuery = request.query().get("listingId");
        std::optional<int64_t> listingId;
        if (listingIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(listingIdQuery.value(), valueQuery_instance)) {
                listingId = valueQuery_instance;
            }
        }
        auto mediaTypeQuery = request.query().get("mediaType");
        std::optional<std::string> mediaType;
        if (mediaTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mediaTypeQuery.value(), valueQuery_instance)) {
                mediaType = valueQuery_instance;
            }
        }
        auto durationQuery = request.query().get("duration");
        std::optional<int32_t> duration;
        if (durationQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(durationQuery.value(), valueQuery_instance)) {
                duration = valueQuery_instance;
            }
        }
        auto authorQuery = request.query().get("author");
        std::optional<std::string> author;
        if (authorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(authorQuery.value(), valueQuery_instance)) {
                author = valueQuery_instance;
            }
        }
        auto releaseDateQuery = request.query().get("releaseDate");
        std::optional<int64_t> releaseDate;
        if (releaseDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(releaseDateQuery.value(), valueQuery_instance)) {
                releaseDate = valueQuery_instance;
            }
        }
        auto collectionIdsQuery = request.query().get("collectionIds");
        std::optional<std::string> collectionIds;
        if (collectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(collectionIdsQuery.value(), valueQuery_instance)) {
                collectionIds = valueQuery_instance;
            }
        }
        auto rebootTimeHourQuery = request.query().get("rebootTimeHour");
        std::optional<int32_t> rebootTimeHour;
        if (rebootTimeHourQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rebootTimeHourQuery.value(), valueQuery_instance)) {
                rebootTimeHour = valueQuery_instance;
            }
        }
        auto rebootTimeMinuteQuery = request.query().get("rebootTimeMinute");
        std::optional<int32_t> rebootTimeMinute;
        if (rebootTimeMinuteQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rebootTimeMinuteQuery.value(), valueQuery_instance)) {
                rebootTimeMinute = valueQuery_instance;
            }
        }
        auto idleTimeoutInSecondQuery = request.query().get("idleTimeoutInSecond");
        std::optional<int32_t> idleTimeoutInSecond;
        if (idleTimeoutInSecondQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(idleTimeoutInSecondQuery.value(), valueQuery_instance)) {
                idleTimeoutInSecond = valueQuery_instance;
            }
        }
        auto serialNumberQuery = request.query().get("serialNumber");
        std::optional<std::string> serialNumber;
        if (serialNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(serialNumberQuery.value(), valueQuery_instance)) {
                serialNumber = valueQuery_instance;
            }
        }
        auto udidQuery = request.query().get("udid");
        std::optional<std::string> udid;
        if (udidQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(udidQuery.value(), valueQuery_instance)) {
                udid = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto devicePowerQuery = request.query().get("devicePower");
        std::optional<double> devicePower;
        if (devicePowerQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(devicePowerQuery.value(), valueQuery_instance)) {
                devicePower = valueQuery_instance;
            }
        }
        auto deviceInterferenceQuery = request.query().get("deviceInterference");
        std::optional<double> deviceInterference;
        if (deviceInterferenceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(deviceInterferenceQuery.value(), valueQuery_instance)) {
                deviceInterference = valueQuery_instance;
            }
        }
        auto availabilityQuery = request.query().get("availability");
        std::optional<std::string> availability;
        if (availabilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilityQuery.value(), valueQuery_instance)) {
                availability = valueQuery_instance;
            }
        }
        auto availabilitySummaryQuery = request.query().get("availabilitySummary");
        std::optional<std::string> availabilitySummary;
        if (availabilitySummaryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilitySummaryQuery.value(), valueQuery_instance)) {
                availabilitySummary = valueQuery_instance;
            }
        }
    


        try {





            this->update_offer(version, offerId, includeOfferLocations, deviceId, accountId, parentOfferId, retailerLocationIds, offerLocations, tags, title, subTitle, details, subDetails, finePrint, barcodeType, barcodeEntry, externalRedeemOptions, externalUrl, externalId, ticketsRewardType, ticketsReward, activated, expires, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPriceType, ticketPrice, fullPrice, discountPrice, showRemaining, showRedeemed, replaced, featured, offerType, specialOfferType, offerVisibility, categoryIds, filterIds, active, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, brand, productType, conditionType, isbn, asin, catalogNumbers, department, features, minimumPrice, width, height, depth, weight, unit, studio, parentalRating, publishDate, availabilityDate, sizeId, listingId, mediaType, duration, author, releaseDate, collectionIds, rebootTimeHour, rebootTimeMinute, idleTimeoutInSecond, serialNumber, udid, deviceType, devicePower, deviceInterference, availability, availabilitySummary, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OfferApi::update_offer_status_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto offerIdsQuery = request.query().get("offerIds");
        std::optional<std::string> offerIds;
        if (offerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerIdsQuery.value(), valueQuery_instance)) {
                offerIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
    


        try {





            this->update_offer_status(version, offerIds, active, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void OfferApi::offer_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

