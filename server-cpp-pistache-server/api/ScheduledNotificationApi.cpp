/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "ScheduledNotificationApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string ScheduledNotificationApi::base = "";

ScheduledNotificationApi::ScheduledNotificationApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void ScheduledNotificationApi::init() {
    setupRoutes();
}

void ScheduledNotificationApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/notification/schedule/create", Routes::bind(&ScheduledNotificationApi::create_scheduled_notification_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/schedule/delete", Routes::bind(&ScheduledNotificationApi::delete_scheduled_notification_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/schedule/get", Routes::bind(&ScheduledNotificationApi::get_scheduled_notification_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/schedule/generate", Routes::bind(&ScheduledNotificationApi::schedule_notification_listings_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/schedule/search", Routes::bind(&ScheduledNotificationApi::search_scheduled_notifications_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/schedule/update", Routes::bind(&ScheduledNotificationApi::update_scheduled_notification_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&ScheduledNotificationApi::scheduled_notification_api_default_handler, this));
}

void ScheduledNotificationApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ScheduledNotificationApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void ScheduledNotificationApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ScheduledNotificationApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void ScheduledNotificationApi::create_scheduled_notification_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto messageQuery = request.query().get("message");
        std::optional<std::string> message;
        if (messageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(messageQuery.value(), valueQuery_instance)) {
                message = valueQuery_instance;
            }
        }
        auto contentIdQuery = request.query().get("contentId");
        std::optional<int64_t> contentId;
        if (contentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(contentIdQuery.value(), valueQuery_instance)) {
                contentId = valueQuery_instance;
            }
        }
        auto contentNameQuery = request.query().get("contentName");
        std::optional<std::string> contentName;
        if (contentNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentNameQuery.value(), valueQuery_instance)) {
                contentName = valueQuery_instance;
            }
        }
        auto contentTypeQuery = request.query().get("contentType");
        std::optional<std::string> contentType;
        if (contentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypeQuery.value(), valueQuery_instance)) {
                contentType = valueQuery_instance;
            }
        }
        auto parentIdQuery = request.query().get("parentId");
        std::optional<int64_t> parentId;
        if (parentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentIdQuery.value(), valueQuery_instance)) {
                parentId = valueQuery_instance;
            }
        }
        auto parentTypeQuery = request.query().get("parentType");
        std::optional<std::string> parentType;
        if (parentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypeQuery.value(), valueQuery_instance)) {
                parentType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto groupingIdQuery = request.query().get("groupingId");
        std::optional<std::string> groupingId;
        if (groupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupingIdQuery.value(), valueQuery_instance)) {
                groupingId = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto connectionAccountIdsQuery = request.query().get("connectionAccountIds");
        std::optional<std::string> connectionAccountIds;
        if (connectionAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionAccountIdsQuery.value(), valueQuery_instance)) {
                connectionAccountIds = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto albumIdsQuery = request.query().get("albumIds");
        std::optional<std::string> albumIds;
        if (albumIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumIdsQuery.value(), valueQuery_instance)) {
                albumIds = valueQuery_instance;
            }
        }
        auto reportIdQuery = request.query().get("reportId");
        std::optional<int64_t> reportId;
        if (reportIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(reportIdQuery.value(), valueQuery_instance)) {
                reportId = valueQuery_instance;
            }
        }
        auto reportParamsQuery = request.query().get("reportParams");
        std::optional<std::string> reportParams;
        if (reportParamsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(reportParamsQuery.value(), valueQuery_instance)) {
                reportParams = valueQuery_instance;
            }
        }
        auto endpointURLQuery = request.query().get("endpointURL");
        std::optional<std::string> endpointURL;
        if (endpointURLQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(endpointURLQuery.value(), valueQuery_instance)) {
                endpointURL = valueQuery_instance;
            }
        }
        auto payloadQuery = request.query().get("payload");
        std::optional<std::string> payload;
        if (payloadQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(payloadQuery.value(), valueQuery_instance)) {
                payload = valueQuery_instance;
            }
        }
        auto scheduledDateQuery = request.query().get("scheduledDate");
        std::optional<int64_t> scheduledDate;
        if (scheduledDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledDateQuery.value(), valueQuery_instance)) {
                scheduledDate = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto cronExpressionQuery = request.query().get("cronExpression");
        std::optional<std::string> cronExpression;
        if (cronExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cronExpressionQuery.value(), valueQuery_instance)) {
                cronExpression = valueQuery_instance;
            }
        }
        auto cronTypeQuery = request.query().get("cronType");
        std::optional<std::string> cronType;
        if (cronTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cronTypeQuery.value(), valueQuery_instance)) {
                cronType = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto conditionalInputQuery = request.query().get("conditionalInput");
        std::optional<std::string> conditionalInput;
        if (conditionalInputQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionalInputQuery.value(), valueQuery_instance)) {
                conditionalInput = valueQuery_instance;
            }
        }
        auto templateTypeQuery = request.query().get("templateType");
        std::optional<std::string> templateType;
        if (templateTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(templateTypeQuery.value(), valueQuery_instance)) {
                templateType = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto sendNowQuery = request.query().get("sendNow");
        std::optional<bool> sendNow;
        if (sendNowQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendNowQuery.value(), valueQuery_instance)) {
                sendNow = valueQuery_instance;
            }
        }
        auto eventTypeQuery = request.query().get("eventType");
        std::optional<std::string> eventType;
        if (eventTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventTypeQuery.value(), valueQuery_instance)) {
                eventType = valueQuery_instance;
            }
        }
        auto deepLinkURIQuery = request.query().get("deepLinkURI");
        std::optional<std::string> deepLinkURI;
        if (deepLinkURIQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deepLinkURIQuery.value(), valueQuery_instance)) {
                deepLinkURI = valueQuery_instance;
            }
        }
        auto sendToAllQuery = request.query().get("sendToAll");
        std::optional<bool> sendToAll;
        if (sendToAllQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendToAllQuery.value(), valueQuery_instance)) {
                sendToAll = valueQuery_instance;
            }
        }
    


        try {





            this->create_scheduled_notification(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ScheduledNotificationApi::delete_scheduled_notification_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto scheduledNotificationIdQuery = request.query().get("scheduledNotificationId");
        std::optional<int64_t> scheduledNotificationId;
        if (scheduledNotificationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledNotificationIdQuery.value(), valueQuery_instance)) {
                scheduledNotificationId = valueQuery_instance;
            }
        }
        auto deleteByGroupingIdQuery = request.query().get("deleteByGroupingId");
        std::optional<bool> deleteByGroupingId;
        if (deleteByGroupingIdQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(deleteByGroupingIdQuery.value(), valueQuery_instance)) {
                deleteByGroupingId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_scheduled_notification(version, accountId, scheduledNotificationId, deleteByGroupingId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ScheduledNotificationApi::get_scheduled_notification_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto scheduledNotificationIdQuery = request.query().get("scheduledNotificationId");
        std::optional<int64_t> scheduledNotificationId;
        if (scheduledNotificationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledNotificationIdQuery.value(), valueQuery_instance)) {
                scheduledNotificationId = valueQuery_instance;
            }
        }
    


        try {





            this->get_scheduled_notification(version, accountId, scheduledNotificationId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ScheduledNotificationApi::schedule_notification_listings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto reportNameQuery = request.query().get("reportName");
        std::optional<std::string> reportName;
        if (reportNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(reportNameQuery.value(), valueQuery_instance)) {
                reportName = valueQuery_instance;
            }
        }
        auto reportParamsQuery = request.query().get("reportParams");
        std::optional<std::string> reportParams;
        if (reportParamsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(reportParamsQuery.value(), valueQuery_instance)) {
                reportParams = valueQuery_instance;
            }
        }
        auto messageQuery = request.query().get("message");
        std::optional<std::string> message;
        if (messageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(messageQuery.value(), valueQuery_instance)) {
                message = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto recipientReportIdQuery = request.query().get("recipientReportId");
        std::optional<int64_t> recipientReportId;
        if (recipientReportIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(recipientReportIdQuery.value(), valueQuery_instance)) {
                recipientReportId = valueQuery_instance;
            }
        }
    


        try {





            this->schedule_notification_listings(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ScheduledNotificationApi::search_scheduled_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto groupingIdQuery = request.query().get("groupingId");
        std::optional<std::string> groupingId;
        if (groupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupingIdQuery.value(), valueQuery_instance)) {
                groupingId = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto filterQuery = request.query().get("filter");
        std::optional<std::string> filter;
        if (filterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterQuery.value(), valueQuery_instance)) {
                filter = valueQuery_instance;
            }
        }
        auto typesQuery = request.query().get("types");
        std::optional<std::string> types;
        if (typesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typesQuery.value(), valueQuery_instance)) {
                types = valueQuery_instance;
            }
        }
        auto contentIdsQuery = request.query().get("contentIds");
        std::optional<std::string> contentIds;
        if (contentIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentIdsQuery.value(), valueQuery_instance)) {
                contentIds = valueQuery_instance;
            }
        }
        auto contentTypesQuery = request.query().get("contentTypes");
        std::optional<std::string> contentTypes;
        if (contentTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypesQuery.value(), valueQuery_instance)) {
                contentTypes = valueQuery_instance;
            }
        }
        auto parentIdsQuery = request.query().get("parentIds");
        std::optional<std::string> parentIds;
        if (parentIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentIdsQuery.value(), valueQuery_instance)) {
                parentIds = valueQuery_instance;
            }
        }
        auto parentTypesQuery = request.query().get("parentTypes");
        std::optional<std::string> parentTypes;
        if (parentTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypesQuery.value(), valueQuery_instance)) {
                parentTypes = valueQuery_instance;
            }
        }
        auto statusesQuery = request.query().get("statuses");
        std::optional<std::string> statuses;
        if (statusesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(statusesQuery.value(), valueQuery_instance)) {
                statuses = valueQuery_instance;
            }
        }
        auto templateTypesQuery = request.query().get("templateTypes");
        std::optional<std::string> templateTypes;
        if (templateTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(templateTypesQuery.value(), valueQuery_instance)) {
                templateTypes = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto groupByGroupingIdQuery = request.query().get("groupByGroupingId");
        std::optional<bool> groupByGroupingId;
        if (groupByGroupingIdQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(groupByGroupingIdQuery.value(), valueQuery_instance)) {
                groupByGroupingId = valueQuery_instance;
            }
        }
        auto returnAudienceAccountCountQuery = request.query().get("returnAudienceAccountCount");
        std::optional<bool> returnAudienceAccountCount;
        if (returnAudienceAccountCountQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAudienceAccountCountQuery.value(), valueQuery_instance)) {
                returnAudienceAccountCount = valueQuery_instance;
            }
        }
    


        try {





            this->search_scheduled_notifications(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ScheduledNotificationApi::update_scheduled_notification_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto scheduledNotificationIdQuery = request.query().get("scheduledNotificationId");
        std::optional<int64_t> scheduledNotificationId;
        if (scheduledNotificationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledNotificationIdQuery.value(), valueQuery_instance)) {
                scheduledNotificationId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto messageQuery = request.query().get("message");
        std::optional<std::string> message;
        if (messageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(messageQuery.value(), valueQuery_instance)) {
                message = valueQuery_instance;
            }
        }
        auto payloadQuery = request.query().get("payload");
        std::optional<std::string> payload;
        if (payloadQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(payloadQuery.value(), valueQuery_instance)) {
                payload = valueQuery_instance;
            }
        }
        auto contentIdQuery = request.query().get("contentId");
        std::optional<int64_t> contentId;
        if (contentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(contentIdQuery.value(), valueQuery_instance)) {
                contentId = valueQuery_instance;
            }
        }
        auto contentNameQuery = request.query().get("contentName");
        std::optional<std::string> contentName;
        if (contentNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentNameQuery.value(), valueQuery_instance)) {
                contentName = valueQuery_instance;
            }
        }
        auto contentTypeQuery = request.query().get("contentType");
        std::optional<std::string> contentType;
        if (contentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypeQuery.value(), valueQuery_instance)) {
                contentType = valueQuery_instance;
            }
        }
        auto parentIdQuery = request.query().get("parentId");
        std::optional<int64_t> parentId;
        if (parentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentIdQuery.value(), valueQuery_instance)) {
                parentId = valueQuery_instance;
            }
        }
        auto parentTypeQuery = request.query().get("parentType");
        std::optional<std::string> parentType;
        if (parentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypeQuery.value(), valueQuery_instance)) {
                parentType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto groupingIdQuery = request.query().get("groupingId");
        std::optional<std::string> groupingId;
        if (groupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupingIdQuery.value(), valueQuery_instance)) {
                groupingId = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto connectionAccountIdsQuery = request.query().get("connectionAccountIds");
        std::optional<std::string> connectionAccountIds;
        if (connectionAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionAccountIdsQuery.value(), valueQuery_instance)) {
                connectionAccountIds = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto albumIdsQuery = request.query().get("albumIds");
        std::optional<std::string> albumIds;
        if (albumIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumIdsQuery.value(), valueQuery_instance)) {
                albumIds = valueQuery_instance;
            }
        }
        auto reportIdQuery = request.query().get("reportId");
        std::optional<int64_t> reportId;
        if (reportIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(reportIdQuery.value(), valueQuery_instance)) {
                reportId = valueQuery_instance;
            }
        }
        auto reportParamsQuery = request.query().get("reportParams");
        std::optional<std::string> reportParams;
        if (reportParamsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(reportParamsQuery.value(), valueQuery_instance)) {
                reportParams = valueQuery_instance;
            }
        }
        auto endpointURLQuery = request.query().get("endpointURL");
        std::optional<std::string> endpointURL;
        if (endpointURLQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(endpointURLQuery.value(), valueQuery_instance)) {
                endpointURL = valueQuery_instance;
            }
        }
        auto scheduledDateQuery = request.query().get("scheduledDate");
        std::optional<int64_t> scheduledDate;
        if (scheduledDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledDateQuery.value(), valueQuery_instance)) {
                scheduledDate = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto cronExpressionQuery = request.query().get("cronExpression");
        std::optional<std::string> cronExpression;
        if (cronExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cronExpressionQuery.value(), valueQuery_instance)) {
                cronExpression = valueQuery_instance;
            }
        }
        auto cronTypeQuery = request.query().get("cronType");
        std::optional<std::string> cronType;
        if (cronTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cronTypeQuery.value(), valueQuery_instance)) {
                cronType = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto conditionalInputQuery = request.query().get("conditionalInput");
        std::optional<std::string> conditionalInput;
        if (conditionalInputQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionalInputQuery.value(), valueQuery_instance)) {
                conditionalInput = valueQuery_instance;
            }
        }
        auto templateTypeQuery = request.query().get("templateType");
        std::optional<std::string> templateType;
        if (templateTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(templateTypeQuery.value(), valueQuery_instance)) {
                templateType = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto errorMessageQuery = request.query().get("errorMessage");
        std::optional<std::string> errorMessage;
        if (errorMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(errorMessageQuery.value(), valueQuery_instance)) {
                errorMessage = valueQuery_instance;
            }
        }
        auto statusQuery = request.query().get("status");
        std::optional<std::string> status;
        if (statusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(statusQuery.value(), valueQuery_instance)) {
                status = valueQuery_instance;
            }
        }
        auto updateByGroupingIdQuery = request.query().get("updateByGroupingId");
        std::optional<bool> updateByGroupingId;
        if (updateByGroupingIdQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updateByGroupingIdQuery.value(), valueQuery_instance)) {
                updateByGroupingId = valueQuery_instance;
            }
        }
        auto sendNowQuery = request.query().get("sendNow");
        std::optional<bool> sendNow;
        if (sendNowQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendNowQuery.value(), valueQuery_instance)) {
                sendNow = valueQuery_instance;
            }
        }
        auto eventTypeQuery = request.query().get("eventType");
        std::optional<std::string> eventType;
        if (eventTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventTypeQuery.value(), valueQuery_instance)) {
                eventType = valueQuery_instance;
            }
        }
        auto deepLinkURIQuery = request.query().get("deepLinkURI");
        std::optional<std::string> deepLinkURI;
        if (deepLinkURIQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deepLinkURIQuery.value(), valueQuery_instance)) {
                deepLinkURI = valueQuery_instance;
            }
        }
        auto sendToAllQuery = request.query().get("sendToAll");
        std::optional<bool> sendToAll;
        if (sendToAllQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendToAllQuery.value(), valueQuery_instance)) {
                sendToAll = valueQuery_instance;
            }
        }
    


        try {





            this->update_scheduled_notification(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void ScheduledNotificationApi::scheduled_notification_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

