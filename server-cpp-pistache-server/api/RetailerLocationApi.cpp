/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "RetailerLocationApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string RetailerLocationApi::base = "";

RetailerLocationApi::RetailerLocationApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void RetailerLocationApi::init() {
    setupRoutes();
}

void RetailerLocationApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/location/create", Routes::bind(&RetailerLocationApi::create_retailer_location_consumer_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/location/create", Routes::bind(&RetailerLocationApi::create_retailer_locations_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/location/delete", Routes::bind(&RetailerLocationApi::delete_retailer_location_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/location/get", Routes::bind(&RetailerLocationApi::get_retailer_location_handler, this));
    Routes::Get(*router, base + "/api/:version/location/get", Routes::bind(&RetailerLocationApi::get_retailer_location_consumer_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/location/idistancesearch", Routes::bind(&RetailerLocationApi::indexed_retailer_location_distance_search_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/location/isearch", Routes::bind(&RetailerLocationApi::indexed_retailer_location_search_handler, this));
    Routes::Get(*router, base + "/api/:version/retailer/location/search", Routes::bind(&RetailerLocationApi::search_retailer_locations_handler, this));
    Routes::Post(*router, base + "/api/:version/retailer/location/update", Routes::bind(&RetailerLocationApi::update_retailer_locations_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&RetailerLocationApi::retailer_location_api_default_handler, this));
}

void RetailerLocationApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RetailerLocationApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void RetailerLocationApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RetailerLocationApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void RetailerLocationApi::create_retailer_location_consumer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto streetAddressQuery = request.query().get("streetAddress");
        std::optional<std::string> streetAddress;
        if (streetAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddressQuery.value(), valueQuery_instance)) {
                streetAddress = valueQuery_instance;
            }
        }
        auto streetAddress2Query = request.query().get("streetAddress2");
        std::optional<std::string> streetAddress2;
        if (streetAddress2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddress2Query.value(), valueQuery_instance)) {
                streetAddress2 = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto postalCodeQuery = request.query().get("postalCode");
        std::optional<std::string> postalCode;
        if (postalCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(postalCodeQuery.value(), valueQuery_instance)) {
                postalCode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto businessPhoneExtQuery = request.query().get("businessPhoneExt");
        std::optional<std::string> businessPhoneExt;
        if (businessPhoneExtQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneExtQuery.value(), valueQuery_instance)) {
                businessPhoneExt = valueQuery_instance;
            }
        }
        auto websiteQuery = request.query().get("website");
        std::optional<std::string> website;
        if (websiteQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(websiteQuery.value(), valueQuery_instance)) {
                website = valueQuery_instance;
            }
        }
        auto emailQuery = request.query().get("email");
        std::optional<std::string> email;
        if (emailQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailQuery.value(), valueQuery_instance)) {
                email = valueQuery_instance;
            }
        }
        auto detailsHeaderQuery = request.query().get("detailsHeader");
        std::optional<std::string> detailsHeader;
        if (detailsHeaderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsHeaderQuery.value(), valueQuery_instance)) {
                detailsHeader = valueQuery_instance;
            }
        }
        auto detailsBodyQuery = request.query().get("detailsBody");
        std::optional<std::string> detailsBody;
        if (detailsBodyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsBodyQuery.value(), valueQuery_instance)) {
                detailsBody = valueQuery_instance;
            }
        }
        auto hoursQuery = request.query().get("hours");
        std::optional<std::string> hours;
        if (hoursQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(hoursQuery.value(), valueQuery_instance)) {
                hours = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto logoAssetIdQuery = request.query().get("logoAssetId");
        std::optional<int64_t> logoAssetId;
        if (logoAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(logoAssetIdQuery.value(), valueQuery_instance)) {
                logoAssetId = valueQuery_instance;
            }
        }
        auto picture1AssetIdQuery = request.query().get("picture1AssetId");
        std::optional<int64_t> picture1AssetId;
        if (picture1AssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(picture1AssetIdQuery.value(), valueQuery_instance)) {
                picture1AssetId = valueQuery_instance;
            }
        }
        auto picture2AssetIdQuery = request.query().get("picture2AssetId");
        std::optional<int64_t> picture2AssetId;
        if (picture2AssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(picture2AssetIdQuery.value(), valueQuery_instance)) {
                picture2AssetId = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto publicLocationQuery = request.query().get("publicLocation");
        std::optional<bool> publicLocation;
        if (publicLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(publicLocationQuery.value(), valueQuery_instance)) {
                publicLocation = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto locationTypeQuery = request.query().get("locationType");
        std::optional<std::string> locationType;
        if (locationTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationTypeQuery.value(), valueQuery_instance)) {
                locationType = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->create_retailer_location_consumer(version, appKey, name, deviceId, accountId, streetAddress, streetAddress2, city, state, postalCode, country, businessPhone, businessPhoneExt, website, email, detailsHeader, detailsBody, hours, tags, logoAssetId, picture1AssetId, picture2AssetId, categoryIds, filterIds, metaData, publicLocation, active, locationType, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::create_retailer_locations_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->create_retailer_locations(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::delete_retailer_location_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_retailer_location(version, deviceId, accountId, retailerLocationId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::get_retailer_location_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto retailerLocationTokenQuery = request.query().get("retailerLocationToken");
        std::optional<std::string> retailerLocationToken;
        if (retailerLocationTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationTokenQuery.value(), valueQuery_instance)) {
                retailerLocationToken = valueQuery_instance;
            }
        }
    


        try {





            this->get_retailer_location(version, retailerLocationId, deviceId, accountId, retailerLocationToken, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::get_retailer_location_consumer_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
    


        try {





            this->get_retailer_location_consumer(version, retailerLocationId, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::indexed_retailer_location_distance_search_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto addressQuery = request.query().get("address");
        std::optional<std::string> address;
        if (addressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(addressQuery.value(), valueQuery_instance)) {
                address = valueQuery_instance;
            }
        }
        auto searchRangeQuery = request.query().get("searchRange");
        std::optional<double> searchRange;
        if (searchRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(searchRangeQuery.value(), valueQuery_instance)) {
                searchRange = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto hasOffersQuery = request.query().get("hasOffers");
        std::optional<bool> hasOffers;
        if (hasOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(hasOffersQuery.value(), valueQuery_instance)) {
                hasOffers = valueQuery_instance;
            }
        }
        auto categoriesQuery = request.query().get("categories");
        std::optional<std::string> categories;
        if (categoriesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoriesQuery.value(), valueQuery_instance)) {
                categories = valueQuery_instance;
            }
        }
        auto filtersQuery = request.query().get("filters");
        std::optional<std::string> filters;
        if (filtersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filtersQuery.value(), valueQuery_instance)) {
                filters = valueQuery_instance;
            }
        }
        auto audiencesQuery = request.query().get("audiences");
        std::optional<std::string> audiences;
        if (audiencesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audiencesQuery.value(), valueQuery_instance)) {
                audiences = valueQuery_instance;
            }
        }
        auto retailerIdsQuery = request.query().get("retailerIds");
        std::optional<std::string> retailerIds;
        if (retailerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerIdsQuery.value(), valueQuery_instance)) {
                retailerIds = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto locationTypeQuery = request.query().get("locationType");
        std::optional<std::string> locationType;
        if (locationTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationTypeQuery.value(), valueQuery_instance)) {
                locationType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto keywordOperatorQuery = request.query().get("keywordOperator");
        std::optional<std::string> keywordOperator;
        if (keywordOperatorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordOperatorQuery.value(), valueQuery_instance)) {
                keywordOperator = valueQuery_instance;
            }
        }
        auto searchExpressionQuery = request.query().get("searchExpression");
        std::optional<std::string> searchExpression;
        if (searchExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchExpressionQuery.value(), valueQuery_instance)) {
                searchExpression = valueQuery_instance;
            }
        }
        auto distanceUnitQuery = request.query().get("distanceUnit");
        std::optional<std::string> distanceUnit;
        if (distanceUnitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(distanceUnitQuery.value(), valueQuery_instance)) {
                distanceUnit = valueQuery_instance;
            }
        }
        auto returnFavoritedQuery = request.query().get("returnFavorited");
        std::optional<bool> returnFavorited;
        if (returnFavoritedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnFavoritedQuery.value(), valueQuery_instance)) {
                returnFavorited = valueQuery_instance;
            }
        }
        auto returnRetailerQuery = request.query().get("returnRetailer");
        std::optional<bool> returnRetailer;
        if (returnRetailerQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRetailerQuery.value(), valueQuery_instance)) {
                returnRetailer = valueQuery_instance;
            }
        }
        auto returnAssetsQuery = request.query().get("returnAssets");
        std::optional<bool> returnAssets;
        if (returnAssetsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAssetsQuery.value(), valueQuery_instance)) {
                returnAssets = valueQuery_instance;
            }
        }
        auto returnOffersQuery = request.query().get("returnOffers");
        std::optional<bool> returnOffers;
        if (returnOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnOffersQuery.value(), valueQuery_instance)) {
                returnOffers = valueQuery_instance;
            }
        }
        auto returnCategoriesQuery = request.query().get("returnCategories");
        std::optional<bool> returnCategories;
        if (returnCategoriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnCategoriesQuery.value(), valueQuery_instance)) {
                returnCategories = valueQuery_instance;
            }
        }
        auto returnFiltersQuery = request.query().get("returnFilters");
        std::optional<bool> returnFilters;
        if (returnFiltersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnFiltersQuery.value(), valueQuery_instance)) {
                returnFilters = valueQuery_instance;
            }
        }
        auto returnAudiencesQuery = request.query().get("returnAudiences");
        std::optional<bool> returnAudiences;
        if (returnAudiencesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAudiencesQuery.value(), valueQuery_instance)) {
                returnAudiences = valueQuery_instance;
            }
        }
        auto returnQrCodeQuery = request.query().get("returnQrCode");
        std::optional<bool> returnQrCode;
        if (returnQrCodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnQrCodeQuery.value(), valueQuery_instance)) {
                returnQrCode = valueQuery_instance;
            }
        }
        auto returnExternalCategoryDataQuery = request.query().get("returnExternalCategoryData");
        std::optional<bool> returnExternalCategoryData;
        if (returnExternalCategoryDataQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnExternalCategoryDataQuery.value(), valueQuery_instance)) {
                returnExternalCategoryData = valueQuery_instance;
            }
        }
        auto includeFavoriteQuery = request.query().get("includeFavorite");
        std::optional<bool> includeFavorite;
        if (includeFavoriteQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFavoriteQuery.value(), valueQuery_instance)) {
                includeFavorite = valueQuery_instance;
            }
        }
        auto includeLikedQuery = request.query().get("includeLiked");
        std::optional<bool> includeLiked;
        if (includeLikedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeLikedQuery.value(), valueQuery_instance)) {
                includeLiked = valueQuery_instance;
            }
        }
        auto includeRatingQuery = request.query().get("includeRating");
        std::optional<bool> includeRating;
        if (includeRatingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRatingQuery.value(), valueQuery_instance)) {
                includeRating = valueQuery_instance;
            }
        }
    


        try {





            this->indexed_retailer_location_distance_search(version, latitude, longitude, searchRange, start, limit, accountId, address, hasOffers, categories, filters, audiences, retailerIds, retailerLocationIds, tags, locationType, sortField, descending, q, keyword, keywordOperator, searchExpression, distanceUnit, returnFavorited, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, returnExternalCategoryData, includeFavorite, includeLiked, includeRating, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::indexed_retailer_location_search_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto hasOffersQuery = request.query().get("hasOffers");
        std::optional<bool> hasOffers;
        if (hasOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(hasOffersQuery.value(), valueQuery_instance)) {
                hasOffers = valueQuery_instance;
            }
        }
        auto categoriesQuery = request.query().get("categories");
        std::optional<std::string> categories;
        if (categoriesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoriesQuery.value(), valueQuery_instance)) {
                categories = valueQuery_instance;
            }
        }
        auto filtersQuery = request.query().get("filters");
        std::optional<std::string> filters;
        if (filtersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filtersQuery.value(), valueQuery_instance)) {
                filters = valueQuery_instance;
            }
        }
        auto audiencesQuery = request.query().get("audiences");
        std::optional<std::string> audiences;
        if (audiencesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audiencesQuery.value(), valueQuery_instance)) {
                audiences = valueQuery_instance;
            }
        }
        auto retailerIdsQuery = request.query().get("retailerIds");
        std::optional<std::string> retailerIds;
        if (retailerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerIdsQuery.value(), valueQuery_instance)) {
                retailerIds = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto locationTypeQuery = request.query().get("locationType");
        std::optional<std::string> locationType;
        if (locationTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationTypeQuery.value(), valueQuery_instance)) {
                locationType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto keywordOperatorQuery = request.query().get("keywordOperator");
        std::optional<std::string> keywordOperator;
        if (keywordOperatorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordOperatorQuery.value(), valueQuery_instance)) {
                keywordOperator = valueQuery_instance;
            }
        }
        auto searchExpressionQuery = request.query().get("searchExpression");
        std::optional<std::string> searchExpression;
        if (searchExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchExpressionQuery.value(), valueQuery_instance)) {
                searchExpression = valueQuery_instance;
            }
        }
        auto returnRetailerQuery = request.query().get("returnRetailer");
        std::optional<bool> returnRetailer;
        if (returnRetailerQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRetailerQuery.value(), valueQuery_instance)) {
                returnRetailer = valueQuery_instance;
            }
        }
        auto returnAssetsQuery = request.query().get("returnAssets");
        std::optional<bool> returnAssets;
        if (returnAssetsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAssetsQuery.value(), valueQuery_instance)) {
                returnAssets = valueQuery_instance;
            }
        }
        auto returnOffersQuery = request.query().get("returnOffers");
        std::optional<bool> returnOffers;
        if (returnOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnOffersQuery.value(), valueQuery_instance)) {
                returnOffers = valueQuery_instance;
            }
        }
        auto returnCategoriesQuery = request.query().get("returnCategories");
        std::optional<bool> returnCategories;
        if (returnCategoriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnCategoriesQuery.value(), valueQuery_instance)) {
                returnCategories = valueQuery_instance;
            }
        }
        auto returnFiltersQuery = request.query().get("returnFilters");
        std::optional<bool> returnFilters;
        if (returnFiltersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnFiltersQuery.value(), valueQuery_instance)) {
                returnFilters = valueQuery_instance;
            }
        }
        auto returnAudiencesQuery = request.query().get("returnAudiences");
        std::optional<bool> returnAudiences;
        if (returnAudiencesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAudiencesQuery.value(), valueQuery_instance)) {
                returnAudiences = valueQuery_instance;
            }
        }
        auto returnQrCodeQuery = request.query().get("returnQrCode");
        std::optional<bool> returnQrCode;
        if (returnQrCodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnQrCodeQuery.value(), valueQuery_instance)) {
                returnQrCode = valueQuery_instance;
            }
        }
        auto returnExternalCategoryDataQuery = request.query().get("returnExternalCategoryData");
        std::optional<bool> returnExternalCategoryData;
        if (returnExternalCategoryDataQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnExternalCategoryDataQuery.value(), valueQuery_instance)) {
                returnExternalCategoryData = valueQuery_instance;
            }
        }
        auto includeFavoriteQuery = request.query().get("includeFavorite");
        std::optional<bool> includeFavorite;
        if (includeFavoriteQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFavoriteQuery.value(), valueQuery_instance)) {
                includeFavorite = valueQuery_instance;
            }
        }
        auto includeLikedQuery = request.query().get("includeLiked");
        std::optional<bool> includeLiked;
        if (includeLikedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeLikedQuery.value(), valueQuery_instance)) {
                includeLiked = valueQuery_instance;
            }
        }
        auto includeRatingQuery = request.query().get("includeRating");
        std::optional<bool> includeRating;
        if (includeRatingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRatingQuery.value(), valueQuery_instance)) {
                includeRating = valueQuery_instance;
            }
        }
    


        try {





            this->indexed_retailer_location_search(version, accountId, start, limit, hasOffers, categories, filters, audiences, retailerIds, retailerLocationIds, tags, locationType, sortField, descending, q, keyword, keywordOperator, searchExpression, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, returnExternalCategoryData, includeFavorite, includeLiked, includeRating, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::search_retailer_locations_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto retailerIdsQuery = request.query().get("retailerIds");
        std::optional<std::string> retailerIds;
        if (retailerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerIdsQuery.value(), valueQuery_instance)) {
                retailerIds = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto locationTypeQuery = request.query().get("locationType");
        std::optional<std::string> locationType;
        if (locationTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationTypeQuery.value(), valueQuery_instance)) {
                locationType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto showPublicLocationsQuery = request.query().get("showPublicLocations");
        std::optional<bool> showPublicLocations;
        if (showPublicLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showPublicLocationsQuery.value(), valueQuery_instance)) {
                showPublicLocations = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto returnRetailerQuery = request.query().get("returnRetailer");
        std::optional<bool> returnRetailer;
        if (returnRetailerQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRetailerQuery.value(), valueQuery_instance)) {
                returnRetailer = valueQuery_instance;
            }
        }
        auto returnAssetsQuery = request.query().get("returnAssets");
        std::optional<bool> returnAssets;
        if (returnAssetsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAssetsQuery.value(), valueQuery_instance)) {
                returnAssets = valueQuery_instance;
            }
        }
        auto returnOffersQuery = request.query().get("returnOffers");
        std::optional<bool> returnOffers;
        if (returnOffersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnOffersQuery.value(), valueQuery_instance)) {
                returnOffers = valueQuery_instance;
            }
        }
        auto returnCategoriesQuery = request.query().get("returnCategories");
        std::optional<bool> returnCategories;
        if (returnCategoriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnCategoriesQuery.value(), valueQuery_instance)) {
                returnCategories = valueQuery_instance;
            }
        }
        auto returnFiltersQuery = request.query().get("returnFilters");
        std::optional<bool> returnFilters;
        if (returnFiltersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnFiltersQuery.value(), valueQuery_instance)) {
                returnFilters = valueQuery_instance;
            }
        }
        auto returnAudiencesQuery = request.query().get("returnAudiences");
        std::optional<bool> returnAudiences;
        if (returnAudiencesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAudiencesQuery.value(), valueQuery_instance)) {
                returnAudiences = valueQuery_instance;
            }
        }
        auto returnQrCodeQuery = request.query().get("returnQrCode");
        std::optional<bool> returnQrCode;
        if (returnQrCodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnQrCodeQuery.value(), valueQuery_instance)) {
                returnQrCode = valueQuery_instance;
            }
        }
        auto includeFavoriteQuery = request.query().get("includeFavorite");
        std::optional<bool> includeFavorite;
        if (includeFavoriteQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFavoriteQuery.value(), valueQuery_instance)) {
                includeFavorite = valueQuery_instance;
            }
        }
        auto includeLikedQuery = request.query().get("includeLiked");
        std::optional<bool> includeLiked;
        if (includeLikedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeLikedQuery.value(), valueQuery_instance)) {
                includeLiked = valueQuery_instance;
            }
        }
        auto includeRatingQuery = request.query().get("includeRating");
        std::optional<bool> includeRating;
        if (includeRatingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRatingQuery.value(), valueQuery_instance)) {
                includeRating = valueQuery_instance;
            }
        }
    


        try {





            this->search_retailer_locations(version, deviceId, accountId, q, keyword, retailerIds, retailerLocationIds, locationType, sortField, descending, i, start, l, limit, showPublicLocations, activeOnly, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, includeFavorite, includeLiked, includeRating, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RetailerLocationApi::update_retailer_locations_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->update_retailer_locations(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void RetailerLocationApi::retailer_location_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

