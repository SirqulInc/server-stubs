/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "AchievementApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string AchievementApi::base = "";

AchievementApi::AchievementApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void AchievementApi::init() {
    setupRoutes();
}

void AchievementApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/achievement/tier/search", Routes::bind(&AchievementApi::api_version_achievement_tier_search_post_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/create", Routes::bind(&AchievementApi::create_achievement_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/tier/create", Routes::bind(&AchievementApi::create_achievement_tier_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/delete", Routes::bind(&AchievementApi::delete_achievement_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/tier/delete", Routes::bind(&AchievementApi::delete_achievement_tier_handler, this));
    Routes::Get(*router, base + "/api/:version/achievement/get", Routes::bind(&AchievementApi::get_achievement_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/tier/get", Routes::bind(&AchievementApi::get_achievement_tier_handler, this));
    Routes::Get(*router, base + "/api/:version/achievement/progress/get", Routes::bind(&AchievementApi::get_user_achievements_handler, this));
    Routes::Get(*router, base + "/api/:version/achievement/tag/list", Routes::bind(&AchievementApi::list_achievement_tags_handler, this));
    Routes::Get(*router, base + "/api/:version/achievement/list", Routes::bind(&AchievementApi::list_achievements_handler, this));
    Routes::Get(*router, base + "/api/:version/achievement/search", Routes::bind(&AchievementApi::search_achievements_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/update", Routes::bind(&AchievementApi::update_achievement_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/tier/update", Routes::bind(&AchievementApi::update_achievement_tier_handler, this));
    Routes::Post(*router, base + "/api/:version/achievement/progress/update", Routes::bind(&AchievementApi::update_user_achievement_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&AchievementApi::achievement_api_default_handler, this));
}

void AchievementApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AchievementApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void AchievementApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AchievementApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void AchievementApi::api_version_achievement_tier_search_post_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto achievementTypeQuery = request.query().get("achievementType");
        std::optional<int64_t> achievementType;
        if (achievementTypeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementTypeQuery.value(), valueQuery_instance)) {
                achievementType = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto descendingGoalQuery = request.query().get("descendingGoal");
        std::optional<bool> descendingGoal;
        if (descendingGoalQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingGoalQuery.value(), valueQuery_instance)) {
                descendingGoal = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int64_t> start;
        if (startQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int64_t> limit;
        if (limitQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->api_version_achievement_tier_search_post(version, deviceId, accountId, appKey, keyword, achievementType, rankType, sortField, descending, descendingGoal, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::create_achievement_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto analyticsTagQuery = request.query().get("analyticsTag");
        std::optional<std::string> analyticsTag;
        if (analyticsTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(analyticsTagQuery.value(), valueQuery_instance)) {
                analyticsTag = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto rankIncrementQuery = request.query().get("rankIncrement");
        std::optional<int32_t> rankIncrement;
        if (rankIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rankIncrementQuery.value(), valueQuery_instance)) {
                rankIncrement = valueQuery_instance;
            }
        }
        auto minIncrementQuery = request.query().get("minIncrement");
        std::optional<int32_t> minIncrement;
        if (minIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minIncrementQuery.value(), valueQuery_instance)) {
                minIncrement = valueQuery_instance;
            }
        }
        auto maxIncrementQuery = request.query().get("maxIncrement");
        std::optional<int32_t> maxIncrement;
        if (maxIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxIncrementQuery.value(), valueQuery_instance)) {
                maxIncrement = valueQuery_instance;
            }
        }
        auto validateQuery = request.query().get("validate");
        std::optional<bool> validate;
        if (validateQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(validateQuery.value(), valueQuery_instance)) {
                validate = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto triggerDefinitionQuery = request.query().get("triggerDefinition");
        std::optional<std::string> triggerDefinition;
        if (triggerDefinitionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(triggerDefinitionQuery.value(), valueQuery_instance)) {
                triggerDefinition = valueQuery_instance;
            }
        }
    


        try {





            this->create_achievement(version, appKey, title, deviceId, accountId, analyticsTag, description, rankType, rankIncrement, minIncrement, maxIncrement, validate, active, triggerDefinition, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::create_achievement_tier_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->create_achievement_tier(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::delete_achievement_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementIdQuery = request.query().get("achievementId");
        std::optional<int64_t> achievementId;
        if (achievementIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementIdQuery.value(), valueQuery_instance)) {
                achievementId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_achievement(version, achievementId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::delete_achievement_tier_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementTierIdQuery = request.query().get("achievementTierId");
        std::optional<int64_t> achievementTierId;
        if (achievementTierIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementTierIdQuery.value(), valueQuery_instance)) {
                achievementTierId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_achievement_tier(version, achievementTierId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::get_achievement_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementIdQuery = request.query().get("achievementId");
        std::optional<int64_t> achievementId;
        if (achievementIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementIdQuery.value(), valueQuery_instance)) {
                achievementId = valueQuery_instance;
            }
        }
        auto achievementTypeQuery = request.query().get("achievementType");
        std::optional<std::string> achievementType;
        if (achievementTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(achievementTypeQuery.value(), valueQuery_instance)) {
                achievementType = valueQuery_instance;
            }
        }
    


        try {





            this->get_achievement(version, achievementId, deviceId, accountId, achievementType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::get_achievement_tier_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementTierIdQuery = request.query().get("achievementTierId");
        std::optional<int64_t> achievementTierId;
        if (achievementTierIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementTierIdQuery.value(), valueQuery_instance)) {
                achievementTierId = valueQuery_instance;
            }
        }
    


        try {





            this->get_achievement_tier(version, accountId, achievementTierId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::get_user_achievements_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountEmailQuery = request.query().get("connectionAccountEmail");
        std::optional<std::string> connectionAccountEmail;
        if (connectionAccountEmailQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionAccountEmailQuery.value(), valueQuery_instance)) {
                connectionAccountEmail = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto achievementTypeQuery = request.query().get("achievementType");
        std::optional<std::string> achievementType;
        if (achievementTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(achievementTypeQuery.value(), valueQuery_instance)) {
                achievementType = valueQuery_instance;
            }
        }
        auto includeUndiscoveredQuery = request.query().get("includeUndiscovered");
        std::optional<bool> includeUndiscovered;
        if (includeUndiscoveredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeUndiscoveredQuery.value(), valueQuery_instance)) {
                includeUndiscovered = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_achievements(version, returnNulls, appKey, includeUndiscovered, deviceId, accountId, connectionAccountEmail, connectionAccountId, rankType, achievementType, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::list_achievement_tags_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
    


        try {





            this->list_achievement_tags(version, appKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::list_achievements_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto achievementTypeQuery = request.query().get("achievementType");
        std::optional<std::string> achievementType;
        if (achievementTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(achievementTypeQuery.value(), valueQuery_instance)) {
                achievementType = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
    


        try {





            this->list_achievements(version, sortField, descending, start, limit, activeOnly, deviceId, accountId, appKey, keyword, achievementType, rankType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::search_achievements_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto achievementTypeQuery = request.query().get("achievementType");
        std::optional<std::string> achievementType;
        if (achievementTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(achievementTypeQuery.value(), valueQuery_instance)) {
                achievementType = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto includeTiersQuery = request.query().get("includeTiers");
        std::optional<bool> includeTiers;
        if (includeTiersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeTiersQuery.value(), valueQuery_instance)) {
                includeTiers = valueQuery_instance;
            }
        }
        auto includeInactiveTiersQuery = request.query().get("includeInactiveTiers");
        std::optional<bool> includeInactiveTiers;
        if (includeInactiveTiersQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeInactiveTiersQuery.value(), valueQuery_instance)) {
                includeInactiveTiers = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_achievements(version, appKey, sortField, descending, includeTiers, includeInactiveTiers, start, limit, deviceId, accountId, keyword, achievementType, rankType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::update_achievement_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementIdQuery = request.query().get("achievementId");
        std::optional<int64_t> achievementId;
        if (achievementIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementIdQuery.value(), valueQuery_instance)) {
                achievementId = valueQuery_instance;
            }
        }
        auto analyticsTagQuery = request.query().get("analyticsTag");
        std::optional<std::string> analyticsTag;
        if (analyticsTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(analyticsTagQuery.value(), valueQuery_instance)) {
                analyticsTag = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto rankIncrementQuery = request.query().get("rankIncrement");
        std::optional<int32_t> rankIncrement;
        if (rankIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(rankIncrementQuery.value(), valueQuery_instance)) {
                rankIncrement = valueQuery_instance;
            }
        }
        auto minIncrementQuery = request.query().get("minIncrement");
        std::optional<int32_t> minIncrement;
        if (minIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minIncrementQuery.value(), valueQuery_instance)) {
                minIncrement = valueQuery_instance;
            }
        }
        auto nullMinIncrementQuery = request.query().get("nullMinIncrement");
        std::optional<bool> nullMinIncrement;
        if (nullMinIncrementQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(nullMinIncrementQuery.value(), valueQuery_instance)) {
                nullMinIncrement = valueQuery_instance;
            }
        }
        auto maxIncrementQuery = request.query().get("maxIncrement");
        std::optional<int32_t> maxIncrement;
        if (maxIncrementQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxIncrementQuery.value(), valueQuery_instance)) {
                maxIncrement = valueQuery_instance;
            }
        }
        auto nullMaxIncrementQuery = request.query().get("nullMaxIncrement");
        std::optional<bool> nullMaxIncrement;
        if (nullMaxIncrementQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(nullMaxIncrementQuery.value(), valueQuery_instance)) {
                nullMaxIncrement = valueQuery_instance;
            }
        }
        auto validateQuery = request.query().get("validate");
        std::optional<bool> validate;
        if (validateQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(validateQuery.value(), valueQuery_instance)) {
                validate = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto triggerDefinitionQuery = request.query().get("triggerDefinition");
        std::optional<std::string> triggerDefinition;
        if (triggerDefinitionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(triggerDefinitionQuery.value(), valueQuery_instance)) {
                triggerDefinition = valueQuery_instance;
            }
        }
    


        try {





            this->update_achievement(version, deviceId, accountId, achievementId, analyticsTag, title, description, rankType, rankIncrement, minIncrement, nullMinIncrement, maxIncrement, nullMaxIncrement, validate, active, triggerDefinition, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::update_achievement_tier_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->update_achievement_tier(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AchievementApi::update_user_achievement_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto achievementIdQuery = request.query().get("achievementId");
        std::optional<int64_t> achievementId;
        if (achievementIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementIdQuery.value(), valueQuery_instance)) {
                achievementId = valueQuery_instance;
            }
        }
        auto tagQuery = request.query().get("tag");
        std::optional<std::string> tag;
        if (tagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagQuery.value(), valueQuery_instance)) {
                tag = valueQuery_instance;
            }
        }
        auto customIdQuery = request.query().get("customId");
        std::optional<int64_t> customId;
        if (customIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customIdQuery.value(), valueQuery_instance)) {
                customId = valueQuery_instance;
            }
        }
        auto incrementQuery = request.query().get("increment");
        std::optional<int64_t> increment;
        if (incrementQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(incrementQuery.value(), valueQuery_instance)) {
                increment = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto returnProgressQuery = request.query().get("returnProgress");
        std::optional<bool> returnProgress;
        if (returnProgressQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnProgressQuery.value(), valueQuery_instance)) {
                returnProgress = valueQuery_instance;
            }
        }
    


        try {





            this->update_user_achievement(version, accountId, achievementId, tag, customId, increment, startDate, endDate, returnProgress, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void AchievementApi::achievement_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

