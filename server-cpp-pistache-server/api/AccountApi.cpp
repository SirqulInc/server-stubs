/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "AccountApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string AccountApi::base = "";

AccountApi::AccountApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void AccountApi::init() {
    setupRoutes();
}

void AccountApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/api/:version/account/search", Routes::bind(&AccountApi::account_location_search_handler, this));
    Routes::Post(*router, base + "/api/:version/account/block", Routes::bind(&AccountApi::block_account_handler, this));
    Routes::Post(*router, base + "/api/:version/account/create", Routes::bind(&AccountApi::create_account_handler, this));
    Routes::Post(*router, base + "/api/:version/account/profile/update", Routes::bind(&AccountApi::edit_account_handler, this));
    Routes::Post(*router, base + "/api/:version/account/username/update", Routes::bind(&AccountApi::edit_username_handler, this));
    Routes::Get(*router, base + "/api/:version/account/profile/get", Routes::bind(&AccountApi::get_account_handler, this));
    Routes::Get(*router, base + "/api/:version/account/profile/assets", Routes::bind(&AccountApi::get_profile_assets_handler, this));
    Routes::Get(*router, base + "/api/:version/account/referral/list", Routes::bind(&AccountApi::get_referral_list_handler, this));
    Routes::Get(*router, base + "/api/:version/account/settings/get", Routes::bind(&AccountApi::get_settings_handler, this));
    Routes::Post(*router, base + "/api/:version/account/login/delegate", Routes::bind(&AccountApi::login_delegate_handler, this));
    Routes::Post(*router, base + "/api/:version/account/login", Routes::bind(&AccountApi::login_general_handler, this));
    Routes::Post(*router, base + "/api/:version/account/get", Routes::bind(&AccountApi::login_username_handler, this));
    Routes::Post(*router, base + "/api/:version/account/logout", Routes::bind(&AccountApi::logout_handler, this));
    Routes::Post(*router, base + "/api/:version/account/merge", Routes::bind(&AccountApi::merge_account_handler, this));
    Routes::Post(*router, base + "/api/:version/account/passwordchange", Routes::bind(&AccountApi::password_change_handler, this));
    Routes::Post(*router, base + "/api/:version/account/passwordreset", Routes::bind(&AccountApi::password_reset_handler, this));
    Routes::Post(*router, base + "/api/:version/account/requestpasswordreset", Routes::bind(&AccountApi::request_password_reset_handler, this));
    Routes::Post(*router, base + "/api/:version/account/requestValidateAccount", Routes::bind(&AccountApi::request_validate_account_handler, this));
    Routes::Get(*router, base + "/api/:version/account/profile/search", Routes::bind(&AccountApi::search_accounts_handler, this));
    Routes::Post(*router, base + "/api/:version/account/login/validate", Routes::bind(&AccountApi::secure_login_handler, this));
    Routes::Post(*router, base + "/api/:version/account/create/validate", Routes::bind(&AccountApi::secure_signup_handler, this));
    Routes::Post(*router, base + "/api/:version/consumer/profile/matchToken", Routes::bind(&AccountApi::set_match_token_handler, this));
    Routes::Post(*router, base + "/api/:version/account/active/update", Routes::bind(&AccountApi::update_actve_status_handler, this));
    Routes::Post(*router, base + "/api/:version/account/location/update", Routes::bind(&AccountApi::update_location_handler, this));
    Routes::Post(*router, base + "/api/:version/account/settings/update", Routes::bind(&AccountApi::update_settings_handler, this));
    Routes::Post(*router, base + "/api/:version/account/validateAccountSignup", Routes::bind(&AccountApi::validate_account_signup_handler, this));
    Routes::Post(*router, base + "/api/:version/account/validatepasswordreset", Routes::bind(&AccountApi::validate_password_reset_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&AccountApi::account_api_default_handler, this));
}

void AccountApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AccountApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void AccountApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AccountApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void AccountApi::account_location_search_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto postalCodeQuery = request.query().get("postalCode");
        std::optional<std::string> postalCode;
        if (postalCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(postalCodeQuery.value(), valueQuery_instance)) {
                postalCode = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rangeQuery = request.query().get("range");
        std::optional<double> range;
        if (rangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(rangeQuery.value(), valueQuery_instance)) {
                range = valueQuery_instance;
            }
        }
        auto locationLastUpdatedQuery = request.query().get("locationLastUpdated");
        std::optional<int64_t> locationLastUpdated;
        if (locationLastUpdatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(locationLastUpdatedQuery.value(), valueQuery_instance)) {
                locationLastUpdated = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto minAgeQuery = request.query().get("minAge");
        std::optional<int32_t> minAge;
        if (minAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minAgeQuery.value(), valueQuery_instance)) {
                minAge = valueQuery_instance;
            }
        }
        auto maxAgeQuery = request.query().get("maxAge");
        std::optional<int32_t> maxAge;
        if (maxAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxAgeQuery.value(), valueQuery_instance)) {
                maxAge = valueQuery_instance;
            }
        }
        auto companionshipIndexQuery = request.query().get("companionshipIndex");
        std::optional<int32_t> companionshipIndex;
        if (companionshipIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(companionshipIndexQuery.value(), valueQuery_instance)) {
                companionshipIndex = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto searchModeQuery = request.query().get("searchMode");
        std::optional<std::string> searchMode;
        if (searchModeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchModeQuery.value(), valueQuery_instance)) {
                searchMode = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto rolesQuery = request.query().get("roles");
        std::optional<std::string> roles;
        if (rolesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rolesQuery.value(), valueQuery_instance)) {
                roles = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto experienceQuery = request.query().get("experience");
        std::optional<std::string> experience;
        if (experienceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(experienceQuery.value(), valueQuery_instance)) {
                experience = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto audienceOperatorQuery = request.query().get("audienceOperator");
        std::optional<std::string> audienceOperator;
        if (audienceOperatorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceOperatorQuery.value(), valueQuery_instance)) {
                audienceOperator = valueQuery_instance;
            }
        }
        auto updateCurrentLocationQuery = request.query().get("updateCurrentLocation");
        std::optional<bool> updateCurrentLocation;
        if (updateCurrentLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updateCurrentLocationQuery.value(), valueQuery_instance)) {
                updateCurrentLocation = valueQuery_instance;
            }
        }
        auto updatePreferredSettingsQuery = request.query().get("updatePreferredSettings");
        std::optional<bool> updatePreferredSettings;
        if (updatePreferredSettingsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updatePreferredSettingsQuery.value(), valueQuery_instance)) {
                updatePreferredSettings = valueQuery_instance;
            }
        }
        auto showExactLocationsQuery = request.query().get("showExactLocations");
        std::optional<bool> showExactLocations;
        if (showExactLocationsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showExactLocationsQuery.value(), valueQuery_instance)) {
                showExactLocations = valueQuery_instance;
            }
        }
        auto showConnectionToSearcherQuery = request.query().get("showConnectionToSearcher");
        std::optional<bool> showConnectionToSearcher;
        if (showConnectionToSearcherQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showConnectionToSearcherQuery.value(), valueQuery_instance)) {
                showConnectionToSearcher = valueQuery_instance;
            }
        }
        auto flagCountMinimumQuery = request.query().get("flagCountMinimum");
        std::optional<int64_t> flagCountMinimum;
        if (flagCountMinimumQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(flagCountMinimumQuery.value(), valueQuery_instance)) {
                flagCountMinimum = valueQuery_instance;
            }
        }
        auto verifiedUserOnlyQuery = request.query().get("verifiedUserOnly");
        std::optional<bool> verifiedUserOnly;
        if (verifiedUserOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(verifiedUserOnlyQuery.value(), valueQuery_instance)) {
                verifiedUserOnly = valueQuery_instance;
            }
        }
        auto contentAdminOnlyQuery = request.query().get("contentAdminOnly");
        std::optional<bool> contentAdminOnly;
        if (contentAdminOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(contentAdminOnlyQuery.value(), valueQuery_instance)) {
                contentAdminOnly = valueQuery_instance;
            }
        }
    


        try {





            this->account_location_search(version, deviceId, accountId, q, keyword, postalCode, latitude, longitude, appKey, range, locationLastUpdated, gender, minAge, maxAge, companionshipIndex, i, start, l, limit, searchMode, sortField, descending, roles, tags, experience, categoryIds, audienceIds, audienceOperator, updateCurrentLocation, updatePreferredSettings, showExactLocations, showConnectionToSearcher, flagCountMinimum, verifiedUserOnly, contentAdminOnly, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::block_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto accountIdBeingBlockedQuery = request.query().get("accountIdBeingBlocked");
        std::optional<int64_t> accountIdBeingBlocked;
        if (accountIdBeingBlockedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdBeingBlockedQuery.value(), valueQuery_instance)) {
                accountIdBeingBlocked = valueQuery_instance;
            }
        }
        auto blockFlagValueQuery = request.query().get("blockFlagValue");
        std::optional<bool> blockFlagValue;
        if (blockFlagValueQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(blockFlagValueQuery.value(), valueQuery_instance)) {
                blockFlagValue = valueQuery_instance;
            }
        }
        auto removeFromGroupsIfBlockedQuery = request.query().get("removeFromGroupsIfBlocked");
        std::optional<bool> removeFromGroupsIfBlocked;
        if (removeFromGroupsIfBlockedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(removeFromGroupsIfBlockedQuery.value(), valueQuery_instance)) {
                removeFromGroupsIfBlocked = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->block_account(version, accountIdBeingBlocked, deviceId, accountId, blockFlagValue, removeFromGroupsIfBlocked, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::create_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto prefixNameQuery = request.query().get("prefixName");
        std::optional<std::string> prefixName;
        if (prefixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(prefixNameQuery.value(), valueQuery_instance)) {
                prefixName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto middleNameQuery = request.query().get("middleName");
        std::optional<std::string> middleName;
        if (middleNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(middleNameQuery.value(), valueQuery_instance)) {
                middleName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto suffixNameQuery = request.query().get("suffixName");
        std::optional<std::string> suffixName;
        if (suffixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixNameQuery.value(), valueQuery_instance)) {
                suffixName = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto deviceIdTypeQuery = request.query().get("deviceIdType");
        std::optional<std::string> deviceIdType;
        if (deviceIdTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdTypeQuery.value(), valueQuery_instance)) {
                deviceIdType = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto streetAddressQuery = request.query().get("streetAddress");
        std::optional<std::string> streetAddress;
        if (streetAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddressQuery.value(), valueQuery_instance)) {
                streetAddress = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto birthdayQuery = request.query().get("birthday");
        std::optional<int64_t> birthday;
        if (birthdayQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(birthdayQuery.value(), valueQuery_instance)) {
                birthday = valueQuery_instance;
            }
        }
        auto homePhoneQuery = request.query().get("homePhone");
        std::optional<std::string> homePhone;
        if (homePhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(homePhoneQuery.value(), valueQuery_instance)) {
                homePhone = valueQuery_instance;
            }
        }
        auto cellPhoneQuery = request.query().get("cellPhone");
        std::optional<std::string> cellPhone;
        if (cellPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneQuery.value(), valueQuery_instance)) {
                cellPhone = valueQuery_instance;
            }
        }
        auto cellPhoneCarrierQuery = request.query().get("cellPhoneCarrier");
        std::optional<std::string> cellPhoneCarrier;
        if (cellPhoneCarrierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneCarrierQuery.value(), valueQuery_instance)) {
                cellPhoneCarrier = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto platformsQuery = request.query().get("platforms");
        std::optional<std::string> platforms;
        if (platformsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(platformsQuery.value(), valueQuery_instance)) {
                platforms = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto aboutUsQuery = request.query().get("aboutUs");
        std::optional<std::string> aboutUs;
        if (aboutUsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(aboutUsQuery.value(), valueQuery_instance)) {
                aboutUs = valueQuery_instance;
            }
        }
        auto gameExperienceQuery = request.query().get("gameExperience");
        std::optional<std::string> gameExperience;
        if (gameExperienceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceQuery.value(), valueQuery_instance)) {
                gameExperience = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto hometownQuery = request.query().get("hometown");
        std::optional<std::string> hometown;
        if (hometownQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(hometownQuery.value(), valueQuery_instance)) {
                hometown = valueQuery_instance;
            }
        }
        auto heightQuery = request.query().get("height");
        std::optional<std::string> height;
        if (heightQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(heightQuery.value(), valueQuery_instance)) {
                height = valueQuery_instance;
            }
        }
        auto heightIndexQuery = request.query().get("heightIndex");
        std::optional<int32_t> heightIndex;
        if (heightIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(heightIndexQuery.value(), valueQuery_instance)) {
                heightIndex = valueQuery_instance;
            }
        }
        auto ethnicityQuery = request.query().get("ethnicity");
        std::optional<std::string> ethnicity;
        if (ethnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ethnicityQuery.value(), valueQuery_instance)) {
                ethnicity = valueQuery_instance;
            }
        }
        auto bodyTypeQuery = request.query().get("bodyType");
        std::optional<std::string> bodyType;
        if (bodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bodyTypeQuery.value(), valueQuery_instance)) {
                bodyType = valueQuery_instance;
            }
        }
        auto maritalStatusQuery = request.query().get("maritalStatus");
        std::optional<std::string> maritalStatus;
        if (maritalStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(maritalStatusQuery.value(), valueQuery_instance)) {
                maritalStatus = valueQuery_instance;
            }
        }
        auto childrenQuery = request.query().get("children");
        std::optional<std::string> children;
        if (childrenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(childrenQuery.value(), valueQuery_instance)) {
                children = valueQuery_instance;
            }
        }
        auto religionQuery = request.query().get("religion");
        std::optional<std::string> religion;
        if (religionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(religionQuery.value(), valueQuery_instance)) {
                religion = valueQuery_instance;
            }
        }
        auto educationQuery = request.query().get("education");
        std::optional<std::string> education;
        if (educationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(educationQuery.value(), valueQuery_instance)) {
                education = valueQuery_instance;
            }
        }
        auto educationIndexQuery = request.query().get("educationIndex");
        std::optional<int32_t> educationIndex;
        if (educationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(educationIndexQuery.value(), valueQuery_instance)) {
                educationIndex = valueQuery_instance;
            }
        }
        auto smokeQuery = request.query().get("smoke");
        std::optional<std::string> smoke;
        if (smokeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(smokeQuery.value(), valueQuery_instance)) {
                smoke = valueQuery_instance;
            }
        }
        auto drinkQuery = request.query().get("drink");
        std::optional<std::string> drink;
        if (drinkQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(drinkQuery.value(), valueQuery_instance)) {
                drink = valueQuery_instance;
            }
        }
        auto companionshipQuery = request.query().get("companionship");
        std::optional<std::string> companionship;
        if (companionshipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(companionshipQuery.value(), valueQuery_instance)) {
                companionship = valueQuery_instance;
            }
        }
        auto companionshipIndexQuery = request.query().get("companionshipIndex");
        std::optional<int32_t> companionshipIndex;
        if (companionshipIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(companionshipIndexQuery.value(), valueQuery_instance)) {
                companionshipIndex = valueQuery_instance;
            }
        }
        auto preferredMinAgeQuery = request.query().get("preferredMinAge");
        std::optional<int32_t> preferredMinAge;
        if (preferredMinAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinAgeQuery.value(), valueQuery_instance)) {
                preferredMinAge = valueQuery_instance;
            }
        }
        auto preferredMaxAgeQuery = request.query().get("preferredMaxAge");
        std::optional<int32_t> preferredMaxAge;
        if (preferredMaxAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxAgeQuery.value(), valueQuery_instance)) {
                preferredMaxAge = valueQuery_instance;
            }
        }
        auto preferredMinHeightQuery = request.query().get("preferredMinHeight");
        std::optional<int32_t> preferredMinHeight;
        if (preferredMinHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinHeightQuery.value(), valueQuery_instance)) {
                preferredMinHeight = valueQuery_instance;
            }
        }
        auto preferredMaxHeightQuery = request.query().get("preferredMaxHeight");
        std::optional<int32_t> preferredMaxHeight;
        if (preferredMaxHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxHeightQuery.value(), valueQuery_instance)) {
                preferredMaxHeight = valueQuery_instance;
            }
        }
        auto preferredGenderQuery = request.query().get("preferredGender");
        std::optional<std::string> preferredGender;
        if (preferredGenderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredGenderQuery.value(), valueQuery_instance)) {
                preferredGender = valueQuery_instance;
            }
        }
        auto preferredEducationQuery = request.query().get("preferredEducation");
        std::optional<std::string> preferredEducation;
        if (preferredEducationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEducationQuery.value(), valueQuery_instance)) {
                preferredEducation = valueQuery_instance;
            }
        }
        auto preferredEducationIndexQuery = request.query().get("preferredEducationIndex");
        std::optional<int32_t> preferredEducationIndex;
        if (preferredEducationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredEducationIndexQuery.value(), valueQuery_instance)) {
                preferredEducationIndex = valueQuery_instance;
            }
        }
        auto preferredBodyTypeQuery = request.query().get("preferredBodyType");
        std::optional<std::string> preferredBodyType;
        if (preferredBodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredBodyTypeQuery.value(), valueQuery_instance)) {
                preferredBodyType = valueQuery_instance;
            }
        }
        auto preferredEthnicityQuery = request.query().get("preferredEthnicity");
        std::optional<std::string> preferredEthnicity;
        if (preferredEthnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEthnicityQuery.value(), valueQuery_instance)) {
                preferredEthnicity = valueQuery_instance;
            }
        }
        auto preferredLocationQuery = request.query().get("preferredLocation");
        std::optional<std::string> preferredLocation;
        if (preferredLocationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredLocationQuery.value(), valueQuery_instance)) {
                preferredLocation = valueQuery_instance;
            }
        }
        auto preferredLocationRangeQuery = request.query().get("preferredLocationRange");
        std::optional<double> preferredLocationRange;
        if (preferredLocationRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(preferredLocationRangeQuery.value(), valueQuery_instance)) {
                preferredLocationRange = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto acceptedTermsQuery = request.query().get("acceptedTerms");
        std::optional<bool> acceptedTerms;
        if (acceptedTermsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(acceptedTermsQuery.value(), valueQuery_instance)) {
                acceptedTerms = valueQuery_instance;
            }
        }
        auto inviteTokenQuery = request.query().get("inviteToken");
        std::optional<std::string> inviteToken;
        if (inviteTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(inviteTokenQuery.value(), valueQuery_instance)) {
                inviteToken = valueQuery_instance;
            }
        }
        auto referralAccountIdQuery = request.query().get("referralAccountId");
        std::optional<int64_t> referralAccountId;
        if (referralAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(referralAccountIdQuery.value(), valueQuery_instance)) {
                referralAccountId = valueQuery_instance;
            }
        }
        auto sendValidationQuery = request.query().get("sendValidation");
        std::optional<bool> sendValidation;
        if (sendValidationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendValidationQuery.value(), valueQuery_instance)) {
                sendValidation = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto responseTypeQuery = request.query().get("responseType");
        std::optional<std::string> responseType;
        if (responseTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseTypeQuery.value(), valueQuery_instance)) {
                responseType = valueQuery_instance;
            }
        }
        auto audienceIdsToAddQuery = request.query().get("audienceIdsToAdd");
        std::optional<std::string> audienceIdsToAdd;
        if (audienceIdsToAddQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsToAddQuery.value(), valueQuery_instance)) {
                audienceIdsToAdd = valueQuery_instance;
            }
        }
        auto appBlobQuery = request.query().get("appBlob");
        std::optional<std::string> appBlob;
        if (appBlobQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appBlobQuery.value(), valueQuery_instance)) {
                appBlob = valueQuery_instance;
            }
        }
        auto appEnablePushQuery = request.query().get("appEnablePush");
        std::optional<bool> appEnablePush;
        if (appEnablePushQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnablePushQuery.value(), valueQuery_instance)) {
                appEnablePush = valueQuery_instance;
            }
        }
        auto appEnableSMSQuery = request.query().get("appEnableSMS");
        std::optional<bool> appEnableSMS;
        if (appEnableSMSQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnableSMSQuery.value(), valueQuery_instance)) {
                appEnableSMS = valueQuery_instance;
            }
        }
        auto appEnableEmailQuery = request.query().get("appEnableEmail");
        std::optional<bool> appEnableEmail;
        if (appEnableEmailQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnableEmailQuery.value(), valueQuery_instance)) {
                appEnableEmail = valueQuery_instance;
            }
        }
        auto locationVisibilityQuery = request.query().get("locationVisibility");
        std::optional<std::string> locationVisibility;
        if (locationVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationVisibilityQuery.value(), valueQuery_instance)) {
                locationVisibility = valueQuery_instance;
            }
        }
        auto homeLatitudeQuery = request.query().get("homeLatitude");
        std::optional<double> homeLatitude;
        if (homeLatitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(homeLatitudeQuery.value(), valueQuery_instance)) {
                homeLatitude = valueQuery_instance;
            }
        }
        auto homeLongitudeQuery = request.query().get("homeLongitude");
        std::optional<double> homeLongitude;
        if (homeLongitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(homeLongitudeQuery.value(), valueQuery_instance)) {
                homeLongitude = valueQuery_instance;
            }
        }
        auto appNicknameQuery = request.query().get("appNickname");
        std::optional<std::string> appNickname;
        if (appNicknameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appNicknameQuery.value(), valueQuery_instance)) {
                appNickname = valueQuery_instance;
            }
        }
        auto personalAudienceIdQuery = request.query().get("personalAudienceId");
        std::optional<int64_t> personalAudienceId;
        if (personalAudienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(personalAudienceIdQuery.value(), valueQuery_instance)) {
                personalAudienceId = valueQuery_instance;
            }
        }
    


        try {





            this->create_account(version, username, password, name, prefixName, firstName, middleName, lastName, suffixName, title, deviceId, deviceIdType, emailAddress, assetId, streetAddress, zipcode, gender, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, role, platforms, tags, aboutUs, gameExperience, categoryIds, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, latitude, longitude, acceptedTerms, inviteToken, referralAccountId, sendValidation, gameType, appKey, appVersion, responseType, audienceIdsToAdd, appBlob, appEnablePush, appEnableSMS, appEnableEmail, locationVisibility, homeLatitude, homeLongitude, appNickname, personalAudienceId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::edit_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto prefixNameQuery = request.query().get("prefixName");
        std::optional<std::string> prefixName;
        if (prefixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(prefixNameQuery.value(), valueQuery_instance)) {
                prefixName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto middleNameQuery = request.query().get("middleName");
        std::optional<std::string> middleName;
        if (middleNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(middleNameQuery.value(), valueQuery_instance)) {
                middleName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto suffixNameQuery = request.query().get("suffixName");
        std::optional<std::string> suffixName;
        if (suffixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixNameQuery.value(), valueQuery_instance)) {
                suffixName = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageQuery = request.query().get("age");
        std::optional<int32_t> age;
        if (ageQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(ageQuery.value(), valueQuery_instance)) {
                age = valueQuery_instance;
            }
        }
        auto birthdayQuery = request.query().get("birthday");
        std::optional<int64_t> birthday;
        if (birthdayQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(birthdayQuery.value(), valueQuery_instance)) {
                birthday = valueQuery_instance;
            }
        }
        auto homePhoneQuery = request.query().get("homePhone");
        std::optional<std::string> homePhone;
        if (homePhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(homePhoneQuery.value(), valueQuery_instance)) {
                homePhone = valueQuery_instance;
            }
        }
        auto cellPhoneQuery = request.query().get("cellPhone");
        std::optional<std::string> cellPhone;
        if (cellPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneQuery.value(), valueQuery_instance)) {
                cellPhone = valueQuery_instance;
            }
        }
        auto cellPhoneCarrierQuery = request.query().get("cellPhoneCarrier");
        std::optional<std::string> cellPhoneCarrier;
        if (cellPhoneCarrierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneCarrierQuery.value(), valueQuery_instance)) {
                cellPhoneCarrier = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto streetAddressQuery = request.query().get("streetAddress");
        std::optional<std::string> streetAddress;
        if (streetAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddressQuery.value(), valueQuery_instance)) {
                streetAddress = valueQuery_instance;
            }
        }
        auto streetAddress2Query = request.query().get("streetAddress2");
        std::optional<std::string> streetAddress2;
        if (streetAddress2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddress2Query.value(), valueQuery_instance)) {
                streetAddress2 = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto makeProfileInfoPublicQuery = request.query().get("makeProfileInfoPublic");
        std::optional<bool> makeProfileInfoPublic;
        if (makeProfileInfoPublicQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(makeProfileInfoPublicQuery.value(), valueQuery_instance)) {
                makeProfileInfoPublic = valueQuery_instance;
            }
        }
        auto makeGameInfoPublicQuery = request.query().get("makeGameInfoPublic");
        std::optional<bool> makeGameInfoPublic;
        if (makeGameInfoPublicQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(makeGameInfoPublicQuery.value(), valueQuery_instance)) {
                makeGameInfoPublic = valueQuery_instance;
            }
        }
        auto makeFriendsInfoPublicQuery = request.query().get("makeFriendsInfoPublic");
        std::optional<bool> makeFriendsInfoPublic;
        if (makeFriendsInfoPublicQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(makeFriendsInfoPublicQuery.value(), valueQuery_instance)) {
                makeFriendsInfoPublic = valueQuery_instance;
            }
        }
        auto hometownQuery = request.query().get("hometown");
        std::optional<std::string> hometown;
        if (hometownQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(hometownQuery.value(), valueQuery_instance)) {
                hometown = valueQuery_instance;
            }
        }
        auto heightQuery = request.query().get("height");
        std::optional<std::string> height;
        if (heightQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(heightQuery.value(), valueQuery_instance)) {
                height = valueQuery_instance;
            }
        }
        auto heightIndexQuery = request.query().get("heightIndex");
        std::optional<int32_t> heightIndex;
        if (heightIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(heightIndexQuery.value(), valueQuery_instance)) {
                heightIndex = valueQuery_instance;
            }
        }
        auto ethnicityQuery = request.query().get("ethnicity");
        std::optional<std::string> ethnicity;
        if (ethnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ethnicityQuery.value(), valueQuery_instance)) {
                ethnicity = valueQuery_instance;
            }
        }
        auto bodyTypeQuery = request.query().get("bodyType");
        std::optional<std::string> bodyType;
        if (bodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bodyTypeQuery.value(), valueQuery_instance)) {
                bodyType = valueQuery_instance;
            }
        }
        auto maritalStatusQuery = request.query().get("maritalStatus");
        std::optional<std::string> maritalStatus;
        if (maritalStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(maritalStatusQuery.value(), valueQuery_instance)) {
                maritalStatus = valueQuery_instance;
            }
        }
        auto childrenQuery = request.query().get("children");
        std::optional<std::string> children;
        if (childrenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(childrenQuery.value(), valueQuery_instance)) {
                children = valueQuery_instance;
            }
        }
        auto religionQuery = request.query().get("religion");
        std::optional<std::string> religion;
        if (religionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(religionQuery.value(), valueQuery_instance)) {
                religion = valueQuery_instance;
            }
        }
        auto educationQuery = request.query().get("education");
        std::optional<std::string> education;
        if (educationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(educationQuery.value(), valueQuery_instance)) {
                education = valueQuery_instance;
            }
        }
        auto educationIndexQuery = request.query().get("educationIndex");
        std::optional<int32_t> educationIndex;
        if (educationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(educationIndexQuery.value(), valueQuery_instance)) {
                educationIndex = valueQuery_instance;
            }
        }
        auto smokeQuery = request.query().get("smoke");
        std::optional<std::string> smoke;
        if (smokeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(smokeQuery.value(), valueQuery_instance)) {
                smoke = valueQuery_instance;
            }
        }
        auto drinkQuery = request.query().get("drink");
        std::optional<std::string> drink;
        if (drinkQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(drinkQuery.value(), valueQuery_instance)) {
                drink = valueQuery_instance;
            }
        }
        auto companionshipQuery = request.query().get("companionship");
        std::optional<std::string> companionship;
        if (companionshipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(companionshipQuery.value(), valueQuery_instance)) {
                companionship = valueQuery_instance;
            }
        }
        auto companionshipIndexQuery = request.query().get("companionshipIndex");
        std::optional<int32_t> companionshipIndex;
        if (companionshipIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(companionshipIndexQuery.value(), valueQuery_instance)) {
                companionshipIndex = valueQuery_instance;
            }
        }
        auto preferredMinAgeQuery = request.query().get("preferredMinAge");
        std::optional<int32_t> preferredMinAge;
        if (preferredMinAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinAgeQuery.value(), valueQuery_instance)) {
                preferredMinAge = valueQuery_instance;
            }
        }
        auto preferredMaxAgeQuery = request.query().get("preferredMaxAge");
        std::optional<int32_t> preferredMaxAge;
        if (preferredMaxAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxAgeQuery.value(), valueQuery_instance)) {
                preferredMaxAge = valueQuery_instance;
            }
        }
        auto preferredMinHeightQuery = request.query().get("preferredMinHeight");
        std::optional<int32_t> preferredMinHeight;
        if (preferredMinHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinHeightQuery.value(), valueQuery_instance)) {
                preferredMinHeight = valueQuery_instance;
            }
        }
        auto preferredMaxHeightQuery = request.query().get("preferredMaxHeight");
        std::optional<int32_t> preferredMaxHeight;
        if (preferredMaxHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxHeightQuery.value(), valueQuery_instance)) {
                preferredMaxHeight = valueQuery_instance;
            }
        }
        auto preferredGenderQuery = request.query().get("preferredGender");
        std::optional<std::string> preferredGender;
        if (preferredGenderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredGenderQuery.value(), valueQuery_instance)) {
                preferredGender = valueQuery_instance;
            }
        }
        auto preferredEducationQuery = request.query().get("preferredEducation");
        std::optional<std::string> preferredEducation;
        if (preferredEducationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEducationQuery.value(), valueQuery_instance)) {
                preferredEducation = valueQuery_instance;
            }
        }
        auto preferredEducationIndexQuery = request.query().get("preferredEducationIndex");
        std::optional<int32_t> preferredEducationIndex;
        if (preferredEducationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredEducationIndexQuery.value(), valueQuery_instance)) {
                preferredEducationIndex = valueQuery_instance;
            }
        }
        auto preferredBodyTypeQuery = request.query().get("preferredBodyType");
        std::optional<std::string> preferredBodyType;
        if (preferredBodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredBodyTypeQuery.value(), valueQuery_instance)) {
                preferredBodyType = valueQuery_instance;
            }
        }
        auto preferredEthnicityQuery = request.query().get("preferredEthnicity");
        std::optional<std::string> preferredEthnicity;
        if (preferredEthnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEthnicityQuery.value(), valueQuery_instance)) {
                preferredEthnicity = valueQuery_instance;
            }
        }
        auto preferredLocationQuery = request.query().get("preferredLocation");
        std::optional<std::string> preferredLocation;
        if (preferredLocationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredLocationQuery.value(), valueQuery_instance)) {
                preferredLocation = valueQuery_instance;
            }
        }
        auto preferredLocationRangeQuery = request.query().get("preferredLocationRange");
        std::optional<double> preferredLocationRange;
        if (preferredLocationRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(preferredLocationRangeQuery.value(), valueQuery_instance)) {
                preferredLocationRange = valueQuery_instance;
            }
        }
        auto platformsQuery = request.query().get("platforms");
        std::optional<std::string> platforms;
        if (platformsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(platformsQuery.value(), valueQuery_instance)) {
                platforms = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto aboutUsQuery = request.query().get("aboutUs");
        std::optional<std::string> aboutUs;
        if (aboutUsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(aboutUsQuery.value(), valueQuery_instance)) {
                aboutUs = valueQuery_instance;
            }
        }
        auto matchTokenQuery = request.query().get("matchToken");
        std::optional<std::string> matchToken;
        if (matchTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(matchTokenQuery.value(), valueQuery_instance)) {
                matchToken = valueQuery_instance;
            }
        }
        auto gameExperienceQuery = request.query().get("gameExperience");
        std::optional<std::string> gameExperience;
        if (gameExperienceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceQuery.value(), valueQuery_instance)) {
                gameExperience = valueQuery_instance;
            }
        }
        auto categoriesQuery = request.query().get("categories");
        std::optional<std::string> categories;
        if (categoriesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoriesQuery.value(), valueQuery_instance)) {
                categories = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
        auto showAsZipcodeQuery = request.query().get("showAsZipcode");
        std::optional<bool> showAsZipcode;
        if (showAsZipcodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showAsZipcodeQuery.value(), valueQuery_instance)) {
                showAsZipcode = valueQuery_instance;
            }
        }
        auto showExactLocationQuery = request.query().get("showExactLocation");
        std::optional<bool> showExactLocation;
        if (showExactLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showExactLocationQuery.value(), valueQuery_instance)) {
                showExactLocation = valueQuery_instance;
            }
        }
        auto showOthersExactLocationQuery = request.query().get("showOthersExactLocation");
        std::optional<bool> showOthersExactLocation;
        if (showOthersExactLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showOthersExactLocationQuery.value(), valueQuery_instance)) {
                showOthersExactLocation = valueQuery_instance;
            }
        }
        auto acceptedTermsQuery = request.query().get("acceptedTerms");
        std::optional<bool> acceptedTerms;
        if (acceptedTermsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(acceptedTermsQuery.value(), valueQuery_instance)) {
                acceptedTerms = valueQuery_instance;
            }
        }
        auto locationVisibilityQuery = request.query().get("locationVisibility");
        std::optional<std::string> locationVisibility;
        if (locationVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationVisibilityQuery.value(), valueQuery_instance)) {
                locationVisibility = valueQuery_instance;
            }
        }
        auto appBlobQuery = request.query().get("appBlob");
        std::optional<std::string> appBlob;
        if (appBlobQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appBlobQuery.value(), valueQuery_instance)) {
                appBlob = valueQuery_instance;
            }
        }
        auto appEnablePushQuery = request.query().get("appEnablePush");
        std::optional<bool> appEnablePush;
        if (appEnablePushQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnablePushQuery.value(), valueQuery_instance)) {
                appEnablePush = valueQuery_instance;
            }
        }
        auto appEnableSMSQuery = request.query().get("appEnableSMS");
        std::optional<bool> appEnableSMS;
        if (appEnableSMSQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnableSMSQuery.value(), valueQuery_instance)) {
                appEnableSMS = valueQuery_instance;
            }
        }
        auto appEnableEmailQuery = request.query().get("appEnableEmail");
        std::optional<bool> appEnableEmail;
        if (appEnableEmailQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(appEnableEmailQuery.value(), valueQuery_instance)) {
                appEnableEmail = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto returnProfileQuery = request.query().get("returnProfile");
        std::optional<bool> returnProfile;
        if (returnProfileQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnProfileQuery.value(), valueQuery_instance)) {
                returnProfile = valueQuery_instance;
            }
        }
        auto audienceIdsToAddQuery = request.query().get("audienceIdsToAdd");
        std::optional<std::string> audienceIdsToAdd;
        if (audienceIdsToAddQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsToAddQuery.value(), valueQuery_instance)) {
                audienceIdsToAdd = valueQuery_instance;
            }
        }
        auto audienceIdsToRemoveQuery = request.query().get("audienceIdsToRemove");
        std::optional<std::string> audienceIdsToRemove;
        if (audienceIdsToRemoveQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsToRemoveQuery.value(), valueQuery_instance)) {
                audienceIdsToRemove = valueQuery_instance;
            }
        }
        auto referralAccountIdQuery = request.query().get("referralAccountId");
        std::optional<int64_t> referralAccountId;
        if (referralAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(referralAccountIdQuery.value(), valueQuery_instance)) {
                referralAccountId = valueQuery_instance;
            }
        }
        auto appNicknameQuery = request.query().get("appNickname");
        std::optional<std::string> appNickname;
        if (appNicknameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appNicknameQuery.value(), valueQuery_instance)) {
                appNickname = valueQuery_instance;
            }
        }
        auto personalAudienceIdQuery = request.query().get("personalAudienceId");
        std::optional<int64_t> personalAudienceId;
        if (personalAudienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(personalAudienceIdQuery.value(), valueQuery_instance)) {
                personalAudienceId = valueQuery_instance;
            }
        }
        auto nonGuestUsernameQuery = request.query().get("nonGuestUsername");
        std::optional<std::string> nonGuestUsername;
        if (nonGuestUsernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nonGuestUsernameQuery.value(), valueQuery_instance)) {
                nonGuestUsername = valueQuery_instance;
            }
        }
    


        try {





            this->edit_account(version, deviceId, accountId, connectionAccountId, role, assetId, name, prefixName, firstName, middleName, lastName, suffixName, title, gender, age, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, makeProfileInfoPublic, makeGameInfoPublic, makeFriendsInfoPublic, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, platforms, tags, aboutUs, matchToken, gameExperience, categories, categoryIds, responseFilters, showAsZipcode, showExactLocation, showOthersExactLocation, acceptedTerms, locationVisibility, appBlob, appEnablePush, appEnableSMS, appEnableEmail, gameType, appKey, latitude, longitude, returnProfile, audienceIdsToAdd, audienceIdsToRemove, referralAccountId, appNickname, personalAudienceId, nonGuestUsername, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::edit_username_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
    


        try {





            this->edit_username(version, deviceId, accountId, emailAddress, username, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::get_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountEmailQuery = request.query().get("connectionAccountEmail");
        std::optional<std::string> connectionAccountEmail;
        if (connectionAccountEmailQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionAccountEmailQuery.value(), valueQuery_instance)) {
                connectionAccountEmail = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto purchaseTypeQuery = request.query().get("purchaseType");
        std::optional<std::string> purchaseType;
        if (purchaseTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(purchaseTypeQuery.value(), valueQuery_instance)) {
                purchaseType = valueQuery_instance;
            }
        }
        auto updateViewedDateQuery = request.query().get("updateViewedDate");
        std::optional<bool> updateViewedDate;
        if (updateViewedDateQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updateViewedDateQuery.value(), valueQuery_instance)) {
                updateViewedDate = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->get_account(version, returnNulls, deviceId, accountId, connectionAccountEmail, connectionAccountId, responseFilters, gameType, appKey, purchaseType, updateViewedDate, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::get_profile_assets_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto ownerIdQuery = request.query().get("ownerId");
        std::optional<int64_t> ownerId;
        if (ownerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ownerIdQuery.value(), valueQuery_instance)) {
                ownerId = valueQuery_instance;
            }
        }
        auto mediaTypesQuery = request.query().get("mediaTypes");
        std::optional<std::string> mediaTypes;
        if (mediaTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mediaTypesQuery.value(), valueQuery_instance)) {
                mediaTypes = valueQuery_instance;
            }
        }
        auto mimeTypesQuery = request.query().get("mimeTypes");
        std::optional<std::string> mimeTypes;
        if (mimeTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mimeTypesQuery.value(), valueQuery_instance)) {
                mimeTypes = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_profile_assets(version, returnNulls, deviceId, accountId, ownerId, mediaTypes, mimeTypes, sortField, descending, latitude, longitude, i, start, l, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::get_referral_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto retrieveTypeQuery = request.query().get("retrieveType");
        std::optional<std::string> retrieveType;
        if (retrieveTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retrieveTypeQuery.value(), valueQuery_instance)) {
                retrieveType = valueQuery_instance;
            }
        }
        auto levelLimitQuery = request.query().get("levelLimit");
        std::optional<double> levelLimit;
        if (levelLimitQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(levelLimitQuery.value(), valueQuery_instance)) {
                levelLimit = valueQuery_instance;
            }
        }
        auto ancestorLevelLimitQuery = request.query().get("ancestorLevelLimit");
        std::optional<double> ancestorLevelLimit;
        if (ancestorLevelLimitQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(ancestorLevelLimitQuery.value(), valueQuery_instance)) {
                ancestorLevelLimit = valueQuery_instance;
            }
        }
        auto childrenLevelLimitQuery = request.query().get("childrenLevelLimit");
        std::optional<double> childrenLevelLimit;
        if (childrenLevelLimitQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(childrenLevelLimitQuery.value(), valueQuery_instance)) {
                childrenLevelLimit = valueQuery_instance;
            }
        }
        auto ancestorListStartQuery = request.query().get("ancestorListStart");
        std::optional<double> ancestorListStart;
        if (ancestorListStartQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(ancestorListStartQuery.value(), valueQuery_instance)) {
                ancestorListStart = valueQuery_instance;
            }
        }
        auto ancestorListLimitQuery = request.query().get("ancestorListLimit");
        std::optional<double> ancestorListLimit;
        if (ancestorListLimitQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(ancestorListLimitQuery.value(), valueQuery_instance)) {
                ancestorListLimit = valueQuery_instance;
            }
        }
        auto childrenListStartQuery = request.query().get("childrenListStart");
        std::optional<double> childrenListStart;
        if (childrenListStartQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(childrenListStartQuery.value(), valueQuery_instance)) {
                childrenListStart = valueQuery_instance;
            }
        }
        auto childrenListLimitQuery = request.query().get("childrenListLimit");
        std::optional<double> childrenListLimit;
        if (childrenListLimitQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(childrenListLimitQuery.value(), valueQuery_instance)) {
                childrenListLimit = valueQuery_instance;
            }
        }
        auto childrenChildrenQuery = request.query().get("childrenChildren");
        std::optional<bool> childrenChildren;
        if (childrenChildrenQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(childrenChildrenQuery.value(), valueQuery_instance)) {
                childrenChildren = valueQuery_instance;
            }
        }
    


        try {





            this->get_referral_list(version, accountId, appKey, retrieveType, levelLimit, ancestorLevelLimit, childrenLevelLimit, ancestorListStart, ancestorListLimit, childrenListStart, childrenListLimit, childrenChildren, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::get_settings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->get_settings(version, deviceId, accountId, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::login_delegate_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accessTokenQuery = request.query().get("accessToken");
        std::optional<std::string> accessToken;
        if (accessTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accessTokenQuery.value(), valueQuery_instance)) {
                accessToken = valueQuery_instance;
            }
        }
        auto accessTokenSecretQuery = request.query().get("accessTokenSecret");
        std::optional<std::string> accessTokenSecret;
        if (accessTokenSecretQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accessTokenSecretQuery.value(), valueQuery_instance)) {
                accessTokenSecret = valueQuery_instance;
            }
        }
        auto delegatedAccountIdQuery = request.query().get("delegatedAccountId");
        std::optional<int64_t> delegatedAccountId;
        if (delegatedAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(delegatedAccountIdQuery.value(), valueQuery_instance)) {
                delegatedAccountId = valueQuery_instance;
            }
        }
        auto delegatedUsernameQuery = request.query().get("delegatedUsername");
        std::optional<std::string> delegatedUsername;
        if (delegatedUsernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(delegatedUsernameQuery.value(), valueQuery_instance)) {
                delegatedUsername = valueQuery_instance;
            }
        }
        auto networkUIDQuery = request.query().get("networkUID");
        std::optional<std::string> networkUID;
        if (networkUIDQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(networkUIDQuery.value(), valueQuery_instance)) {
                networkUID = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto ageRestrictionQuery = request.query().get("ageRestriction");
        std::optional<int32_t> ageRestriction;
        if (ageRestrictionQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(ageRestrictionQuery.value(), valueQuery_instance)) {
                ageRestriction = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->login_delegate(version, accessToken, appKey, deviceId, accessTokenSecret, delegatedAccountId, delegatedUsername, networkUID, ageRestriction, responseFilters, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::login_general_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto deviceIdTypeQuery = request.query().get("deviceIdType");
        std::optional<std::string> deviceIdType;
        if (deviceIdTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdTypeQuery.value(), valueQuery_instance)) {
                deviceIdType = valueQuery_instance;
            }
        }
        auto accessTokenQuery = request.query().get("accessToken");
        std::optional<std::string> accessToken;
        if (accessTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accessTokenQuery.value(), valueQuery_instance)) {
                accessToken = valueQuery_instance;
            }
        }
        auto accessTokenSecretQuery = request.query().get("accessTokenSecret");
        std::optional<std::string> accessTokenSecret;
        if (accessTokenSecretQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accessTokenSecretQuery.value(), valueQuery_instance)) {
                accessTokenSecret = valueQuery_instance;
            }
        }
        auto networkUIDQuery = request.query().get("networkUID");
        std::optional<std::string> networkUID;
        if (networkUIDQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(networkUIDQuery.value(), valueQuery_instance)) {
                networkUID = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto ageRestrictionQuery = request.query().get("ageRestriction");
        std::optional<int32_t> ageRestriction;
        if (ageRestrictionQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(ageRestrictionQuery.value(), valueQuery_instance)) {
                ageRestriction = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto emailMatchQuery = request.query().get("emailMatch");
        std::optional<bool> emailMatch;
        if (emailMatchQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(emailMatchQuery.value(), valueQuery_instance)) {
                emailMatch = valueQuery_instance;
            }
        }
        auto chosenAccountIdQuery = request.query().get("chosenAccountId");
        std::optional<int64_t> chosenAccountId;
        if (chosenAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(chosenAccountIdQuery.value(), valueQuery_instance)) {
                chosenAccountId = valueQuery_instance;
            }
        }
        auto thirdPartyCredentialIdQuery = request.query().get("thirdPartyCredentialId");
        std::optional<int64_t> thirdPartyCredentialId;
        if (thirdPartyCredentialIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(thirdPartyCredentialIdQuery.value(), valueQuery_instance)) {
                thirdPartyCredentialId = valueQuery_instance;
            }
        }
    


        try {





            this->login_general(version, accessToken, networkUID, appKey, deviceId, deviceIdType, accessTokenSecret, ageRestriction, responseFilters, latitude, longitude, emailMatch, chosenAccountId, thirdPartyCredentialId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::login_username_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto appQuery = request.query().get("app");
        std::optional<std::string> app;
        if (appQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appQuery.value(), valueQuery_instance)) {
                app = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnProfileQuery = request.query().get("returnProfile");
        std::optional<bool> returnProfile;
        if (returnProfileQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnProfileQuery.value(), valueQuery_instance)) {
                returnProfile = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
    


        try {





            this->login_username(version, username, password, deviceId, latitude, longitude, app, gameType, appKey, returnProfile, responseFilters, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::logout_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto deviceIdTypeQuery = request.query().get("deviceIdType");
        std::optional<std::string> deviceIdType;
        if (deviceIdTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdTypeQuery.value(), valueQuery_instance)) {
                deviceIdType = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->logout(version, deviceId, deviceIdType, accountId, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::merge_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto mergeAccountIdQuery = request.query().get("mergeAccountId");
        std::optional<int64_t> mergeAccountId;
        if (mergeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(mergeAccountIdQuery.value(), valueQuery_instance)) {
                mergeAccountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
    


        try {





            this->merge_account(version, mergeAccountId, appKey, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::password_change_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto oldPasswordQuery = request.query().get("oldPassword");
        std::optional<std::string> oldPassword;
        if (oldPasswordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(oldPasswordQuery.value(), valueQuery_instance)) {
                oldPassword = valueQuery_instance;
            }
        }
        auto newPasswordQuery = request.query().get("newPassword");
        std::optional<std::string> newPassword;
        if (newPasswordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(newPasswordQuery.value(), valueQuery_instance)) {
                newPassword = valueQuery_instance;
            }
        }
        auto confirmPasswordQuery = request.query().get("confirmPassword");
        std::optional<std::string> confirmPassword;
        if (confirmPasswordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(confirmPasswordQuery.value(), valueQuery_instance)) {
                confirmPassword = valueQuery_instance;
            }
        }
    


        try {





            this->password_change(version, accountId, oldPassword, newPassword, confirmPassword, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::password_reset_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto tokenQuery = request.query().get("token");
        std::optional<std::string> token;
        if (tokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenQuery.value(), valueQuery_instance)) {
                token = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto confirmQuery = request.query().get("confirm");
        std::optional<std::string> confirm;
        if (confirmQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(confirmQuery.value(), valueQuery_instance)) {
                confirm = valueQuery_instance;
            }
        }
    


        try {





            this->password_reset(version, token, password, confirm, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::request_password_reset_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto emailQuery = request.query().get("email");
        std::optional<std::string> email;
        if (emailQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailQuery.value(), valueQuery_instance)) {
                email = valueQuery_instance;
            }
        }
        auto fromQuery = request.query().get("from");
        std::optional<std::string> from;
        if (fromQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(fromQuery.value(), valueQuery_instance)) {
                from = valueQuery_instance;
            }
        }
        auto domainQuery = request.query().get("domain");
        std::optional<std::string> domain;
        if (domainQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(domainQuery.value(), valueQuery_instance)) {
                domain = valueQuery_instance;
            }
        }
        auto subUrlQuery = request.query().get("subUrl");
        std::optional<std::string> subUrl;
        if (subUrlQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subUrlQuery.value(), valueQuery_instance)) {
                subUrl = valueQuery_instance;
            }
        }
        auto refererQuery = request.query().get("referer");
        std::optional<std::string> referer;
        if (refererQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(refererQuery.value(), valueQuery_instance)) {
                referer = valueQuery_instance;
            }
        }
    


        try {





            this->request_password_reset(version, email, from, domain, subUrl, referer, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::request_validate_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->request_validate_account(version, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::search_accounts_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto radiusQuery = request.query().get("radius");
        std::optional<double> radius;
        if (radiusQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(radiusQuery.value(), valueQuery_instance)) {
                radius = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto gameExperienceQuery = request.query().get("gameExperience");
        std::optional<std::string> gameExperience;
        if (gameExperienceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceQuery.value(), valueQuery_instance)) {
                gameExperience = valueQuery_instance;
            }
        }
        auto ageQuery = request.query().get("age");
        std::optional<int32_t> age;
        if (ageQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(ageQuery.value(), valueQuery_instance)) {
                age = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
        auto purchaseTypeQuery = request.query().get("purchaseType");
        std::optional<std::string> purchaseType;
        if (purchaseTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(purchaseTypeQuery.value(), valueQuery_instance)) {
                purchaseType = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
    


        try {





            this->search_accounts(version, accountId, appKey, keyword, latitude, longitude, radius, gender, gameExperience, age, categoryIds, returnNulls, responseFilters, purchaseType, sortField, descending, start, limit, activeOnly, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::secure_login_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto charsetNameQuery = request.query().get("charsetName");
        std::optional<std::string> charsetName;
        if (charsetNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(charsetNameQuery.value(), valueQuery_instance)) {
                charsetName = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto returnProfileQuery = request.query().get("returnProfile");
        std::optional<bool> returnProfile;
        if (returnProfileQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnProfileQuery.value(), valueQuery_instance)) {
                returnProfile = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
    


        try {





            this->secure_login(version, username, password, gameType, deviceId, charsetName, latitude, longitude, returnProfile, responseFilters, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::secure_signup_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto inviteTokenQuery = request.query().get("inviteToken");
        std::optional<std::string> inviteToken;
        if (inviteTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(inviteTokenQuery.value(), valueQuery_instance)) {
                inviteToken = valueQuery_instance;
            }
        }
        auto prefixNameQuery = request.query().get("prefixName");
        std::optional<std::string> prefixName;
        if (prefixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(prefixNameQuery.value(), valueQuery_instance)) {
                prefixName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto middleNameQuery = request.query().get("middleName");
        std::optional<std::string> middleName;
        if (middleNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(middleNameQuery.value(), valueQuery_instance)) {
                middleName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto suffixNameQuery = request.query().get("suffixName");
        std::optional<std::string> suffixName;
        if (suffixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixNameQuery.value(), valueQuery_instance)) {
                suffixName = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto deviceIdTypeQuery = request.query().get("deviceIdType");
        std::optional<std::string> deviceIdType;
        if (deviceIdTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdTypeQuery.value(), valueQuery_instance)) {
                deviceIdType = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto addressQuery = request.query().get("address");
        std::optional<std::string> address;
        if (addressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(addressQuery.value(), valueQuery_instance)) {
                address = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto birthdayQuery = request.query().get("birthday");
        std::optional<int64_t> birthday;
        if (birthdayQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(birthdayQuery.value(), valueQuery_instance)) {
                birthday = valueQuery_instance;
            }
        }
        auto homePhoneQuery = request.query().get("homePhone");
        std::optional<std::string> homePhone;
        if (homePhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(homePhoneQuery.value(), valueQuery_instance)) {
                homePhone = valueQuery_instance;
            }
        }
        auto cellPhoneQuery = request.query().get("cellPhone");
        std::optional<std::string> cellPhone;
        if (cellPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneQuery.value(), valueQuery_instance)) {
                cellPhone = valueQuery_instance;
            }
        }
        auto cellPhoneCarrierQuery = request.query().get("cellPhoneCarrier");
        std::optional<std::string> cellPhoneCarrier;
        if (cellPhoneCarrierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneCarrierQuery.value(), valueQuery_instance)) {
                cellPhoneCarrier = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto platformsQuery = request.query().get("platforms");
        std::optional<std::string> platforms;
        if (platformsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(platformsQuery.value(), valueQuery_instance)) {
                platforms = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto aboutUsQuery = request.query().get("aboutUs");
        std::optional<std::string> aboutUs;
        if (aboutUsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(aboutUsQuery.value(), valueQuery_instance)) {
                aboutUs = valueQuery_instance;
            }
        }
        auto gameExperienceQuery = request.query().get("gameExperience");
        std::optional<std::string> gameExperience;
        if (gameExperienceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceQuery.value(), valueQuery_instance)) {
                gameExperience = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto hometownQuery = request.query().get("hometown");
        std::optional<std::string> hometown;
        if (hometownQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(hometownQuery.value(), valueQuery_instance)) {
                hometown = valueQuery_instance;
            }
        }
        auto heightQuery = request.query().get("height");
        std::optional<std::string> height;
        if (heightQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(heightQuery.value(), valueQuery_instance)) {
                height = valueQuery_instance;
            }
        }
        auto heightIndexQuery = request.query().get("heightIndex");
        std::optional<int32_t> heightIndex;
        if (heightIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(heightIndexQuery.value(), valueQuery_instance)) {
                heightIndex = valueQuery_instance;
            }
        }
        auto ethnicityQuery = request.query().get("ethnicity");
        std::optional<std::string> ethnicity;
        if (ethnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ethnicityQuery.value(), valueQuery_instance)) {
                ethnicity = valueQuery_instance;
            }
        }
        auto bodyTypeQuery = request.query().get("bodyType");
        std::optional<std::string> bodyType;
        if (bodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bodyTypeQuery.value(), valueQuery_instance)) {
                bodyType = valueQuery_instance;
            }
        }
        auto maritalStatusQuery = request.query().get("maritalStatus");
        std::optional<std::string> maritalStatus;
        if (maritalStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(maritalStatusQuery.value(), valueQuery_instance)) {
                maritalStatus = valueQuery_instance;
            }
        }
        auto childrenQuery = request.query().get("children");
        std::optional<std::string> children;
        if (childrenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(childrenQuery.value(), valueQuery_instance)) {
                children = valueQuery_instance;
            }
        }
        auto religionQuery = request.query().get("religion");
        std::optional<std::string> religion;
        if (religionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(religionQuery.value(), valueQuery_instance)) {
                religion = valueQuery_instance;
            }
        }
        auto educationQuery = request.query().get("education");
        std::optional<std::string> education;
        if (educationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(educationQuery.value(), valueQuery_instance)) {
                education = valueQuery_instance;
            }
        }
        auto educationIndexQuery = request.query().get("educationIndex");
        std::optional<int32_t> educationIndex;
        if (educationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(educationIndexQuery.value(), valueQuery_instance)) {
                educationIndex = valueQuery_instance;
            }
        }
        auto smokeQuery = request.query().get("smoke");
        std::optional<std::string> smoke;
        if (smokeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(smokeQuery.value(), valueQuery_instance)) {
                smoke = valueQuery_instance;
            }
        }
        auto drinkQuery = request.query().get("drink");
        std::optional<std::string> drink;
        if (drinkQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(drinkQuery.value(), valueQuery_instance)) {
                drink = valueQuery_instance;
            }
        }
        auto companionshipQuery = request.query().get("companionship");
        std::optional<std::string> companionship;
        if (companionshipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(companionshipQuery.value(), valueQuery_instance)) {
                companionship = valueQuery_instance;
            }
        }
        auto companionshipIndexQuery = request.query().get("companionshipIndex");
        std::optional<int32_t> companionshipIndex;
        if (companionshipIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(companionshipIndexQuery.value(), valueQuery_instance)) {
                companionshipIndex = valueQuery_instance;
            }
        }
        auto preferredMinAgeQuery = request.query().get("preferredMinAge");
        std::optional<int32_t> preferredMinAge;
        if (preferredMinAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinAgeQuery.value(), valueQuery_instance)) {
                preferredMinAge = valueQuery_instance;
            }
        }
        auto preferredMaxAgeQuery = request.query().get("preferredMaxAge");
        std::optional<int32_t> preferredMaxAge;
        if (preferredMaxAgeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxAgeQuery.value(), valueQuery_instance)) {
                preferredMaxAge = valueQuery_instance;
            }
        }
        auto preferredMinHeightQuery = request.query().get("preferredMinHeight");
        std::optional<int32_t> preferredMinHeight;
        if (preferredMinHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMinHeightQuery.value(), valueQuery_instance)) {
                preferredMinHeight = valueQuery_instance;
            }
        }
        auto preferredMaxHeightQuery = request.query().get("preferredMaxHeight");
        std::optional<int32_t> preferredMaxHeight;
        if (preferredMaxHeightQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredMaxHeightQuery.value(), valueQuery_instance)) {
                preferredMaxHeight = valueQuery_instance;
            }
        }
        auto preferredGenderQuery = request.query().get("preferredGender");
        std::optional<std::string> preferredGender;
        if (preferredGenderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredGenderQuery.value(), valueQuery_instance)) {
                preferredGender = valueQuery_instance;
            }
        }
        auto preferredEducationQuery = request.query().get("preferredEducation");
        std::optional<std::string> preferredEducation;
        if (preferredEducationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEducationQuery.value(), valueQuery_instance)) {
                preferredEducation = valueQuery_instance;
            }
        }
        auto preferredEducationIndexQuery = request.query().get("preferredEducationIndex");
        std::optional<int32_t> preferredEducationIndex;
        if (preferredEducationIndexQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preferredEducationIndexQuery.value(), valueQuery_instance)) {
                preferredEducationIndex = valueQuery_instance;
            }
        }
        auto preferredBodyTypeQuery = request.query().get("preferredBodyType");
        std::optional<std::string> preferredBodyType;
        if (preferredBodyTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredBodyTypeQuery.value(), valueQuery_instance)) {
                preferredBodyType = valueQuery_instance;
            }
        }
        auto preferredEthnicityQuery = request.query().get("preferredEthnicity");
        std::optional<std::string> preferredEthnicity;
        if (preferredEthnicityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredEthnicityQuery.value(), valueQuery_instance)) {
                preferredEthnicity = valueQuery_instance;
            }
        }
        auto preferredLocationQuery = request.query().get("preferredLocation");
        std::optional<std::string> preferredLocation;
        if (preferredLocationQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preferredLocationQuery.value(), valueQuery_instance)) {
                preferredLocation = valueQuery_instance;
            }
        }
        auto preferredLocationRangeQuery = request.query().get("preferredLocationRange");
        std::optional<double> preferredLocationRange;
        if (preferredLocationRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(preferredLocationRangeQuery.value(), valueQuery_instance)) {
                preferredLocationRange = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto acceptedTermsQuery = request.query().get("acceptedTerms");
        std::optional<bool> acceptedTerms;
        if (acceptedTermsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(acceptedTermsQuery.value(), valueQuery_instance)) {
                acceptedTerms = valueQuery_instance;
            }
        }
        auto charsetNameQuery = request.query().get("charsetName");
        std::optional<std::string> charsetName;
        if (charsetNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(charsetNameQuery.value(), valueQuery_instance)) {
                charsetName = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto responseTypeQuery = request.query().get("responseType");
        std::optional<std::string> responseType;
        if (responseTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseTypeQuery.value(), valueQuery_instance)) {
                responseType = valueQuery_instance;
            }
        }
    


        try {





            this->secure_signup(version, deviceId, username, password, name, inviteToken, prefixName, firstName, middleName, lastName, suffixName, title, deviceIdType, emailAddress, assetId, address, zipcode, gender, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, role, platforms, tags, aboutUs, gameExperience, categoryIds, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, latitude, longitude, acceptedTerms, charsetName, gameType, appKey, appVersion, responseType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::set_match_token_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto matchTokenQuery = request.query().get("matchToken");
        std::optional<std::string> matchToken;
        if (matchTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(matchTokenQuery.value(), valueQuery_instance)) {
                matchToken = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->set_match_token(version, deviceId, accountId, matchToken, gameType, appKey, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::update_actve_status_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
    


        try {





            this->update_actve_status(version, accountId, connectionAccountId, active, deviceId, appKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::update_location_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto clientTimeQuery = request.query().get("clientTime");
        std::optional<int64_t> clientTime;
        if (clientTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(clientTimeQuery.value(), valueQuery_instance)) {
                clientTime = valueQuery_instance;
            }
        }
    


        try {





            this->update_location(version, deviceId, accountId, latitude, longitude, clientTime, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::update_settings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto blockedNotificationsQuery = request.query().get("blockedNotifications");
        std::optional<std::string> blockedNotifications;
        if (blockedNotificationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(blockedNotificationsQuery.value(), valueQuery_instance)) {
                blockedNotifications = valueQuery_instance;
            }
        }
        auto suggestionMethodQuery = request.query().get("suggestionMethod");
        std::optional<std::string> suggestionMethod;
        if (suggestionMethodQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suggestionMethodQuery.value(), valueQuery_instance)) {
                suggestionMethod = valueQuery_instance;
            }
        }
        auto suggestionCountQuery = request.query().get("suggestionCount");
        std::optional<int32_t> suggestionCount;
        if (suggestionCountQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(suggestionCountQuery.value(), valueQuery_instance)) {
                suggestionCount = valueQuery_instance;
            }
        }
        auto suggestionTimeFrameQuery = request.query().get("suggestionTimeFrame");
        std::optional<int32_t> suggestionTimeFrame;
        if (suggestionTimeFrameQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(suggestionTimeFrameQuery.value(), valueQuery_instance)) {
                suggestionTimeFrame = valueQuery_instance;
            }
        }
        auto showOthersExactLocationQuery = request.query().get("showOthersExactLocation");
        std::optional<bool> showOthersExactLocation;
        if (showOthersExactLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showOthersExactLocationQuery.value(), valueQuery_instance)) {
                showOthersExactLocation = valueQuery_instance;
            }
        }
        auto showAsZipcodeQuery = request.query().get("showAsZipcode");
        std::optional<bool> showAsZipcode;
        if (showAsZipcodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showAsZipcodeQuery.value(), valueQuery_instance)) {
                showAsZipcode = valueQuery_instance;
            }
        }
        auto showExactLocationQuery = request.query().get("showExactLocation");
        std::optional<bool> showExactLocation;
        if (showExactLocationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showExactLocationQuery.value(), valueQuery_instance)) {
                showExactLocation = valueQuery_instance;
            }
        }
        auto favoriteVisibilityQuery = request.query().get("favoriteVisibility");
        std::optional<std::string> favoriteVisibility;
        if (favoriteVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(favoriteVisibilityQuery.value(), valueQuery_instance)) {
                favoriteVisibility = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->update_settings(version, deviceId, accountId, blockedNotifications, suggestionMethod, suggestionCount, suggestionTimeFrame, showOthersExactLocation, showAsZipcode, showExactLocation, favoriteVisibility, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::validate_account_signup_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto tokenQuery = request.query().get("token");
        std::optional<std::string> token;
        if (tokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenQuery.value(), valueQuery_instance)) {
                token = valueQuery_instance;
            }
        }
    


        try {





            this->validate_account_signup(version, token, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AccountApi::validate_password_reset_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto tokenQuery = request.query().get("token");
        std::optional<std::string> token;
        if (tokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenQuery.value(), valueQuery_instance)) {
                token = valueQuery_instance;
            }
        }
    


        try {





            this->validate_password_reset(version, token, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void AccountApi::account_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

