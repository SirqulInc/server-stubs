/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "CreativeApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string CreativeApi::base = "";

CreativeApi::CreativeApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void CreativeApi::init() {
    setupRoutes();
}

void CreativeApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/creative/addpreview", Routes::bind(&CreativeApi::add_preview_handler, this));
    Routes::Get(*router, base + "/api/:version/ads/find", Routes::bind(&CreativeApi::ads_find_handler, this));
    Routes::Post(*router, base + "/api/:version/creative/create", Routes::bind(&CreativeApi::create_creative_handler, this));
    Routes::Post(*router, base + "/api/:version/creative/delete", Routes::bind(&CreativeApi::delete_creative_handler, this));
    Routes::Get(*router, base + "/api/:version/creative/get", Routes::bind(&CreativeApi::get_creative_handler, this));
    Routes::Get(*router, base + "/api/:version/creative/search", Routes::bind(&CreativeApi::get_creatives_by_application_handler, this));
    Routes::Post(*router, base + "/api/:version/creative/removepreview", Routes::bind(&CreativeApi::remove_preview_handler, this));
    Routes::Post(*router, base + "/api/:version/creative/update", Routes::bind(&CreativeApi::update_creative_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&CreativeApi::creative_api_default_handler, this));
}

void CreativeApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> CreativeApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void CreativeApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> CreativeApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void CreativeApi::add_preview_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto creativeIdQuery = request.query().get("creativeId");
        std::optional<int64_t> creativeId;
        if (creativeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(creativeIdQuery.value(), valueQuery_instance)) {
                creativeId = valueQuery_instance;
            }
        }
    


        try {





            this->add_preview(version, accountId, creativeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::ads_find_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto deviceQuery = request.query().get("device");
        std::optional<std::string> device;
        if (deviceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceQuery.value(), valueQuery_instance)) {
                device = valueQuery_instance;
            }
        }
        auto deviceIdentifierQuery = request.query().get("deviceIdentifier");
        std::optional<int64_t> deviceIdentifier;
        if (deviceIdentifierQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(deviceIdentifierQuery.value(), valueQuery_instance)) {
                deviceIdentifier = valueQuery_instance;
            }
        }
        auto deviceVersionQuery = request.query().get("deviceVersion");
        std::optional<std::string> deviceVersion;
        if (deviceVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceVersionQuery.value(), valueQuery_instance)) {
                deviceVersion = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto includeAudiencesQuery = request.query().get("includeAudiences");
        std::optional<bool> includeAudiences;
        if (includeAudiencesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeAudiencesQuery.value(), valueQuery_instance)) {
                includeAudiences = valueQuery_instance;
            }
        }
        auto allocatesTicketsQuery = request.query().get("allocatesTickets");
        std::optional<bool> allocatesTickets;
        if (allocatesTicketsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(allocatesTicketsQuery.value(), valueQuery_instance)) {
                allocatesTickets = valueQuery_instance;
            }
        }
        auto randomizeQuery = request.query().get("randomize");
        std::optional<bool> randomize;
        if (randomizeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(randomizeQuery.value(), valueQuery_instance)) {
                randomize = valueQuery_instance;
            }
        }
        auto targetedAdsOnlyQuery = request.query().get("targetedAdsOnly");
        std::optional<bool> targetedAdsOnly;
        if (targetedAdsOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(targetedAdsOnlyQuery.value(), valueQuery_instance)) {
                targetedAdsOnly = valueQuery_instance;
            }
        }
        auto missionIdsQuery = request.query().get("missionIds");
        std::optional<std::string> missionIds;
        if (missionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(missionIdsQuery.value(), valueQuery_instance)) {
                missionIds = valueQuery_instance;
            }
        }
    


        try {





            this->ads_find(version, appKey, randomize, targetedAdsOnly, type, accountId, appVersion, latitude, longitude, device, deviceIdentifier, deviceVersion, start, limit, includeAudiences, allocatesTickets, missionIds, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::create_creative_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto assetImageIdQuery = request.query().get("assetImageId");
        std::optional<int64_t> assetImageId;
        if (assetImageIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetImageIdQuery.value(), valueQuery_instance)) {
                assetImageId = valueQuery_instance;
            }
        }
        auto actionQuery = request.query().get("action");
        std::optional<std::string> action;
        if (actionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionQuery.value(), valueQuery_instance)) {
                action = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
        auto suffixQuery = request.query().get("suffix");
        std::optional<std::string> suffix;
        if (suffixQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixQuery.value(), valueQuery_instance)) {
                suffix = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto balanceQuery = request.query().get("balance");
        std::optional<double> balance;
        if (balanceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(balanceQuery.value(), valueQuery_instance)) {
                balance = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto referenceIdQuery = request.query().get("referenceId");
        std::optional<int64_t> referenceId;
        if (referenceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(referenceIdQuery.value(), valueQuery_instance)) {
                referenceId = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto waitForAssetQuery = request.query().get("waitForAsset");
        std::optional<bool> waitForAsset;
        if (waitForAssetQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(waitForAssetQuery.value(), valueQuery_instance)) {
                waitForAsset = valueQuery_instance;
            }
        }
    


        try {





            this->create_creative(version, accountId, name, active, waitForAsset, description, assetImageId, action, data, suffix, type, balance, referenceId, appVersion, missionId, offerId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::delete_creative_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto creativeIdQuery = request.query().get("creativeId");
        std::optional<int64_t> creativeId;
        if (creativeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(creativeIdQuery.value(), valueQuery_instance)) {
                creativeId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_creative(version, accountId, creativeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::get_creative_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto creativeIdQuery = request.query().get("creativeId");
        std::optional<int64_t> creativeId;
        if (creativeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(creativeIdQuery.value(), valueQuery_instance)) {
                creativeId = valueQuery_instance;
            }
        }
    


        try {





            this->get_creative(version, accountId, creativeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::get_creatives_by_application_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_creatives_by_application(version, accountId, appKey, start, limit, missionId, keyword, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::remove_preview_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto creativeIdQuery = request.query().get("creativeId");
        std::optional<int64_t> creativeId;
        if (creativeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(creativeIdQuery.value(), valueQuery_instance)) {
                creativeId = valueQuery_instance;
            }
        }
    


        try {





            this->remove_preview(version, accountId, creativeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void CreativeApi::update_creative_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto creativeIdQuery = request.query().get("creativeId");
        std::optional<int64_t> creativeId;
        if (creativeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(creativeIdQuery.value(), valueQuery_instance)) {
                creativeId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto assetImageIdQuery = request.query().get("assetImageId");
        std::optional<int64_t> assetImageId;
        if (assetImageIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetImageIdQuery.value(), valueQuery_instance)) {
                assetImageId = valueQuery_instance;
            }
        }
        auto actionQuery = request.query().get("action");
        std::optional<std::string> action;
        if (actionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionQuery.value(), valueQuery_instance)) {
                action = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
        auto suffixQuery = request.query().get("suffix");
        std::optional<std::string> suffix;
        if (suffixQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixQuery.value(), valueQuery_instance)) {
                suffix = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto balanceQuery = request.query().get("balance");
        std::optional<double> balance;
        if (balanceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(balanceQuery.value(), valueQuery_instance)) {
                balance = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto referenceIdQuery = request.query().get("referenceId");
        std::optional<int64_t> referenceId;
        if (referenceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(referenceIdQuery.value(), valueQuery_instance)) {
                referenceId = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
    


        try {





            this->update_creative(version, accountId, creativeId, name, description, assetImageId, action, data, suffix, type, balance, active, referenceId, appVersion, missionId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void CreativeApi::creative_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

