/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "MediaApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string MediaApi::base = "";

MediaApi::MediaApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void MediaApi::init() {
    setupRoutes();
}

void MediaApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/media/create", Routes::bind(&MediaApi::create_media_handler, this));
    Routes::Post(*router, base + "/api/:version/media/delete", Routes::bind(&MediaApi::delete_media_handler, this));
    Routes::Get(*router, base + "/api/:version/media/get", Routes::bind(&MediaApi::get_media_handler, this));
    Routes::Get(*router, base + "/api/:version/media/search", Routes::bind(&MediaApi::search_media_handler, this));
    Routes::Post(*router, base + "/api/:version/media/update", Routes::bind(&MediaApi::update_media_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&MediaApi::media_api_default_handler, this));
}

void MediaApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> MediaApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void MediaApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> MediaApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void MediaApi::create_media_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTitleQuery = request.query().get("subTitle");
        std::optional<std::string> subTitle;
        if (subTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTitleQuery.value(), valueQuery_instance)) {
                subTitle = valueQuery_instance;
            }
        }
        auto detailsQuery = request.query().get("details");
        std::optional<std::string> details;
        if (detailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsQuery.value(), valueQuery_instance)) {
                details = valueQuery_instance;
            }
        }
        auto subDetailsQuery = request.query().get("subDetails");
        std::optional<std::string> subDetails;
        if (subDetailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subDetailsQuery.value(), valueQuery_instance)) {
                subDetails = valueQuery_instance;
            }
        }
        auto finePrintQuery = request.query().get("finePrint");
        std::optional<std::string> finePrint;
        if (finePrintQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(finePrintQuery.value(), valueQuery_instance)) {
                finePrint = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto externalRedeemOptionsQuery = request.query().get("externalRedeemOptions");
        std::optional<std::string> externalRedeemOptions;
        if (externalRedeemOptionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalRedeemOptionsQuery.value(), valueQuery_instance)) {
                externalRedeemOptions = valueQuery_instance;
            }
        }
        auto externalUrlQuery = request.query().get("externalUrl");
        std::optional<std::string> externalUrl;
        if (externalUrlQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalUrlQuery.value(), valueQuery_instance)) {
                externalUrl = valueQuery_instance;
            }
        }
        auto ticketsRewardTypeQuery = request.query().get("ticketsRewardType");
        std::optional<std::string> ticketsRewardType;
        if (ticketsRewardTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketsRewardTypeQuery.value(), valueQuery_instance)) {
                ticketsRewardType = valueQuery_instance;
            }
        }
        auto ticketsRewardQuery = request.query().get("ticketsReward");
        std::optional<int64_t> ticketsReward;
        if (ticketsRewardQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketsRewardQuery.value(), valueQuery_instance)) {
                ticketsReward = valueQuery_instance;
            }
        }
        auto activatedQuery = request.query().get("activated");
        std::optional<int64_t> activated;
        if (activatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(activatedQuery.value(), valueQuery_instance)) {
                activated = valueQuery_instance;
            }
        }
        auto expiresQuery = request.query().get("expires");
        std::optional<int64_t> expires;
        if (expiresQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(expiresQuery.value(), valueQuery_instance)) {
                expires = valueQuery_instance;
            }
        }
        auto noExpirationQuery = request.query().get("noExpiration");
        std::optional<bool> noExpiration;
        if (noExpirationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(noExpirationQuery.value(), valueQuery_instance)) {
                noExpiration = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto availableLimitPerUserQuery = request.query().get("availableLimitPerUser");
        std::optional<int32_t> availableLimitPerUser;
        if (availableLimitPerUserQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitPerUserQuery.value(), valueQuery_instance)) {
                availableLimitPerUser = valueQuery_instance;
            }
        }
        auto addedLimitQuery = request.query().get("addedLimit");
        std::optional<int32_t> addedLimit;
        if (addedLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(addedLimitQuery.value(), valueQuery_instance)) {
                addedLimit = valueQuery_instance;
            }
        }
        auto viewLimitQuery = request.query().get("viewLimit");
        std::optional<int32_t> viewLimit;
        if (viewLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(viewLimitQuery.value(), valueQuery_instance)) {
                viewLimit = valueQuery_instance;
            }
        }
        auto maxPrintsQuery = request.query().get("maxPrints");
        std::optional<int32_t> maxPrints;
        if (maxPrintsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxPrintsQuery.value(), valueQuery_instance)) {
                maxPrints = valueQuery_instance;
            }
        }
        auto ticketPriceTypeQuery = request.query().get("ticketPriceType");
        std::optional<std::string> ticketPriceType;
        if (ticketPriceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketPriceTypeQuery.value(), valueQuery_instance)) {
                ticketPriceType = valueQuery_instance;
            }
        }
        auto ticketPriceQuery = request.query().get("ticketPrice");
        std::optional<int64_t> ticketPrice;
        if (ticketPriceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketPriceQuery.value(), valueQuery_instance)) {
                ticketPrice = valueQuery_instance;
            }
        }
        auto fullPriceQuery = request.query().get("fullPrice");
        std::optional<double> fullPrice;
        if (fullPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(fullPriceQuery.value(), valueQuery_instance)) {
                fullPrice = valueQuery_instance;
            }
        }
        auto discountPriceQuery = request.query().get("discountPrice");
        std::optional<double> discountPrice;
        if (discountPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(discountPriceQuery.value(), valueQuery_instance)) {
                discountPrice = valueQuery_instance;
            }
        }
        auto showRemainingQuery = request.query().get("showRemaining");
        std::optional<bool> showRemaining;
        if (showRemainingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRemainingQuery.value(), valueQuery_instance)) {
                showRemaining = valueQuery_instance;
            }
        }
        auto showRedeemedQuery = request.query().get("showRedeemed");
        std::optional<bool> showRedeemed;
        if (showRedeemedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRedeemedQuery.value(), valueQuery_instance)) {
                showRedeemed = valueQuery_instance;
            }
        }
        auto replacedQuery = request.query().get("replaced");
        std::optional<bool> replaced;
        if (replacedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(replacedQuery.value(), valueQuery_instance)) {
                replaced = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto offerVisibilityQuery = request.query().get("offerVisibility");
        std::optional<std::string> offerVisibility;
        if (offerVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerVisibilityQuery.value(), valueQuery_instance)) {
                offerVisibility = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto barcodeAssetIdQuery = request.query().get("barcodeAssetId");
        std::optional<int64_t> barcodeAssetId;
        if (barcodeAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(barcodeAssetIdQuery.value(), valueQuery_instance)) {
                barcodeAssetId = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto imageAssetId1Query = request.query().get("imageAssetId1");
        std::optional<int64_t> imageAssetId1;
        if (imageAssetId1Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId1Query.value(), valueQuery_instance)) {
                imageAssetId1 = valueQuery_instance;
            }
        }
        auto imageAssetId2Query = request.query().get("imageAssetId2");
        std::optional<int64_t> imageAssetId2;
        if (imageAssetId2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId2Query.value(), valueQuery_instance)) {
                imageAssetId2 = valueQuery_instance;
            }
        }
        auto imageAssetId3Query = request.query().get("imageAssetId3");
        std::optional<int64_t> imageAssetId3;
        if (imageAssetId3Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId3Query.value(), valueQuery_instance)) {
                imageAssetId3 = valueQuery_instance;
            }
        }
        auto imageAssetId4Query = request.query().get("imageAssetId4");
        std::optional<int64_t> imageAssetId4;
        if (imageAssetId4Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId4Query.value(), valueQuery_instance)) {
                imageAssetId4 = valueQuery_instance;
            }
        }
        auto imageAssetId5Query = request.query().get("imageAssetId5");
        std::optional<int64_t> imageAssetId5;
        if (imageAssetId5Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId5Query.value(), valueQuery_instance)) {
                imageAssetId5 = valueQuery_instance;
            }
        }
        auto publisherQuery = request.query().get("publisher");
        std::optional<std::string> publisher;
        if (publisherQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(publisherQuery.value(), valueQuery_instance)) {
                publisher = valueQuery_instance;
            }
        }
        auto redeemableStartQuery = request.query().get("redeemableStart");
        std::optional<int64_t> redeemableStart;
        if (redeemableStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableStartQuery.value(), valueQuery_instance)) {
                redeemableStart = valueQuery_instance;
            }
        }
        auto redeemableEndQuery = request.query().get("redeemableEnd");
        std::optional<int64_t> redeemableEnd;
        if (redeemableEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableEndQuery.value(), valueQuery_instance)) {
                redeemableEnd = valueQuery_instance;
            }
        }
        auto conditionTypeQuery = request.query().get("conditionType");
        std::optional<std::string> conditionType;
        if (conditionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionTypeQuery.value(), valueQuery_instance)) {
                conditionType = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto catalogNumbersQuery = request.query().get("catalogNumbers");
        std::optional<std::string> catalogNumbers;
        if (catalogNumbersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(catalogNumbersQuery.value(), valueQuery_instance)) {
                catalogNumbers = valueQuery_instance;
            }
        }
        auto parentalRatingQuery = request.query().get("parentalRating");
        std::optional<std::string> parentalRating;
        if (parentalRatingQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentalRatingQuery.value(), valueQuery_instance)) {
                parentalRating = valueQuery_instance;
            }
        }
        auto availabilityDateQuery = request.query().get("availabilityDate");
        std::optional<int64_t> availabilityDate;
        if (availabilityDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(availabilityDateQuery.value(), valueQuery_instance)) {
                availabilityDate = valueQuery_instance;
            }
        }
        auto mediaTypeQuery = request.query().get("mediaType");
        std::optional<std::string> mediaType;
        if (mediaTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mediaTypeQuery.value(), valueQuery_instance)) {
                mediaType = valueQuery_instance;
            }
        }
        auto durationQuery = request.query().get("duration");
        std::optional<int32_t> duration;
        if (durationQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(durationQuery.value(), valueQuery_instance)) {
                duration = valueQuery_instance;
            }
        }
        auto authorQuery = request.query().get("author");
        std::optional<std::string> author;
        if (authorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(authorQuery.value(), valueQuery_instance)) {
                author = valueQuery_instance;
            }
        }
        auto releaseDateQuery = request.query().get("releaseDate");
        std::optional<int64_t> releaseDate;
        if (releaseDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(releaseDateQuery.value(), valueQuery_instance)) {
                releaseDate = valueQuery_instance;
            }
        }
        auto collectionIdsQuery = request.query().get("collectionIds");
        std::optional<std::string> collectionIds;
        if (collectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(collectionIdsQuery.value(), valueQuery_instance)) {
                collectionIds = valueQuery_instance;
            }
        }
        auto availabilityQuery = request.query().get("availability");
        std::optional<std::string> availability;
        if (availabilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilityQuery.value(), valueQuery_instance)) {
                availability = valueQuery_instance;
            }
        }
        auto availabilitySummaryQuery = request.query().get("availabilitySummary");
        std::optional<std::string> availabilitySummary;
        if (availabilitySummaryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilitySummaryQuery.value(), valueQuery_instance)) {
                availabilitySummary = valueQuery_instance;
            }
        }
    


        try {





            this->create_media(version, accountId, title, barcodeType, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPrice, fullPrice, discountPrice, specialOfferType, offerVisibility, active, retailerLocationIds, subTitle, details, subDetails, finePrint, barcodeEntry, externalRedeemOptions, externalUrl, ticketsRewardType, ticketsReward, activated, expires, ticketPriceType, showRemaining, showRedeemed, replaced, featured, categoryIds, filterIds, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, conditionType, isbn, asin, catalogNumbers, parentalRating, availabilityDate, mediaType, duration, author, releaseDate, collectionIds, availability, availabilitySummary, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void MediaApi::delete_media_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto mediaIdQuery = request.query().get("mediaId");
        std::optional<int64_t> mediaId;
        if (mediaIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(mediaIdQuery.value(), valueQuery_instance)) {
                mediaId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_media(version, accountId, mediaId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void MediaApi::get_media_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto mediaIdQuery = request.query().get("mediaId");
        std::optional<int64_t> mediaId;
        if (mediaIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(mediaIdQuery.value(), valueQuery_instance)) {
                mediaId = valueQuery_instance;
            }
        }
    


        try {





            this->get_media(version, accountId, mediaId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void MediaApi::search_media_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_media(version, accountId, activeOnly, sortField, descending, keyword, categoryIds, filterIds, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void MediaApi::update_media_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto mediaIdQuery = request.query().get("mediaId");
        std::optional<int64_t> mediaId;
        if (mediaIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(mediaIdQuery.value(), valueQuery_instance)) {
                mediaId = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto offerLocationsQuery = request.query().get("offerLocations");
        std::optional<std::string> offerLocations;
        if (offerLocationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerLocationsQuery.value(), valueQuery_instance)) {
                offerLocations = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTitleQuery = request.query().get("subTitle");
        std::optional<std::string> subTitle;
        if (subTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTitleQuery.value(), valueQuery_instance)) {
                subTitle = valueQuery_instance;
            }
        }
        auto detailsQuery = request.query().get("details");
        std::optional<std::string> details;
        if (detailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(detailsQuery.value(), valueQuery_instance)) {
                details = valueQuery_instance;
            }
        }
        auto subDetailsQuery = request.query().get("subDetails");
        std::optional<std::string> subDetails;
        if (subDetailsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subDetailsQuery.value(), valueQuery_instance)) {
                subDetails = valueQuery_instance;
            }
        }
        auto finePrintQuery = request.query().get("finePrint");
        std::optional<std::string> finePrint;
        if (finePrintQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(finePrintQuery.value(), valueQuery_instance)) {
                finePrint = valueQuery_instance;
            }
        }
        auto barcodeTypeQuery = request.query().get("barcodeType");
        std::optional<std::string> barcodeType;
        if (barcodeTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeTypeQuery.value(), valueQuery_instance)) {
                barcodeType = valueQuery_instance;
            }
        }
        auto barcodeEntryQuery = request.query().get("barcodeEntry");
        std::optional<std::string> barcodeEntry;
        if (barcodeEntryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(barcodeEntryQuery.value(), valueQuery_instance)) {
                barcodeEntry = valueQuery_instance;
            }
        }
        auto externalRedeemOptionsQuery = request.query().get("externalRedeemOptions");
        std::optional<std::string> externalRedeemOptions;
        if (externalRedeemOptionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalRedeemOptionsQuery.value(), valueQuery_instance)) {
                externalRedeemOptions = valueQuery_instance;
            }
        }
        auto externalUrlQuery = request.query().get("externalUrl");
        std::optional<std::string> externalUrl;
        if (externalUrlQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(externalUrlQuery.value(), valueQuery_instance)) {
                externalUrl = valueQuery_instance;
            }
        }
        auto ticketsRewardTypeQuery = request.query().get("ticketsRewardType");
        std::optional<std::string> ticketsRewardType;
        if (ticketsRewardTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketsRewardTypeQuery.value(), valueQuery_instance)) {
                ticketsRewardType = valueQuery_instance;
            }
        }
        auto ticketsRewardQuery = request.query().get("ticketsReward");
        std::optional<int64_t> ticketsReward;
        if (ticketsRewardQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketsRewardQuery.value(), valueQuery_instance)) {
                ticketsReward = valueQuery_instance;
            }
        }
        auto activatedQuery = request.query().get("activated");
        std::optional<int64_t> activated;
        if (activatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(activatedQuery.value(), valueQuery_instance)) {
                activated = valueQuery_instance;
            }
        }
        auto expiresQuery = request.query().get("expires");
        std::optional<int64_t> expires;
        if (expiresQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(expiresQuery.value(), valueQuery_instance)) {
                expires = valueQuery_instance;
            }
        }
        auto noExpirationQuery = request.query().get("noExpiration");
        std::optional<bool> noExpiration;
        if (noExpirationQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(noExpirationQuery.value(), valueQuery_instance)) {
                noExpiration = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto availableLimitPerUserQuery = request.query().get("availableLimitPerUser");
        std::optional<int32_t> availableLimitPerUser;
        if (availableLimitPerUserQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitPerUserQuery.value(), valueQuery_instance)) {
                availableLimitPerUser = valueQuery_instance;
            }
        }
        auto addedLimitQuery = request.query().get("addedLimit");
        std::optional<int32_t> addedLimit;
        if (addedLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(addedLimitQuery.value(), valueQuery_instance)) {
                addedLimit = valueQuery_instance;
            }
        }
        auto viewLimitQuery = request.query().get("viewLimit");
        std::optional<int32_t> viewLimit;
        if (viewLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(viewLimitQuery.value(), valueQuery_instance)) {
                viewLimit = valueQuery_instance;
            }
        }
        auto maxPrintsQuery = request.query().get("maxPrints");
        std::optional<int32_t> maxPrints;
        if (maxPrintsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maxPrintsQuery.value(), valueQuery_instance)) {
                maxPrints = valueQuery_instance;
            }
        }
        auto ticketPriceTypeQuery = request.query().get("ticketPriceType");
        std::optional<std::string> ticketPriceType;
        if (ticketPriceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketPriceTypeQuery.value(), valueQuery_instance)) {
                ticketPriceType = valueQuery_instance;
            }
        }
        auto ticketPriceQuery = request.query().get("ticketPrice");
        std::optional<int64_t> ticketPrice;
        if (ticketPriceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketPriceQuery.value(), valueQuery_instance)) {
                ticketPrice = valueQuery_instance;
            }
        }
        auto fullPriceQuery = request.query().get("fullPrice");
        std::optional<double> fullPrice;
        if (fullPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(fullPriceQuery.value(), valueQuery_instance)) {
                fullPrice = valueQuery_instance;
            }
        }
        auto discountPriceQuery = request.query().get("discountPrice");
        std::optional<double> discountPrice;
        if (discountPriceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(discountPriceQuery.value(), valueQuery_instance)) {
                discountPrice = valueQuery_instance;
            }
        }
        auto showRemainingQuery = request.query().get("showRemaining");
        std::optional<bool> showRemaining;
        if (showRemainingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRemainingQuery.value(), valueQuery_instance)) {
                showRemaining = valueQuery_instance;
            }
        }
        auto showRedeemedQuery = request.query().get("showRedeemed");
        std::optional<bool> showRedeemed;
        if (showRedeemedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showRedeemedQuery.value(), valueQuery_instance)) {
                showRedeemed = valueQuery_instance;
            }
        }
        auto replacedQuery = request.query().get("replaced");
        std::optional<bool> replaced;
        if (replacedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(replacedQuery.value(), valueQuery_instance)) {
                replaced = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto specialOfferTypeQuery = request.query().get("specialOfferType");
        std::optional<std::string> specialOfferType;
        if (specialOfferTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(specialOfferTypeQuery.value(), valueQuery_instance)) {
                specialOfferType = valueQuery_instance;
            }
        }
        auto offerVisibilityQuery = request.query().get("offerVisibility");
        std::optional<std::string> offerVisibility;
        if (offerVisibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerVisibilityQuery.value(), valueQuery_instance)) {
                offerVisibility = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto filterIdsQuery = request.query().get("filterIds");
        std::optional<std::string> filterIds;
        if (filterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterIdsQuery.value(), valueQuery_instance)) {
                filterIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto barcodeAssetIdQuery = request.query().get("barcodeAssetId");
        std::optional<int64_t> barcodeAssetId;
        if (barcodeAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(barcodeAssetIdQuery.value(), valueQuery_instance)) {
                barcodeAssetId = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto imageAssetId1Query = request.query().get("imageAssetId1");
        std::optional<int64_t> imageAssetId1;
        if (imageAssetId1Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId1Query.value(), valueQuery_instance)) {
                imageAssetId1 = valueQuery_instance;
            }
        }
        auto imageAssetId2Query = request.query().get("imageAssetId2");
        std::optional<int64_t> imageAssetId2;
        if (imageAssetId2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId2Query.value(), valueQuery_instance)) {
                imageAssetId2 = valueQuery_instance;
            }
        }
        auto imageAssetId3Query = request.query().get("imageAssetId3");
        std::optional<int64_t> imageAssetId3;
        if (imageAssetId3Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId3Query.value(), valueQuery_instance)) {
                imageAssetId3 = valueQuery_instance;
            }
        }
        auto imageAssetId4Query = request.query().get("imageAssetId4");
        std::optional<int64_t> imageAssetId4;
        if (imageAssetId4Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId4Query.value(), valueQuery_instance)) {
                imageAssetId4 = valueQuery_instance;
            }
        }
        auto imageAssetId5Query = request.query().get("imageAssetId5");
        std::optional<int64_t> imageAssetId5;
        if (imageAssetId5Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetId5Query.value(), valueQuery_instance)) {
                imageAssetId5 = valueQuery_instance;
            }
        }
        auto publisherQuery = request.query().get("publisher");
        std::optional<std::string> publisher;
        if (publisherQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(publisherQuery.value(), valueQuery_instance)) {
                publisher = valueQuery_instance;
            }
        }
        auto redeemableStartQuery = request.query().get("redeemableStart");
        std::optional<int64_t> redeemableStart;
        if (redeemableStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableStartQuery.value(), valueQuery_instance)) {
                redeemableStart = valueQuery_instance;
            }
        }
        auto redeemableEndQuery = request.query().get("redeemableEnd");
        std::optional<int64_t> redeemableEnd;
        if (redeemableEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(redeemableEndQuery.value(), valueQuery_instance)) {
                redeemableEnd = valueQuery_instance;
            }
        }
        auto conditionTypeQuery = request.query().get("conditionType");
        std::optional<std::string> conditionType;
        if (conditionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionTypeQuery.value(), valueQuery_instance)) {
                conditionType = valueQuery_instance;
            }
        }
        auto isbnQuery = request.query().get("isbn");
        std::optional<std::string> isbn;
        if (isbnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(isbnQuery.value(), valueQuery_instance)) {
                isbn = valueQuery_instance;
            }
        }
        auto asinQuery = request.query().get("asin");
        std::optional<std::string> asin;
        if (asinQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(asinQuery.value(), valueQuery_instance)) {
                asin = valueQuery_instance;
            }
        }
        auto catalogNumbersQuery = request.query().get("catalogNumbers");
        std::optional<std::string> catalogNumbers;
        if (catalogNumbersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(catalogNumbersQuery.value(), valueQuery_instance)) {
                catalogNumbers = valueQuery_instance;
            }
        }
        auto availabilityDateQuery = request.query().get("availabilityDate");
        std::optional<int64_t> availabilityDate;
        if (availabilityDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(availabilityDateQuery.value(), valueQuery_instance)) {
                availabilityDate = valueQuery_instance;
            }
        }
        auto parentalRatingQuery = request.query().get("parentalRating");
        std::optional<std::string> parentalRating;
        if (parentalRatingQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentalRatingQuery.value(), valueQuery_instance)) {
                parentalRating = valueQuery_instance;
            }
        }
        auto mediaTypeQuery = request.query().get("mediaType");
        std::optional<std::string> mediaType;
        if (mediaTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(mediaTypeQuery.value(), valueQuery_instance)) {
                mediaType = valueQuery_instance;
            }
        }
        auto durationQuery = request.query().get("duration");
        std::optional<int32_t> duration;
        if (durationQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(durationQuery.value(), valueQuery_instance)) {
                duration = valueQuery_instance;
            }
        }
        auto authorQuery = request.query().get("author");
        std::optional<std::string> author;
        if (authorQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(authorQuery.value(), valueQuery_instance)) {
                author = valueQuery_instance;
            }
        }
        auto releaseDateQuery = request.query().get("releaseDate");
        std::optional<int64_t> releaseDate;
        if (releaseDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(releaseDateQuery.value(), valueQuery_instance)) {
                releaseDate = valueQuery_instance;
            }
        }
        auto collectionIdsQuery = request.query().get("collectionIds");
        std::optional<std::string> collectionIds;
        if (collectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(collectionIdsQuery.value(), valueQuery_instance)) {
                collectionIds = valueQuery_instance;
            }
        }
        auto availabilityQuery = request.query().get("availability");
        std::optional<std::string> availability;
        if (availabilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilityQuery.value(), valueQuery_instance)) {
                availability = valueQuery_instance;
            }
        }
        auto availabilitySummaryQuery = request.query().get("availabilitySummary");
        std::optional<std::string> availabilitySummary;
        if (availabilitySummaryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(availabilitySummaryQuery.value(), valueQuery_instance)) {
                availabilitySummary = valueQuery_instance;
            }
        }
    


        try {





            this->update_media(version, accountId, mediaId, retailerLocationIds, offerLocations, title, subTitle, details, subDetails, finePrint, barcodeType, barcodeEntry, externalRedeemOptions, externalUrl, ticketsRewardType, ticketsReward, activated, expires, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPriceType, ticketPrice, fullPrice, discountPrice, showRemaining, showRedeemed, replaced, featured, specialOfferType, offerVisibility, categoryIds, filterIds, active, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, conditionType, isbn, asin, catalogNumbers, availabilityDate, parentalRating, mediaType, duration, author, releaseDate, collectionIds, availability, availabilitySummary, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void MediaApi::media_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

