/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "OrsonApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string OrsonApi::base = "";

OrsonApi::OrsonApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void OrsonApi::init() {
    setupRoutes();
}

void OrsonApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/orson/ai/addMovie", Routes::bind(&OrsonApi::add_movie_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/docs", Routes::bind(&OrsonApi::ai_docs_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/img", Routes::bind(&OrsonApi::ai_find_images_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/tags", Routes::bind(&OrsonApi::ai_tags_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/text", Routes::bind(&OrsonApi::ai_text_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/batch", Routes::bind(&OrsonApi::batch_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/stories/episodes/instant", Routes::bind(&OrsonApi::create_instant_episode_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/voiceCanvas", Routes::bind(&OrsonApi::create_voice_canvas_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/emotion", Routes::bind(&OrsonApi::emotion_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/addMovie/:requestId", Routes::bind(&OrsonApi::get_add_movie_result_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/batch/:requestId", Routes::bind(&OrsonApi::get_batch_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/emotion/:requestId", Routes::bind(&OrsonApi::get_emotion_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/stories/episodes/:episodeId/status", Routes::bind(&OrsonApi::get_episode_status_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/stories/renders/:renderId/status", Routes::bind(&OrsonApi::get_render_status_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/stt/:requestId", Routes::bind(&OrsonApi::get_stt_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/tts/:requestId", Routes::bind(&OrsonApi::get_tts_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/techTune/:requestId", Routes::bind(&OrsonApi::get_tech_tune_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/topics/:requestId", Routes::bind(&OrsonApi::get_topics_handler, this));
    Routes::Get(*router, base + "/api/:version/orson/ai/voiceCanvas/:requestId", Routes::bind(&OrsonApi::get_voice_canvas_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/stories/renders", Routes::bind(&OrsonApi::start_video_render_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/stt", Routes::bind(&OrsonApi::stt_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/topics", Routes::bind(&OrsonApi::summarize_topics_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/techTune", Routes::bind(&OrsonApi::tech_tune_handler, this));
    Routes::Post(*router, base + "/api/:version/orson/ai/tts", Routes::bind(&OrsonApi::tts_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&OrsonApi::orson_api_default_handler, this));
}

void OrsonApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OrsonApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void OrsonApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> OrsonApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void OrsonApi::add_movie_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->add_movie(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::ai_docs_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto docQuery = request.query().get("doc");
        std::optional<std::string> doc;
        if (docQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(docQuery.value(), valueQuery_instance)) {
                doc = valueQuery_instance;
            }
        }
        auto returnTopicsQuery = request.query().get("return_topics");
        std::optional<bool> returnTopics;
        if (returnTopicsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnTopicsQuery.value(), valueQuery_instance)) {
                returnTopics = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
    


        try {





            this->ai_docs(version, accountId, doc, returnTopics, limit, offset, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::ai_find_images_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto textQuery = request.query().get("text");
        std::optional<std::string> text;
        if (textQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(textQuery.value(), valueQuery_instance)) {
                text = valueQuery_instance;
            }
        }
        auto parseFlagQuery = request.query().get("parse_flag");
        std::optional<std::string> parseFlag;
        if (parseFlagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parseFlagQuery.value(), valueQuery_instance)) {
                parseFlag = valueQuery_instance;
            }
        }
        auto fetchFlagQuery = request.query().get("fetch_flag");
        std::optional<std::string> fetchFlag;
        if (fetchFlagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(fetchFlagQuery.value(), valueQuery_instance)) {
                fetchFlag = valueQuery_instance;
            }
        }
        auto sizeQuery = request.query().get("size");
        std::optional<std::string> size;
        if (sizeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sizeQuery.value(), valueQuery_instance)) {
                size = valueQuery_instance;
            }
        }
    


        try {





            this->ai_find_images(version, accountId, text, parseFlag, fetchFlag, size, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::ai_tags_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
        auto conditionalQuery = request.query().get("conditional");
        std::optional<std::string> conditional;
        if (conditionalQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionalQuery.value(), valueQuery_instance)) {
                conditional = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
    


        try {





            this->ai_tags(version, accountId, tags, conditional, limit, offset, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::ai_text_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto termsQuery = request.query().get("terms");
        std::optional<std::string> terms;
        if (termsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(termsQuery.value(), valueQuery_instance)) {
                terms = valueQuery_instance;
            }
        }
        auto conditionalQuery = request.query().get("conditional");
        std::optional<std::string> conditional;
        if (conditionalQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conditionalQuery.value(), valueQuery_instance)) {
                conditional = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
    


        try {





            this->ai_text(version, accountId, terms, conditional, limit, offset, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->batch(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::create_instant_episode_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
    


        try {





            this->create_instant_episode(version, accountId, data, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::create_voice_canvas_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->create_voice_canvas(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::emotion_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->emotion(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_add_movie_result_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_add_movie_result(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_batch(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_emotion_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_emotion(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_episode_status_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto episodeId = request.param(":episodeId").as<int64_t>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_episode_status(version, episodeId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_render_status_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto renderId = request.param(":renderId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_render_status(version, renderId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_stt_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_stt(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_tts_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_tts(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_tech_tune_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_tech_tune(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_topics_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_topics(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::get_voice_canvas_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto requestId = request.param(":requestId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_voice_canvas(version, requestId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::start_video_render_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
    


        try {





            this->start_video_render(version, accountId, data, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::stt_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->stt(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::summarize_topics_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->summarize_topics(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::tech_tune_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->tech_tune(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void OrsonApi::tts_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto thirdPartyAccountIdQuery = request.query().get("thirdPartyAccountId");
        std::optional<std::string> thirdPartyAccountId;
        if (thirdPartyAccountIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(thirdPartyAccountIdQuery.value(), valueQuery_instance)) {
                thirdPartyAccountId = valueQuery_instance;
            }
        }
        auto textQuery = request.query().get("text");
        std::optional<std::string> text;
        if (textQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(textQuery.value(), valueQuery_instance)) {
                text = valueQuery_instance;
            }
        }
        auto languageQuery = request.query().get("language");
        std::optional<std::string> language;
        if (languageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(languageQuery.value(), valueQuery_instance)) {
                language = valueQuery_instance;
            }
        }
        auto voiceQuery = request.query().get("voice");
        std::optional<std::string> voice;
        if (voiceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(voiceQuery.value(), valueQuery_instance)) {
                voice = valueQuery_instance;
            }
        }
        auto callbackQuery = request.query().get("callback");
        std::optional<std::string> callback;
        if (callbackQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(callbackQuery.value(), valueQuery_instance)) {
                callback = valueQuery_instance;
            }
        }
    


        try {





            this->tts(version, accountId, text, thirdPartyAccountId, language, voice, callback, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void OrsonApi::orson_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

