/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "BillingInfoApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string BillingInfoApi::base = "";

BillingInfoApi::BillingInfoApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void BillingInfoApi::init() {
    setupRoutes();
}

void BillingInfoApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/billing/update", Routes::bind(&BillingInfoApi::add_payment_method_handler, this));
    Routes::Post(*router, base + "/api/:version/billing/create", Routes::bind(&BillingInfoApi::create_payment_method_handler, this));
    Routes::Post(*router, base + "/api/:version/billing/crypto/transfer", Routes::bind(&BillingInfoApi::create_smart_contract_handler, this));
    Routes::Get(*router, base + "/api/:version/billing/crypto/get", Routes::bind(&BillingInfoApi::get_crypto_balance_handler, this));
    Routes::Get(*router, base + "/api/:version/billing/get", Routes::bind(&BillingInfoApi::get_payment_method_handler, this));
    Routes::Get(*router, base + "/api/:version/billing/search", Routes::bind(&BillingInfoApi::search_payment_method_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&BillingInfoApi::billing_info_api_default_handler, this));
}

void BillingInfoApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> BillingInfoApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void BillingInfoApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> BillingInfoApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void BillingInfoApi::add_payment_method_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto paymentMethodIdQuery = request.query().get("paymentMethodId");
        std::optional<int64_t> paymentMethodId;
        if (paymentMethodIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(paymentMethodIdQuery.value(), valueQuery_instance)) {
                paymentMethodId = valueQuery_instance;
            }
        }
        auto accountNameQuery = request.query().get("accountName");
        std::optional<std::string> accountName;
        if (accountNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accountNameQuery.value(), valueQuery_instance)) {
                accountName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto addressQuery = request.query().get("address");
        std::optional<std::string> address;
        if (addressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(addressQuery.value(), valueQuery_instance)) {
                address = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto postalCodeQuery = request.query().get("postalCode");
        std::optional<std::string> postalCode;
        if (postalCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(postalCodeQuery.value(), valueQuery_instance)) {
                postalCode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto phoneQuery = request.query().get("phone");
        std::optional<std::string> phone;
        if (phoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(phoneQuery.value(), valueQuery_instance)) {
                phone = valueQuery_instance;
            }
        }
        auto creditCardNumberQuery = request.query().get("creditCardNumber");
        std::optional<std::string> creditCardNumber;
        if (creditCardNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(creditCardNumberQuery.value(), valueQuery_instance)) {
                creditCardNumber = valueQuery_instance;
            }
        }
        auto expirationDateQuery = request.query().get("expirationDate");
        std::optional<std::string> expirationDate;
        if (expirationDateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(expirationDateQuery.value(), valueQuery_instance)) {
                expirationDate = valueQuery_instance;
            }
        }
        auto ccvQuery = request.query().get("ccv");
        std::optional<std::string> ccv;
        if (ccvQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ccvQuery.value(), valueQuery_instance)) {
                ccv = valueQuery_instance;
            }
        }
        auto accountNumberQuery = request.query().get("accountNumber");
        std::optional<std::string> accountNumber;
        if (accountNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accountNumberQuery.value(), valueQuery_instance)) {
                accountNumber = valueQuery_instance;
            }
        }
        auto bankNameQuery = request.query().get("bankName");
        std::optional<std::string> bankName;
        if (bankNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bankNameQuery.value(), valueQuery_instance)) {
                bankName = valueQuery_instance;
            }
        }
        auto routingNumberQuery = request.query().get("routingNumber");
        std::optional<std::string> routingNumber;
        if (routingNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(routingNumberQuery.value(), valueQuery_instance)) {
                routingNumber = valueQuery_instance;
            }
        }
        auto defaultPaymentMethodQuery = request.query().get("defaultPaymentMethod");
        std::optional<bool> defaultPaymentMethod;
        if (defaultPaymentMethodQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(defaultPaymentMethodQuery.value(), valueQuery_instance)) {
                defaultPaymentMethod = valueQuery_instance;
            }
        }
        auto paymentMethodNicknameQuery = request.query().get("paymentMethodNickname");
        std::optional<std::string> paymentMethodNickname;
        if (paymentMethodNicknameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(paymentMethodNicknameQuery.value(), valueQuery_instance)) {
                paymentMethodNickname = valueQuery_instance;
            }
        }
        auto taxIdQuery = request.query().get("taxId");
        std::optional<std::string> taxId;
        if (taxIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(taxIdQuery.value(), valueQuery_instance)) {
                taxId = valueQuery_instance;
            }
        }
        auto providerCustomerProfileIdQuery = request.query().get("providerCustomerProfileId");
        std::optional<std::string> providerCustomerProfileId;
        if (providerCustomerProfileIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerCustomerProfileIdQuery.value(), valueQuery_instance)) {
                providerCustomerProfileId = valueQuery_instance;
            }
        }
        auto providerPaymentProfileIdQuery = request.query().get("providerPaymentProfileId");
        std::optional<std::string> providerPaymentProfileId;
        if (providerPaymentProfileIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerPaymentProfileIdQuery.value(), valueQuery_instance)) {
                providerPaymentProfileId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
    


        try {





            this->add_payment_method(version, accountId, paymentMethodId, accountName, firstName, lastName, address, city, state, postalCode, country, phone, creditCardNumber, expirationDate, ccv, accountNumber, bankName, routingNumber, defaultPaymentMethod, paymentMethodNickname, taxId, providerCustomerProfileId, providerPaymentProfileId, metaData, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void BillingInfoApi::create_payment_method_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto accountNameQuery = request.query().get("accountName");
        std::optional<std::string> accountName;
        if (accountNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accountNameQuery.value(), valueQuery_instance)) {
                accountName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto addressQuery = request.query().get("address");
        std::optional<std::string> address;
        if (addressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(addressQuery.value(), valueQuery_instance)) {
                address = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto postalCodeQuery = request.query().get("postalCode");
        std::optional<std::string> postalCode;
        if (postalCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(postalCodeQuery.value(), valueQuery_instance)) {
                postalCode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto phoneQuery = request.query().get("phone");
        std::optional<std::string> phone;
        if (phoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(phoneQuery.value(), valueQuery_instance)) {
                phone = valueQuery_instance;
            }
        }
        auto creditCardNumberQuery = request.query().get("creditCardNumber");
        std::optional<std::string> creditCardNumber;
        if (creditCardNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(creditCardNumberQuery.value(), valueQuery_instance)) {
                creditCardNumber = valueQuery_instance;
            }
        }
        auto expirationDateQuery = request.query().get("expirationDate");
        std::optional<std::string> expirationDate;
        if (expirationDateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(expirationDateQuery.value(), valueQuery_instance)) {
                expirationDate = valueQuery_instance;
            }
        }
        auto ccvQuery = request.query().get("ccv");
        std::optional<std::string> ccv;
        if (ccvQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ccvQuery.value(), valueQuery_instance)) {
                ccv = valueQuery_instance;
            }
        }
        auto accountNumberQuery = request.query().get("accountNumber");
        std::optional<std::string> accountNumber;
        if (accountNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(accountNumberQuery.value(), valueQuery_instance)) {
                accountNumber = valueQuery_instance;
            }
        }
        auto bankNameQuery = request.query().get("bankName");
        std::optional<std::string> bankName;
        if (bankNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bankNameQuery.value(), valueQuery_instance)) {
                bankName = valueQuery_instance;
            }
        }
        auto routingNumberQuery = request.query().get("routingNumber");
        std::optional<std::string> routingNumber;
        if (routingNumberQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(routingNumberQuery.value(), valueQuery_instance)) {
                routingNumber = valueQuery_instance;
            }
        }
        auto paymentMethodNicknameQuery = request.query().get("paymentMethodNickname");
        std::optional<std::string> paymentMethodNickname;
        if (paymentMethodNicknameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(paymentMethodNicknameQuery.value(), valueQuery_instance)) {
                paymentMethodNickname = valueQuery_instance;
            }
        }
        auto taxIdQuery = request.query().get("taxId");
        std::optional<std::string> taxId;
        if (taxIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(taxIdQuery.value(), valueQuery_instance)) {
                taxId = valueQuery_instance;
            }
        }
        auto defaultPaymentMethodQuery = request.query().get("defaultPaymentMethod");
        std::optional<bool> defaultPaymentMethod;
        if (defaultPaymentMethodQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(defaultPaymentMethodQuery.value(), valueQuery_instance)) {
                defaultPaymentMethod = valueQuery_instance;
            }
        }
        auto authTokenQuery = request.query().get("authToken");
        std::optional<std::string> authToken;
        if (authTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(authTokenQuery.value(), valueQuery_instance)) {
                authToken = valueQuery_instance;
            }
        }
        auto providerQuery = request.query().get("provider");
        std::optional<std::string> provider;
        if (providerQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerQuery.value(), valueQuery_instance)) {
                provider = valueQuery_instance;
            }
        }
        auto providerCustomerProfileIdQuery = request.query().get("providerCustomerProfileId");
        std::optional<std::string> providerCustomerProfileId;
        if (providerCustomerProfileIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerCustomerProfileIdQuery.value(), valueQuery_instance)) {
                providerCustomerProfileId = valueQuery_instance;
            }
        }
        auto providerPaymentProfileIdQuery = request.query().get("providerPaymentProfileId");
        std::optional<std::string> providerPaymentProfileId;
        if (providerPaymentProfileIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerPaymentProfileIdQuery.value(), valueQuery_instance)) {
                providerPaymentProfileId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
    


        try {





            this->create_payment_method(version, accountId, accountName, firstName, lastName, address, city, state, postalCode, country, phone, creditCardNumber, expirationDate, ccv, accountNumber, bankName, routingNumber, paymentMethodNickname, taxId, defaultPaymentMethod, authToken, provider, providerCustomerProfileId, providerPaymentProfileId, metaData, appKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void BillingInfoApi::create_smart_contract_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto paymentMethodIdQuery = request.query().get("paymentMethodId");
        std::optional<int64_t> paymentMethodId;
        if (paymentMethodIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(paymentMethodIdQuery.value(), valueQuery_instance)) {
                paymentMethodId = valueQuery_instance;
            }
        }
        auto tokenNameQuery = request.query().get("tokenName");
        std::optional<std::string> tokenName;
        if (tokenNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenNameQuery.value(), valueQuery_instance)) {
                tokenName = valueQuery_instance;
            }
        }
        auto tokenSymbolQuery = request.query().get("tokenSymbol");
        std::optional<std::string> tokenSymbol;
        if (tokenSymbolQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenSymbolQuery.value(), valueQuery_instance)) {
                tokenSymbol = valueQuery_instance;
            }
        }
    


        try {





            this->create_smart_contract(version, accountId, tokenName, tokenSymbol, paymentMethodId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void BillingInfoApi::get_crypto_balance_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto ownerAccountIdQuery = request.query().get("ownerAccountId");
        std::optional<int64_t> ownerAccountId;
        if (ownerAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ownerAccountIdQuery.value(), valueQuery_instance)) {
                ownerAccountId = valueQuery_instance;
            }
        }
        auto paymentMethodIdQuery = request.query().get("paymentMethodId");
        std::optional<int64_t> paymentMethodId;
        if (paymentMethodIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(paymentMethodIdQuery.value(), valueQuery_instance)) {
                paymentMethodId = valueQuery_instance;
            }
        }
    


        try {





            this->get_crypto_balance(version, accountId, ownerAccountId, paymentMethodId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void BillingInfoApi::get_payment_method_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto paymentMethodIdQuery = request.query().get("paymentMethodId");
        std::optional<int64_t> paymentMethodId;
        if (paymentMethodIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(paymentMethodIdQuery.value(), valueQuery_instance)) {
                paymentMethodId = valueQuery_instance;
            }
        }
        auto getCurrentBalanceQuery = request.query().get("getCurrentBalance");
        std::optional<bool> getCurrentBalance;
        if (getCurrentBalanceQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(getCurrentBalanceQuery.value(), valueQuery_instance)) {
                getCurrentBalance = valueQuery_instance;
            }
        }
    


        try {





            this->get_payment_method(version, accountId, paymentMethodId, getCurrentBalance, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void BillingInfoApi::search_payment_method_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto providerQuery = request.query().get("provider");
        std::optional<std::string> provider;
        if (providerQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(providerQuery.value(), valueQuery_instance)) {
                provider = valueQuery_instance;
            }
        }
        auto typeQuery = request.query().get("type");
        std::optional<std::string> type;
        if (typeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(typeQuery.value(), valueQuery_instance)) {
                type = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_payment_method(version, accountId, provider, type, keyword, sortField, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void BillingInfoApi::billing_info_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

