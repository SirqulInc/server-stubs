/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
/*
 * TrackingApi.h
 *
 * 
 */

#ifndef TrackingApi_H_
#define TrackingApi_H_


#include "ApiBase.h"

#include <pistache/http.h>
#include <pistache/router.h>
#include <pistache/http_headers.h>

#include <optional>
#include <utility>

#include "AccountMiniResponse.h"
#include "Leg.h"
#include "LegResponse.h"
#include "PredictedLocationResponse.h"
#include "PreferredLocationResponse.h"
#include "SirqulResponse.h"
#include "StepResponse.h"
#include <string>
#include <vector>

namespace org::openapitools::server::api
{

class  TrackingApi : public ApiBase {
public:
    explicit TrackingApi(const std::shared_ptr<Pistache::Rest::Router>& rtr);
    ~TrackingApi() override = default;
    void init() override;

    static const std::string base;

private:
    void setupRoutes();

    void batch_save_tracking_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_predicted_locations_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_predicted_path_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_preferred_locations_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_tracking_legs_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void save_tracking_leg_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void save_tracking_step_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void search_accounts_with_tracking_legs_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void search_tracking_legs_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void tracking_api_default_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);

    /// <summary>
    /// Helper function to handle unexpected Exceptions during Parameter parsing and validation.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual void handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during Parameter parsing and validation.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual std::pair<Pistache::Http::Code, std::string> handleParsingException(const std::exception& ex) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during processing of the request in handler functions.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual void handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during processing of the request in handler functions.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual std::pair<Pistache::Http::Code, std::string> handleOperationException(const std::exception& ex) const noexcept;

    /// <summary>
    /// Create Batch Tracking
    /// </summary>
    /// <remarks>
    /// Batch create tracking legs
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="data">JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; </param>
    /// <param name="deviceId">the device id (deviceId or accountId required) (optional, default to &quot;&quot;)</param>
    /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional, default to 0L)</param>
    /// <param name="generateAccounts">Whether to generate accounts for tracking entries when the owner does not exist (optional, default to false)</param>
    /// <param name="updateAccountLocations">Whether to update the account&#39;s current location from the incoming tracking data (optional, default to false)</param>
    /// <param name="defaultTag">The default tag to apply to incoming legs when no tag is provided (optional, default to &quot;PASSIVE&quot;)</param>
    /// <param name="slaveUID"> (optional, default to &quot;&quot;)</param>
    virtual void batch_save_tracking( const double &version, const std::optional<std::string> &data, const std::optional<std::string> &deviceId, const std::optional<int64_t> &accountId, const std::optional<bool> &generateAccounts, const std::optional<bool> &updateAccountLocations, const std::optional<std::string> &defaultTag, const std::optional<std::string> &slaveUID, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Get Predicted Locations
    /// </summary>
    /// <remarks>
    /// Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the customer</param>
    /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional, default to 0.0)</param>
    /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional, default to 0.0)</param>
    /// <param name="dateCheck">Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional, default to 0L)</param>
    /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="threshold">The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1L)</param>
    /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to &quot;MILES&quot;)</param>
    /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)</param>
    /// <param name="sortOrder">The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to &quot;MATCHES&quot;)</param>
    virtual void get_predicted_locations( const double &version, const std::optional<int64_t> &accountId, const std::optional<double> &latitude, const std::optional<double> &longitude, const std::optional<int64_t> &dateCheck, const std::optional<std::string> &hourCheck, const std::optional<int64_t> &threshold, const std::optional<std::string> &distanceUnit, const std::optional<double> &searchRange, const std::optional<std::string> &sortOrder, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Get Tracking Path
    /// </summary>
    /// <remarks>
    /// Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the customer</param>
    /// <param name="startStepId">The stepId to begin from</param>
    /// <param name="endStepId">The stepId to end with</param>
    virtual void get_predicted_path( const double &version, const std::optional<int64_t> &accountId, const std::optional<int64_t> &startStepId, const std::optional<int64_t> &endStepId, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Search Preferred Locations
    /// </summary>
    /// <remarks>
    /// Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the customer</param>
    /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional, default to 0.0)</param>
    /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional, default to 0.0)</param>
    /// <param name="dateCheck">Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional, default to 0L)</param>
    /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="sortField">Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to &quot;PREFERRED_DATE&quot;)</param>
    /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
    /// <param name="start">The start index for pagination (optional, default to 0)</param>
    /// <param name="limit">The limit for pagination (optional, default to 20)</param>
    /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)</param>
    /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to &quot;MILES&quot;)</param>
    virtual void get_preferred_locations( const double &version, const std::optional<int64_t> &accountId, const std::optional<double> &latitude, const std::optional<double> &longitude, const std::optional<int64_t> &dateCheck, const std::optional<std::string> &hourCheck, const std::optional<std::string> &sortField, const std::optional<bool> &descending, const std::optional<int32_t> &start, const std::optional<int32_t> &limit, const std::optional<double> &searchRange, const std::optional<std::string> &distanceUnit, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Search Tracking
    /// </summary>
    /// <remarks>
    /// Retrieve tracking data to be able to show where a user has been.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="deviceId">the device id (deviceId or accountId required) (optional, default to &quot;&quot;)</param>
    /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional, default to 0L)</param>
    /// <param name="ownerId">the account id of the person the user wants to tracking data for (optional, default to 0L)</param>
    /// <param name="trackingDeviceId">the id of the tracking device (optional, default to &quot;&quot;)</param>
    /// <param name="startDate">the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional, default to 0L)</param>
    /// <param name="endDate">the end date in (UTC milliseconds) to filter the tracking results (optional, default to 0L)</param>
    /// <param name="tags">filter results by tag (optional, default to &quot;&quot;)</param>
    /// <param name="getLastPoint">gets the last known location of the user (optional, default to false)</param>
    virtual void get_tracking_legs( const double &version, const std::optional<std::string> &deviceId, const std::optional<int64_t> &accountId, const std::optional<int64_t> &ownerId, const std::optional<std::string> &trackingDeviceId, const std::optional<int64_t> &startDate, const std::optional<int64_t> &endDate, const std::optional<std::string> &tags, const std::optional<bool> &getLastPoint, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Create Tracking Leg
    /// </summary>
    /// <remarks>
    /// Send tracking points to be able to generate pathing data
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="startLat">the latitude of the first point</param>
    /// <param name="startLng">the longitude of the first point</param>
    /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
    /// <param name="endLat">the latitude of the last point</param>
    /// <param name="endLng">the longitude of the last point</param>
    /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
    /// <param name="deviceId">the device id (deviceId or accountId required) (optional, default to &quot;&quot;)</param>
    /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional, default to 0L)</param>
    /// <param name="distance">the total distance (optional, default to 0.0)</param>
    /// <param name="duration">the total duration (optional, default to 0L)</param>
    /// <param name="steps">JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional, default to &quot;&quot;)</param>
    /// <param name="tags">name the leg for searching (optional, default to &quot;&quot;)</param>
    virtual void save_tracking_leg( const double &version, const std::optional<double> &startLat, const std::optional<double> &startLng, const std::optional<int64_t> &startDate, const std::optional<double> &endLat, const std::optional<double> &endLng, const std::optional<int64_t> &endDate, const std::optional<std::string> &deviceId, const std::optional<int64_t> &accountId, const std::optional<double> &distance, const std::optional<int64_t> &duration, const std::optional<std::string> &steps, const std::optional<std::string> &tags, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Create Tracking Step
    /// </summary>
    /// <remarks>
    /// Send tracking points to be able to generate pathing data
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="legId">the leg to add the step to</param>
    /// <param name="startLat">the latitude of the first point</param>
    /// <param name="startLng">the longitude of the first point</param>
    /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
    /// <param name="endLat">the latitude of the last point</param>
    /// <param name="endLng">the longitude of the last point</param>
    /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
    /// <param name="deviceId">the device id (deviceId or accountId required) (optional, default to &quot;&quot;)</param>
    /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional, default to 0L)</param>
    /// <param name="distance">the total distance (optional, default to 0.0)</param>
    /// <param name="duration">the total duration (optional, default to 0L)</param>
    virtual void save_tracking_step( const double &version, const std::optional<int64_t> &legId, const std::optional<double> &startLat, const std::optional<double> &startLng, const std::optional<int64_t> &startDate, const std::optional<double> &endLat, const std::optional<double> &endLng, const std::optional<int64_t> &endDate, const std::optional<std::string> &deviceId, const std::optional<int64_t> &accountId, const std::optional<double> &distance, const std::optional<int64_t> &duration, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// List Tracking
    /// </summary>
    /// <remarks>
    /// Search for all accounts that have tracking legs data by the given constraints.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the user</param>
    /// <param name="keyword">Used for LIKE search of first or last name on the acocunt (optional, default to &quot;&quot;)</param>
    /// <param name="startDate">Range to begin in UTC milliseconds (optional, default to 0L)</param>
    /// <param name="endDate">Range to end in UTC milliseconds (optional, default to 0L)</param>
    /// <param name="tags">Exact match on tag field of Legs&#39;s searchTag (optional, default to &quot;&quot;)</param>
    /// <param name="audienceIds"> (optional, default to &quot;&quot;)</param>
    /// <param name="latitude">Origin latitude to perform searching constraints with given range (optional, default to 0.0)</param>
    /// <param name="longitude">Origin longitude to perform searching constraints with given range (optional, default to 0.0)</param>
    /// <param name="range">The radius, in miles, to perform the search for (optional, default to 5)</param>
    /// <param name="sortField">The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to &quot;LEG_START_DATE&quot;)</param>
    /// <param name="descending">The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)</param>
    /// <param name="start">The index into the record set to start with. Default is 0. (optional, default to 0)</param>
    /// <param name="limit">The total number of records to return. Default is 20. (optional, default to 20)</param>
    /// <param name="activeOnly">Determines whether to return only active results. Default is false. (optional, default to false)</param>
    virtual void search_accounts_with_tracking_legs( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &keyword, const std::optional<int64_t> &startDate, const std::optional<int64_t> &endDate, const std::optional<std::string> &tags, const std::optional<std::string> &audienceIds, const std::optional<double> &latitude, const std::optional<double> &longitude, const std::optional<double> &range, const std::optional<std::string> &sortField, const std::optional<bool> &descending, const std::optional<int32_t> &start, const std::optional<int32_t> &limit, const std::optional<bool> &activeOnly, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Search Tracking (Billable)
    /// </summary>
    /// <remarks>
    /// Retrieve tracking data for billable/account scoped queries.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id to search tracking for</param>
    /// <param name="appKey">The application key</param>
    /// <param name="trackingDeviceId">The id of the tracking device (optional, default to &quot;&quot;)</param>
    /// <param name="startDate">The start date in (UTC milliseconds) to filter the tracking results (optional, default to 0L)</param>
    /// <param name="endDate">The end date in (UTC milliseconds) to filter the tracking results (optional, default to 0L)</param>
    /// <param name="tags">Filter results by tag (optional, default to &quot;&quot;)</param>
    /// <param name="start">The start index for pagination (optional, default to 0)</param>
    /// <param name="limit">The limit for pagination (optional, default to 100)</param>
    virtual void search_tracking_legs( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &trackingDeviceId, const std::optional<int64_t> &startDate, const std::optional<int64_t> &endDate, const std::optional<std::string> &tags, const std::optional<int32_t> &start, const std::optional<int32_t> &limit, Pistache::Http::ResponseWriter &response) = 0;

};

} // namespace org::openapitools::server::api

#endif /* TrackingApi_H_ */

