/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "RankingApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string RankingApi::base = "";

RankingApi::RankingApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void RankingApi::init() {
    setupRoutes();
}

void RankingApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/api/:version/ranking/historical/search", Routes::bind(&RankingApi::get_historical_rankings_handler, this));
    Routes::Get(*router, base + "/api/:version/ranking/search", Routes::bind(&RankingApi::get_rankings_handler, this));
    Routes::Post(*router, base + "/api/:version/ranking/personal/ranks", Routes::bind(&RankingApi::get_user_rank_handler, this));
    Routes::Post(*router, base + "/api/:version/ranking/override", Routes::bind(&RankingApi::override_user_rank_handler, this));
    Routes::Post(*router, base + "/api/:version/ranking/update", Routes::bind(&RankingApi::update_rankings_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&RankingApi::ranking_api_default_handler, this));
}

void RankingApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RankingApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void RankingApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RankingApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void RankingApi::get_historical_rankings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_historical_rankings(version, appKey, rankType, startDate, endDate, deviceId, accountId, sortField, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RankingApi::get_rankings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto leaderboardModeQuery = request.query().get("leaderboardMode");
        std::optional<std::string> leaderboardMode;
        if (leaderboardModeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(leaderboardModeQuery.value(), valueQuery_instance)) {
                leaderboardMode = valueQuery_instance;
            }
        }
        auto withinAccountIdsQuery = request.query().get("withinAccountIds");
        std::optional<std::string> withinAccountIds;
        if (withinAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(withinAccountIdsQuery.value(), valueQuery_instance)) {
                withinAccountIds = valueQuery_instance;
            }
        }
        auto returnUserRankQuery = request.query().get("returnUserRank");
        std::optional<bool> returnUserRank;
        if (returnUserRankQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnUserRankQuery.value(), valueQuery_instance)) {
                returnUserRank = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_rankings(version, deviceId, accountId, gameType, appKey, q, keyword, rankType, leaderboardMode, withinAccountIds, returnUserRank, albumId, audienceId, sortField, descending, i, start, l, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RankingApi::get_user_rank_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto returnUserRankQuery = request.query().get("returnUserRank");
        std::optional<bool> returnUserRank;
        if (returnUserRankQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnUserRankQuery.value(), valueQuery_instance)) {
                returnUserRank = valueQuery_instance;
            }
        }
        auto leaderboardModeQuery = request.query().get("leaderboardMode");
        std::optional<std::string> leaderboardMode;
        if (leaderboardModeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(leaderboardModeQuery.value(), valueQuery_instance)) {
                leaderboardMode = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_rank(version, deviceId, accountId, appKey, rankType, returnUserRank, leaderboardMode, sortField, keyword, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RankingApi::override_user_rank_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto ownerAccountIdQuery = request.query().get("ownerAccountId");
        std::optional<int64_t> ownerAccountId;
        if (ownerAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ownerAccountIdQuery.value(), valueQuery_instance)) {
                ownerAccountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto totalScoreQuery = request.query().get("totalScore");
        std::optional<int64_t> totalScore;
        if (totalScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(totalScoreQuery.value(), valueQuery_instance)) {
                totalScore = valueQuery_instance;
            }
        }
        auto totalCountQuery = request.query().get("totalCount");
        std::optional<int64_t> totalCount;
        if (totalCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(totalCountQuery.value(), valueQuery_instance)) {
                totalCount = valueQuery_instance;
            }
        }
        auto totalTimeQuery = request.query().get("totalTime");
        std::optional<int64_t> totalTime;
        if (totalTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(totalTimeQuery.value(), valueQuery_instance)) {
                totalTime = valueQuery_instance;
            }
        }
        auto dailyScoreQuery = request.query().get("dailyScore");
        std::optional<int64_t> dailyScore;
        if (dailyScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(dailyScoreQuery.value(), valueQuery_instance)) {
                dailyScore = valueQuery_instance;
            }
        }
        auto dailyCountQuery = request.query().get("dailyCount");
        std::optional<int64_t> dailyCount;
        if (dailyCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(dailyCountQuery.value(), valueQuery_instance)) {
                dailyCount = valueQuery_instance;
            }
        }
        auto dailyTimeQuery = request.query().get("dailyTime");
        std::optional<int64_t> dailyTime;
        if (dailyTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(dailyTimeQuery.value(), valueQuery_instance)) {
                dailyTime = valueQuery_instance;
            }
        }
        auto weeklyScoreQuery = request.query().get("weeklyScore");
        std::optional<int64_t> weeklyScore;
        if (weeklyScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(weeklyScoreQuery.value(), valueQuery_instance)) {
                weeklyScore = valueQuery_instance;
            }
        }
        auto weeklyCountQuery = request.query().get("weeklyCount");
        std::optional<int64_t> weeklyCount;
        if (weeklyCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(weeklyCountQuery.value(), valueQuery_instance)) {
                weeklyCount = valueQuery_instance;
            }
        }
        auto weeklyTimeQuery = request.query().get("weeklyTime");
        std::optional<int64_t> weeklyTime;
        if (weeklyTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(weeklyTimeQuery.value(), valueQuery_instance)) {
                weeklyTime = valueQuery_instance;
            }
        }
        auto monthlyScoreQuery = request.query().get("monthlyScore");
        std::optional<int64_t> monthlyScore;
        if (monthlyScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(monthlyScoreQuery.value(), valueQuery_instance)) {
                monthlyScore = valueQuery_instance;
            }
        }
        auto monthlyCountQuery = request.query().get("monthlyCount");
        std::optional<int64_t> monthlyCount;
        if (monthlyCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(monthlyCountQuery.value(), valueQuery_instance)) {
                monthlyCount = valueQuery_instance;
            }
        }
        auto monthlyTimeQuery = request.query().get("monthlyTime");
        std::optional<int64_t> monthlyTime;
        if (monthlyTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(monthlyTimeQuery.value(), valueQuery_instance)) {
                monthlyTime = valueQuery_instance;
            }
        }
        auto topScoreQuery = request.query().get("topScore");
        std::optional<int64_t> topScore;
        if (topScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(topScoreQuery.value(), valueQuery_instance)) {
                topScore = valueQuery_instance;
            }
        }
        auto lowestScoreQuery = request.query().get("lowestScore");
        std::optional<int64_t> lowestScore;
        if (lowestScoreQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(lowestScoreQuery.value(), valueQuery_instance)) {
                lowestScore = valueQuery_instance;
            }
        }
        auto streakCountQuery = request.query().get("streakCount");
        std::optional<int64_t> streakCount;
        if (streakCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(streakCountQuery.value(), valueQuery_instance)) {
                streakCount = valueQuery_instance;
            }
        }
        auto streakBestCountQuery = request.query().get("streakBestCount");
        std::optional<int64_t> streakBestCount;
        if (streakBestCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(streakBestCountQuery.value(), valueQuery_instance)) {
                streakBestCount = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
    


        try {





            this->override_user_rank(version, accountId, ownerAccountId, appKey, rankType, totalScore, totalCount, totalTime, dailyScore, dailyCount, dailyTime, weeklyScore, weeklyCount, weeklyTime, monthlyScore, monthlyCount, monthlyTime, topScore, lowestScore, streakCount, streakBestCount, startDate, endDate, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RankingApi::update_rankings_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto rankTypeQuery = request.query().get("rankType");
        std::optional<std::string> rankType;
        if (rankTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(rankTypeQuery.value(), valueQuery_instance)) {
                rankType = valueQuery_instance;
            }
        }
        auto incrementQuery = request.query().get("increment");
        std::optional<int64_t> increment;
        if (incrementQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(incrementQuery.value(), valueQuery_instance)) {
                increment = valueQuery_instance;
            }
        }
        auto timeIncrementQuery = request.query().get("timeIncrement");
        std::optional<int64_t> timeIncrement;
        if (timeIncrementQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(timeIncrementQuery.value(), valueQuery_instance)) {
                timeIncrement = valueQuery_instance;
            }
        }
        auto tagQuery = request.query().get("tag");
        std::optional<std::string> tag;
        if (tagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagQuery.value(), valueQuery_instance)) {
                tag = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto updateGlobalQuery = request.query().get("updateGlobal");
        std::optional<bool> updateGlobal;
        if (updateGlobalQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updateGlobalQuery.value(), valueQuery_instance)) {
                updateGlobal = valueQuery_instance;
            }
        }
        auto createLeaderboardQuery = request.query().get("createLeaderboard");
        std::optional<bool> createLeaderboard;
        if (createLeaderboardQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(createLeaderboardQuery.value(), valueQuery_instance)) {
                createLeaderboard = valueQuery_instance;
            }
        }
    


        try {





            this->update_rankings(version, accountId, appKey, rankType, increment, timeIncrement, tag, startDate, endDate, updateGlobal, createLeaderboard, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void RankingApi::ranking_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

