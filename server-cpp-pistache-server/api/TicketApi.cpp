/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "TicketApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string TicketApi::base = "";

TicketApi::TicketApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void TicketApi::init() {
    setupRoutes();
}

void TicketApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/api/:version/ticket/count", Routes::bind(&TicketApi::get_ticket_count_handler, this));
    Routes::Get(*router, base + "/api/:version/ticket/getList", Routes::bind(&TicketApi::get_ticket_list_handler, this));
    Routes::Post(*router, base + "/api/:version/purchase/gift", Routes::bind(&TicketApi::gift_purchase_handler, this));
    Routes::Post(*router, base + "/api/:version/ticket/save", Routes::bind(&TicketApi::save_ticket_handler, this));
    Routes::Post(*router, base + "/api/:version/ticket/save/fileUpload", Routes::bind(&TicketApi::save_ticket_via_file_upload_handler, this));
    Routes::Get(*router, base + "/api/:version/ticket/ticketoffers", Routes::bind(&TicketApi::ticket_offers_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&TicketApi::ticket_api_default_handler, this));
}

void TicketApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> TicketApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void TicketApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> TicketApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void TicketApi::get_ticket_count_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto ticketTypeQuery = request.query().get("ticketType");
        std::optional<std::string> ticketType;
        if (ticketTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketTypeQuery.value(), valueQuery_instance)) {
                ticketType = valueQuery_instance;
            }
        }
    


        try {





            this->get_ticket_count(version, deviceId, accountId, gameType, appKey, ticketType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TicketApi::get_ticket_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto ticketObjectTypeQuery = request.query().get("ticketObjectType");
        std::optional<std::string> ticketObjectType;
        if (ticketObjectTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketObjectTypeQuery.value(), valueQuery_instance)) {
                ticketObjectType = valueQuery_instance;
            }
        }
        auto actionTypeQuery = request.query().get("actionType");
        std::optional<std::string> actionType;
        if (actionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionTypeQuery.value(), valueQuery_instance)) {
                actionType = valueQuery_instance;
            }
        }
        auto ticketIdsQuery = request.query().get("ticketIds");
        std::optional<std::string> ticketIds;
        if (ticketIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketIdsQuery.value(), valueQuery_instance)) {
                ticketIds = valueQuery_instance;
            }
        }
        auto objectIdsQuery = request.query().get("objectIds");
        std::optional<std::string> objectIds;
        if (objectIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectIdsQuery.value(), valueQuery_instance)) {
                objectIds = valueQuery_instance;
            }
        }
        auto receiptTokensQuery = request.query().get("receiptTokens");
        std::optional<std::string> receiptTokens;
        if (receiptTokensQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(receiptTokensQuery.value(), valueQuery_instance)) {
                receiptTokens = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
    


        try {





            this->get_ticket_list(version, deviceId, accountId, ticketObjectType, actionType, ticketIds, objectIds, receiptTokens, gameType, appKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TicketApi::gift_purchase_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto receiverAccountIdQuery = request.query().get("receiverAccountId");
        std::optional<int64_t> receiverAccountId;
        if (receiverAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(receiverAccountIdQuery.value(), valueQuery_instance)) {
                receiverAccountId = valueQuery_instance;
            }
        }
        auto ticketIdQuery = request.query().get("ticketId");
        std::optional<int64_t> ticketId;
        if (ticketIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketIdQuery.value(), valueQuery_instance)) {
                ticketId = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto customMessageQuery = request.query().get("customMessage");
        std::optional<std::string> customMessage;
        if (customMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessageQuery.value(), valueQuery_instance)) {
                customMessage = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
    


        try {





            this->gift_purchase(version, receiverAccountId, ticketId, deviceId, accountId, assetId, customMessage, gameType, appKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TicketApi::save_ticket_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto actionTypeQuery = request.query().get("actionType");
        std::optional<std::string> actionType;
        if (actionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionTypeQuery.value(), valueQuery_instance)) {
                actionType = valueQuery_instance;
            }
        }
        auto ticketObjectTypeQuery = request.query().get("ticketObjectType");
        std::optional<std::string> ticketObjectType;
        if (ticketObjectTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketObjectTypeQuery.value(), valueQuery_instance)) {
                ticketObjectType = valueQuery_instance;
            }
        }
        auto objectIdQuery = request.query().get("objectId");
        std::optional<int64_t> objectId;
        if (objectIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(objectIdQuery.value(), valueQuery_instance)) {
                objectId = valueQuery_instance;
            }
        }
        auto purchaseCodeQuery = request.query().get("purchaseCode");
        std::optional<std::string> purchaseCode;
        if (purchaseCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(purchaseCodeQuery.value(), valueQuery_instance)) {
                purchaseCode = valueQuery_instance;
            }
        }
        auto receiptTokenQuery = request.query().get("receiptToken");
        std::optional<std::string> receiptToken;
        if (receiptTokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(receiptTokenQuery.value(), valueQuery_instance)) {
                receiptToken = valueQuery_instance;
            }
        }
        auto receiptDataQuery = request.query().get("receiptData");
        std::optional<std::string> receiptData;
        if (receiptDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(receiptDataQuery.value(), valueQuery_instance)) {
                receiptData = valueQuery_instance;
            }
        }
        auto countQuery = request.query().get("count");
        std::optional<int64_t> count;
        if (countQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(countQuery.value(), valueQuery_instance)) {
                count = valueQuery_instance;
            }
        }
        auto ticketTypeQuery = request.query().get("ticketType");
        std::optional<std::string> ticketType;
        if (ticketTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketTypeQuery.value(), valueQuery_instance)) {
                ticketType = valueQuery_instance;
            }
        }
        auto purchaseProviderQuery = request.query().get("purchaseProvider");
        std::optional<std::string> purchaseProvider;
        if (purchaseProviderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(purchaseProviderQuery.value(), valueQuery_instance)) {
                purchaseProvider = valueQuery_instance;
            }
        }
        auto purchaseTypeQuery = request.query().get("purchaseType");
        std::optional<std::string> purchaseType;
        if (purchaseTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(purchaseTypeQuery.value(), valueQuery_instance)) {
                purchaseType = valueQuery_instance;
            }
        }
        auto returnProfileResponseQuery = request.query().get("returnProfileResponse");
        std::optional<bool> returnProfileResponse;
        if (returnProfileResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnProfileResponseQuery.value(), valueQuery_instance)) {
                returnProfileResponse = valueQuery_instance;
            }
        }
        auto includeProfileResponseQuery = request.query().get("includeProfileResponse");
        std::optional<bool> includeProfileResponse;
        if (includeProfileResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeProfileResponseQuery.value(), valueQuery_instance)) {
                includeProfileResponse = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
    


        try {





            this->save_ticket(version, actionType, ticketObjectType, returnNulls, deviceId, accountId, gameType, appKey, objectId, purchaseCode, receiptToken, receiptData, count, ticketType, purchaseProvider, purchaseType, returnProfileResponse, includeProfileResponse, appVersion, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TicketApi::save_ticket_via_file_upload_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->save_ticket_via_file_upload(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TicketApi::ticket_offers_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
    


        try {





            this->ticket_offers(version, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void TicketApi::ticket_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

