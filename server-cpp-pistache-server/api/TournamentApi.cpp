/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "TournamentApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string TournamentApi::base = "";

TournamentApi::TournamentApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void TournamentApi::init() {
    setupRoutes();
}

void TournamentApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/tournament/create", Routes::bind(&TournamentApi::create_tournament_handler, this));
    Routes::Post(*router, base + "/api/:version/tournament/delete", Routes::bind(&TournamentApi::delete_tournament_handler, this));
    Routes::Get(*router, base + "/api/:version/tournament/get", Routes::bind(&TournamentApi::get_tournament_handler, this));
    Routes::Get(*router, base + "/api/:version/tournament/object/search", Routes::bind(&TournamentApi::search_objects_handler, this));
    Routes::Get(*router, base + "/api/:version/tournament/round/search", Routes::bind(&TournamentApi::search_rounds_handler, this));
    Routes::Get(*router, base + "/api/:version/tournament/search", Routes::bind(&TournamentApi::search_tournaments_handler, this));
    Routes::Post(*router, base + "/api/:version/tournament/score", Routes::bind(&TournamentApi::submit_tournament_score_handler, this));
    Routes::Post(*router, base + "/api/:version/tournament/vote", Routes::bind(&TournamentApi::submit_tournament_vote_handler, this));
    Routes::Post(*router, base + "/api/:version/tournament/substitute", Routes::bind(&TournamentApi::substitute_tournament_player_handler, this));
    Routes::Post(*router, base + "/api/:version/tournament/update", Routes::bind(&TournamentApi::update_tournament_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&TournamentApi::tournament_api_default_handler, this));
}

void TournamentApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> TournamentApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void TournamentApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> TournamentApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void TournamentApi::create_tournament_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTypeQuery = request.query().get("subType");
        std::optional<std::string> subType;
        if (subTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTypeQuery.value(), valueQuery_instance)) {
                subType = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto secondsBetweenLevelsQuery = request.query().get("secondsBetweenLevels");
        std::optional<int32_t> secondsBetweenLevels;
        if (secondsBetweenLevelsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsBetweenLevelsQuery.value(), valueQuery_instance)) {
                secondsBetweenLevels = valueQuery_instance;
            }
        }
        auto secondsForTieBreakerQuery = request.query().get("secondsForTieBreaker");
        std::optional<int32_t> secondsForTieBreaker;
        if (secondsForTieBreakerQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsForTieBreakerQuery.value(), valueQuery_instance)) {
                secondsForTieBreaker = valueQuery_instance;
            }
        }
        auto secondsBetweenPacksQuery = request.query().get("secondsBetweenPacks");
        std::optional<int32_t> secondsBetweenPacks;
        if (secondsBetweenPacksQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsBetweenPacksQuery.value(), valueQuery_instance)) {
                secondsBetweenPacks = valueQuery_instance;
            }
        }
        auto maximumLevelLengthQuery = request.query().get("maximumLevelLength");
        std::optional<int32_t> maximumLevelLength;
        if (maximumLevelLengthQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maximumLevelLengthQuery.value(), valueQuery_instance)) {
                maximumLevelLength = valueQuery_instance;
            }
        }
        auto costToPlayQuery = request.query().get("costToPlay");
        std::optional<int32_t> costToPlay;
        if (costToPlayQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(costToPlayQuery.value(), valueQuery_instance)) {
                costToPlay = valueQuery_instance;
            }
        }
        auto costToPlayTypeQuery = request.query().get("costToPlayType");
        std::optional<std::string> costToPlayType;
        if (costToPlayTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(costToPlayTypeQuery.value(), valueQuery_instance)) {
                costToPlayType = valueQuery_instance;
            }
        }
        auto minimumToPlayQuery = request.query().get("minimumToPlay");
        std::optional<int32_t> minimumToPlay;
        if (minimumToPlayQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minimumToPlayQuery.value(), valueQuery_instance)) {
                minimumToPlay = valueQuery_instance;
            }
        }
        auto startingLimitQuery = request.query().get("startingLimit");
        std::optional<int32_t> startingLimit;
        if (startingLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startingLimitQuery.value(), valueQuery_instance)) {
                startingLimit = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto enableBuyBackQuery = request.query().get("enableBuyBack");
        std::optional<bool> enableBuyBack;
        if (enableBuyBackQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableBuyBackQuery.value(), valueQuery_instance)) {
                enableBuyBack = valueQuery_instance;
            }
        }
        auto offerIdsQuery = request.query().get("offerIds");
        std::optional<std::string> offerIds;
        if (offerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerIdsQuery.value(), valueQuery_instance)) {
                offerIds = valueQuery_instance;
            }
        }
        auto offerAssetIdQuery = request.query().get("offerAssetId");
        std::optional<int64_t> offerAssetId;
        if (offerAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerAssetIdQuery.value(), valueQuery_instance)) {
                offerAssetId = valueQuery_instance;
            }
        }
        auto fixedRewardQuery = request.query().get("fixedReward");
        std::optional<bool> fixedReward;
        if (fixedRewardQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(fixedRewardQuery.value(), valueQuery_instance)) {
                fixedReward = valueQuery_instance;
            }
        }
        auto splitRewardQuery = request.query().get("splitReward");
        std::optional<std::string> splitReward;
        if (splitRewardQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(splitRewardQuery.value(), valueQuery_instance)) {
                splitReward = valueQuery_instance;
            }
        }
        auto allocateTicketsQuery = request.query().get("allocateTickets");
        std::optional<bool> allocateTickets;
        if (allocateTicketsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(allocateTicketsQuery.value(), valueQuery_instance)) {
                allocateTickets = valueQuery_instance;
            }
        }
        auto tournamentDataQuery = request.query().get("tournamentData");
        std::optional<std::string> tournamentData;
        if (tournamentDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tournamentDataQuery.value(), valueQuery_instance)) {
                tournamentData = valueQuery_instance;
            }
        }
        auto missionTypeQuery = request.query().get("missionType");
        std::optional<std::string> missionType;
        if (missionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(missionTypeQuery.value(), valueQuery_instance)) {
                missionType = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto preliminaryGroupsQuery = request.query().get("preliminaryGroups");
        std::optional<int32_t> preliminaryGroups;
        if (preliminaryGroupsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preliminaryGroupsQuery.value(), valueQuery_instance)) {
                preliminaryGroups = valueQuery_instance;
            }
        }
        auto preliminaryGroupAdvancementsQuery = request.query().get("preliminaryGroupAdvancements");
        std::optional<std::string> preliminaryGroupAdvancements;
        if (preliminaryGroupAdvancementsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preliminaryGroupAdvancementsQuery.value(), valueQuery_instance)) {
                preliminaryGroupAdvancements = valueQuery_instance;
            }
        }
        auto enableMultipleEntriesQuery = request.query().get("enableMultipleEntries");
        std::optional<bool> enableMultipleEntries;
        if (enableMultipleEntriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableMultipleEntriesQuery.value(), valueQuery_instance)) {
                enableMultipleEntries = valueQuery_instance;
            }
        }
        auto enableMultipleVotesQuery = request.query().get("enableMultipleVotes");
        std::optional<bool> enableMultipleVotes;
        if (enableMultipleVotesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableMultipleVotesQuery.value(), valueQuery_instance)) {
                enableMultipleVotes = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto winnerTagQuery = request.query().get("winnerTag");
        std::optional<std::string> winnerTag;
        if (winnerTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(winnerTagQuery.value(), valueQuery_instance)) {
                winnerTag = valueQuery_instance;
            }
        }
        auto tieTagQuery = request.query().get("tieTag");
        std::optional<std::string> tieTag;
        if (tieTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tieTagQuery.value(), valueQuery_instance)) {
                tieTag = valueQuery_instance;
            }
        }
    


        try {





            this->create_tournament(version, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::delete_tournament_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_tournament(version, accountId, missionId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::get_tournament_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto joinCodeQuery = request.query().get("joinCode");
        std::optional<std::string> joinCode;
        if (joinCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(joinCodeQuery.value(), valueQuery_instance)) {
                joinCode = valueQuery_instance;
            }
        }
        auto includeScoresQuery = request.query().get("includeScores");
        std::optional<std::string> includeScores;
        if (includeScoresQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(includeScoresQuery.value(), valueQuery_instance)) {
                includeScores = valueQuery_instance;
            }
        }
        auto objectPreviewSizeQuery = request.query().get("objectPreviewSize");
        std::optional<int32_t> objectPreviewSize;
        if (objectPreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(objectPreviewSizeQuery.value(), valueQuery_instance)) {
                objectPreviewSize = valueQuery_instance;
            }
        }
    


        try {





            this->get_tournament(version, accountId, missionId, joinCode, includeScores, objectPreviewSize, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::search_objects_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto gameLevelIdQuery = request.query().get("gameLevelId");
        std::optional<int64_t> gameLevelId;
        if (gameLevelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(gameLevelIdQuery.value(), valueQuery_instance)) {
                gameLevelId = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_objects(version, accountId, gameLevelId, sortField, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::search_rounds_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto statusQuery = request.query().get("status");
        std::optional<std::string> status;
        if (statusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(statusQuery.value(), valueQuery_instance)) {
                status = valueQuery_instance;
            }
        }
        auto missionTypeQuery = request.query().get("missionType");
        std::optional<std::string> missionType;
        if (missionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(missionTypeQuery.value(), valueQuery_instance)) {
                missionType = valueQuery_instance;
            }
        }
        auto currentOnlyQuery = request.query().get("currentOnly");
        std::optional<bool> currentOnly;
        if (currentOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(currentOnlyQuery.value(), valueQuery_instance)) {
                currentOnly = valueQuery_instance;
            }
        }
        auto visibilitiesQuery = request.query().get("visibilities");
        std::optional<std::string> visibilities;
        if (visibilitiesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilitiesQuery.value(), valueQuery_instance)) {
                visibilities = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_rounds(version, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::search_tournaments_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto subTypeQuery = request.query().get("subType");
        std::optional<std::string> subType;
        if (subTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTypeQuery.value(), valueQuery_instance)) {
                subType = valueQuery_instance;
            }
        }
        auto includeInactiveQuery = request.query().get("includeInactive");
        std::optional<bool> includeInactive;
        if (includeInactiveQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeInactiveQuery.value(), valueQuery_instance)) {
                includeInactive = valueQuery_instance;
            }
        }
        auto missionTypesQuery = request.query().get("missionTypes");
        std::optional<std::string> missionTypes;
        if (missionTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(missionTypesQuery.value(), valueQuery_instance)) {
                missionTypes = valueQuery_instance;
            }
        }
        auto filterQuery = request.query().get("filter");
        std::optional<std::string> filter;
        if (filterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterQuery.value(), valueQuery_instance)) {
                filter = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_tournaments(version, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::submit_tournament_score_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto gameIdQuery = request.query().get("gameId");
        std::optional<int64_t> gameId;
        if (gameIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(gameIdQuery.value(), valueQuery_instance)) {
                gameId = valueQuery_instance;
            }
        }
        auto packIdQuery = request.query().get("packId");
        std::optional<int64_t> packId;
        if (packIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(packIdQuery.value(), valueQuery_instance)) {
                packId = valueQuery_instance;
            }
        }
        auto gameLevelIdQuery = request.query().get("gameLevelId");
        std::optional<int64_t> gameLevelId;
        if (gameLevelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(gameLevelIdQuery.value(), valueQuery_instance)) {
                gameLevelId = valueQuery_instance;
            }
        }
        auto scoresQuery = request.query().get("scores");
        std::optional<std::string> scores;
        if (scoresQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(scoresQuery.value(), valueQuery_instance)) {
                scores = valueQuery_instance;
            }
        }
    


        try {





            this->submit_tournament_score(version, accountId, appKey, missionId, gameId, packId, scores, gameLevelId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::submit_tournament_vote_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto gameObjectIdQuery = request.query().get("gameObjectId");
        std::optional<int64_t> gameObjectId;
        if (gameObjectIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(gameObjectIdQuery.value(), valueQuery_instance)) {
                gameObjectId = valueQuery_instance;
            }
        }
        auto checkIfDeviceAlreadyVotedQuery = request.query().get("checkIfDeviceAlreadyVoted");
        std::optional<bool> checkIfDeviceAlreadyVoted;
        if (checkIfDeviceAlreadyVotedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(checkIfDeviceAlreadyVotedQuery.value(), valueQuery_instance)) {
                checkIfDeviceAlreadyVoted = valueQuery_instance;
            }
        }
    


        try {





            this->submit_tournament_vote(version, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::substitute_tournament_player_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto packIdQuery = request.query().get("packId");
        std::optional<int64_t> packId;
        if (packIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(packIdQuery.value(), valueQuery_instance)) {
                packId = valueQuery_instance;
            }
        }
        auto gameLevelIdQuery = request.query().get("gameLevelId");
        std::optional<int64_t> gameLevelId;
        if (gameLevelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(gameLevelIdQuery.value(), valueQuery_instance)) {
                gameLevelId = valueQuery_instance;
            }
        }
    


        try {





            this->substitute_tournament_player(version, accountId, missionId, packId, gameLevelId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void TournamentApi::update_tournament_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto missionIdQuery = request.query().get("missionId");
        std::optional<int64_t> missionId;
        if (missionIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(missionIdQuery.value(), valueQuery_instance)) {
                missionId = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto subTypeQuery = request.query().get("subType");
        std::optional<std::string> subType;
        if (subTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTypeQuery.value(), valueQuery_instance)) {
                subType = valueQuery_instance;
            }
        }
        auto imageAssetIdQuery = request.query().get("imageAssetId");
        std::optional<int64_t> imageAssetId;
        if (imageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(imageAssetIdQuery.value(), valueQuery_instance)) {
                imageAssetId = valueQuery_instance;
            }
        }
        auto secondsBetweenLevelsQuery = request.query().get("secondsBetweenLevels");
        std::optional<int32_t> secondsBetweenLevels;
        if (secondsBetweenLevelsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsBetweenLevelsQuery.value(), valueQuery_instance)) {
                secondsBetweenLevels = valueQuery_instance;
            }
        }
        auto secondsForTieBreakerQuery = request.query().get("secondsForTieBreaker");
        std::optional<int32_t> secondsForTieBreaker;
        if (secondsForTieBreakerQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsForTieBreakerQuery.value(), valueQuery_instance)) {
                secondsForTieBreaker = valueQuery_instance;
            }
        }
        auto secondsBetweenPacksQuery = request.query().get("secondsBetweenPacks");
        std::optional<int32_t> secondsBetweenPacks;
        if (secondsBetweenPacksQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(secondsBetweenPacksQuery.value(), valueQuery_instance)) {
                secondsBetweenPacks = valueQuery_instance;
            }
        }
        auto maximumLevelLengthQuery = request.query().get("maximumLevelLength");
        std::optional<int32_t> maximumLevelLength;
        if (maximumLevelLengthQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(maximumLevelLengthQuery.value(), valueQuery_instance)) {
                maximumLevelLength = valueQuery_instance;
            }
        }
        auto costToPlayQuery = request.query().get("costToPlay");
        std::optional<int32_t> costToPlay;
        if (costToPlayQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(costToPlayQuery.value(), valueQuery_instance)) {
                costToPlay = valueQuery_instance;
            }
        }
        auto costToPlayTypeQuery = request.query().get("costToPlayType");
        std::optional<std::string> costToPlayType;
        if (costToPlayTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(costToPlayTypeQuery.value(), valueQuery_instance)) {
                costToPlayType = valueQuery_instance;
            }
        }
        auto minimumToPlayQuery = request.query().get("minimumToPlay");
        std::optional<int32_t> minimumToPlay;
        if (minimumToPlayQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minimumToPlayQuery.value(), valueQuery_instance)) {
                minimumToPlay = valueQuery_instance;
            }
        }
        auto startingLimitQuery = request.query().get("startingLimit");
        std::optional<int32_t> startingLimit;
        if (startingLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startingLimitQuery.value(), valueQuery_instance)) {
                startingLimit = valueQuery_instance;
            }
        }
        auto availableLimitQuery = request.query().get("availableLimit");
        std::optional<int32_t> availableLimit;
        if (availableLimitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(availableLimitQuery.value(), valueQuery_instance)) {
                availableLimit = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto enableBuyBackQuery = request.query().get("enableBuyBack");
        std::optional<bool> enableBuyBack;
        if (enableBuyBackQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableBuyBackQuery.value(), valueQuery_instance)) {
                enableBuyBack = valueQuery_instance;
            }
        }
        auto offerIdsQuery = request.query().get("offerIds");
        std::optional<std::string> offerIds;
        if (offerIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(offerIdsQuery.value(), valueQuery_instance)) {
                offerIds = valueQuery_instance;
            }
        }
        auto offerAssetIdQuery = request.query().get("offerAssetId");
        std::optional<int64_t> offerAssetId;
        if (offerAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerAssetIdQuery.value(), valueQuery_instance)) {
                offerAssetId = valueQuery_instance;
            }
        }
        auto fixedRewardQuery = request.query().get("fixedReward");
        std::optional<bool> fixedReward;
        if (fixedRewardQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(fixedRewardQuery.value(), valueQuery_instance)) {
                fixedReward = valueQuery_instance;
            }
        }
        auto splitRewardQuery = request.query().get("splitReward");
        std::optional<std::string> splitReward;
        if (splitRewardQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(splitRewardQuery.value(), valueQuery_instance)) {
                splitReward = valueQuery_instance;
            }
        }
        auto allocateTicketsQuery = request.query().get("allocateTickets");
        std::optional<bool> allocateTickets;
        if (allocateTicketsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(allocateTicketsQuery.value(), valueQuery_instance)) {
                allocateTickets = valueQuery_instance;
            }
        }
        auto tournamentDataQuery = request.query().get("tournamentData");
        std::optional<std::string> tournamentData;
        if (tournamentDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tournamentDataQuery.value(), valueQuery_instance)) {
                tournamentData = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto preliminaryGroupsQuery = request.query().get("preliminaryGroups");
        std::optional<int32_t> preliminaryGroups;
        if (preliminaryGroupsQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(preliminaryGroupsQuery.value(), valueQuery_instance)) {
                preliminaryGroups = valueQuery_instance;
            }
        }
        auto preliminaryGroupAdvancementsQuery = request.query().get("preliminaryGroupAdvancements");
        std::optional<std::string> preliminaryGroupAdvancements;
        if (preliminaryGroupAdvancementsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(preliminaryGroupAdvancementsQuery.value(), valueQuery_instance)) {
                preliminaryGroupAdvancements = valueQuery_instance;
            }
        }
        auto enableMultipleEntriesQuery = request.query().get("enableMultipleEntries");
        std::optional<bool> enableMultipleEntries;
        if (enableMultipleEntriesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableMultipleEntriesQuery.value(), valueQuery_instance)) {
                enableMultipleEntries = valueQuery_instance;
            }
        }
        auto enableMultipleVotesQuery = request.query().get("enableMultipleVotes");
        std::optional<bool> enableMultipleVotes;
        if (enableMultipleVotesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(enableMultipleVotesQuery.value(), valueQuery_instance)) {
                enableMultipleVotes = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto winnerTagQuery = request.query().get("winnerTag");
        std::optional<std::string> winnerTag;
        if (winnerTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(winnerTagQuery.value(), valueQuery_instance)) {
                winnerTag = valueQuery_instance;
            }
        }
        auto tieTagQuery = request.query().get("tieTag");
        std::optional<std::string> tieTag;
        if (tieTagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tieTagQuery.value(), valueQuery_instance)) {
                tieTag = valueQuery_instance;
            }
        }
    


        try {





            this->update_tournament(version, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void TournamentApi::tournament_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

