/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "AudienceApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string AudienceApi::base = "";

AudienceApi::AudienceApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void AudienceApi::init() {
    setupRoutes();
}

void AudienceApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/audience/create", Routes::bind(&AudienceApi::create_audience_handler, this));
    Routes::Post(*router, base + "/api/:version/audience/delete", Routes::bind(&AudienceApi::delete_audience_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/ageGroups", Routes::bind(&AudienceApi::get_age_groups_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/get", Routes::bind(&AudienceApi::get_audience_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/search", Routes::bind(&AudienceApi::get_audience_list_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/devices", Routes::bind(&AudienceApi::get_devices_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/experiences", Routes::bind(&AudienceApi::get_experiences_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/grouped/get", Routes::bind(&AudienceApi::get_grouped_audiences_handler, this));
    Routes::Post(*router, base + "/api/:version/audience/suggestion/list", Routes::bind(&AudienceApi::list_by_account_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/suggestion/offersByAudience", Routes::bind(&AudienceApi::list_by_audience_handler, this));
    Routes::Get(*router, base + "/api/:version/audience/suggestion/latest", Routes::bind(&AudienceApi::list_lastest_by_account_handler, this));
    Routes::Post(*router, base + "/api/:version/audience/suggestion/send", Routes::bind(&AudienceApi::send_by_account_handler, this));
    Routes::Post(*router, base + "/api/:version/audience/update", Routes::bind(&AudienceApi::update_audience_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&AudienceApi::audience_api_default_handler, this));
}

void AudienceApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AudienceApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void AudienceApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AudienceApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void AudienceApi::create_audience_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto searchTagsQuery = request.query().get("searchTags");
        std::optional<std::string> searchTags;
        if (searchTagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchTagsQuery.value(), valueQuery_instance)) {
                searchTags = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageGroupsQuery = request.query().get("ageGroups");
        std::optional<std::string> ageGroups;
        if (ageGroupsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ageGroupsQuery.value(), valueQuery_instance)) {
                ageGroups = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto applicationIdsQuery = request.query().get("applicationIds");
        std::optional<std::string> applicationIds;
        if (applicationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(applicationIdsQuery.value(), valueQuery_instance)) {
                applicationIds = valueQuery_instance;
            }
        }
        auto gameExperienceLevelQuery = request.query().get("gameExperienceLevel");
        std::optional<std::string> gameExperienceLevel;
        if (gameExperienceLevelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceLevelQuery.value(), valueQuery_instance)) {
                gameExperienceLevel = valueQuery_instance;
            }
        }
        auto devicesQuery = request.query().get("devices");
        std::optional<std::string> devices;
        if (devicesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(devicesQuery.value(), valueQuery_instance)) {
                devices = valueQuery_instance;
            }
        }
        auto deviceIdsQuery = request.query().get("deviceIds");
        std::optional<std::string> deviceIds;
        if (deviceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdsQuery.value(), valueQuery_instance)) {
                deviceIds = valueQuery_instance;
            }
        }
        auto deviceVersionsQuery = request.query().get("deviceVersions");
        std::optional<std::string> deviceVersions;
        if (deviceVersionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceVersionsQuery.value(), valueQuery_instance)) {
                deviceVersions = valueQuery_instance;
            }
        }
        auto locationsQuery = request.query().get("locations");
        std::optional<std::string> locations;
        if (locationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationsQuery.value(), valueQuery_instance)) {
                locations = valueQuery_instance;
            }
        }
        auto radiusQuery = request.query().get("radius");
        std::optional<std::string> radius;
        if (radiusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(radiusQuery.value(), valueQuery_instance)) {
                radius = valueQuery_instance;
            }
        }
        auto startTimeOffsetQuery = request.query().get("startTimeOffset");
        std::optional<int32_t> startTimeOffset;
        if (startTimeOffsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startTimeOffsetQuery.value(), valueQuery_instance)) {
                startTimeOffset = valueQuery_instance;
            }
        }
        auto endTimeOffsetQuery = request.query().get("endTimeOffset");
        std::optional<int32_t> endTimeOffset;
        if (endTimeOffsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(endTimeOffsetQuery.value(), valueQuery_instance)) {
                endTimeOffset = valueQuery_instance;
            }
        }
        auto sendSuggestionQuery = request.query().get("sendSuggestion");
        std::optional<bool> sendSuggestion;
        if (sendSuggestionQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendSuggestionQuery.value(), valueQuery_instance)) {
                sendSuggestion = valueQuery_instance;
            }
        }
        auto associateDescriptionQuery = request.query().get("associateDescription");
        std::optional<std::string> associateDescription;
        if (associateDescriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(associateDescriptionQuery.value(), valueQuery_instance)) {
                associateDescription = valueQuery_instance;
            }
        }
        auto associateTypeQuery = request.query().get("associateType");
        std::optional<std::string> associateType;
        if (associateTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(associateTypeQuery.value(), valueQuery_instance)) {
                associateType = valueQuery_instance;
            }
        }
        auto associateIdQuery = request.query().get("associateId");
        std::optional<int64_t> associateId;
        if (associateIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(associateIdQuery.value(), valueQuery_instance)) {
                associateId = valueQuery_instance;
            }
        }
        auto groupingIdQuery = request.query().get("groupingId");
        std::optional<std::string> groupingId;
        if (groupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupingIdQuery.value(), valueQuery_instance)) {
                groupingId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto audienceTypeQuery = request.query().get("audienceType");
        std::optional<std::string> audienceType;
        if (audienceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceTypeQuery.value(), valueQuery_instance)) {
                audienceType = valueQuery_instance;
            }
        }
        auto useOrderQuery = request.query().get("useOrder");
        std::optional<bool> useOrder;
        if (useOrderQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(useOrderQuery.value(), valueQuery_instance)) {
                useOrder = valueQuery_instance;
            }
        }
        auto cohortRegionsDataQuery = request.query().get("cohortRegionsData");
        std::optional<std::string> cohortRegionsData;
        if (cohortRegionsDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cohortRegionsDataQuery.value(), valueQuery_instance)) {
                cohortRegionsData = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto trilaterationTypesQuery = request.query().get("trilaterationTypes");
        std::optional<std::string> trilaterationTypes;
        if (trilaterationTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(trilaterationTypesQuery.value(), valueQuery_instance)) {
                trilaterationTypes = valueQuery_instance;
            }
        }
        auto uniqueNameQuery = request.query().get("uniqueName");
        std::optional<bool> uniqueName;
        if (uniqueNameQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(uniqueNameQuery.value(), valueQuery_instance)) {
                uniqueName = valueQuery_instance;
            }
        }
    


        try {





            this->create_audience(version, accountId, name, description, searchTags, gender, ageGroups, categoryIds, applicationIds, gameExperienceLevel, devices, deviceIds, deviceVersions, locations, radius, startTimeOffset, endTimeOffset, sendSuggestion, associateDescription, associateType, associateId, groupingId, metaData, visibility, audienceType, useOrder, cohortRegionsData, appKey, trilaterationTypes, uniqueName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::delete_audience_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_audience(version, accountId, audienceId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_age_groups_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
    


        try {





            this->get_age_groups(version, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_audience_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnAccountCountQuery = request.query().get("returnAccountCount");
        std::optional<bool> returnAccountCount;
        if (returnAccountCountQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAccountCountQuery.value(), valueQuery_instance)) {
                returnAccountCount = valueQuery_instance;
            }
        }
        auto returnAlbumCountQuery = request.query().get("returnAlbumCount");
        std::optional<bool> returnAlbumCount;
        if (returnAlbumCountQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAlbumCountQuery.value(), valueQuery_instance)) {
                returnAlbumCount = valueQuery_instance;
            }
        }
        auto albumTypesForCountQuery = request.query().get("albumTypesForCount");
        std::optional<std::string> albumTypesForCount;
        if (albumTypesForCountQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumTypesForCountQuery.value(), valueQuery_instance)) {
                albumTypesForCount = valueQuery_instance;
            }
        }
    


        try {





            this->get_audience(version, accountId, audienceId, appKey, returnAccountCount, returnAlbumCount, albumTypesForCount, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_audience_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdsQuery = request.query().get("albumIds");
        std::optional<std::string> albumIds;
        if (albumIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumIdsQuery.value(), valueQuery_instance)) {
                albumIds = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto keywordFieldsQuery = request.query().get("keywordFields");
        std::optional<std::string> keywordFields;
        if (keywordFieldsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordFieldsQuery.value(), valueQuery_instance)) {
                keywordFields = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto sendSuggestionQuery = request.query().get("sendSuggestion");
        std::optional<bool> sendSuggestion;
        if (sendSuggestionQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendSuggestionQuery.value(), valueQuery_instance)) {
                sendSuggestion = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto groupByGroupingIdQuery = request.query().get("groupByGroupingId");
        std::optional<bool> groupByGroupingId;
        if (groupByGroupingIdQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(groupByGroupingIdQuery.value(), valueQuery_instance)) {
                groupByGroupingId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnGlobalQuery = request.query().get("returnGlobal");
        std::optional<bool> returnGlobal;
        if (returnGlobalQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnGlobalQuery.value(), valueQuery_instance)) {
                returnGlobal = valueQuery_instance;
            }
        }
        auto exactKeywordQuery = request.query().get("exactKeyword");
        std::optional<bool> exactKeyword;
        if (exactKeywordQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(exactKeywordQuery.value(), valueQuery_instance)) {
                exactKeyword = valueQuery_instance;
            }
        }
        auto audienceTypeQuery = request.query().get("audienceType");
        std::optional<std::string> audienceType;
        if (audienceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceTypeQuery.value(), valueQuery_instance)) {
                audienceType = valueQuery_instance;
            }
        }
        auto audienceTypesQuery = request.query().get("audienceTypes");
        std::optional<std::string> audienceTypes;
        if (audienceTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceTypesQuery.value(), valueQuery_instance)) {
                audienceTypes = valueQuery_instance;
            }
        }
        auto returnAccountCountQuery = request.query().get("returnAccountCount");
        std::optional<bool> returnAccountCount;
        if (returnAccountCountQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAccountCountQuery.value(), valueQuery_instance)) {
                returnAccountCount = valueQuery_instance;
            }
        }
        auto returnAlbumCountQuery = request.query().get("returnAlbumCount");
        std::optional<bool> returnAlbumCount;
        if (returnAlbumCountQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnAlbumCountQuery.value(), valueQuery_instance)) {
                returnAlbumCount = valueQuery_instance;
            }
        }
        auto albumTypesForCountQuery = request.query().get("albumTypesForCount");
        std::optional<std::string> albumTypesForCount;
        if (albumTypesForCountQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumTypesForCountQuery.value(), valueQuery_instance)) {
                albumTypesForCount = valueQuery_instance;
            }
        }
    


        try {





            this->get_audience_list(version, accountId, albumIds, keyword, keywordFields, sortField, descending, start, limit, sendSuggestion, activeOnly, groupByGroupingId, appKey, returnGlobal, exactKeyword, audienceType, audienceTypes, returnAccountCount, returnAlbumCount, albumTypesForCount, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_devices_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto includeInactiveQuery = request.query().get("includeInactive");
        std::optional<bool> includeInactive;
        if (includeInactiveQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeInactiveQuery.value(), valueQuery_instance)) {
                includeInactive = valueQuery_instance;
            }
        }
    


        try {





            this->get_devices(version, includeInactive, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_experiences_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
    


        try {





            this->get_experiences(version, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::get_grouped_audiences_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto audienceGroupingIdQuery = request.query().get("audienceGroupingId");
        std::optional<std::string> audienceGroupingId;
        if (audienceGroupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceGroupingIdQuery.value(), valueQuery_instance)) {
                audienceGroupingId = valueQuery_instance;
            }
        }
    


        try {





            this->get_grouped_audiences(version, accountId, audienceGroupingId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::list_by_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto suggestionTypeQuery = request.query().get("suggestionType");
        std::optional<std::string> suggestionType;
        if (suggestionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suggestionTypeQuery.value(), valueQuery_instance)) {
                suggestionType = valueQuery_instance;
            }
        }
    


        try {





            this->list_by_account(version, accountId, limit, suggestionType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::list_by_audience_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageQuery = request.query().get("age");
        std::optional<int32_t> age;
        if (ageQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(ageQuery.value(), valueQuery_instance)) {
                age = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->list_by_audience(version, limit, gender, age, categoryIds, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::list_lastest_by_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto timeframeQuery = request.query().get("timeframe");
        std::optional<int32_t> timeframe;
        if (timeframeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(timeframeQuery.value(), valueQuery_instance)) {
                timeframe = valueQuery_instance;
            }
        }
        auto suggestionTypeQuery = request.query().get("suggestionType");
        std::optional<std::string> suggestionType;
        if (suggestionTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suggestionTypeQuery.value(), valueQuery_instance)) {
                suggestionType = valueQuery_instance;
            }
        }
    


        try {





            this->list_lastest_by_account(version, accountId, timeframe, suggestionType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::send_by_account_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->send_by_account(version, accountId, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AudienceApi::update_audience_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto searchTagsQuery = request.query().get("searchTags");
        std::optional<std::string> searchTags;
        if (searchTagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchTagsQuery.value(), valueQuery_instance)) {
                searchTags = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageGroupsQuery = request.query().get("ageGroups");
        std::optional<std::string> ageGroups;
        if (ageGroupsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ageGroupsQuery.value(), valueQuery_instance)) {
                ageGroups = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto applicationIdsQuery = request.query().get("applicationIds");
        std::optional<std::string> applicationIds;
        if (applicationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(applicationIdsQuery.value(), valueQuery_instance)) {
                applicationIds = valueQuery_instance;
            }
        }
        auto gameExperienceLevelQuery = request.query().get("gameExperienceLevel");
        std::optional<std::string> gameExperienceLevel;
        if (gameExperienceLevelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameExperienceLevelQuery.value(), valueQuery_instance)) {
                gameExperienceLevel = valueQuery_instance;
            }
        }
        auto devicesQuery = request.query().get("devices");
        std::optional<std::string> devices;
        if (devicesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(devicesQuery.value(), valueQuery_instance)) {
                devices = valueQuery_instance;
            }
        }
        auto deviceIdsQuery = request.query().get("deviceIds");
        std::optional<std::string> deviceIds;
        if (deviceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdsQuery.value(), valueQuery_instance)) {
                deviceIds = valueQuery_instance;
            }
        }
        auto deviceVersionsQuery = request.query().get("deviceVersions");
        std::optional<std::string> deviceVersions;
        if (deviceVersionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceVersionsQuery.value(), valueQuery_instance)) {
                deviceVersions = valueQuery_instance;
            }
        }
        auto locationsQuery = request.query().get("locations");
        std::optional<std::string> locations;
        if (locationsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationsQuery.value(), valueQuery_instance)) {
                locations = valueQuery_instance;
            }
        }
        auto radiusQuery = request.query().get("radius");
        std::optional<std::string> radius;
        if (radiusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(radiusQuery.value(), valueQuery_instance)) {
                radius = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto sendSuggestionQuery = request.query().get("sendSuggestion");
        std::optional<bool> sendSuggestion;
        if (sendSuggestionQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(sendSuggestionQuery.value(), valueQuery_instance)) {
                sendSuggestion = valueQuery_instance;
            }
        }
        auto startTimeOffsetQuery = request.query().get("startTimeOffset");
        std::optional<int32_t> startTimeOffset;
        if (startTimeOffsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startTimeOffsetQuery.value(), valueQuery_instance)) {
                startTimeOffset = valueQuery_instance;
            }
        }
        auto endTimeOffsetQuery = request.query().get("endTimeOffset");
        std::optional<int32_t> endTimeOffset;
        if (endTimeOffsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(endTimeOffsetQuery.value(), valueQuery_instance)) {
                endTimeOffset = valueQuery_instance;
            }
        }
        auto associateDescriptionQuery = request.query().get("associateDescription");
        std::optional<std::string> associateDescription;
        if (associateDescriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(associateDescriptionQuery.value(), valueQuery_instance)) {
                associateDescription = valueQuery_instance;
            }
        }
        auto associateTypeQuery = request.query().get("associateType");
        std::optional<std::string> associateType;
        if (associateTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(associateTypeQuery.value(), valueQuery_instance)) {
                associateType = valueQuery_instance;
            }
        }
        auto associateIdQuery = request.query().get("associateId");
        std::optional<int64_t> associateId;
        if (associateIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(associateIdQuery.value(), valueQuery_instance)) {
                associateId = valueQuery_instance;
            }
        }
        auto groupingIdQuery = request.query().get("groupingId");
        std::optional<std::string> groupingId;
        if (groupingIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupingIdQuery.value(), valueQuery_instance)) {
                groupingId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto audienceTypeQuery = request.query().get("audienceType");
        std::optional<std::string> audienceType;
        if (audienceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceTypeQuery.value(), valueQuery_instance)) {
                audienceType = valueQuery_instance;
            }
        }
        auto useOrderQuery = request.query().get("useOrder");
        std::optional<bool> useOrder;
        if (useOrderQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(useOrderQuery.value(), valueQuery_instance)) {
                useOrder = valueQuery_instance;
            }
        }
        auto cohortRegionsDataQuery = request.query().get("cohortRegionsData");
        std::optional<std::string> cohortRegionsData;
        if (cohortRegionsDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cohortRegionsDataQuery.value(), valueQuery_instance)) {
                cohortRegionsData = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto trilaterationTypesQuery = request.query().get("trilaterationTypes");
        std::optional<std::string> trilaterationTypes;
        if (trilaterationTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(trilaterationTypesQuery.value(), valueQuery_instance)) {
                trilaterationTypes = valueQuery_instance;
            }
        }
        auto uniqueNameQuery = request.query().get("uniqueName");
        std::optional<bool> uniqueName;
        if (uniqueNameQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(uniqueNameQuery.value(), valueQuery_instance)) {
                uniqueName = valueQuery_instance;
            }
        }
    


        try {





            this->update_audience(version, accountId, audienceId, name, description, searchTags, gender, ageGroups, categoryIds, applicationIds, gameExperienceLevel, devices, deviceIds, deviceVersions, locations, radius, active, sendSuggestion, startTimeOffset, endTimeOffset, associateDescription, associateType, associateId, groupingId, metaData, visibility, audienceType, useOrder, cohortRegionsData, appKey, trilaterationTypes, uniqueName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void AudienceApi::audience_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

