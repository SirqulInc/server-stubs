/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "LocationApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string LocationApi::base = "";

LocationApi::LocationApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void LocationApi::init() {
    setupRoutes();
}

void LocationApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/location/trilaterate/cache", Routes::bind(&LocationApi::cache_trilateration_data_handler, this));
    Routes::Post(*router, base + "/api/:version/location/trilaterate/cache/submit", Routes::bind(&LocationApi::cache_trilateration_data_gzip_handler, this));
    Routes::Get(*router, base + "/api/:version/location/ip", Routes::bind(&LocationApi::get_location_by_ip_handler, this));
    Routes::Get(*router, base + "/api/:version/account/location/trilaterate", Routes::bind(&LocationApi::get_location_by_trilateration_handler, this));
    Routes::Get(*router, base + "/api/:version/location/search", Routes::bind(&LocationApi::get_locations_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&LocationApi::location_api_default_handler, this));
}

void LocationApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> LocationApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void LocationApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> LocationApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void LocationApi::cache_trilateration_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->cache_trilateration_data(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void LocationApi::cache_trilateration_data_gzip_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        // Getting the body param
        
        TrilatCacheRequest body;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            body.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->cache_trilateration_data_gzip(version, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void LocationApi::get_location_by_ip_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto ipQuery = request.query().get("ip");
        std::optional<std::string> ip;
        if (ipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ipQuery.value(), valueQuery_instance)) {
                ip = valueQuery_instance;
            }
        }
    


        try {





            this->get_location_by_ip(version, ip, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void LocationApi::get_location_by_trilateration_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
        auto responseFiltersQuery = request.query().get("responseFilters");
        std::optional<std::string> responseFilters;
        if (responseFiltersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFiltersQuery.value(), valueQuery_instance)) {
                responseFilters = valueQuery_instance;
            }
        }
    


        try {





            this->get_location_by_trilateration(version, accountId, latitude, longitude, data, responseFilters, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void LocationApi::get_locations_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto currentlatitudeQuery = request.query().get("currentlatitude");
        std::optional<double> currentlatitude;
        if (currentlatitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(currentlatitudeQuery.value(), valueQuery_instance)) {
                currentlatitude = valueQuery_instance;
            }
        }
        auto currentlongitudeQuery = request.query().get("currentlongitude");
        std::optional<double> currentlongitude;
        if (currentlongitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(currentlongitudeQuery.value(), valueQuery_instance)) {
                currentlongitude = valueQuery_instance;
            }
        }
        auto currentLatitudeQuery = request.query().get("currentLatitude");
        std::optional<double> currentLatitude;
        if (currentLatitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(currentLatitudeQuery.value(), valueQuery_instance)) {
                currentLatitude = valueQuery_instance;
            }
        }
        auto currentLongitudeQuery = request.query().get("currentLongitude");
        std::optional<double> currentLongitude;
        if (currentLongitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(currentLongitudeQuery.value(), valueQuery_instance)) {
                currentLongitude = valueQuery_instance;
            }
        }
        auto queryQuery = request.query().get("query");
        std::optional<std::string> query;
        if (queryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(queryQuery.value(), valueQuery_instance)) {
                query = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto zipCodeQuery = request.query().get("zipCode");
        std::optional<std::string> zipCode;
        if (zipCodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipCodeQuery.value(), valueQuery_instance)) {
                zipCode = valueQuery_instance;
            }
        }
        auto selectedMaplatitudeQuery = request.query().get("selectedMaplatitude");
        std::optional<double> selectedMaplatitude;
        if (selectedMaplatitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(selectedMaplatitudeQuery.value(), valueQuery_instance)) {
                selectedMaplatitude = valueQuery_instance;
            }
        }
        auto selectedMaplongitudeQuery = request.query().get("selectedMaplongitude");
        std::optional<double> selectedMaplongitude;
        if (selectedMaplongitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(selectedMaplongitudeQuery.value(), valueQuery_instance)) {
                selectedMaplongitude = valueQuery_instance;
            }
        }
        auto selectedMapLatitudeQuery = request.query().get("selectedMapLatitude");
        std::optional<double> selectedMapLatitude;
        if (selectedMapLatitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(selectedMapLatitudeQuery.value(), valueQuery_instance)) {
                selectedMapLatitude = valueQuery_instance;
            }
        }
        auto selectedMapLongitudeQuery = request.query().get("selectedMapLongitude");
        std::optional<double> selectedMapLongitude;
        if (selectedMapLongitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(selectedMapLongitudeQuery.value(), valueQuery_instance)) {
                selectedMapLongitude = valueQuery_instance;
            }
        }
        auto searchRangeQuery = request.query().get("searchRange");
        std::optional<double> searchRange;
        if (searchRangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(searchRangeQuery.value(), valueQuery_instance)) {
                searchRange = valueQuery_instance;
            }
        }
        auto useGeocodeQuery = request.query().get("useGeocode");
        std::optional<bool> useGeocode;
        if (useGeocodeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(useGeocodeQuery.value(), valueQuery_instance)) {
                useGeocode = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_locations(version, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void LocationApi::location_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

