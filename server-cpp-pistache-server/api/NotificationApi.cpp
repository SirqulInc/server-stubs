/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "NotificationApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string NotificationApi::base = "";

NotificationApi::NotificationApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void NotificationApi::init() {
    setupRoutes();
}

void NotificationApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/notification/template/create", Routes::bind(&NotificationApi::create_notification_template_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/blocked/batch", Routes::bind(&NotificationApi::create_or_update_blocked_notifications_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/template/delete", Routes::bind(&NotificationApi::delete_notification_template_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/template/get", Routes::bind(&NotificationApi::get_notification_template_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/search", Routes::bind(&NotificationApi::get_notifications_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/token", Routes::bind(&NotificationApi::register_notification_token_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/blocked/search", Routes::bind(&NotificationApi::search_blocked_notifications_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/template/search", Routes::bind(&NotificationApi::search_notification_template_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/recipient/search", Routes::bind(&NotificationApi::search_recipients_handler, this));
    Routes::Get(*router, base + "/api/:version/notification/recipient/search/count", Routes::bind(&NotificationApi::search_recipients_count_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/batch", Routes::bind(&NotificationApi::send_batch_notifications_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/custom", Routes::bind(&NotificationApi::send_custom_notifications_handler, this));
    Routes::Post(*router, base + "/api/:version/notification/template/update", Routes::bind(&NotificationApi::update_notification_template_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&NotificationApi::notification_api_default_handler, this));
}

void NotificationApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> NotificationApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void NotificationApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> NotificationApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void NotificationApi::create_notification_template_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto eventQuery = request.query().get("event");
        std::optional<std::string> event;
        if (eventQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventQuery.value(), valueQuery_instance)) {
                event = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto bodyQuery = request.query().get("body");
        std::optional<std::string> body;
        if (bodyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bodyQuery.value(), valueQuery_instance)) {
                body = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
    


        try {





            this->create_notification_template(version, accountId, conduit, title, body, appKey, event, tags, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::create_or_update_blocked_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
    


        try {





            this->create_or_update_blocked_notifications(version, appKey, data, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::delete_notification_template_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto notificationTemplateIdQuery = request.query().get("notificationTemplateId");
        std::optional<int64_t> notificationTemplateId;
        if (notificationTemplateIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(notificationTemplateIdQuery.value(), valueQuery_instance)) {
                notificationTemplateId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_notification_template(version, accountId, notificationTemplateId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::get_notification_template_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto notificationTemplateIdQuery = request.query().get("notificationTemplateId");
        std::optional<int64_t> notificationTemplateId;
        if (notificationTemplateIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(notificationTemplateIdQuery.value(), valueQuery_instance)) {
                notificationTemplateId = valueQuery_instance;
            }
        }
    


        try {





            this->get_notification_template(version, accountId, notificationTemplateId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::get_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto eventTypeQuery = request.query().get("eventType");
        std::optional<std::string> eventType;
        if (eventTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventTypeQuery.value(), valueQuery_instance)) {
                eventType = valueQuery_instance;
            }
        }
        auto contentIdsQuery = request.query().get("contentIds");
        std::optional<std::string> contentIds;
        if (contentIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentIdsQuery.value(), valueQuery_instance)) {
                contentIds = valueQuery_instance;
            }
        }
        auto contentTypesQuery = request.query().get("contentTypes");
        std::optional<std::string> contentTypes;
        if (contentTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypesQuery.value(), valueQuery_instance)) {
                contentTypes = valueQuery_instance;
            }
        }
        auto parentIdsQuery = request.query().get("parentIds");
        std::optional<std::string> parentIds;
        if (parentIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentIdsQuery.value(), valueQuery_instance)) {
                parentIds = valueQuery_instance;
            }
        }
        auto parentTypesQuery = request.query().get("parentTypes");
        std::optional<std::string> parentTypes;
        if (parentTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypesQuery.value(), valueQuery_instance)) {
                parentTypes = valueQuery_instance;
            }
        }
        auto actionCategoryQuery = request.query().get("actionCategory");
        std::optional<std::string> actionCategory;
        if (actionCategoryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionCategoryQuery.value(), valueQuery_instance)) {
                actionCategory = valueQuery_instance;
            }
        }
        auto conduitsQuery = request.query().get("conduits");
        std::optional<std::string> conduits;
        if (conduitsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitsQuery.value(), valueQuery_instance)) {
                conduits = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto returnReadMessagesQuery = request.query().get("returnReadMessages");
        std::optional<bool> returnReadMessages;
        if (returnReadMessagesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnReadMessagesQuery.value(), valueQuery_instance)) {
                returnReadMessages = valueQuery_instance;
            }
        }
        auto markAsReadQuery = request.query().get("markAsRead");
        std::optional<bool> markAsRead;
        if (markAsReadQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(markAsReadQuery.value(), valueQuery_instance)) {
                markAsRead = valueQuery_instance;
            }
        }
        auto fromDateQuery = request.query().get("fromDate");
        std::optional<int64_t> fromDate;
        if (fromDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(fromDateQuery.value(), valueQuery_instance)) {
                fromDate = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto returnSentQuery = request.query().get("returnSent");
        std::optional<bool> returnSent;
        if (returnSentQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnSentQuery.value(), valueQuery_instance)) {
                returnSent = valueQuery_instance;
            }
        }
        auto ignoreFlaggedQuery = request.query().get("ignoreFlagged");
        std::optional<bool> ignoreFlagged;
        if (ignoreFlaggedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(ignoreFlaggedQuery.value(), valueQuery_instance)) {
                ignoreFlagged = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_notifications(version, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::register_notification_token_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto tokenQuery = request.query().get("token");
        std::optional<std::string> token;
        if (tokenQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tokenQuery.value(), valueQuery_instance)) {
                token = valueQuery_instance;
            }
        }
        auto pushTypeQuery = request.query().get("pushType");
        std::optional<std::string> pushType;
        if (pushTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(pushTypeQuery.value(), valueQuery_instance)) {
                pushType = valueQuery_instance;
            }
        }
        auto environmentQuery = request.query().get("environment");
        std::optional<std::string> environment;
        if (environmentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(environmentQuery.value(), valueQuery_instance)) {
                environment = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->register_notification_token(version, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::search_blocked_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto searchTagsQuery = request.query().get("searchTags");
        std::optional<std::string> searchTags;
        if (searchTagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchTagsQuery.value(), valueQuery_instance)) {
                searchTags = valueQuery_instance;
            }
        }
        auto eventsQuery = request.query().get("events");
        std::optional<std::string> events;
        if (eventsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventsQuery.value(), valueQuery_instance)) {
                events = valueQuery_instance;
            }
        }
        auto conduitsQuery = request.query().get("conduits");
        std::optional<std::string> conduits;
        if (conduitsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitsQuery.value(), valueQuery_instance)) {
                conduits = valueQuery_instance;
            }
        }
        auto customTypesQuery = request.query().get("customTypes");
        std::optional<std::string> customTypes;
        if (customTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customTypesQuery.value(), valueQuery_instance)) {
                customTypes = valueQuery_instance;
            }
        }
        auto contentTypesQuery = request.query().get("contentTypes");
        std::optional<std::string> contentTypes;
        if (contentTypesQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypesQuery.value(), valueQuery_instance)) {
                contentTypes = valueQuery_instance;
            }
        }
        auto contentIdsQuery = request.query().get("contentIds");
        std::optional<std::string> contentIds;
        if (contentIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentIdsQuery.value(), valueQuery_instance)) {
                contentIds = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_blocked_notifications(version, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::search_notification_template_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto eventQuery = request.query().get("event");
        std::optional<std::string> event;
        if (eventQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(eventQuery.value(), valueQuery_instance)) {
                event = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto globalOnlyQuery = request.query().get("globalOnly");
        std::optional<bool> globalOnly;
        if (globalOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(globalOnlyQuery.value(), valueQuery_instance)) {
                globalOnly = valueQuery_instance;
            }
        }
        auto reservedOnlyQuery = request.query().get("reservedOnly");
        std::optional<bool> reservedOnly;
        if (reservedOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(reservedOnlyQuery.value(), valueQuery_instance)) {
                reservedOnly = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_notification_template(version, accountId, sortField, descending, start, limit, appKey, event, conduit, globalOnly, reservedOnly, keyword, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::search_recipients_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto recipientAccountIdsQuery = request.query().get("recipientAccountIds");
        std::optional<std::string> recipientAccountIds;
        if (recipientAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(recipientAccountIdsQuery.value(), valueQuery_instance)) {
                recipientAccountIds = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_recipients(version, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::search_recipients_count_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto audienceIdQuery = request.query().get("audienceId");
        std::optional<int64_t> audienceId;
        if (audienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(audienceIdQuery.value(), valueQuery_instance)) {
                audienceId = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_recipients_count(version, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::send_batch_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto customMessageQuery = request.query().get("customMessage");
        std::optional<std::string> customMessage;
        if (customMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessageQuery.value(), valueQuery_instance)) {
                customMessage = valueQuery_instance;
            }
        }
        auto contentIdQuery = request.query().get("contentId");
        std::optional<int64_t> contentId;
        if (contentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(contentIdQuery.value(), valueQuery_instance)) {
                contentId = valueQuery_instance;
            }
        }
        auto contentNameQuery = request.query().get("contentName");
        std::optional<std::string> contentName;
        if (contentNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentNameQuery.value(), valueQuery_instance)) {
                contentName = valueQuery_instance;
            }
        }
        auto contentTypeQuery = request.query().get("contentType");
        std::optional<std::string> contentType;
        if (contentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypeQuery.value(), valueQuery_instance)) {
                contentType = valueQuery_instance;
            }
        }
        auto parentIdQuery = request.query().get("parentId");
        std::optional<int64_t> parentId;
        if (parentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentIdQuery.value(), valueQuery_instance)) {
                parentId = valueQuery_instance;
            }
        }
        auto parentTypeQuery = request.query().get("parentType");
        std::optional<std::string> parentType;
        if (parentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypeQuery.value(), valueQuery_instance)) {
                parentType = valueQuery_instance;
            }
        }
    


        try {





            this->send_batch_notifications(version, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::send_custom_notifications_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto receiverAccountIdsQuery = request.query().get("receiverAccountIds");
        std::optional<std::string> receiverAccountIds;
        if (receiverAccountIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(receiverAccountIdsQuery.value(), valueQuery_instance)) {
                receiverAccountIds = valueQuery_instance;
            }
        }
        auto includeFriendGroupQuery = request.query().get("includeFriendGroup");
        std::optional<bool> includeFriendGroup;
        if (includeFriendGroupQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFriendGroupQuery.value(), valueQuery_instance)) {
                includeFriendGroup = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto gameTypeQuery = request.query().get("gameType");
        std::optional<std::string> gameType;
        if (gameTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameTypeQuery.value(), valueQuery_instance)) {
                gameType = valueQuery_instance;
            }
        }
        auto conduitQuery = request.query().get("conduit");
        std::optional<std::string> conduit;
        if (conduitQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(conduitQuery.value(), valueQuery_instance)) {
                conduit = valueQuery_instance;
            }
        }
        auto contentIdQuery = request.query().get("contentId");
        std::optional<int64_t> contentId;
        if (contentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(contentIdQuery.value(), valueQuery_instance)) {
                contentId = valueQuery_instance;
            }
        }
        auto contentNameQuery = request.query().get("contentName");
        std::optional<std::string> contentName;
        if (contentNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentNameQuery.value(), valueQuery_instance)) {
                contentName = valueQuery_instance;
            }
        }
        auto contentTypeQuery = request.query().get("contentType");
        std::optional<std::string> contentType;
        if (contentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(contentTypeQuery.value(), valueQuery_instance)) {
                contentType = valueQuery_instance;
            }
        }
        auto parentIdQuery = request.query().get("parentId");
        std::optional<int64_t> parentId;
        if (parentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentIdQuery.value(), valueQuery_instance)) {
                parentId = valueQuery_instance;
            }
        }
        auto parentTypeQuery = request.query().get("parentType");
        std::optional<std::string> parentType;
        if (parentTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(parentTypeQuery.value(), valueQuery_instance)) {
                parentType = valueQuery_instance;
            }
        }
        auto actionCategoryQuery = request.query().get("actionCategory");
        std::optional<std::string> actionCategory;
        if (actionCategoryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(actionCategoryQuery.value(), valueQuery_instance)) {
                actionCategory = valueQuery_instance;
            }
        }
        auto subjectQuery = request.query().get("subject");
        std::optional<std::string> subject;
        if (subjectQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subjectQuery.value(), valueQuery_instance)) {
                subject = valueQuery_instance;
            }
        }
        auto customMessageQuery = request.query().get("customMessage");
        std::optional<std::string> customMessage;
        if (customMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessageQuery.value(), valueQuery_instance)) {
                customMessage = valueQuery_instance;
            }
        }
        auto friendOnlyAPNSQuery = request.query().get("friendOnlyAPNS");
        std::optional<bool> friendOnlyAPNS;
        if (friendOnlyAPNSQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(friendOnlyAPNSQuery.value(), valueQuery_instance)) {
                friendOnlyAPNS = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->send_custom_notifications(version, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void NotificationApi::update_notification_template_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto notificationTemplateIdQuery = request.query().get("notificationTemplateId");
        std::optional<int64_t> notificationTemplateId;
        if (notificationTemplateIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(notificationTemplateIdQuery.value(), valueQuery_instance)) {
                notificationTemplateId = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto bodyQuery = request.query().get("body");
        std::optional<std::string> body;
        if (bodyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(bodyQuery.value(), valueQuery_instance)) {
                body = valueQuery_instance;
            }
        }
        auto tagsQuery = request.query().get("tags");
        std::optional<std::string> tags;
        if (tagsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagsQuery.value(), valueQuery_instance)) {
                tags = valueQuery_instance;
            }
        }
    


        try {





            this->update_notification_template(version, accountId, notificationTemplateId, title, body, tags, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void NotificationApi::notification_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

