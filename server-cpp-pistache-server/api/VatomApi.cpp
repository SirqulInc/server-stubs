/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "VatomApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;

const std::string VatomApi::base = "";

VatomApi::VatomApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void VatomApi::init() {
    setupRoutes();
}

void VatomApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/vatom/me/rels/following/create", Routes::bind(&VatomApi::create_following_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/spaces/create", Routes::bind(&VatomApi::create_space_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/events/create", Routes::bind(&VatomApi::create_vatom_event_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/me/rels/following/delete", Routes::bind(&VatomApi::delete_following_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/campaign/points/delete", Routes::bind(&VatomApi::delete_points_balance_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/spaces/delete", Routes::bind(&VatomApi::delete_space_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/events/delete", Routes::bind(&VatomApi::delete_vatom_event_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/vatoms/delete", Routes::bind(&VatomApi::delete_vatom_nft_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/vatoms/execute-action", Routes::bind(&VatomApi::execute_action_on_nft_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/vatoms/geo-map/search", Routes::bind(&VatomApi::geomap_search_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/behaviors", Routes::bind(&VatomApi::get_business_behaviors_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/coins/get", Routes::bind(&VatomApi::get_business_coins_balance_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/me/businesses", Routes::bind(&VatomApi::get_business_ids_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/get", Routes::bind(&VatomApi::get_business_info_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/users", Routes::bind(&VatomApi::get_business_users_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign-groups/entities", Routes::bind(&VatomApi::get_campaign_group_entities_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign-groups/rules", Routes::bind(&VatomApi::get_campaign_group_rules_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign-groups/stats", Routes::bind(&VatomApi::get_campaign_group_stats_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign-groups/get", Routes::bind(&VatomApi::get_campaign_info_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/events/guests/get", Routes::bind(&VatomApi::get_event_guest_list_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/me/inventory", Routes::bind(&VatomApi::get_inventory_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/me/rels/following", Routes::bind(&VatomApi::get_my_following_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/u/campaign/points/get", Routes::bind(&VatomApi::get_points_balance_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign/u/points/get", Routes::bind(&VatomApi::get_points_balance_as_business_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/spaces/get", Routes::bind(&VatomApi::get_space_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/users/coins/get", Routes::bind(&VatomApi::get_user_coins_as_business_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/u/coins/get", Routes::bind(&VatomApi::get_user_coins_balance_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/users/rels/followers", Routes::bind(&VatomApi::get_user_followers_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/users/rels/following", Routes::bind(&VatomApi::get_user_following_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/user/get", Routes::bind(&VatomApi::get_user_info_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/me/get", Routes::bind(&VatomApi::get_user_profile_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/events/get", Routes::bind(&VatomApi::get_vatom_event_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/vatoms/get", Routes::bind(&VatomApi::get_vatom_nft_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/communities/search", Routes::bind(&VatomApi::list_communities_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/events/search", Routes::bind(&VatomApi::list_events_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/spaces/search", Routes::bind(&VatomApi::list_spaces_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/u/coins/txns/search", Routes::bind(&VatomApi::list_user_coin_transactions_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/users/coins/txns/search", Routes::bind(&VatomApi::list_user_coin_transactions_as_business_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/me/vatoms/actions", Routes::bind(&VatomApi::perform_action_on_nft_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/redemptions", Routes::bind(&VatomApi::redeem_nft_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/users/coins/redeem", Routes::bind(&VatomApi::redeem_user_coins_as_business_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/search", Routes::bind(&VatomApi::search_businesses_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/b/campaign-groups/search", Routes::bind(&VatomApi::search_campaign_groups_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/me/identities/search", Routes::bind(&VatomApi::search_identities_handler, this));
    Routes::Get(*router, base + "/api/:version/vatom/user-inventory/search", Routes::bind(&VatomApi::search_inventory_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/campaigns/send", Routes::bind(&VatomApi::send_nft_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/campaign/u/points/update", Routes::bind(&VatomApi::set_points_balance_as_business_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/u/coins/transfer", Routes::bind(&VatomApi::transfer_user_coins_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/coins/update", Routes::bind(&VatomApi::update_business_coins_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/events/guests/update", Routes::bind(&VatomApi::update_event_guest_list_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/spaces/update", Routes::bind(&VatomApi::update_space_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/users/coins/update", Routes::bind(&VatomApi::update_user_coins_as_business_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/me/update", Routes::bind(&VatomApi::update_user_profile_handler, this));
    Routes::Post(*router, base + "/api/:version/vatom/b/events/update", Routes::bind(&VatomApi::update_vatom_event_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&VatomApi::vatom_api_default_handler, this));
}

void VatomApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> VatomApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void VatomApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> VatomApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void VatomApi::create_following_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->create_following(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::create_space_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->create_space(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::create_vatom_event_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->create_vatom_event(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::delete_following_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomRelsKeyQuery = request.query().get("vatomRelsKey");
        std::optional<std::string> vatomRelsKey;
        if (vatomRelsKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomRelsKeyQuery.value(), valueQuery_instance)) {
                vatomRelsKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->delete_following(version, accountId, vatomRelsKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::delete_points_balance_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->delete_points_balance(version, accountId, appKey, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::delete_space_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomSpaceIdQuery = request.query().get("vatomSpaceId");
        std::optional<std::string> vatomSpaceId;
        if (vatomSpaceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomSpaceIdQuery.value(), valueQuery_instance)) {
                vatomSpaceId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->delete_space(version, accountId, appKey, vatomSpaceId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::delete_vatom_event_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomEventIdQuery = request.query().get("vatomEventId");
        std::optional<std::string> vatomEventId;
        if (vatomEventIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomEventIdQuery.value(), valueQuery_instance)) {
                vatomEventId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->delete_vatom_event(version, accountId, appKey, vatomEventId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::delete_vatom_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomIdQuery = request.query().get("vatomId");
        std::optional<std::string> vatomId;
        if (vatomIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomIdQuery.value(), valueQuery_instance)) {
                vatomId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->delete_vatom_nft(version, accountId, vatomId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::execute_action_on_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomIdQuery = request.query().get("vatomId");
        std::optional<std::string> vatomId;
        if (vatomIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomIdQuery.value(), valueQuery_instance)) {
                vatomId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->execute_action_on_nft(version, accountId, vatomId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::geomap_search_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->geomap_search(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_business_behaviors_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_business_behaviors(version, accountId, appKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_business_coins_balance_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_business_coins_balance(version, accountId, appKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_business_ids_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_business_ids(version, accountId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_business_info_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_business_info(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_business_users_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_business_users(version, accountId, appKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_campaign_group_entities_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_campaign_group_entities(version, accountId, appKey, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_campaign_group_rules_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_campaign_group_rules(version, accountId, appKey, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_campaign_group_stats_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_campaign_group_stats(version, accountId, appKey, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_campaign_info_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_campaign_info(version, accountId, appKey, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_event_guest_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomEventIdQuery = request.query().get("vatomEventId");
        std::optional<std::string> vatomEventId;
        if (vatomEventIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomEventIdQuery.value(), valueQuery_instance)) {
                vatomEventId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_event_guest_list(version, accountId, appKey, vatomEventId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_inventory_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_inventory(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_my_following_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_my_following(version, accountId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_points_balance_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_points_balance(version, accountId, vatomUserId, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_points_balance_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_points_balance_as_business(version, accountId, appKey, vatomUserId, vatomCampaignId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_space_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomSpaceIdQuery = request.query().get("vatomSpaceId");
        std::optional<std::string> vatomSpaceId;
        if (vatomSpaceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomSpaceIdQuery.value(), valueQuery_instance)) {
                vatomSpaceId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_space(version, accountId, appKey, vatomSpaceId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_coins_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_coins_as_business(version, accountId, vatomUserId, appKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_coins_balance_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_coins_balance(version, accountId, vatomUserId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_followers_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_followers(version, accountId, vatomUserId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_following_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_following(version, accountId, vatomUserId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_info_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_info(version, accountId, vatomUserId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_user_profile_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_user_profile(version, accountId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_vatom_event_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomEventIdQuery = request.query().get("vatomEventId");
        std::optional<std::string> vatomEventId;
        if (vatomEventIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomEventIdQuery.value(), valueQuery_instance)) {
                vatomEventId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_vatom_event(version, accountId, appKey, vatomEventId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::get_vatom_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomIdQuery = request.query().get("vatomId");
        std::optional<std::string> vatomId;
        if (vatomIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomIdQuery.value(), valueQuery_instance)) {
                vatomId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->get_vatom_nft(version, accountId, vatomId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::list_communities_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->list_communities(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::list_events_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->list_events(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::list_spaces_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->list_spaces(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::list_user_coin_transactions_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->list_user_coin_transactions(version, accountId, vatomUserId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::list_user_coin_transactions_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->list_user_coin_transactions_as_business(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::perform_action_on_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomIdQuery = request.query().get("vatomId");
        std::optional<std::string> vatomId;
        if (vatomIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomIdQuery.value(), valueQuery_instance)) {
                vatomId = valueQuery_instance;
            }
        }
        auto vatomActionQuery = request.query().get("vatomAction");
        std::optional<std::string> vatomAction;
        if (vatomActionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomActionQuery.value(), valueQuery_instance)) {
                vatomAction = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->perform_action_on_nft(version, accountId, vatomId, vatomAction, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::redeem_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->redeem_nft(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::redeem_user_coins_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->redeem_user_coins_as_business(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::search_businesses_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->search_businesses(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::search_campaign_groups_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->search_campaign_groups(version, accountId, appKey, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::search_identities_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->search_identities(version, accountId, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::search_inventory_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->search_inventory(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::send_nft_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->send_nft(version, accountId, appKey, vatomCampaignId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::set_points_balance_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomCampaignIdQuery = request.query().get("vatomCampaignId");
        std::optional<std::string> vatomCampaignId;
        if (vatomCampaignIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomCampaignIdQuery.value(), valueQuery_instance)) {
                vatomCampaignId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->set_points_balance_as_business(version, accountId, appKey, vatomUserId, vatomCampaignId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::transfer_user_coins_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->transfer_user_coins(version, accountId, vatomUserId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_business_coins_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_business_coins(version, accountId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_event_guest_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomEventIdQuery = request.query().get("vatomEventId");
        std::optional<std::string> vatomEventId;
        if (vatomEventIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomEventIdQuery.value(), valueQuery_instance)) {
                vatomEventId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_event_guest_list(version, accountId, appKey, vatomEventId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_space_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomSpaceIdQuery = request.query().get("vatomSpaceId");
        std::optional<std::string> vatomSpaceId;
        if (vatomSpaceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomSpaceIdQuery.value(), valueQuery_instance)) {
                vatomSpaceId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_space(version, accountId, appKey, vatomSpaceId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_user_coins_as_business_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomUserIdQuery = request.query().get("vatomUserId");
        std::optional<std::string> vatomUserId;
        if (vatomUserIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomUserIdQuery.value(), valueQuery_instance)) {
                vatomUserId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_user_coins_as_business(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_user_profile_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_user_profile(version, accountId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void VatomApi::update_vatom_event_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto vatomEventIdQuery = request.query().get("vatomEventId");
        std::optional<std::string> vatomEventId;
        if (vatomEventIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomEventIdQuery.value(), valueQuery_instance)) {
                vatomEventId = valueQuery_instance;
            }
        }
        auto vatomParametersQuery = request.query().get("vatomParameters");
        std::optional<std::string> vatomParameters;
        if (vatomParametersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(vatomParametersQuery.value(), valueQuery_instance)) {
                vatomParameters = valueQuery_instance;
            }
        }
        auto returnRawResponseQuery = request.query().get("returnRawResponse");
        std::optional<bool> returnRawResponse;
        if (returnRawResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnRawResponseQuery.value(), valueQuery_instance)) {
                returnRawResponse = valueQuery_instance;
            }
        }
    


        try {





            this->update_vatom_event(version, accountId, appKey, vatomEventId, vatomParameters, returnRawResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void VatomApi::vatom_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

