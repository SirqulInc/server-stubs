/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
/*
 * ObjectStoreApi.h
 *
 * 
 */

#ifndef ObjectStoreApi_H_
#define ObjectStoreApi_H_


#include "ApiBase.h"

#include <pistache/http.h>
#include <pistache/router.h>
#include <pistache/http_headers.h>

#include <optional>
#include <utility>

#include "ObjectStoreResponse.h"
#include <string>

namespace org::openapitools::server::api
{

class  ObjectStoreApi : public ApiBase {
public:
    explicit ObjectStoreApi(const std::shared_ptr<Pistache::Rest::Router>& rtr);
    ~ObjectStoreApi() override = default;
    void init() override;

    static const std::string base;

private:
    void setupRoutes();

    void add_field_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void create_data_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void create_object_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void delete_data_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void delete_field_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void delete_object_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_data_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void get_object_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void search_data_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void search_object_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void update_data_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);
    void object_store_api_default_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response);

    /// <summary>
    /// Helper function to handle unexpected Exceptions during Parameter parsing and validation.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual void handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during Parameter parsing and validation.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual std::pair<Pistache::Http::Code, std::string> handleParsingException(const std::exception& ex) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during processing of the request in handler functions.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual void handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept;

    /// <summary>
    /// Helper function to handle unexpected Exceptions during processing of the request in handler functions.
    /// May be overridden to return custom error formats. This is called inside a catch block.
    /// Important: When overriding, do not call `throw ex;`, but instead use `throw;`.
    /// </summary>
    virtual std::pair<Pistache::Http::Code, std::string> handleOperationException(const std::exception& ex) const noexcept;

    /// <summary>
    /// Create Field
    /// </summary>
    /// <remarks>
    /// Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the logged in user</param>
    /// <param name="appKey">The application key for updating an existing application</param>
    /// <param name="objectName">The name of the object to add the field to</param>
    /// <param name="fieldName">field name The name of the field to add.</param>
    /// <param name="fieldType">field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY</param>
    virtual void add_field( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &objectName, const std::optional<std::string> &fieldName, const std::optional<std::string> &fieldType, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Create Data
    /// </summary>
    /// <remarks>
    /// Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="objectName">the name of the object to create data for</param>
    /// <param name="accountId">the account id (optional, default to 0L)</param>
    /// <param name="body"> (optional)</param>
    virtual void create_data( const double &version, const std::string &objectName, const std::optional<int64_t> &accountId, const std::string &body, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Create Object
    /// </summary>
    /// <remarks>
    /// Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the logged in user</param>
    /// <param name="appKey">The application key for updating an existing application</param>
    /// <param name="objectName">The name of the object to create</param>
    virtual void create_object( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &objectName, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Delete Data
    /// </summary>
    /// <remarks>
    /// Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="objectName">The name of the object to search upon</param>
    /// <param name="objectId">objectId The id of the record to return</param>
    /// <param name="accountId">The account id of the logged in user (optional, default to 0L)</param>
    virtual void delete_data( const double &version, const std::string &objectName, const std::string &objectId, const std::optional<int64_t> &accountId, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Delete Field
    /// </summary>
    /// <remarks>
    /// Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the logged in user</param>
    /// <param name="appKey">The application key for updating an existing application</param>
    /// <param name="objectName">The name of the object to remove the field from</param>
    /// <param name="fieldName">field name The name of the field to remove.</param>
    virtual void delete_field( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &objectName, const std::optional<std::string> &fieldName, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Delete Object
    /// </summary>
    /// <remarks>
    /// Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">the id of the logged in user</param>
    /// <param name="appKey">the application key</param>
    /// <param name="objectName">the name of the object to delete</param>
    virtual void delete_object( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &objectName, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Get Data
    /// </summary>
    /// <remarks>
    /// Get a specific record from a specified object.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="objectName">The name of the object to search upon</param>
    /// <param name="objectId">objectId The id of the record to return</param>
    /// <param name="accountId">The account id of the logged in user (optional, default to 0L)</param>
    /// <param name="include"> (optional, default to &quot;&quot;)</param>
    virtual void get_data( const double &version, const std::string &objectName, const std::string &objectId, const std::optional<int64_t> &accountId, const std::optional<std::string> &include, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Get Object
    /// </summary>
    /// <remarks>
    /// Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the logged in user</param>
    /// <param name="appKey">The application key for updating an existing application</param>
    /// <param name="objectName">The name of the object to get the definition for</param>
    virtual void get_object( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<std::string> &objectName, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Search Data
    /// </summary>
    /// <remarks>
    /// Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="objectName">The name of the object to search upon</param>
    /// <param name="count">If true just return the record count of the search. False (default) will return the actual records</param>
    /// <param name="start">The start of the pagination</param>
    /// <param name="limit">The limit of the pagination</param>
    /// <param name="accountId">The account id of the logged in user (optional, default to 0L)</param>
    /// <param name="criteria">The search criteria (optional, default to &quot;&quot;)</param>
    /// <param name="order">The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional, default to &quot;&quot;)</param>
    /// <param name="include"> (optional, default to &quot;&quot;)</param>
    virtual void search_data( const double &version, const std::string &objectName, const std::optional<bool> &count, const std::optional<int64_t> &start, const std::optional<int64_t> &limit, const std::optional<int64_t> &accountId, const std::optional<std::string> &criteria, const std::optional<std::string> &order, const std::optional<std::string> &include, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Search Objects
    /// </summary>
    /// <remarks>
    /// Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="accountId">The account id of the logged in user</param>
    /// <param name="appKey">The application key for updating an existing application</param>
    /// <param name="start">The start of the pagination</param>
    /// <param name="limit">The limit of the pagination</param>
    /// <param name="keyword">The name of the object(s) to search for, can be a partial match (optional, default to &quot;&quot;)</param>
    virtual void search_object( const double &version, const std::optional<int64_t> &accountId, const std::optional<std::string> &appKey, const std::optional<int64_t> &start, const std::optional<int64_t> &limit, const std::optional<std::string> &keyword, Pistache::Http::ResponseWriter &response) = 0;
    /// <summary>
    /// Update Data
    /// </summary>
    /// <remarks>
    /// Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
    /// </remarks>
    /// <param name="version"></param>
    /// <param name="objectName">The name of the object to search upon</param>
    /// <param name="objectId">objectId The id of the record to return</param>
    /// <param name="accountId">The account id of the logged in user (optional, default to 0L)</param>
    /// <param name="body"> (optional)</param>
    virtual void update_data( const double &version, const std::string &objectName, const std::string &objectId, const std::optional<int64_t> &accountId, const std::string &body, Pistache::Http::ResponseWriter &response) = 0;

};

} // namespace org::openapitools::server::api

#endif /* ObjectStoreApi_H_ */

