/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "EmployeeApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string EmployeeApi::base = "";

EmployeeApi::EmployeeApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void EmployeeApi::init() {
    setupRoutes();
}

void EmployeeApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/employee/assign", Routes::bind(&EmployeeApi::assign_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/assignToLocation", Routes::bind(&EmployeeApi::assign_to_location_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/create", Routes::bind(&EmployeeApi::create_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/delete", Routes::bind(&EmployeeApi::delete_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/get", Routes::bind(&EmployeeApi::get_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/search", Routes::bind(&EmployeeApi::search_employees_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/unassign", Routes::bind(&EmployeeApi::unassign_employee_handler, this));
    Routes::Post(*router, base + "/api/:version/employee/update", Routes::bind(&EmployeeApi::update_employee_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&EmployeeApi::employee_api_default_handler, this));
}

void EmployeeApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> EmployeeApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void EmployeeApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> EmployeeApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void EmployeeApi::assign_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto managerAccountIdQuery = request.query().get("managerAccountId");
        std::optional<int64_t> managerAccountId;
        if (managerAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(managerAccountIdQuery.value(), valueQuery_instance)) {
                managerAccountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
    


        try {





            this->assign_employee(version, accountId, managerAccountId, employeeAccountId, role, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::assign_to_location_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto assignQuery = request.query().get("assign");
        std::optional<bool> assign;
        if (assignQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(assignQuery.value(), valueQuery_instance)) {
                assign = valueQuery_instance;
            }
        }
    


        try {





            this->assign_to_location_employee(version, accountId, retailerLocationId, employeeAccountId, assign, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::create_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto managerAccountIdQuery = request.query().get("managerAccountId");
        std::optional<int64_t> managerAccountId;
        if (managerAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(managerAccountIdQuery.value(), valueQuery_instance)) {
                managerAccountId = valueQuery_instance;
            }
        }
        auto usernameQuery = request.query().get("username");
        std::optional<std::string> username;
        if (usernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(usernameQuery.value(), valueQuery_instance)) {
                username = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto prefixNameQuery = request.query().get("prefixName");
        std::optional<std::string> prefixName;
        if (prefixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(prefixNameQuery.value(), valueQuery_instance)) {
                prefixName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto middleNameQuery = request.query().get("middleName");
        std::optional<std::string> middleName;
        if (middleNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(middleNameQuery.value(), valueQuery_instance)) {
                middleName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto suffixNameQuery = request.query().get("suffixName");
        std::optional<std::string> suffixName;
        if (suffixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixNameQuery.value(), valueQuery_instance)) {
                suffixName = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto aboutUsQuery = request.query().get("aboutUs");
        std::optional<std::string> aboutUs;
        if (aboutUsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(aboutUsQuery.value(), valueQuery_instance)) {
                aboutUs = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto homePhoneQuery = request.query().get("homePhone");
        std::optional<std::string> homePhone;
        if (homePhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(homePhoneQuery.value(), valueQuery_instance)) {
                homePhone = valueQuery_instance;
            }
        }
        auto cellPhoneQuery = request.query().get("cellPhone");
        std::optional<std::string> cellPhone;
        if (cellPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneQuery.value(), valueQuery_instance)) {
                cellPhone = valueQuery_instance;
            }
        }
        auto cellPhoneCarrierQuery = request.query().get("cellPhoneCarrier");
        std::optional<std::string> cellPhoneCarrier;
        if (cellPhoneCarrierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneCarrierQuery.value(), valueQuery_instance)) {
                cellPhoneCarrier = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto streetAddressQuery = request.query().get("streetAddress");
        std::optional<std::string> streetAddress;
        if (streetAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddressQuery.value(), valueQuery_instance)) {
                streetAddress = valueQuery_instance;
            }
        }
        auto streetAddress2Query = request.query().get("streetAddress2");
        std::optional<std::string> streetAddress2;
        if (streetAddress2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddress2Query.value(), valueQuery_instance)) {
                streetAddress2 = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto settingsAppKeyQuery = request.query().get("settingsAppKey");
        std::optional<std::string> settingsAppKey;
        if (settingsAppKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(settingsAppKeyQuery.value(), valueQuery_instance)) {
                settingsAppKey = valueQuery_instance;
            }
        }
        auto appBlobQuery = request.query().get("appBlob");
        std::optional<std::string> appBlob;
        if (appBlobQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appBlobQuery.value(), valueQuery_instance)) {
                appBlob = valueQuery_instance;
            }
        }
        auto assignedDeviceIdQuery = request.query().get("assignedDeviceId");
        std::optional<std::string> assignedDeviceId;
        if (assignedDeviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(assignedDeviceIdQuery.value(), valueQuery_instance)) {
                assignedDeviceId = valueQuery_instance;
            }
        }
    


        try {





            this->create_employee(version, accountId, managerAccountId, username, password, name, prefixName, firstName, middleName, lastName, suffixName, title, aboutUs, assetId, gender, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, role, retailerLocationIds, settingsAppKey, appBlob, assignedDeviceId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::delete_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_employee(version, accountId, employeeAccountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::get_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
        auto settingsAppKeyQuery = request.query().get("settingsAppKey");
        std::optional<std::string> settingsAppKey;
        if (settingsAppKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(settingsAppKeyQuery.value(), valueQuery_instance)) {
                settingsAppKey = valueQuery_instance;
            }
        }
    


        try {





            this->get_employee(version, accountId, employeeAccountId, settingsAppKey, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::search_employees_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto retailerIdQuery = request.query().get("retailerId");
        std::optional<int64_t> retailerId;
        if (retailerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerIdQuery.value(), valueQuery_instance)) {
                retailerId = valueQuery_instance;
            }
        }
        auto retailerLocationIdQuery = request.query().get("retailerLocationId");
        std::optional<int64_t> retailerLocationId;
        if (retailerLocationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(retailerLocationIdQuery.value(), valueQuery_instance)) {
                retailerLocationId = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto iQuery = request.query().get("_i");
        std::optional<int32_t> i;
        if (iQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(iQuery.value(), valueQuery_instance)) {
                i = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto managedOnlyQuery = request.query().get("managedOnly");
        std::optional<bool> managedOnly;
        if (managedOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(managedOnlyQuery.value(), valueQuery_instance)) {
                managedOnly = valueQuery_instance;
            }
        }
        auto settingsAppKeyQuery = request.query().get("settingsAppKey");
        std::optional<std::string> settingsAppKey;
        if (settingsAppKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(settingsAppKeyQuery.value(), valueQuery_instance)) {
                settingsAppKey = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto queryQuery = request.query().get("query");
        std::optional<std::string> query;
        if (queryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(queryQuery.value(), valueQuery_instance)) {
                query = valueQuery_instance;
            }
        }
    


        try {





            this->search_employees(version, accountId, role, retailerId, retailerLocationId, q, keyword, sortField, descending, i, start, l, limit, activeOnly, managedOnly, settingsAppKey, categoryIds, query, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::unassign_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
    


        try {





            this->unassign_employee(version, accountId, employeeAccountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void EmployeeApi::update_employee_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto employeeAccountIdQuery = request.query().get("employeeAccountId");
        std::optional<int64_t> employeeAccountId;
        if (employeeAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(employeeAccountIdQuery.value(), valueQuery_instance)) {
                employeeAccountId = valueQuery_instance;
            }
        }
        auto managerAccountIdQuery = request.query().get("managerAccountId");
        std::optional<int64_t> managerAccountId;
        if (managerAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(managerAccountIdQuery.value(), valueQuery_instance)) {
                managerAccountId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto prefixNameQuery = request.query().get("prefixName");
        std::optional<std::string> prefixName;
        if (prefixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(prefixNameQuery.value(), valueQuery_instance)) {
                prefixName = valueQuery_instance;
            }
        }
        auto firstNameQuery = request.query().get("firstName");
        std::optional<std::string> firstName;
        if (firstNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(firstNameQuery.value(), valueQuery_instance)) {
                firstName = valueQuery_instance;
            }
        }
        auto middleNameQuery = request.query().get("middleName");
        std::optional<std::string> middleName;
        if (middleNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(middleNameQuery.value(), valueQuery_instance)) {
                middleName = valueQuery_instance;
            }
        }
        auto lastNameQuery = request.query().get("lastName");
        std::optional<std::string> lastName;
        if (lastNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(lastNameQuery.value(), valueQuery_instance)) {
                lastName = valueQuery_instance;
            }
        }
        auto suffixNameQuery = request.query().get("suffixName");
        std::optional<std::string> suffixName;
        if (suffixNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(suffixNameQuery.value(), valueQuery_instance)) {
                suffixName = valueQuery_instance;
            }
        }
        auto titleQuery = request.query().get("title");
        std::optional<std::string> title;
        if (titleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(titleQuery.value(), valueQuery_instance)) {
                title = valueQuery_instance;
            }
        }
        auto assetIdQuery = request.query().get("assetId");
        std::optional<int64_t> assetId;
        if (assetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIdQuery.value(), valueQuery_instance)) {
                assetId = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto homePhoneQuery = request.query().get("homePhone");
        std::optional<std::string> homePhone;
        if (homePhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(homePhoneQuery.value(), valueQuery_instance)) {
                homePhone = valueQuery_instance;
            }
        }
        auto cellPhoneQuery = request.query().get("cellPhone");
        std::optional<std::string> cellPhone;
        if (cellPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneQuery.value(), valueQuery_instance)) {
                cellPhone = valueQuery_instance;
            }
        }
        auto cellPhoneCarrierQuery = request.query().get("cellPhoneCarrier");
        std::optional<std::string> cellPhoneCarrier;
        if (cellPhoneCarrierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cellPhoneCarrierQuery.value(), valueQuery_instance)) {
                cellPhoneCarrier = valueQuery_instance;
            }
        }
        auto businessPhoneQuery = request.query().get("businessPhone");
        std::optional<std::string> businessPhone;
        if (businessPhoneQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(businessPhoneQuery.value(), valueQuery_instance)) {
                businessPhone = valueQuery_instance;
            }
        }
        auto emailAddressQuery = request.query().get("emailAddress");
        std::optional<std::string> emailAddress;
        if (emailAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(emailAddressQuery.value(), valueQuery_instance)) {
                emailAddress = valueQuery_instance;
            }
        }
        auto streetAddressQuery = request.query().get("streetAddress");
        std::optional<std::string> streetAddress;
        if (streetAddressQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddressQuery.value(), valueQuery_instance)) {
                streetAddress = valueQuery_instance;
            }
        }
        auto streetAddress2Query = request.query().get("streetAddress2");
        std::optional<std::string> streetAddress2;
        if (streetAddress2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(streetAddress2Query.value(), valueQuery_instance)) {
                streetAddress2 = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto zipcodeQuery = request.query().get("zipcode");
        std::optional<std::string> zipcode;
        if (zipcodeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipcodeQuery.value(), valueQuery_instance)) {
                zipcode = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto roleQuery = request.query().get("role");
        std::optional<std::string> role;
        if (roleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(roleQuery.value(), valueQuery_instance)) {
                role = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto passwordQuery = request.query().get("password");
        std::optional<std::string> password;
        if (passwordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(passwordQuery.value(), valueQuery_instance)) {
                password = valueQuery_instance;
            }
        }
        auto retailerLocationIdsQuery = request.query().get("retailerLocationIds");
        std::optional<std::string> retailerLocationIds;
        if (retailerLocationIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(retailerLocationIdsQuery.value(), valueQuery_instance)) {
                retailerLocationIds = valueQuery_instance;
            }
        }
        auto settingsAppKeyQuery = request.query().get("settingsAppKey");
        std::optional<std::string> settingsAppKey;
        if (settingsAppKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(settingsAppKeyQuery.value(), valueQuery_instance)) {
                settingsAppKey = valueQuery_instance;
            }
        }
        auto appBlobQuery = request.query().get("appBlob");
        std::optional<std::string> appBlob;
        if (appBlobQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appBlobQuery.value(), valueQuery_instance)) {
                appBlob = valueQuery_instance;
            }
        }
        auto assignedDeviceIdQuery = request.query().get("assignedDeviceId");
        std::optional<std::string> assignedDeviceId;
        if (assignedDeviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(assignedDeviceIdQuery.value(), valueQuery_instance)) {
                assignedDeviceId = valueQuery_instance;
            }
        }
    


        try {





            this->update_employee(version, accountId, employeeAccountId, managerAccountId, name, prefixName, firstName, middleName, lastName, suffixName, title, assetId, gender, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, role, active, password, retailerLocationIds, settingsAppKey, appBlob, assignedDeviceId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void EmployeeApi::employee_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

