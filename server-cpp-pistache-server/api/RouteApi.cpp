/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "RouteApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string RouteApi::base = "";

RouteApi::RouteApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void RouteApi::init() {
    setupRoutes();
}

void RouteApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/route/:routeId/approve", Routes::bind(&RouteApi::approve_route_handler, this));
    Routes::Post(*router, base + "/api/:version/route/:routeId/copy", Routes::bind(&RouteApi::copy_route_handler, this));
    Routes::Post(*router, base + "/api/:version/route", Routes::bind(&RouteApi::create_route_handler, this));
    Routes::Put(*router, base + "/api/:version/route/:routeId/directions", Routes::bind(&RouteApi::create_route_directions_handler, this));
    Routes::Put(*router, base + "/api/:version/route/:routeId/polyline", Routes::bind(&RouteApi::create_route_polyline_handler, this));
    Routes::Delete(*router, base + "/api/:version/route/:routeId", Routes::bind(&RouteApi::delete_route_handler, this));
    Routes::Post(*router, base + "/api/:version/route/:routeId/disapprove", Routes::bind(&RouteApi::disapprove_route_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId", Routes::bind(&RouteApi::get_route_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId/directions", Routes::bind(&RouteApi::get_route_directions_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId/shipments", Routes::bind(&RouteApi::get_route_shipments_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId/stop/:stopId", Routes::bind(&RouteApi::get_route_stop_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId/stops", Routes::bind(&RouteApi::get_route_stops_handler, this));
    Routes::Get(*router, base + "/api/:version/route/:routeId/stop/:stopId/shipments", Routes::bind(&RouteApi::get_shipments_at_stop_handler, this));
    Routes::Post(*router, base + "/api/:version/route/:routeId/optimize", Routes::bind(&RouteApi::optimize_route_handler, this));
    Routes::Delete(*router, base + "/api/:version/route/:routeId/stop/:stopId", Routes::bind(&RouteApi::remove_stop_handler, this));
    Routes::Patch(*router, base + "/api/:version/route/:routeId/stops/reorder", Routes::bind(&RouteApi::reorder_route_stops_patch_handler, this));
    Routes::Post(*router, base + "/api/:version/route/:routeId/stops/reorder", Routes::bind(&RouteApi::reorder_route_stops_post_handler, this));
    Routes::Get(*router, base + "/api/:version/route", Routes::bind(&RouteApi::search_routes_handler, this));
    Routes::Post(*router, base + "/api/:version/route/:id/driver/:driverId", Routes::bind(&RouteApi::set_driver_handler, this));
    Routes::Put(*router, base + "/api/:version/route/:routeId", Routes::bind(&RouteApi::update_route_handler, this));
    Routes::Put(*router, base + "/api/:version/route/:routeId/stop/:stopId", Routes::bind(&RouteApi::update_route_stop_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&RouteApi::route_api_default_handler, this));
}

void RouteApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RouteApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void RouteApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> RouteApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void RouteApi::approve_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->approve_route(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::copy_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        // Getting the body param
        
        Route body;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            body.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->copy_route(version, routeId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::create_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        // Getting the body param
        
        Route body;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            body.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->create_route(version, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::create_route_directions_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->create_route_directions(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::create_route_polyline_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->create_route_polyline(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::delete_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->delete_route(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::disapprove_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->disapprove_route(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
        // Getting the query params
        auto showInheritedPropertiesQuery = request.query().get("showInheritedProperties");
        std::optional<bool> showInheritedProperties;
        if (showInheritedPropertiesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showInheritedPropertiesQuery.value(), valueQuery_instance)) {
                showInheritedProperties = valueQuery_instance;
            }
        }
    


        try {





            this->get_route(version, routeId, showInheritedProperties, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_route_directions_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->get_route_directions(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_route_shipments_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->get_route_shipments(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_route_stop_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        auto stopId = request.param(":stopId").as<int64_t>();
        
        
    


        try {





            this->get_route_stop(version, routeId, stopId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_route_stops_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
        // Getting the query params
        auto confirmedOnlyQuery = request.query().get("confirmedOnly");
        std::optional<bool> confirmedOnly;
        if (confirmedOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(confirmedOnlyQuery.value(), valueQuery_instance)) {
                confirmedOnly = valueQuery_instance;
            }
        }
    


        try {





            this->get_route_stops(version, routeId, confirmedOnly, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::get_shipments_at_stop_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        auto stopId = request.param(":stopId").as<int64_t>();
        
        
    


        try {





            this->get_shipments_at_stop(version, routeId, stopId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::optimize_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        
    


        try {





            this->optimize_route(version, routeId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::remove_stop_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        auto stopId = request.param(":stopId").as<int64_t>();
        
        
    


        try {





            this->remove_stop(version, routeId, stopId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::reorder_route_stops_patch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        // Getting the body param
                std::vector<Stop> body;
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            for (const auto& validationParam : body) 
                validationParam.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->reorder_route_stops_patch(version, routeId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::reorder_route_stops_post_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        // Getting the body param
                std::vector<Stop> body;
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            for (const auto& validationParam : body) 
                validationParam.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->reorder_route_stops_post(version, routeId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::search_routes_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto hubIdQuery = request.query().get("hubId");
        std::optional<int64_t> hubId;
        if (hubIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(hubIdQuery.value(), valueQuery_instance)) {
                hubId = valueQuery_instance;
            }
        }
        auto programIdQuery = request.query().get("programId");
        std::optional<int64_t> programId;
        if (programIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(programIdQuery.value(), valueQuery_instance)) {
                programId = valueQuery_instance;
            }
        }
        auto scheduledStartQuery = request.query().get("scheduledStart");
        std::optional<int64_t> scheduledStart;
        if (scheduledStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledStartQuery.value(), valueQuery_instance)) {
                scheduledStart = valueQuery_instance;
            }
        }
        auto scheduledEndQuery = request.query().get("scheduledEnd");
        std::optional<int64_t> scheduledEnd;
        if (scheduledEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(scheduledEndQuery.value(), valueQuery_instance)) {
                scheduledEnd = valueQuery_instance;
            }
        }
        auto updatedStartQuery = request.query().get("updatedStart");
        std::optional<int64_t> updatedStart;
        if (updatedStartQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(updatedStartQuery.value(), valueQuery_instance)) {
                updatedStart = valueQuery_instance;
            }
        }
        auto updatedEndQuery = request.query().get("updatedEnd");
        std::optional<int64_t> updatedEnd;
        if (updatedEndQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(updatedEndQuery.value(), valueQuery_instance)) {
                updatedEnd = valueQuery_instance;
            }
        }
        auto featuredQuery = request.query().get("featured");
        std::optional<bool> featured;
        if (featuredQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(featuredQuery.value(), valueQuery_instance)) {
                featured = valueQuery_instance;
            }
        }
        auto seatCountQuery = request.query().get("seatCount");
        std::optional<int32_t> seatCount;
        if (seatCountQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(seatCountQuery.value(), valueQuery_instance)) {
                seatCount = valueQuery_instance;
            }
        }
        auto approvedQuery = request.query().get("approved");
        std::optional<bool> approved;
        if (approvedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(approvedQuery.value(), valueQuery_instance)) {
                approved = valueQuery_instance;
            }
        }
        auto startedQuery = request.query().get("started");
        std::optional<bool> started;
        if (startedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(startedQuery.value(), valueQuery_instance)) {
                started = valueQuery_instance;
            }
        }
        auto completedQuery = request.query().get("completed");
        std::optional<bool> completed;
        if (completedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(completedQuery.value(), valueQuery_instance)) {
                completed = valueQuery_instance;
            }
        }
        auto validQuery = request.query().get("valid");
        std::optional<bool> valid;
        if (validQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(validQuery.value(), valueQuery_instance)) {
                valid = valueQuery_instance;
            }
        }
        auto parentIdQuery = request.query().get("parentId");
        std::optional<int64_t> parentId;
        if (parentIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(parentIdQuery.value(), valueQuery_instance)) {
                parentId = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto includesEmptyQuery = request.query().get("includesEmpty");
        std::optional<bool> includesEmpty;
        if (includesEmptyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includesEmptyQuery.value(), valueQuery_instance)) {
                includesEmpty = valueQuery_instance;
            }
        }
        auto rootOnlyQuery = request.query().get("rootOnly");
        std::optional<bool> rootOnly;
        if (rootOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(rootOnlyQuery.value(), valueQuery_instance)) {
                rootOnly = valueQuery_instance;
            }
        }
        auto showInheritedPropertiesQuery = request.query().get("showInheritedProperties");
        std::optional<bool> showInheritedProperties;
        if (showInheritedPropertiesQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(showInheritedPropertiesQuery.value(), valueQuery_instance)) {
                showInheritedProperties = valueQuery_instance;
            }
        }
    


        try {





            this->search_routes(version, sortField, descending, start, limit, activeOnly, includesEmpty, rootOnly, showInheritedProperties, hubId, programId, scheduledStart, scheduledEnd, updatedStart, updatedEnd, featured, seatCount, approved, started, completed, valid, parentId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::set_driver_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto id = request.param(":id").as<int64_t>();
        auto driverId = request.param(":driverId").as<int64_t>();
        
        
    


        try {





            this->set_driver(version, id, driverId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::update_route_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        
        // Getting the body param
        
        Route body;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            body.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->update_route(version, routeId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void RouteApi::update_route_stop_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto routeId = request.param(":routeId").as<int64_t>();
        auto stopId = request.param(":stopId").as<int64_t>();
        
        // Getting the body param
        
        Stop body;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(body);
            body.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->update_route_stop(version, routeId, stopId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void RouteApi::route_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

