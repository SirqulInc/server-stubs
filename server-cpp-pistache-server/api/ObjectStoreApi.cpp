/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "ObjectStoreApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string ObjectStoreApi::base = "";

ObjectStoreApi::ObjectStoreApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void ObjectStoreApi::init() {
    setupRoutes();
}

void ObjectStoreApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/object/field/add", Routes::bind(&ObjectStoreApi::add_field_handler, this));
    Routes::Post(*router, base + "/api/:version/object/data/:objectName", Routes::bind(&ObjectStoreApi::create_data_handler, this));
    Routes::Post(*router, base + "/api/:version/object/create", Routes::bind(&ObjectStoreApi::create_object_handler, this));
    Routes::Delete(*router, base + "/api/:version/object/data/:objectName/:objectId", Routes::bind(&ObjectStoreApi::delete_data_handler, this));
    Routes::Post(*router, base + "/api/:version/object/field/delete", Routes::bind(&ObjectStoreApi::delete_field_handler, this));
    Routes::Post(*router, base + "/api/:version/object/delete", Routes::bind(&ObjectStoreApi::delete_object_handler, this));
    Routes::Get(*router, base + "/api/:version/object/data/:objectName/:objectId", Routes::bind(&ObjectStoreApi::get_data_handler, this));
    Routes::Get(*router, base + "/api/:version/object/get", Routes::bind(&ObjectStoreApi::get_object_handler, this));
    Routes::Get(*router, base + "/api/:version/object/data/:objectName", Routes::bind(&ObjectStoreApi::search_data_handler, this));
    Routes::Get(*router, base + "/api/:version/object/search", Routes::bind(&ObjectStoreApi::search_object_handler, this));
    Routes::Put(*router, base + "/api/:version/object/data/:objectName/:objectId", Routes::bind(&ObjectStoreApi::update_data_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&ObjectStoreApi::object_store_api_default_handler, this));
}

void ObjectStoreApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ObjectStoreApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void ObjectStoreApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> ObjectStoreApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void ObjectStoreApi::add_field_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto objectNameQuery = request.query().get("objectName");
        std::optional<std::string> objectName;
        if (objectNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectNameQuery.value(), valueQuery_instance)) {
                objectName = valueQuery_instance;
            }
        }
        auto fieldNameQuery = request.query().get("fieldName");
        std::optional<std::string> fieldName;
        if (fieldNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(fieldNameQuery.value(), valueQuery_instance)) {
                fieldName = valueQuery_instance;
            }
        }
        auto fieldTypeQuery = request.query().get("fieldType");
        std::optional<std::string> fieldType;
        if (fieldTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(fieldTypeQuery.value(), valueQuery_instance)) {
                fieldType = valueQuery_instance;
            }
        }
    


        try {





            this->add_field(version, accountId, appKey, objectName, fieldName, fieldType, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::create_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto objectName = request.param(":objectName").as<std::string>();
        
        // Getting the body param
                std::string body;
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    

        try {
            body = request.body();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->create_data(version, objectName, accountId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::create_object_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto objectNameQuery = request.query().get("objectName");
        std::optional<std::string> objectName;
        if (objectNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectNameQuery.value(), valueQuery_instance)) {
                objectName = valueQuery_instance;
            }
        }
    


        try {





            this->create_object(version, accountId, appKey, objectName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::delete_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto objectName = request.param(":objectName").as<std::string>();
        auto objectId = request.param(":objectId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_data(version, objectName, objectId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::delete_field_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto objectNameQuery = request.query().get("objectName");
        std::optional<std::string> objectName;
        if (objectNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectNameQuery.value(), valueQuery_instance)) {
                objectName = valueQuery_instance;
            }
        }
        auto fieldNameQuery = request.query().get("fieldName");
        std::optional<std::string> fieldName;
        if (fieldNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(fieldNameQuery.value(), valueQuery_instance)) {
                fieldName = valueQuery_instance;
            }
        }
    


        try {





            this->delete_field(version, accountId, appKey, objectName, fieldName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::delete_object_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto objectNameQuery = request.query().get("objectName");
        std::optional<std::string> objectName;
        if (objectNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectNameQuery.value(), valueQuery_instance)) {
                objectName = valueQuery_instance;
            }
        }
    


        try {





            this->delete_object(version, accountId, appKey, objectName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::get_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto objectName = request.param(":objectName").as<std::string>();
        auto objectId = request.param(":objectId").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto includeQuery = request.query().get("include");
        std::optional<std::string> include;
        if (includeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(includeQuery.value(), valueQuery_instance)) {
                include = valueQuery_instance;
            }
        }
    


        try {





            this->get_data(version, objectName, objectId, accountId, include, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::get_object_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto objectNameQuery = request.query().get("objectName");
        std::optional<std::string> objectName;
        if (objectNameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(objectNameQuery.value(), valueQuery_instance)) {
                objectName = valueQuery_instance;
            }
        }
    


        try {





            this->get_object(version, accountId, appKey, objectName, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::search_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto objectName = request.param(":objectName").as<std::string>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto criteriaQuery = request.query().get("criteria");
        std::optional<std::string> criteria;
        if (criteriaQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(criteriaQuery.value(), valueQuery_instance)) {
                criteria = valueQuery_instance;
            }
        }
        auto countQuery = request.query().get("count");
        std::optional<bool> count;
        if (countQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(countQuery.value(), valueQuery_instance)) {
                count = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int64_t> start;
        if (startQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int64_t> limit;
        if (limitQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto orderQuery = request.query().get("order");
        std::optional<std::string> order;
        if (orderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(orderQuery.value(), valueQuery_instance)) {
                order = valueQuery_instance;
            }
        }
        auto includeQuery = request.query().get("include");
        std::optional<std::string> include;
        if (includeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(includeQuery.value(), valueQuery_instance)) {
                include = valueQuery_instance;
            }
        }
    


        try {





            this->search_data(version, objectName, count, start, limit, accountId, criteria, order, include, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::search_object_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int64_t> start;
        if (startQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int64_t> limit;
        if (limitQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->search_object(version, accountId, appKey, start, limit, keyword, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void ObjectStoreApi::update_data_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        auto objectName = request.param(":objectName").as<std::string>();
        auto objectId = request.param(":objectId").as<std::string>();
        
        // Getting the body param
                std::string body;
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    

        try {
            body = request.body();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {





            this->update_data(version, objectName, objectId, accountId, body, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void ObjectStoreApi::object_store_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

