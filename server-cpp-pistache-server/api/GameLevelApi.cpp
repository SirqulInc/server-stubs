/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "GameLevelApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string GameLevelApi::base = "";

GameLevelApi::GameLevelApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void GameLevelApi::init() {
    setupRoutes();
}

void GameLevelApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/level/create", Routes::bind(&GameLevelApi::create_game_level_handler, this));
    Routes::Post(*router, base + "/api/:version/level/delete", Routes::bind(&GameLevelApi::delete_game_level_handler, this));
    Routes::Get(*router, base + "/api/:version/level/get", Routes::bind(&GameLevelApi::get_game_level_handler, this));
    Routes::Get(*router, base + "/api/:version/level/search", Routes::bind(&GameLevelApi::get_game_levels_by_application_handler, this));
    Routes::Get(*router, base + "/api/:version/level/searchByBillableEntity", Routes::bind(&GameLevelApi::get_game_levels_by_billable_entity_handler, this));
    Routes::Get(*router, base + "/api/:version/level/questions/get", Routes::bind(&GameLevelApi::get_questions_in_level_handler, this));
    Routes::Get(*router, base + "/api/:version/level/words/get", Routes::bind(&GameLevelApi::get_words_in_level_handler, this));
    Routes::Post(*router, base + "/api/:version/level/update", Routes::bind(&GameLevelApi::update_game_level_handler, this));
    Routes::Post(*router, base + "/api/:version/level/questions/update", Routes::bind(&GameLevelApi::update_questions_in_level_handler, this));
    Routes::Post(*router, base + "/api/:version/level/words/update", Routes::bind(&GameLevelApi::update_words_in_level_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&GameLevelApi::game_level_api_default_handler, this));
}

void GameLevelApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> GameLevelApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void GameLevelApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> GameLevelApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void GameLevelApi::create_game_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto difficultyQuery = request.query().get("difficulty");
        std::optional<std::string> difficulty;
        if (difficultyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(difficultyQuery.value(), valueQuery_instance)) {
                difficulty = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto assetImageIdQuery = request.query().get("assetImageId");
        std::optional<int64_t> assetImageId;
        if (assetImageIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetImageIdQuery.value(), valueQuery_instance)) {
                assetImageId = valueQuery_instance;
            }
        }
        auto assetIconIdQuery = request.query().get("assetIconId");
        std::optional<int64_t> assetIconId;
        if (assetIconIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIconIdQuery.value(), valueQuery_instance)) {
                assetIconId = valueQuery_instance;
            }
        }
        auto gameDataQuery = request.query().get("gameData");
        std::optional<std::string> gameData;
        if (gameDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameDataQuery.value(), valueQuery_instance)) {
                gameData = valueQuery_instance;
            }
        }
        auto gameDataSuffixQuery = request.query().get("gameDataSuffix");
        std::optional<std::string> gameDataSuffix;
        if (gameDataSuffixQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameDataSuffixQuery.value(), valueQuery_instance)) {
                gameDataSuffix = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto friendGroupQuery = request.query().get("friendGroup");
        std::optional<bool> friendGroup;
        if (friendGroupQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(friendGroupQuery.value(), valueQuery_instance)) {
                friendGroup = valueQuery_instance;
            }
        }
        auto connectionIdsQuery = request.query().get("connectionIds");
        std::optional<std::string> connectionIds;
        if (connectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionIdsQuery.value(), valueQuery_instance)) {
                connectionIds = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto balanceQuery = request.query().get("balance");
        std::optional<double> balance;
        if (balanceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(balanceQuery.value(), valueQuery_instance)) {
                balance = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto allocateTicketsQuery = request.query().get("allocateTickets");
        std::optional<bool> allocateTickets;
        if (allocateTicketsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(allocateTicketsQuery.value(), valueQuery_instance)) {
                allocateTickets = valueQuery_instance;
            }
        }
        auto ticketCountQuery = request.query().get("ticketCount");
        std::optional<int64_t> ticketCount;
        if (ticketCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketCountQuery.value(), valueQuery_instance)) {
                ticketCount = valueQuery_instance;
            }
        }
        auto ticketTypeQuery = request.query().get("ticketType");
        std::optional<std::string> ticketType;
        if (ticketTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketTypeQuery.value(), valueQuery_instance)) {
                ticketType = valueQuery_instance;
            }
        }
        auto pointsQuery = request.query().get("points");
        std::optional<int64_t> points;
        if (pointsQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(pointsQuery.value(), valueQuery_instance)) {
                points = valueQuery_instance;
            }
        }
        auto tutorialTitleQuery = request.query().get("tutorialTitle");
        std::optional<std::string> tutorialTitle;
        if (tutorialTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialTitleQuery.value(), valueQuery_instance)) {
                tutorialTitle = valueQuery_instance;
            }
        }
        auto tutorialMessageQuery = request.query().get("tutorialMessage");
        std::optional<std::string> tutorialMessage;
        if (tutorialMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialMessageQuery.value(), valueQuery_instance)) {
                tutorialMessage = valueQuery_instance;
            }
        }
        auto tutorialAlignmentQuery = request.query().get("tutorialAlignment");
        std::optional<std::string> tutorialAlignment;
        if (tutorialAlignmentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialAlignmentQuery.value(), valueQuery_instance)) {
                tutorialAlignment = valueQuery_instance;
            }
        }
        auto tutorialImageAssetIdQuery = request.query().get("tutorialImageAssetId");
        std::optional<int64_t> tutorialImageAssetId;
        if (tutorialImageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(tutorialImageAssetIdQuery.value(), valueQuery_instance)) {
                tutorialImageAssetId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
    


        try {





            this->create_game_level(version, accountId, name, gameData, gameDataSuffix, appKey, description, difficulty, appVersion, assetImageId, assetIconId, visibility, friendGroup, connectionIds, connectionGroupIds, balance, active, allocateTickets, ticketCount, ticketType, points, tutorialTitle, tutorialMessage, tutorialAlignment, tutorialImageAssetId, offerId, metaData, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::delete_game_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
    


        try {





            this->delete_game_level(version, accountId, levelId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::get_game_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto includeGameDataQuery = request.query().get("includeGameData");
        std::optional<bool> includeGameData;
        if (includeGameDataQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeGameDataQuery.value(), valueQuery_instance)) {
                includeGameData = valueQuery_instance;
            }
        }
    


        try {





            this->get_game_level(version, accountId, levelId, includeGameData, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::get_game_levels_by_application_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto includeGameDataQuery = request.query().get("includeGameData");
        std::optional<bool> includeGameData;
        if (includeGameDataQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeGameDataQuery.value(), valueQuery_instance)) {
                includeGameData = valueQuery_instance;
            }
        }
        auto filtersQuery = request.query().get("filters");
        std::optional<std::string> filters;
        if (filtersQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filtersQuery.value(), valueQuery_instance)) {
                filters = valueQuery_instance;
            }
        }
    


        try {





            this->get_game_levels_by_application(version, accountId, appKey, keyword, sortField, descending, start, limit, appVersion, includeGameData, filters, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::get_game_levels_by_billable_entity_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto activeOnlyQuery = request.query().get("activeOnly");
        std::optional<bool> activeOnly;
        if (activeOnlyQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeOnlyQuery.value(), valueQuery_instance)) {
                activeOnly = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int64_t> start;
        if (startQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int64_t> limit;
        if (limitQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
    


        try {





            this->get_game_levels_by_billable_entity(version, accountId, appKey, keyword, sortField, descending, activeOnly, start, limit, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::get_questions_in_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_questions_in_level(version, levelId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::get_words_in_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->get_words_in_level(version, levelId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::update_game_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto nameQuery = request.query().get("name");
        std::optional<std::string> name;
        if (nameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(nameQuery.value(), valueQuery_instance)) {
                name = valueQuery_instance;
            }
        }
        auto descriptionQuery = request.query().get("description");
        std::optional<std::string> description;
        if (descriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(descriptionQuery.value(), valueQuery_instance)) {
                description = valueQuery_instance;
            }
        }
        auto difficultyQuery = request.query().get("difficulty");
        std::optional<std::string> difficulty;
        if (difficultyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(difficultyQuery.value(), valueQuery_instance)) {
                difficulty = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto assetImageIdQuery = request.query().get("assetImageId");
        std::optional<int64_t> assetImageId;
        if (assetImageIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetImageIdQuery.value(), valueQuery_instance)) {
                assetImageId = valueQuery_instance;
            }
        }
        auto assetIconIdQuery = request.query().get("assetIconId");
        std::optional<int64_t> assetIconId;
        if (assetIconIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(assetIconIdQuery.value(), valueQuery_instance)) {
                assetIconId = valueQuery_instance;
            }
        }
        auto gameDataQuery = request.query().get("gameData");
        std::optional<std::string> gameData;
        if (gameDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameDataQuery.value(), valueQuery_instance)) {
                gameData = valueQuery_instance;
            }
        }
        auto gameDataSuffixQuery = request.query().get("gameDataSuffix");
        std::optional<std::string> gameDataSuffix;
        if (gameDataSuffixQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(gameDataSuffixQuery.value(), valueQuery_instance)) {
                gameDataSuffix = valueQuery_instance;
            }
        }
        auto visibilityQuery = request.query().get("visibility");
        std::optional<std::string> visibility;
        if (visibilityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(visibilityQuery.value(), valueQuery_instance)) {
                visibility = valueQuery_instance;
            }
        }
        auto friendGroupQuery = request.query().get("friendGroup");
        std::optional<bool> friendGroup;
        if (friendGroupQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(friendGroupQuery.value(), valueQuery_instance)) {
                friendGroup = valueQuery_instance;
            }
        }
        auto connectionIdsQuery = request.query().get("connectionIds");
        std::optional<std::string> connectionIds;
        if (connectionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionIdsQuery.value(), valueQuery_instance)) {
                connectionIds = valueQuery_instance;
            }
        }
        auto connectionGroupIdsQuery = request.query().get("connectionGroupIds");
        std::optional<std::string> connectionGroupIds;
        if (connectionGroupIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupIdsQuery.value(), valueQuery_instance)) {
                connectionGroupIds = valueQuery_instance;
            }
        }
        auto balanceQuery = request.query().get("balance");
        std::optional<double> balance;
        if (balanceQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(balanceQuery.value(), valueQuery_instance)) {
                balance = valueQuery_instance;
            }
        }
        auto activeQuery = request.query().get("active");
        std::optional<bool> active;
        if (activeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(activeQuery.value(), valueQuery_instance)) {
                active = valueQuery_instance;
            }
        }
        auto allocateTicketsQuery = request.query().get("allocateTickets");
        std::optional<bool> allocateTickets;
        if (allocateTicketsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(allocateTicketsQuery.value(), valueQuery_instance)) {
                allocateTickets = valueQuery_instance;
            }
        }
        auto ticketCountQuery = request.query().get("ticketCount");
        std::optional<int64_t> ticketCount;
        if (ticketCountQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ticketCountQuery.value(), valueQuery_instance)) {
                ticketCount = valueQuery_instance;
            }
        }
        auto ticketTypeQuery = request.query().get("ticketType");
        std::optional<std::string> ticketType;
        if (ticketTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ticketTypeQuery.value(), valueQuery_instance)) {
                ticketType = valueQuery_instance;
            }
        }
        auto pointsQuery = request.query().get("points");
        std::optional<int64_t> points;
        if (pointsQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(pointsQuery.value(), valueQuery_instance)) {
                points = valueQuery_instance;
            }
        }
        auto tutorialTitleQuery = request.query().get("tutorialTitle");
        std::optional<std::string> tutorialTitle;
        if (tutorialTitleQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialTitleQuery.value(), valueQuery_instance)) {
                tutorialTitle = valueQuery_instance;
            }
        }
        auto tutorialMessageQuery = request.query().get("tutorialMessage");
        std::optional<std::string> tutorialMessage;
        if (tutorialMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialMessageQuery.value(), valueQuery_instance)) {
                tutorialMessage = valueQuery_instance;
            }
        }
        auto tutorialAlignmentQuery = request.query().get("tutorialAlignment");
        std::optional<std::string> tutorialAlignment;
        if (tutorialAlignmentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tutorialAlignmentQuery.value(), valueQuery_instance)) {
                tutorialAlignment = valueQuery_instance;
            }
        }
        auto tutorialImageAssetIdQuery = request.query().get("tutorialImageAssetId");
        std::optional<int64_t> tutorialImageAssetId;
        if (tutorialImageAssetIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(tutorialImageAssetIdQuery.value(), valueQuery_instance)) {
                tutorialImageAssetId = valueQuery_instance;
            }
        }
        auto offerIdQuery = request.query().get("offerId");
        std::optional<int64_t> offerId;
        if (offerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(offerIdQuery.value(), valueQuery_instance)) {
                offerId = valueQuery_instance;
            }
        }
        auto metaDataQuery = request.query().get("metaData");
        std::optional<std::string> metaData;
        if (metaDataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(metaDataQuery.value(), valueQuery_instance)) {
                metaData = valueQuery_instance;
            }
        }
    


        try {





            this->update_game_level(version, accountId, levelId, appKey, name, description, difficulty, appVersion, assetImageId, assetIconId, gameData, gameDataSuffix, visibility, friendGroup, connectionIds, connectionGroupIds, balance, active, allocateTickets, ticketCount, ticketType, points, tutorialTitle, tutorialMessage, tutorialAlignment, tutorialImageAssetId, offerId, metaData, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::update_questions_in_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto questionIdsQuery = request.query().get("questionIds");
        std::optional<std::string> questionIds;
        if (questionIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(questionIdsQuery.value(), valueQuery_instance)) {
                questionIds = valueQuery_instance;
            }
        }
    


        try {





            this->update_questions_in_level(version, levelId, accountId, questionIds, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void GameLevelApi::update_words_in_level_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto levelIdQuery = request.query().get("levelId");
        std::optional<int64_t> levelId;
        if (levelIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(levelIdQuery.value(), valueQuery_instance)) {
                levelId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto wordIdsQuery = request.query().get("wordIds");
        std::optional<std::string> wordIds;
        if (wordIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(wordIdsQuery.value(), valueQuery_instance)) {
                wordIds = valueQuery_instance;
            }
        }
    


        try {





            this->update_words_in_level(version, levelId, accountId, wordIds, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void GameLevelApi::game_level_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

