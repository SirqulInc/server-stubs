/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "AlbumApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string AlbumApi::base = "";

AlbumApi::AlbumApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void AlbumApi::init() {
    setupRoutes();
}

void AlbumApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/api/:version/album/create", Routes::bind(&AlbumApi::add_album_collection_handler, this));
    Routes::Post(*router, base + "/api/:version/album/user/add", Routes::bind(&AlbumApi::add_album_users_handler, this));
    Routes::Post(*router, base + "/api/:version/album/approve", Routes::bind(&AlbumApi::approve_album_handler, this));
    Routes::Get(*router, base + "/api/:version/album/get", Routes::bind(&AlbumApi::get_album_collection_handler, this));
    Routes::Post(*router, base + "/api/:version/album/user/leave", Routes::bind(&AlbumApi::leave_album_handler, this));
    Routes::Post(*router, base + "/api/:version/album/delete", Routes::bind(&AlbumApi::remove_album_handler, this));
    Routes::Post(*router, base + "/api/:version/album/user/delete", Routes::bind(&AlbumApi::remove_album_users_handler, this));
    Routes::Get(*router, base + "/api/:version/album/search", Routes::bind(&AlbumApi::search_albums_handler, this));
    Routes::Post(*router, base + "/api/:version/album/update", Routes::bind(&AlbumApi::update_album_collection_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&AlbumApi::album_api_default_handler, this));
}

void AlbumApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AlbumApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void AlbumApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AlbumApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void AlbumApi::add_album_collection_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->add_album_collection(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::add_album_users_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
        auto readQuery = request.query().get("read");
        std::optional<bool> read;
        if (readQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(readQuery.value(), valueQuery_instance)) {
                read = valueQuery_instance;
            }
        }
        auto writeQuery = request.query().get("write");
        std::optional<bool> write;
        if (writeQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(writeQuery.value(), valueQuery_instance)) {
                write = valueQuery_instance;
            }
        }
        auto r_deleteQuery = request.query().get("delete");
        std::optional<bool> r_delete;
        if (r_deleteQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(r_deleteQuery.value(), valueQuery_instance)) {
                r_delete = valueQuery_instance;
            }
        }
        auto addQuery = request.query().get("add");
        std::optional<bool> add;
        if (addQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(addQuery.value(), valueQuery_instance)) {
                add = valueQuery_instance;
            }
        }
        auto connectionsQuery = request.query().get("connections");
        std::optional<std::string> connections;
        if (connectionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionsQuery.value(), valueQuery_instance)) {
                connections = valueQuery_instance;
            }
        }
        auto connectionGroupsQuery = request.query().get("connectionGroups");
        std::optional<std::string> connectionGroups;
        if (connectionGroupsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupsQuery.value(), valueQuery_instance)) {
                connectionGroups = valueQuery_instance;
            }
        }
        auto includeFriendGroupQuery = request.query().get("includeFriendGroup");
        std::optional<bool> includeFriendGroup;
        if (includeFriendGroupQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFriendGroupQuery.value(), valueQuery_instance)) {
                includeFriendGroup = valueQuery_instance;
            }
        }
    


        try {





            this->add_album_users(version, albumId, includeFriendGroup, deviceId, accountId, read, write, r_delete, add, connections, connectionGroups, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::approve_album_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
        auto approvalStatusQuery = request.query().get("approvalStatus");
        std::optional<std::string> approvalStatus;
        if (approvalStatusQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(approvalStatusQuery.value(), valueQuery_instance)) {
                approvalStatus = valueQuery_instance;
            }
        }
        auto verifiedQuery = request.query().get("verified");
        std::optional<bool> verified;
        if (verifiedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(verifiedQuery.value(), valueQuery_instance)) {
                verified = valueQuery_instance;
            }
        }
    


        try {





            this->approve_album(version, albumId, deviceId, accountId, approvalStatus, verified, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::get_album_collection_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto returnNullsQuery = request.query().get("returnNulls");
        std::optional<bool> returnNulls;
        if (returnNullsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnNullsQuery.value(), valueQuery_instance)) {
                returnNulls = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
        auto likePreviewSizeQuery = request.query().get("likePreviewSize");
        std::optional<int32_t> likePreviewSize;
        if (likePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(likePreviewSizeQuery.value(), valueQuery_instance)) {
                likePreviewSize = valueQuery_instance;
            }
        }
        auto assetPreviewSizeQuery = request.query().get("assetPreviewSize");
        std::optional<int32_t> assetPreviewSize;
        if (assetPreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(assetPreviewSizeQuery.value(), valueQuery_instance)) {
                assetPreviewSize = valueQuery_instance;
            }
        }
        auto notePreviewSizeQuery = request.query().get("notePreviewSize");
        std::optional<int32_t> notePreviewSize;
        if (notePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(notePreviewSizeQuery.value(), valueQuery_instance)) {
                notePreviewSize = valueQuery_instance;
            }
        }
        auto connectionPreviewSizeQuery = request.query().get("connectionPreviewSize");
        std::optional<int32_t> connectionPreviewSize;
        if (connectionPreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(connectionPreviewSizeQuery.value(), valueQuery_instance)) {
                connectionPreviewSize = valueQuery_instance;
            }
        }
        auto audiencePreviewSizeQuery = request.query().get("audiencePreviewSize");
        std::optional<int32_t> audiencePreviewSize;
        if (audiencePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(audiencePreviewSizeQuery.value(), valueQuery_instance)) {
                audiencePreviewSize = valueQuery_instance;
            }
        }
    


        try {





            this->get_album_collection(version, returnNulls, albumId, deviceId, accountId, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::leave_album_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
    


        try {





            this->leave_album(version, albumId, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::remove_album_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
    


        try {





            this->remove_album(version, albumId, deviceId, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::remove_album_users_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto albumIdQuery = request.query().get("albumId");
        std::optional<int64_t> albumId;
        if (albumIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumIdQuery.value(), valueQuery_instance)) {
                albumId = valueQuery_instance;
            }
        }
        auto connectionsQuery = request.query().get("connections");
        std::optional<std::string> connections;
        if (connectionsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionsQuery.value(), valueQuery_instance)) {
                connections = valueQuery_instance;
            }
        }
        auto connectionGroupsQuery = request.query().get("connectionGroups");
        std::optional<std::string> connectionGroups;
        if (connectionGroupsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(connectionGroupsQuery.value(), valueQuery_instance)) {
                connectionGroups = valueQuery_instance;
            }
        }
        auto removeFriendGroupQuery = request.query().get("removeFriendGroup");
        std::optional<bool> removeFriendGroup;
        if (removeFriendGroupQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(removeFriendGroupQuery.value(), valueQuery_instance)) {
                removeFriendGroup = valueQuery_instance;
            }
        }
    


        try {





            this->remove_album_users(version, albumId, removeFriendGroup, deviceId, accountId, connections, connectionGroups, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::search_albums_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto connectionAccountIdQuery = request.query().get("connectionAccountId");
        std::optional<int64_t> connectionAccountId;
        if (connectionAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(connectionAccountIdQuery.value(), valueQuery_instance)) {
                connectionAccountId = valueQuery_instance;
            }
        }
        auto ownerIdQuery = request.query().get("ownerId");
        std::optional<int64_t> ownerId;
        if (ownerIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(ownerIdQuery.value(), valueQuery_instance)) {
                ownerId = valueQuery_instance;
            }
        }
        auto albumIdsQuery = request.query().get("albumIds");
        std::optional<std::string> albumIds;
        if (albumIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumIdsQuery.value(), valueQuery_instance)) {
                albumIds = valueQuery_instance;
            }
        }
        auto excludeAlbumIdsQuery = request.query().get("excludeAlbumIds");
        std::optional<std::string> excludeAlbumIds;
        if (excludeAlbumIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(excludeAlbumIdsQuery.value(), valueQuery_instance)) {
                excludeAlbumIds = valueQuery_instance;
            }
        }
        auto mediaIdQuery = request.query().get("mediaId");
        std::optional<int64_t> mediaId;
        if (mediaIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(mediaIdQuery.value(), valueQuery_instance)) {
                mediaId = valueQuery_instance;
            }
        }
        auto keywordQuery = request.query().get("keyword");
        std::optional<std::string> keyword;
        if (keywordQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(keywordQuery.value(), valueQuery_instance)) {
                keyword = valueQuery_instance;
            }
        }
        auto filterQuery = request.query().get("filter");
        std::optional<std::string> filter;
        if (filterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterQuery.value(), valueQuery_instance)) {
                filter = valueQuery_instance;
            }
        }
        auto albumTypeQuery = request.query().get("albumType");
        std::optional<std::string> albumType;
        if (albumTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(albumTypeQuery.value(), valueQuery_instance)) {
                albumType = valueQuery_instance;
            }
        }
        auto albumTypeIdQuery = request.query().get("albumTypeId");
        std::optional<int64_t> albumTypeId;
        if (albumTypeIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(albumTypeIdQuery.value(), valueQuery_instance)) {
                albumTypeId = valueQuery_instance;
            }
        }
        auto subTypeQuery = request.query().get("subType");
        std::optional<std::string> subType;
        if (subTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(subTypeQuery.value(), valueQuery_instance)) {
                subType = valueQuery_instance;
            }
        }
        auto includeInactiveQuery = request.query().get("includeInactive");
        std::optional<bool> includeInactive;
        if (includeInactiveQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeInactiveQuery.value(), valueQuery_instance)) {
                includeInactive = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto limitPerAlbumTypeQuery = request.query().get("limitPerAlbumType");
        std::optional<int32_t> limitPerAlbumType;
        if (limitPerAlbumTypeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitPerAlbumTypeQuery.value(), valueQuery_instance)) {
                limitPerAlbumType = valueQuery_instance;
            }
        }
        auto dateCreatedQuery = request.query().get("dateCreated");
        std::optional<int64_t> dateCreated;
        if (dateCreatedQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(dateCreatedQuery.value(), valueQuery_instance)) {
                dateCreated = valueQuery_instance;
            }
        }
        auto updatedSinceQuery = request.query().get("updatedSince");
        std::optional<int64_t> updatedSince;
        if (updatedSinceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(updatedSinceQuery.value(), valueQuery_instance)) {
                updatedSince = valueQuery_instance;
            }
        }
        auto updatedBeforeQuery = request.query().get("updatedBefore");
        std::optional<int64_t> updatedBefore;
        if (updatedBeforeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(updatedBeforeQuery.value(), valueQuery_instance)) {
                updatedBefore = valueQuery_instance;
            }
        }
        auto createdSinceQuery = request.query().get("createdSince");
        std::optional<int64_t> createdSince;
        if (createdSinceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(createdSinceQuery.value(), valueQuery_instance)) {
                createdSince = valueQuery_instance;
            }
        }
        auto createdBeforeQuery = request.query().get("createdBefore");
        std::optional<int64_t> createdBefore;
        if (createdBeforeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(createdBeforeQuery.value(), valueQuery_instance)) {
                createdBefore = valueQuery_instance;
            }
        }
        auto startedSinceQuery = request.query().get("startedSince");
        std::optional<int64_t> startedSince;
        if (startedSinceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startedSinceQuery.value(), valueQuery_instance)) {
                startedSince = valueQuery_instance;
            }
        }
        auto startedBeforeQuery = request.query().get("startedBefore");
        std::optional<int64_t> startedBefore;
        if (startedBeforeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startedBeforeQuery.value(), valueQuery_instance)) {
                startedBefore = valueQuery_instance;
            }
        }
        auto endedSinceQuery = request.query().get("endedSince");
        std::optional<int64_t> endedSince;
        if (endedSinceQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endedSinceQuery.value(), valueQuery_instance)) {
                endedSince = valueQuery_instance;
            }
        }
        auto endedBeforeQuery = request.query().get("endedBefore");
        std::optional<int64_t> endedBefore;
        if (endedBeforeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endedBeforeQuery.value(), valueQuery_instance)) {
                endedBefore = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto rangeQuery = request.query().get("range");
        std::optional<double> range;
        if (rangeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(rangeQuery.value(), valueQuery_instance)) {
                range = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto categoryIdsQuery = request.query().get("categoryIds");
        std::optional<std::string> categoryIds;
        if (categoryIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryIdsQuery.value(), valueQuery_instance)) {
                categoryIds = valueQuery_instance;
            }
        }
        auto categoryFilterIdsQuery = request.query().get("categoryFilterIds");
        std::optional<std::string> categoryFilterIds;
        if (categoryFilterIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(categoryFilterIdsQuery.value(), valueQuery_instance)) {
                categoryFilterIds = valueQuery_instance;
            }
        }
        auto audienceIdsQuery = request.query().get("audienceIds");
        std::optional<std::string> audienceIds;
        if (audienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(audienceIdsQuery.value(), valueQuery_instance)) {
                audienceIds = valueQuery_instance;
            }
        }
        auto excludeAudienceIdsQuery = request.query().get("excludeAudienceIds");
        std::optional<std::string> excludeAudienceIds;
        if (excludeAudienceIdsQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(excludeAudienceIdsQuery.value(), valueQuery_instance)) {
                excludeAudienceIds = valueQuery_instance;
            }
        }
        auto includeLikedQuery = request.query().get("includeLiked");
        std::optional<bool> includeLiked;
        if (includeLikedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeLikedQuery.value(), valueQuery_instance)) {
                includeLiked = valueQuery_instance;
            }
        }
        auto includeFavoritedQuery = request.query().get("includeFavorited");
        std::optional<bool> includeFavorited;
        if (includeFavoritedQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeFavoritedQuery.value(), valueQuery_instance)) {
                includeFavorited = valueQuery_instance;
            }
        }
        auto includePermissionsQuery = request.query().get("includePermissions");
        std::optional<bool> includePermissions;
        if (includePermissionsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includePermissionsQuery.value(), valueQuery_instance)) {
                includePermissions = valueQuery_instance;
            }
        }
        auto includeCompletableQuery = request.query().get("includeCompletable");
        std::optional<bool> includeCompletable;
        if (includeCompletableQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeCompletableQuery.value(), valueQuery_instance)) {
                includeCompletable = valueQuery_instance;
            }
        }
        auto includeRatingQuery = request.query().get("includeRating");
        std::optional<bool> includeRating;
        if (includeRatingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(includeRatingQuery.value(), valueQuery_instance)) {
                includeRating = valueQuery_instance;
            }
        }
        auto likePreviewSizeQuery = request.query().get("likePreviewSize");
        std::optional<int32_t> likePreviewSize;
        if (likePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(likePreviewSizeQuery.value(), valueQuery_instance)) {
                likePreviewSize = valueQuery_instance;
            }
        }
        auto assetPreviewSizeQuery = request.query().get("assetPreviewSize");
        std::optional<int32_t> assetPreviewSize;
        if (assetPreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(assetPreviewSizeQuery.value(), valueQuery_instance)) {
                assetPreviewSize = valueQuery_instance;
            }
        }
        auto notePreviewSizeQuery = request.query().get("notePreviewSize");
        std::optional<int32_t> notePreviewSize;
        if (notePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(notePreviewSizeQuery.value(), valueQuery_instance)) {
                notePreviewSize = valueQuery_instance;
            }
        }
        auto connectionPreviewSizeQuery = request.query().get("connectionPreviewSize");
        std::optional<int32_t> connectionPreviewSize;
        if (connectionPreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(connectionPreviewSizeQuery.value(), valueQuery_instance)) {
                connectionPreviewSize = valueQuery_instance;
            }
        }
        auto audiencePreviewSizeQuery = request.query().get("audiencePreviewSize");
        std::optional<int32_t> audiencePreviewSize;
        if (audiencePreviewSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(audiencePreviewSizeQuery.value(), valueQuery_instance)) {
                audiencePreviewSize = valueQuery_instance;
            }
        }
        auto searchModeQuery = request.query().get("searchMode");
        std::optional<std::string> searchMode;
        if (searchModeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchModeQuery.value(), valueQuery_instance)) {
                searchMode = valueQuery_instance;
            }
        }
        auto stackSearchQuery = request.query().get("stackSearch");
        std::optional<bool> stackSearch;
        if (stackSearchQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(stackSearchQuery.value(), valueQuery_instance)) {
                stackSearch = valueQuery_instance;
            }
        }
        auto stackWindowSizeQuery = request.query().get("stackWindowSize");
        std::optional<int32_t> stackWindowSize;
        if (stackWindowSizeQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(stackWindowSizeQuery.value(), valueQuery_instance)) {
                stackWindowSize = valueQuery_instance;
            }
        }
        auto minStackPerPageQuery = request.query().get("minStackPerPage");
        std::optional<int32_t> minStackPerPage;
        if (minStackPerPageQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(minStackPerPageQuery.value(), valueQuery_instance)) {
                minStackPerPage = valueQuery_instance;
            }
        }
        auto stackPaginationIdentifierQuery = request.query().get("stackPaginationIdentifier");
        std::optional<std::string> stackPaginationIdentifier;
        if (stackPaginationIdentifierQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stackPaginationIdentifierQuery.value(), valueQuery_instance)) {
                stackPaginationIdentifier = valueQuery_instance;
            }
        }
        auto stackDetailsQuery = request.query().get("stackDetails");
        std::optional<bool> stackDetails;
        if (stackDetailsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(stackDetailsQuery.value(), valueQuery_instance)) {
                stackDetails = valueQuery_instance;
            }
        }
        auto flagCountMinimumQuery = request.query().get("flagCountMinimum");
        std::optional<int64_t> flagCountMinimum;
        if (flagCountMinimumQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(flagCountMinimumQuery.value(), valueQuery_instance)) {
                flagCountMinimum = valueQuery_instance;
            }
        }
        auto removeFlaggedContentQuery = request.query().get("removeFlaggedContent");
        std::optional<bool> removeFlaggedContent;
        if (removeFlaggedContentQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(removeFlaggedContentQuery.value(), valueQuery_instance)) {
                removeFlaggedContent = valueQuery_instance;
            }
        }
        auto verifiedFilterQuery = request.query().get("verifiedFilter");
        std::optional<bool> verifiedFilter;
        if (verifiedFilterQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(verifiedFilterQuery.value(), valueQuery_instance)) {
                verifiedFilter = valueQuery_instance;
            }
        }
        auto linkedObjectTypeQuery = request.query().get("linkedObjectType");
        std::optional<std::string> linkedObjectType;
        if (linkedObjectTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(linkedObjectTypeQuery.value(), valueQuery_instance)) {
                linkedObjectType = valueQuery_instance;
            }
        }
        auto linkedObjectIdQuery = request.query().get("linkedObjectId");
        std::optional<int64_t> linkedObjectId;
        if (linkedObjectIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(linkedObjectIdQuery.value(), valueQuery_instance)) {
                linkedObjectId = valueQuery_instance;
            }
        }
        auto orderAudienceIdQuery = request.query().get("orderAudienceId");
        std::optional<int64_t> orderAudienceId;
        if (orderAudienceIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(orderAudienceIdQuery.value(), valueQuery_instance)) {
                orderAudienceId = valueQuery_instance;
            }
        }
        auto ignoreDefaultAppFilterQuery = request.query().get("ignoreDefaultAppFilter");
        std::optional<bool> ignoreDefaultAppFilter;
        if (ignoreDefaultAppFilterQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(ignoreDefaultAppFilterQuery.value(), valueQuery_instance)) {
                ignoreDefaultAppFilter = valueQuery_instance;
            }
        }
        auto searchExpressionQuery = request.query().get("searchExpression");
        std::optional<std::string> searchExpression;
        if (searchExpressionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(searchExpressionQuery.value(), valueQuery_instance)) {
                searchExpression = valueQuery_instance;
            }
        }
        auto generateAlbumsQuery = request.query().get("generateAlbums");
        std::optional<bool> generateAlbums;
        if (generateAlbumsQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(generateAlbumsQuery.value(), valueQuery_instance)) {
                generateAlbums = valueQuery_instance;
            }
        }
    


        try {





            this->search_albums(version, filter, albumTypeId, subType, includeInactive, sortField, descending, start, limit, range, includeLiked, includeFavorited, includePermissions, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, deviceId, accountId, connectionAccountId, ownerId, albumIds, excludeAlbumIds, mediaId, keyword, albumType, limitPerAlbumType, dateCreated, updatedSince, updatedBefore, createdSince, createdBefore, startedSince, startedBefore, endedSince, endedBefore, latitude, longitude, appKey, categoryIds, categoryFilterIds, audienceIds, excludeAudienceIds, includeCompletable, includeRating, searchMode, stackSearch, stackWindowSize, minStackPerPage, stackPaginationIdentifier, stackDetails, flagCountMinimum, removeFlaggedContent, verifiedFilter, linkedObjectType, linkedObjectId, orderAudienceId, ignoreDefaultAppFilter, searchExpression, generateAlbums, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AlbumApi::update_album_collection_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {
            
            try {
                this->update_album_collection(request, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void AlbumApi::album_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

