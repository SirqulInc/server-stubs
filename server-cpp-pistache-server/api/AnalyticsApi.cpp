/**
* Sirqul IoT Platform
* Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
*
* The version of the OpenAPI document: 3.16
* Contact: info@sirqul.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "AnalyticsApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string AnalyticsApi::base = "";

AnalyticsApi::AnalyticsApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void AnalyticsApi::init() {
    setupRoutes();
}

void AnalyticsApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/api/:version/analytics/useractivity", Routes::bind(&AnalyticsApi::activities_handler, this));
    Routes::Get(*router, base + "/api/:version/analytics/aggregatedFilteredUsage", Routes::bind(&AnalyticsApi::aggregated_filtered_usage_handler, this));
    Routes::Get(*router, base + "/api/:version/analytics/filteredUsage", Routes::bind(&AnalyticsApi::filtered_usage_handler, this));
    Routes::Post(*router, base + "/api/:version/analytics/usage", Routes::bind(&AnalyticsApi::usage_handler, this));
    Routes::Post(*router, base + "/api/:version/analytics/usage/batch", Routes::bind(&AnalyticsApi::usage_batch_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&AnalyticsApi::analytics_api_default_handler, this));
}

void AnalyticsApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AnalyticsApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void AnalyticsApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> AnalyticsApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void AnalyticsApi::activities_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto startQuery = request.query().get("start");
        std::optional<int32_t> start;
        if (startQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(startQuery.value(), valueQuery_instance)) {
                start = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
    


        try {





            this->activities(version, start, limit, accountId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AnalyticsApi::aggregated_filtered_usage_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto applicationIdQuery = request.query().get("applicationId");
        std::optional<int64_t> applicationId;
        if (applicationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(applicationIdQuery.value(), valueQuery_instance)) {
                applicationId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto deviceQuery = request.query().get("device");
        std::optional<std::string> device;
        if (deviceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceQuery.value(), valueQuery_instance)) {
                device = valueQuery_instance;
            }
        }
        auto deviceOSQuery = request.query().get("deviceOS");
        std::optional<std::string> deviceOS;
        if (deviceOSQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceOSQuery.value(), valueQuery_instance)) {
                deviceOS = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageGroupQuery = request.query().get("ageGroup");
        std::optional<std::string> ageGroup;
        if (ageGroupQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ageGroupQuery.value(), valueQuery_instance)) {
                ageGroup = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto zipQuery = request.query().get("zip");
        std::optional<std::string> zip;
        if (zipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipQuery.value(), valueQuery_instance)) {
                zip = valueQuery_instance;
            }
        }
        auto modelQuery = request.query().get("model");
        std::optional<std::string> model;
        if (modelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(modelQuery.value(), valueQuery_instance)) {
                model = valueQuery_instance;
            }
        }
        auto tagQuery = request.query().get("tag");
        std::optional<std::string> tag;
        if (tagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagQuery.value(), valueQuery_instance)) {
                tag = valueQuery_instance;
            }
        }
        auto userAccountIdQuery = request.query().get("userAccountId");
        std::optional<int64_t> userAccountId;
        if (userAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(userAccountIdQuery.value(), valueQuery_instance)) {
                userAccountId = valueQuery_instance;
            }
        }
        auto userAccountDisplayQuery = request.query().get("userAccountDisplay");
        std::optional<std::string> userAccountDisplay;
        if (userAccountDisplayQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(userAccountDisplayQuery.value(), valueQuery_instance)) {
                userAccountDisplay = valueQuery_instance;
            }
        }
        auto userAccountUsernameQuery = request.query().get("userAccountUsername");
        std::optional<std::string> userAccountUsername;
        if (userAccountUsernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(userAccountUsernameQuery.value(), valueQuery_instance)) {
                userAccountUsername = valueQuery_instance;
            }
        }
        auto groupByRootQuery = request.query().get("groupByRoot");
        std::optional<std::string> groupByRoot;
        if (groupByRootQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupByRootQuery.value(), valueQuery_instance)) {
                groupByRoot = valueQuery_instance;
            }
        }
        auto groupByQuery = request.query().get("groupBy");
        std::optional<std::string> groupBy;
        if (groupByQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupByQuery.value(), valueQuery_instance)) {
                groupBy = valueQuery_instance;
            }
        }
        auto distinctCountQuery = request.query().get("distinctCount");
        std::optional<std::string> distinctCount;
        if (distinctCountQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(distinctCountQuery.value(), valueQuery_instance)) {
                distinctCount = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto hideUnknownQuery = request.query().get("hideUnknown");
        std::optional<bool> hideUnknown;
        if (hideUnknownQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(hideUnknownQuery.value(), valueQuery_instance)) {
                hideUnknown = valueQuery_instance;
            }
        }
        auto responseFormatQuery = request.query().get("responseFormat");
        std::optional<std::string> responseFormat;
        if (responseFormatQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFormatQuery.value(), valueQuery_instance)) {
                responseFormat = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->aggregated_filtered_usage(version, deviceId, accountId, applicationId, appKey, startDate, endDate, deviceType, device, deviceOS, gender, ageGroup, country, state, city, zip, model, tag, userAccountId, userAccountDisplay, userAccountUsername, groupByRoot, groupBy, distinctCount, sortField, descending, hideUnknown, responseFormat, l, limit, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AnalyticsApi::filtered_usage_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto applicationIdQuery = request.query().get("applicationId");
        std::optional<int64_t> applicationId;
        if (applicationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(applicationIdQuery.value(), valueQuery_instance)) {
                applicationId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto startDateQuery = request.query().get("startDate");
        std::optional<int64_t> startDate;
        if (startDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(startDateQuery.value(), valueQuery_instance)) {
                startDate = valueQuery_instance;
            }
        }
        auto endDateQuery = request.query().get("endDate");
        std::optional<int64_t> endDate;
        if (endDateQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(endDateQuery.value(), valueQuery_instance)) {
                endDate = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto deviceQuery = request.query().get("device");
        std::optional<std::string> device;
        if (deviceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceQuery.value(), valueQuery_instance)) {
                device = valueQuery_instance;
            }
        }
        auto deviceOSQuery = request.query().get("deviceOS");
        std::optional<std::string> deviceOS;
        if (deviceOSQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceOSQuery.value(), valueQuery_instance)) {
                deviceOS = valueQuery_instance;
            }
        }
        auto genderQuery = request.query().get("gender");
        std::optional<std::string> gender;
        if (genderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(genderQuery.value(), valueQuery_instance)) {
                gender = valueQuery_instance;
            }
        }
        auto ageGroupQuery = request.query().get("ageGroup");
        std::optional<std::string> ageGroup;
        if (ageGroupQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ageGroupQuery.value(), valueQuery_instance)) {
                ageGroup = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto zipQuery = request.query().get("zip");
        std::optional<std::string> zip;
        if (zipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipQuery.value(), valueQuery_instance)) {
                zip = valueQuery_instance;
            }
        }
        auto modelQuery = request.query().get("model");
        std::optional<std::string> model;
        if (modelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(modelQuery.value(), valueQuery_instance)) {
                model = valueQuery_instance;
            }
        }
        auto tagQuery = request.query().get("tag");
        std::optional<std::string> tag;
        if (tagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagQuery.value(), valueQuery_instance)) {
                tag = valueQuery_instance;
            }
        }
        auto userAccountIdQuery = request.query().get("userAccountId");
        std::optional<int64_t> userAccountId;
        if (userAccountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(userAccountIdQuery.value(), valueQuery_instance)) {
                userAccountId = valueQuery_instance;
            }
        }
        auto userAccountDisplayQuery = request.query().get("userAccountDisplay");
        std::optional<std::string> userAccountDisplay;
        if (userAccountDisplayQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(userAccountDisplayQuery.value(), valueQuery_instance)) {
                userAccountDisplay = valueQuery_instance;
            }
        }
        auto userAccountUsernameQuery = request.query().get("userAccountUsername");
        std::optional<std::string> userAccountUsername;
        if (userAccountUsernameQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(userAccountUsernameQuery.value(), valueQuery_instance)) {
                userAccountUsername = valueQuery_instance;
            }
        }
        auto customIdQuery = request.query().get("customId");
        std::optional<int64_t> customId;
        if (customIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customIdQuery.value(), valueQuery_instance)) {
                customId = valueQuery_instance;
            }
        }
        auto customTypeQuery = request.query().get("customType");
        std::optional<std::string> customType;
        if (customTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customTypeQuery.value(), valueQuery_instance)) {
                customType = valueQuery_instance;
            }
        }
        auto customValueQuery = request.query().get("customValue");
        std::optional<double> customValue;
        if (customValueQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(customValueQuery.value(), valueQuery_instance)) {
                customValue = valueQuery_instance;
            }
        }
        auto customValue2Query = request.query().get("customValue2");
        std::optional<double> customValue2;
        if (customValue2Query.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(customValue2Query.value(), valueQuery_instance)) {
                customValue2 = valueQuery_instance;
            }
        }
        auto customLongQuery = request.query().get("customLong");
        std::optional<int64_t> customLong;
        if (customLongQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customLongQuery.value(), valueQuery_instance)) {
                customLong = valueQuery_instance;
            }
        }
        auto customLong2Query = request.query().get("customLong2");
        std::optional<int64_t> customLong2;
        if (customLong2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customLong2Query.value(), valueQuery_instance)) {
                customLong2 = valueQuery_instance;
            }
        }
        auto customMessageQuery = request.query().get("customMessage");
        std::optional<std::string> customMessage;
        if (customMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessageQuery.value(), valueQuery_instance)) {
                customMessage = valueQuery_instance;
            }
        }
        auto customMessage2Query = request.query().get("customMessage2");
        std::optional<std::string> customMessage2;
        if (customMessage2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessage2Query.value(), valueQuery_instance)) {
                customMessage2 = valueQuery_instance;
            }
        }
        auto groupByQuery = request.query().get("groupBy");
        std::optional<std::string> groupBy;
        if (groupByQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(groupByQuery.value(), valueQuery_instance)) {
                groupBy = valueQuery_instance;
            }
        }
        auto distinctCountQuery = request.query().get("distinctCount");
        std::optional<std::string> distinctCount;
        if (distinctCountQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(distinctCountQuery.value(), valueQuery_instance)) {
                distinctCount = valueQuery_instance;
            }
        }
        auto sumColumnQuery = request.query().get("sumColumn");
        std::optional<std::string> sumColumn;
        if (sumColumnQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sumColumnQuery.value(), valueQuery_instance)) {
                sumColumn = valueQuery_instance;
            }
        }
        auto sortFieldQuery = request.query().get("sortField");
        std::optional<std::string> sortField;
        if (sortFieldQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(sortFieldQuery.value(), valueQuery_instance)) {
                sortField = valueQuery_instance;
            }
        }
        auto descendingQuery = request.query().get("descending");
        std::optional<bool> descending;
        if (descendingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(descendingQuery.value(), valueQuery_instance)) {
                descending = valueQuery_instance;
            }
        }
        auto hideUnknownQuery = request.query().get("hideUnknown");
        std::optional<bool> hideUnknown;
        if (hideUnknownQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(hideUnknownQuery.value(), valueQuery_instance)) {
                hideUnknown = valueQuery_instance;
            }
        }
        auto responseFormatQuery = request.query().get("responseFormat");
        std::optional<std::string> responseFormat;
        if (responseFormatQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(responseFormatQuery.value(), valueQuery_instance)) {
                responseFormat = valueQuery_instance;
            }
        }
        auto lQuery = request.query().get("_l");
        std::optional<int32_t> l;
        if (lQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(lQuery.value(), valueQuery_instance)) {
                l = valueQuery_instance;
            }
        }
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
    


        try {





            this->filtered_usage(version, deviceId, accountId, applicationId, appKey, startDate, endDate, deviceType, device, deviceOS, gender, ageGroup, country, state, city, zip, model, tag, userAccountId, userAccountDisplay, userAccountUsername, customId, customType, customValue, customValue2, customLong, customLong2, customMessage, customMessage2, groupBy, distinctCount, sumColumn, sortField, descending, hideUnknown, responseFormat, l, limit, latitude, longitude, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AnalyticsApi::usage_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto tagQuery = request.query().get("tag");
        std::optional<std::string> tag;
        if (tagQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(tagQuery.value(), valueQuery_instance)) {
                tag = valueQuery_instance;
            }
        }
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto applicationIdQuery = request.query().get("applicationId");
        std::optional<int64_t> applicationId;
        if (applicationIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(applicationIdQuery.value(), valueQuery_instance)) {
                applicationId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto deviceQuery = request.query().get("device");
        std::optional<std::string> device;
        if (deviceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceQuery.value(), valueQuery_instance)) {
                device = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto deviceOSQuery = request.query().get("deviceOS");
        std::optional<std::string> deviceOS;
        if (deviceOSQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceOSQuery.value(), valueQuery_instance)) {
                deviceOS = valueQuery_instance;
            }
        }
        auto modelQuery = request.query().get("model");
        std::optional<std::string> model;
        if (modelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(modelQuery.value(), valueQuery_instance)) {
                model = valueQuery_instance;
            }
        }
        auto latitudeQuery = request.query().get("latitude");
        std::optional<double> latitude;
        if (latitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(latitudeQuery.value(), valueQuery_instance)) {
                latitude = valueQuery_instance;
            }
        }
        auto longitudeQuery = request.query().get("longitude");
        std::optional<double> longitude;
        if (longitudeQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(longitudeQuery.value(), valueQuery_instance)) {
                longitude = valueQuery_instance;
            }
        }
        auto customIdQuery = request.query().get("customId");
        std::optional<int64_t> customId;
        if (customIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customIdQuery.value(), valueQuery_instance)) {
                customId = valueQuery_instance;
            }
        }
        auto customTypeQuery = request.query().get("customType");
        std::optional<std::string> customType;
        if (customTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customTypeQuery.value(), valueQuery_instance)) {
                customType = valueQuery_instance;
            }
        }
        auto achievementIncrementQuery = request.query().get("achievementIncrement");
        std::optional<int64_t> achievementIncrement;
        if (achievementIncrementQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(achievementIncrementQuery.value(), valueQuery_instance)) {
                achievementIncrement = valueQuery_instance;
            }
        }
        auto cityQuery = request.query().get("city");
        std::optional<std::string> city;
        if (cityQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(cityQuery.value(), valueQuery_instance)) {
                city = valueQuery_instance;
            }
        }
        auto stateQuery = request.query().get("state");
        std::optional<std::string> state;
        if (stateQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(stateQuery.value(), valueQuery_instance)) {
                state = valueQuery_instance;
            }
        }
        auto countryQuery = request.query().get("country");
        std::optional<std::string> country;
        if (countryQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(countryQuery.value(), valueQuery_instance)) {
                country = valueQuery_instance;
            }
        }
        auto zipQuery = request.query().get("zip");
        std::optional<std::string> zip;
        if (zipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(zipQuery.value(), valueQuery_instance)) {
                zip = valueQuery_instance;
            }
        }
        auto locationDescriptionQuery = request.query().get("locationDescription");
        std::optional<std::string> locationDescription;
        if (locationDescriptionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(locationDescriptionQuery.value(), valueQuery_instance)) {
                locationDescription = valueQuery_instance;
            }
        }
        auto clientTimeQuery = request.query().get("clientTime");
        std::optional<int64_t> clientTime;
        if (clientTimeQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(clientTimeQuery.value(), valueQuery_instance)) {
                clientTime = valueQuery_instance;
            }
        }
        auto errorMessageQuery = request.query().get("errorMessage");
        std::optional<std::string> errorMessage;
        if (errorMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(errorMessageQuery.value(), valueQuery_instance)) {
                errorMessage = valueQuery_instance;
            }
        }
        auto ipQuery = request.query().get("ip");
        std::optional<std::string> ip;
        if (ipQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(ipQuery.value(), valueQuery_instance)) {
                ip = valueQuery_instance;
            }
        }
        auto userAgentQuery = request.query().get("userAgent");
        std::optional<std::string> userAgent;
        if (userAgentQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(userAgentQuery.value(), valueQuery_instance)) {
                userAgent = valueQuery_instance;
            }
        }
        auto backgroundEventQuery = request.query().get("backgroundEvent");
        std::optional<bool> backgroundEvent;
        if (backgroundEventQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(backgroundEventQuery.value(), valueQuery_instance)) {
                backgroundEvent = valueQuery_instance;
            }
        }
        auto customMessageQuery = request.query().get("customMessage");
        std::optional<std::string> customMessage;
        if (customMessageQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessageQuery.value(), valueQuery_instance)) {
                customMessage = valueQuery_instance;
            }
        }
        auto customMessage2Query = request.query().get("customMessage2");
        std::optional<std::string> customMessage2;
        if (customMessage2Query.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(customMessage2Query.value(), valueQuery_instance)) {
                customMessage2 = valueQuery_instance;
            }
        }
        auto customValueQuery = request.query().get("customValue");
        std::optional<double> customValue;
        if (customValueQuery.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(customValueQuery.value(), valueQuery_instance)) {
                customValue = valueQuery_instance;
            }
        }
        auto customValue2Query = request.query().get("customValue2");
        std::optional<double> customValue2;
        if (customValue2Query.has_value()) {
            double valueQuery_instance;
            if (fromStringValue(customValue2Query.value(), valueQuery_instance)) {
                customValue2 = valueQuery_instance;
            }
        }
        auto customLongQuery = request.query().get("customLong");
        std::optional<int64_t> customLong;
        if (customLongQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customLongQuery.value(), valueQuery_instance)) {
                customLong = valueQuery_instance;
            }
        }
        auto customLong2Query = request.query().get("customLong2");
        std::optional<int64_t> customLong2;
        if (customLong2Query.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(customLong2Query.value(), valueQuery_instance)) {
                customLong2 = valueQuery_instance;
            }
        }
    


        try {





            this->usage(version, tag, deviceId, accountId, applicationId, appKey, appVersion, device, deviceType, deviceOS, model, latitude, longitude, customId, customType, achievementIncrement, city, state, country, zip, locationDescription, clientTime, errorMessage, ip, userAgent, backgroundEvent, customMessage, customMessage2, customValue, customValue2, customLong, customLong2, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}

void AnalyticsApi::usage_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto version = request.param(":version").as<double>();
        
        
        // Getting the query params
        auto deviceIdQuery = request.query().get("deviceId");
        std::optional<std::string> deviceId;
        if (deviceIdQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceIdQuery.value(), valueQuery_instance)) {
                deviceId = valueQuery_instance;
            }
        }
        auto accountIdQuery = request.query().get("accountId");
        std::optional<int64_t> accountId;
        if (accountIdQuery.has_value()) {
            int64_t valueQuery_instance;
            if (fromStringValue(accountIdQuery.value(), valueQuery_instance)) {
                accountId = valueQuery_instance;
            }
        }
        auto appKeyQuery = request.query().get("appKey");
        std::optional<std::string> appKey;
        if (appKeyQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appKeyQuery.value(), valueQuery_instance)) {
                appKey = valueQuery_instance;
            }
        }
        auto appVersionQuery = request.query().get("appVersion");
        std::optional<std::string> appVersion;
        if (appVersionQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(appVersionQuery.value(), valueQuery_instance)) {
                appVersion = valueQuery_instance;
            }
        }
        auto deviceQuery = request.query().get("device");
        std::optional<std::string> device;
        if (deviceQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceQuery.value(), valueQuery_instance)) {
                device = valueQuery_instance;
            }
        }
        auto deviceTypeQuery = request.query().get("deviceType");
        std::optional<std::string> deviceType;
        if (deviceTypeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceTypeQuery.value(), valueQuery_instance)) {
                deviceType = valueQuery_instance;
            }
        }
        auto deviceOSQuery = request.query().get("deviceOS");
        std::optional<std::string> deviceOS;
        if (deviceOSQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(deviceOSQuery.value(), valueQuery_instance)) {
                deviceOS = valueQuery_instance;
            }
        }
        auto modelQuery = request.query().get("model");
        std::optional<std::string> model;
        if (modelQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(modelQuery.value(), valueQuery_instance)) {
                model = valueQuery_instance;
            }
        }
        auto dataQuery = request.query().get("data");
        std::optional<std::string> data;
        if (dataQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(dataQuery.value(), valueQuery_instance)) {
                data = valueQuery_instance;
            }
        }
        auto updateRankingQuery = request.query().get("updateRanking");
        std::optional<bool> updateRanking;
        if (updateRankingQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(updateRankingQuery.value(), valueQuery_instance)) {
                updateRanking = valueQuery_instance;
            }
        }
        auto returnSummaryResponseQuery = request.query().get("returnSummaryResponse");
        std::optional<bool> returnSummaryResponse;
        if (returnSummaryResponseQuery.has_value()) {
            bool valueQuery_instance;
            if (fromStringValue(returnSummaryResponseQuery.value(), valueQuery_instance)) {
                returnSummaryResponse = valueQuery_instance;
            }
        }
    


        try {





            this->usage_batch(version, appKey, device, data, deviceId, accountId, appVersion, deviceType, deviceOS, model, updateRanking, returnSummaryResponse, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }


}


void AnalyticsApi::analytics_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

